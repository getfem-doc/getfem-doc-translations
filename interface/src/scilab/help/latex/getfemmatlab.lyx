#LyX 1.6.2 created this file. For more info see http://www.lyx.org/

% Copyright (C) 2009-2020 Yann Colette
%
% This file is a part of GetFEM++
%
%  GetFEM++  is  free software;  you  can  redistribute  it  and/or modify it
%  under  the  terms  of the  GNU  Lesser General Public License as published
%  by  the  Free Software Foundation;  either version 3 of the License,  or
%  (at your option) any later version along with the GCC Runtime Library
%  Exception either version 3.1 or (at your option) any later version.
%  This program  is  distributed  in  the  hope  that it will be useful,  but
%  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
%  or  FITNESS  FOR  A PARTICULAR PURPOSE.  See the GNU Lesser General Public
%  License and GCC Runtime Library Exception for more details.
%  You  should  have received a copy of the GNU Lesser General Public License
%  along  with  this program;  if not, write to the Free Software Foundation,
%  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301, USA.

\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
% allow both latex and PDFlatex compatibility  (from pdfTeX FAQ)
\usepackage{hyperlatex}
\usepackage{pifont}

\usepackage{alltt}
\@ifundefined{definecolor}
 {\usepackage{color}}{}

\texonly{
\newif\ifpdf
\ifx\pdfoutput\undefined
    \pdffalse% we are not running PDFLaTeX
\else\pdfoutput=1% we are running PDFLaTeX
\pdftrue
\fi
\ifpdf
  
  \usepackage{soul}% hilighting
  \pdfcompresslevel=9
\else
  
\fi
\usepackage{xspace} % insere un espace si necessaire 
\ifpdf
  \usepackage[pdftex,pageanchor=true,hyperindex=true,pagebackref=true,pdfhighlight=/O,
colorlinks=true,pdfauthor={Julien Pommier},urlcolor=blue]{hyperref}
\else
  \usepackage[dvips,pageanchor=true,hyperindex=true,pagebackref=true,pdfhighlight=/O,
colorlinks=true,pdfauthor={Julien Pommier},urlcolor=blue]{hyperref}
\fi

\usepackage{underscore}
\oddsidemargin -0.9cm
\evensidemargin -0.9cm
\topmargin -1cm
\textheight 22.5cm
\textwidth 17.6cm
\headheight 1.0cm
}% end texonly

\W \newcommand{\HlxIcons}{./}
%\W \usepackage{frames} % navigation panel
\W \htmldirectory{gfm}
\W \htmlname{gfm}
%\W \HlxFramesNavigation

\makeindex
\definecolor{darkblue}{rgb}{0.,0.,0.4}
\definecolor{darkgreen}{rgb}{0.,0.4,0.}
\definecolor{darkyel}{rgb}{0.3,0.3,0.}
\definecolor{darkred}{rgb}{0.3,0.,0.}
\definecolor{lightred}{rgb}{1,0.5,0.5}
\definecolor{red}{rgb}{1.0,0.,0.}
\definecolor{gray80}{rgb}{0.2,0.2,0.2}
\definecolor{darkmag}{rgb}{0.2,0.0,0.4}
\definecolor{sepbg}{rgb}{1,1,0.7} % see also hilighted in docstyle.css

\htmlonly{
%  \htmlpanelfield{Contents}{gfmcontents}
  \htmlpanelfield{Index}{gfmindex}
  \htmlcss{docstyle.css}
%\htmlcss{gfm.css}

\setcounter{htmldepth}{3}%only section && subsection are given their own node

  \newcommand{\hypertarget}[1]{\label{#1}}
  \newcommand{\vfill}{}
  \newcommand{\newpage}{}
  \newcommand{\textrm}[1]{\mathrm{#1}}
  \newcommand{\text}[1]{\mathrm{#1}}
  \newcommand{\sf}[1]{#1}
  \newcommand{\star}{*}
  \newcommand{\WEB}[2]{\xmlattributes*{a}{target="_top"}\xlink{#2}{#1}}
  \newcommand{\nabla}{\htmlsym{nabla}}%renamed \xmlent by lastest version of hyperlatex
  \newcommand{\ell}{\htmlsym{tau}}
  \newcommand{\lambda}{\htmlsym{lambda}}
  \newcommand{\varepsilon}{\htmlsym{epsilon}}
  \newcommand{\phi}{\htmlsym{phi}}
  \newcommand{\varphi}{\htmlsym{phi}}
  \newcommand{\psi}{\htmlsym{psi}}
  \newcommand{\sigma}{\htmlsym{sigma}}
  \newcommand{\nu}{\htmlsym{nu}}
  \newcommand{\beta}{\htmlsym{beta}}
  \newcommand{\gamma}{\htmlsym{gamma}}
  \newcommand{\Gamma}{\htmlsym{Gamma}}
  \newcommand{\Delta}{\htmlsym{Delta}}
  \newcommand{\delta}{\htmlsym{delta}}
  \newcommand{\Omega}{\htmlsym{Omega}}
  \newcommand{\omega}{\htmlsym{omega}}
  \newcommand{\partial}{\htmlsym{part}}
  \newcommand{\sum}{\htmlsym{sum}}
  \newcommand{\int}{{\Large\htmlsym{int}}}
%  \newcommand{\htmlimg}[1]{\htmlimage{#1}}% will be deprecated as soon as debian upgrades
  \newcommand{\kw}[1]{\textcolor{darkblue}{\texttt{#1}}}
  \newcommand{\hlnk}[2]{\link{#1}{#2}}
  \newcommand{\kwl}[2]{\xmlattributes*{a}{class="matlab"}\texttt{\link{#2}{#1}}}
  \newcommand{\vartype}[1]{\xmlattributes*{a}{class="mltype"}{\link{#1}{typelist}}}
  \newenvironment{minipage}[2]{}{}
  \newenvironment{matlab}{\begin{rawxml}<div class="mlabcode">\end{rawxml}\begin{example}}{\end{example}\begin{rawxml}</div>\end{rawxml}}
  \newenvironment{mcode}{\begin{rawxml}<div class="mlabcode">\end{rawxml}\begin{example}}{\end{example}\begin{rawxml}</div>\end{rawxml}}
  \newcommand{\hil}[1]{\begin{rawxml}<span class="hilighted">\end{rawxml}#1\begin{rawxml}</span>\end{rawxml}}
  \newcommand{\sep}[1]{\medskip\par\hil{#1}}
}

\texonly {
  \newcommand{\WEB}[2]{\href{#1}{#2}}
  \newcommand{\kw}[1]{\textcolor{darkblue}{\texttt{#1}}}
  \newcommand{\hlnk}[2]{\hyperlink{#1}{\textcolor{darkblue}{#2}}}
  \newcommand{\kwl}[2]{\texttt{\hyperlink{#1}{\textcolor{darkblue}{#2}}}}
  \newcommand{\vartype}[1]{\texttt{\textit{\hyperlink{typelist}{\textcolor{darkred}{#1}}}}}
  \newenvironment{matlab}{\begin{alltt}}{\end{alltt}}
  \newenvironment{mcode}{\begin{alltt}}{\end{alltt}}
  \newcommand{\hil}[1]{\colorbox{sepbg}{#1}}
  \newcommand{\sep}[1]{\medskip\par#1}
}

% some commands used by the perl script
\newcommand{\mlabprompt}{\texttt{\textcolor{gray80}{>>}}}
\T \newcommand{\mlabcomment}[1]{\textrm{\textcolor{gray80}{#1}}}
\W \newcommand{\mlabcomment}[1]{\textcolor{gray80}{#1}}
\newcommand{\mlabkeyword}[1]{\textcolor{darkmag}{#1}}
\T \newcommand{\mlaboutput}[1]{\textsl{#1}}
\W \newcommand{\mlaboutput}[1]{\textcolor{darkmag}{#1}}
\newcommand{\inlinescilab}[1]{\texttt{#1}}
\newcommand{\inlinematlab}[1]{\texttt{#1}}
\newcommand{\str}[1]{'\textcolor{darkgreen}{\texttt{#1}}'}
\newcommand{\mesh}{mesh\xspace}
\newcommand{\mf}{mesh fem\xspace}
\newcommand{\mim}{mesh im\xspace}
\newcommand{\mdbrick}{mdbrick\xspace}
\newcommand{\mdstate}{mdstate\xspace}
\newcommand{\model}{model\xspace}
\newcommand{\slc}{mesh slice\xspace}
\newcommand{\spmat}{sparse matrix\xspace}
\newcommand{\precond}{preconditioner\xspace}
\newcommand{\fem}{fem\xspace}
\newcommand{\gt}{geotrans\xspace}
\newcommand{\integ}{integ\xspace}
\newcommand{\cvstruct}{cvstruct\xspace}
\newcommand{\tint}{\vartype{int}\xspace}
\newcommand{\tuint}{\vartype{uint32}\xspace}
\newcommand{\thobj}{\vartype{hobj}\xspace}
\newcommand{\tscal}{\vartype{scalar}\xspace}
\newcommand{\tvec}{\vartype{vec}\xspace}
\newcommand{\tivec}{\vartype{ivec}\xspace}
\newcommand{\tmesh}{\vartype{mesh}\xspace}
\newcommand{\tcmesh}{\vartype{const\_mesh}\xspace}
\newcommand{\tcvstruct}{\vartype{cvstruct}\xspace}
\newcommand{\tgeotrans}{\vartype{geotrans}\xspace}
\newcommand{\tmf}{\vartype{mesh\_fem}\xspace}
\newcommand{\tmim}{\vartype{mesh\_im}\xspace}
\newcommand{\tmdstate}{\vartype{mdstate}\xspace}
\newcommand{\tmodel}{\vartype{model}\xspace}
\newcommand{\tmdbrick}{\vartype{mdbrick}\xspace}
\newcommand{\tslc}{\vartype{mesh\_slice}\xspace}
\newcommand{\tfem}{\vartype{fem}\xspace}
\newcommand{\teltm}{\vartype{eltm}\xspace}
\newcommand{\tinteg}{\vartype{integ}\xspace}
\newcommand{\timat}{\vartype{imat}\xspace}
\newcommand{\tmat}{\vartype{mat}\xspace}
\newcommand{\tspmat}{\vartype{spmat}\xspace}
\newcommand{\tprecond}{\vartype{precond}\xspace}
\newcommand{\tstr}{\vartype{string}\xspace}
\texonly{
  \newcommand{\Mlab}{{\sf Matlab\raisebox{4pt}{\tiny {\textregistered}}}\xspace}
}\htmlonly {
  \newcommand{\Mlab}{Matlab\xspace}  
}
\texonly{
  \newcommand{\Slab}{{\sf Scilab\raisebox{4pt}{\tiny {\textregistered}}}\xspace}
}\htmlonly {
  \newcommand{\Slab}{Scilab\xspace}  
}
\newcommand{\mlab}{{\sf matlab}\xspace}
\newcommand{\slab}{{\sf scitlab}\xspace}
\newcommand{\pdetool}{{\sf pdetool}\xspace}
\newcommand{\gf}{{\sf getfem${++}$}\xspace}
\newcommand{\Gf}{{\sf Getfem${++}$}\xspace}
\newcommand{\gfi}{{\sf getfem-interface}\xspace}
\newcommand{\Gfi}{{\sf Getfem-interface}\xspace}
\newcommand{\gfm}{{\sf getfem-matlab}\xspace}
\newcommand{\Gfm}{{\sf Getfem-matlab}\xspace}
\newcommand{\SuperLU}{\WEB{http://crd.lbl.gov/\~{}xiaoye/SuperLU/}{SuperLU}\xspace}
\newcommand{\VTK}{\WEB{http://www.vtk.org}{VTK}\xspace}
\newcommand{\OpenDX}{\WEB{http://www.opendx.org}{OpenDX}\xspace}
\T \newenvironment{purpose}{\begin{flushleft}\textsc{\large Purpose:\\\vskip.1truecm}}{\end{flushleft}}
\W \newenvironment{purpose}{\begin{rawxml}<div class="mlpurp"><h3>Purpose</h3><div class="mlbox">\end{rawxml}}{\begin{rawxml}</div></div>\end{rawxml}}
\T \newenvironment{synopsis}{\begin{flushleft}\textsc{\large Synopsis:}\begin{alltt}}{\end{alltt}\end{flushleft}}
\W \newenvironment{synopsis}{\begin{rawxml}<div class="mlsynopsis"><h3>Synopsis</h3><div class="mlbox">\end{rawxml}\begin{example}}{\end{example}\begin{rawxml}</div></div>\end{rawxml}}
\T \newenvironment{cmddescription}{\noindent\textsc{\large Description:\\\vskip.1truecm}}{\par\medskip}
\W \newenvironment{cmddescription}{\begin{rawxml}<div class="mldesc"><h3>Description</h3><div class="mlbox">\end{rawxml}}{\begin{rawxml}</div></div>\end{rawxml}}
\T \newenvironment{cmdexamples}{\noindent\textsc{\large Examples:\\\vskip.1truecm}}{\par\medskip}
\W \newenvironment{cmdexamples}{\begin{rawxml}<div class="mlexamples"><h3>Examples</h3><div class="mlbox">\end{rawxml}}{\begin{rawxml}</div></div>\end{rawxml}}
\T \newenvironment{gfseealso}{\begin{flushleft}\textsc{\large See also:\\\vskip.1truecm}}{\end{flushleft}}
\W \newenvironment{gfseealso}{\begin{rawxml}<div class="mlseealso"><h3>See Also</h3><div class="mlbox">\end{rawxml}}{\begin{rawxml}</div></div>\end{rawxml}}
\newcommand{\warning}[1]{\textcolor{red}{warning} \textit{#1}}

\T \newcommand{\Div}{\textrm{div}}
\W \newcommand{\Div}{div}
\T \newcommand{\Grad}{\textrm{grad}}
\W \newcommand{\Grad}{grad}
\T \newcommand{\Rot}{\textrm{curl}}
\W \newcommand{\Rot}{curl}
\W \newcommand{\to}{\texttt{->}}
\W \newcommand{\vec}[1]{#1}
%\DeclareMathOperator{\Div}{div}
%\DeclareMathOperator{\Rot}{curl}
%\DeclareMathOperator{\Grad}{grad}

\newcommand{\NEW}{\textcolor{lightred}{\textbf{(New in getfem 2.0)}}}
\end_preamble
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmltitle
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Getfem-Matlab Interface
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlpanel
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

0
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%disable navigation panel
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Graphics
	filename logogetfemwhitebg.png
	width 10cm
	scaleBeforeRotation

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[0.2cm]
\end_layout

\end_inset

 a Generic Finite Element library in C++ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[0.5cm]
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
fbox{
\end_layout

\end_inset


\shape smallcaps
\size giant
Scilab
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
raisebox{4pt}{
\end_layout

\end_inset


\size tiny

\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textregistered
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Interface - User Documentation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[0.5cm]
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

 
\size large
Yves Renard, Julien Pommier
\shape default
 
\shape smallcaps

\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\size large
 
\shape italic
MIP, INSAT, Complexe scientifique de Rangueil, 31077 Toulouse, France, Yves.Renar
d@insa-toulouse.fr, Julien.Pommier@insa-toulouse.fr 
\end_layout

\end_inset

, Yann Collette 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\shape smallcaps
\size large
Scilab, Domaine de Voluceaux, Rocquencourt, yann.collette@scilab.org
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[1.0cm]
\end_layout

\end_inset

 February, 2006
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[1.0cm]
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
xlink
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlimg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

logogetfem.png
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

the getfem logo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

http://www-gmm.insa-toulouse.fr/getfem
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

 a Generic Finite Element library in C++ 
\begin_inset Newline newline
\end_inset

 
\size giant
Scilab Interface - User Documentation
\size default
 
\begin_inset Newline newline
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

 
\size large

\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
xlink
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Yves Renard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

mailto:Yves.Renard@insa-toulouse.fr
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
xlink
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

Julien Pommier
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

mailto:Julien.Pommier@insa-toulouse.fr
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\shape default
 
\shape italic
MIP, INSAT, Complexe scientifique de Rangueil, 31077 Toulouse, France.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash
begin{abstract}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% Basic user documentation for GetFEM++.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash
end{abstract}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

%          INTRODUCTION                                                
 %
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section*
Introduction
\end_layout

\begin_layout Standard
This guide provides a reference about the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
Slab
\end_layout

\end_inset

 interface of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

.
 For a complete reference of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

, please report to the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www-gmm.insa-toulouse.fr/getfem/doc
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

specific guides
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, but you should be able to use the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 interface without any particular knowledge of the getfem internals, although
 a basic knowledge about Finite Elements is required.
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset

 
\end_layout

\begin_layout Quote
\begin_inset CommandInset include
LatexCommand input
filename "license.lyx"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset

 
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
\begin_inset Index
status collapsed

\begin_layout Plain Layout
installation
\end_layout

\end_inset

 The installation of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfi
\end_layout

\end_inset

 toolbox can be somewhat tricky, since it combines a C++ compiler, libraries
 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
Slab
\end_layout

\end_inset

 interaction\SpecialChar \ldots{}
 In case of troubles with a non-GNU compiler, gcc/g++ (
\begin_inset Formula $\geq3.0$
\end_inset

) should be a safe solution.
\end_layout

\begin_layout Standard
CAUTION: 
\end_layout

\begin_layout Itemize
you should not use a different compiler than the one that was used for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Itemize
you should have built the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 static library (i.e.
 do not use 
\family typewriter
./configure --disable-static
\family default
 when building 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

).
 On linux/x86_64 platforms, a mandatory option when building 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfi
\end_layout

\end_inset

 (and any static library linked to them) is the 
\family typewriter
--with-pic
\family default
 option of their 
\family typewriter
./configure
\family default
 script.
 
\end_layout

\begin_layout Standard
Here we assume that 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 was installed in the directory 
\family typewriter
\shape italic
gfdestdir
\family default
\shape default
 (i.e.
 you ran 
\family typewriter
./configure --prefix=
\shape italic
gfdestdir
\family default
\shape default
 before compiling and installing 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

, the default value being 
\family typewriter
/usr/local
\family default
).
\end_layout

\begin_layout Standard
Unpack the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfi
\end_layout

\end_inset

 archive and run the configure script:
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[2mm]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+# gzip -dc getfem-interface-2.0.tar.gz | tar xvf -+
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+# cd getfem-interface-2.0+
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you did install 
\family typewriter
getfem++
\family default
, then running 
\family typewriter
./configure
\family default
 or 
\family typewriter
./configure --prefix=
\shape italic
gfdestdir
\family default
\shape default
 should be sufficient.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Nevertheless, if 
\family typewriter
\shape italic
gfdestdir
\shape default
/bin
\family default
 is not in the 
\family typewriter
PATH
\family default
, then you will have to to provide the path to the 
\family typewriter
getfem-config
\family default
 script with 
\family typewriter
--with-getfem-config=/
\shape italic
gfdestdir
\shape default
/bin/getfem-config
\family default
.
\end_layout

\begin_layout Standard
You may also use 
\family typewriter
--with-toolbox-dir=
\shape italic
toolboxdir
\family default
\shape default
 to change the default toolbox installation directory (
\family typewriter
$prefix/getfemtoolbox
\family default
).
 Use 
\family typewriter
./configure --help
\family default
 for more options.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[2mm]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the 
\family typewriter
configure
\family default
 is done, you can compile the toolbox (use 
\family typewriter
gmake
\family default
 if your default 
\family typewriter
make
\family default
 is not the GNU one)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+# make+
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[1mm]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An optional step is 
\family typewriter
make check
\family default
 in order to check the matlab interface (this sets some environment variables
 and runs the 
\family typewriter
checkall.m
\family default
 script which is the 
\family typewriter
tests/matlab
\family default
 directory of the distribution)
\end_layout

\begin_layout Standard
and install it (the libraries will be copied in 
\family typewriter
\shape italic
gfdestdir
\shape default
/lib
\family default
, while the MEX-File and M-Files will be copied in 
\family typewriter
\shape italic
toolboxdir
\family default
\shape default
)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+# make install+
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you want to use a different compiler than the one chosen automatically
 by the 
\family typewriter
./configure
\family default
 script, just specify its name on the command line: 
\family typewriter
./configure CXX=mycompiler.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%When the library is installed, you may have to set the
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
texttt{LD_LIBRARY_PATH} environment variable to the directory containing
 the
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
texttt{libgetfem.so} and 
\backslash
texttt{libgetfemint.so}, which is 
\backslash
texttt{
\backslash
textit{gfdest_dir}/lib}:
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
texttt{export LD
\backslash
_LIBRARY
\backslash
_PATH=
\backslash
textit{gfdest_dir}/lib} (if you use ksh or bash)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last step is to add the path to the toolbox in the matlab path: 
\end_layout

\begin_layout Itemize
you can set the environment variable 
\family typewriter
MATLABPATH
\family default
 to 
\family typewriter
\shape italic
toolboxdir
\family default
\shape default
 (
\family typewriter
export MATLABPATH=
\shape italic
toolboxdir
\family default
\shape default
 for example).
 
\end_layout

\begin_layout Itemize
you can put @@addpath('
\shape italic
toolboxdir
\shape default
')@@ to your 
\family typewriter
$HOME/matlab/startup.m
\family default
 
\end_layout

\begin_layout Standard
More specific instructions can be found in the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

README
\begin_inset Formula $\star$
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 files of the distribution.
\end_layout

\begin_layout Section
Preliminary
\end_layout

\begin_layout Standard
This is just a short summary of the terms employed in this manual.
 If you are not familiar with finite elements, this should be useful (but
 in any case, you should definitively read the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://home.gna.org/getfem/doc.html
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 project documentation
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
The 
\series bold
mesh
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh
\end_layout

\end_inset

 is composed of 
\series bold
convexes
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
convexes
\end_layout

\end_inset

.
 What we call convexes can be simple line segments, prisms, tetrahedrons,
 curved triangles, of even something which is not convex (in the geometrical
 sense).
 They all have an associated 
\series bold
reference convex
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
reference convex
\end_layout

\end_inset

: for segments, this will be the 
\begin_inset Formula $[0,1]$
\end_inset

 segment, for triangles this will be the canonical triangle 
\begin_inset Formula $(0,0)-(0,1)-(1,0)$
\end_inset

 etc\SpecialChar \ldots{}
 All convexes of the mesh are constructed from the reference convex
 through a 
\series bold
geometric transformation
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
geometric transformation
\end_layout

\end_inset

.
 In simple cases (when the convexes are simplices for example), this transformat
ion will be linear (hence it is easily inverted, which can be a great advantage).
 In order to define the geometric transformation, one defines 
\series bold
geometrical nodes
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
geometrical nodes
\end_layout

\end_inset

 on the reference convex.
 The geometrical transformation maps these nodes to the 
\series bold
mesh nodes
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh nodes
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
On the mesh, one defines a set a basis functions: the 
\series bold
FEM
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
FEM
\end_layout

\end_inset

.
 A FEM is associated at each convex.
 The basis functions are also attached to some geometrical points (which
 can be arbitrarily chosen).
 These points are similar to the mesh nodes, but 
\series bold
they don't have to be the same
\series default
 (this only happens on very simple cases, such as a classical P1 fem on
 a triangular mesh).
 The set of all basis functions on the mesh forms the basis of a vector
 space, on which the PDE will be solved.
 These basis functions (and their associated geometrical point) are the
 
\series bold
degrees of freedom (dof)
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
degrees of freedom
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
dof
\end_layout

\end_inset

.
 The FEM is said to be 
\series bold
Lagrangian
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
Lagrangian
\end_layout

\end_inset

 when each of its basis functions is equal to one at its attached geometrical
 point, and is null at the geometrical points of others basis functions.
 This is an important property as it is very easy to 
\series bold
interpolate
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
interpolation
\end_layout

\end_inset

 an arbitrary function on the finite elements space.
\end_layout

\begin_layout Standard
The finite elements method involves evaluation of integrals of these basis
 functions (or product of basis functions etc\SpecialChar \ldots{}
) on convexes (and faces of
 convexes).
 In simple cases (polynomial basis functions and linear geometrical transformati
on), one can evaluate analytically these integrals.
 In other cases, one has to approximate it, using 
\series bold
quadrature formulas
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
quadrature formulas
\end_layout

\end_inset

.
 Hence, at each convex is attached an 
\series bold
integration method
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
integration method
\end_layout

\end_inset

 along with the FEM.
 If you have to use an approximate integration method, always choose carefully
 its order(i.e.
 highest degree of the polynomials who are exactly integrated with the method)
 : the degree of the FEM, of the polynomial degree of the geometrical transforma
tion, and the nature of the elementary matrix have to be taken into account.
 If you are unsure about the appropriate degree, always prefer a high order
 integration method (which will slow down the assembly) to a low order one
 which will produce a useless linear-system.
\end_layout

\begin_layout Standard
The process of construction of a global linear system from integrals of
 basis functions on each convex is the 
\series bold
assembly
\series default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
assembly
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A mesh, with a set of FEM attached to its convexes is called a 
\series bold
mesh_fem
\series default
 object in GetFEM++.
\end_layout

\begin_layout Standard
A mesh, with a set of integration methods attached to its convexes is called
 a 
\series bold
mesh_im
\series default
 object in GetFEM++ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
A 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 can be used to approximate scalar fields (heat, pression, ..), or vector
 fields (displacement, electric field, ..).
 A 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 will be used to perform numerical integrations on these fields.
 Most of the finite elements implemented in GetFEM++ are scalar (however,
 TR0 and edges elements are also available).
 Of course, these scalar FEMs can be used to approximate each component
 of a vector field.
 This is done by setting the 
\series bold
Qdim
\series default
 of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 to the dimension of the vector field (i.e.
 Qdim=1 
\begin_inset Formula $\Rightarrow$
\end_inset

 scalar field, Qdim=2 
\begin_inset Formula $\Rightarrow$
\end_inset

 2D vector field etc\SpecialChar \ldots{}
).
\end_layout

\begin_layout Standard
When solving a PDE, one often has to use more than one FEM.
 The most important one will be of course the one on which is defined the
 solution of the PDE.
 But most PDEs involve various coefficients, for example: 
\begin_inset Formula \[
\nabla.(\lambda(x)\nabla u)=f(x).\]

\end_inset

 Hence one has to define an FEM for the main unknown 
\begin_inset Formula $u$
\end_inset

, but also for the data 
\begin_inset Formula $\lambda(x)$
\end_inset

 and 
\begin_inset Formula $f(x)$
\end_inset

 if they are not constant.
 In order to interpolate easily these coefficients in their finite element
 space, one often choose a Lagrangian FEM.
\end_layout

\begin_layout Standard
The convexes, mesh nodes, and dof are all numbered.
 We sometimes refer to the number associated to a convex as its 
\shape italic
convex id
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
convex id
\end_layout

\end_inset

 (contracted to 
\shape italic
cvid
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
cvid
\end_layout

\end_inset

).
 Mesh node numbers are also called 
\shape italic
point id
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
point id
\end_layout

\end_inset

 (contracted to 
\shape italic
pid
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
pid
\end_layout

\end_inset

).
 Faces of convexes do not have a global numbering, but only a local number
 in each convex.
 Hence functions which need or return a list of faces
\begin_inset Index
status collapsed

\begin_layout Plain Layout
list of faces
\end_layout

\end_inset

 will always use a two-rows matrix, the first one containing convex IDs,
 and the second one containing local face number.
\end_layout

\begin_layout Standard
While the 
\series bold
dof
\series default
 are always numbered consecutively, 
\series bold
this is not always the case for point ids and convex ids
\series default
, especially if you have removed points or convexes from the mesh.
 To ensure that they form a continuous sequence (starting from 1), you have
 to call @@gfmeshset(m,'optimize structure')@@.
\end_layout

\begin_layout Section
Changes from the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfi
\end_layout

\end_inset

-1.7
\end_layout

\begin_layout Standard
A (small) number of changes have been made which break backward compability
 with the releases 1.x of gfi.
 The most important one, is the splitting of the old 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 structure into two parts: 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 objects, which now hold only the finite elements 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 objects, which hold the integration methods 
\end_layout

\begin_layout Standard
As a consequence, the assembly routines require a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object.
\end_layout

\begin_layout Standard
Another important change is the displacement of the 
\begin_inset Quotes eld
\end_inset

boundaries
\begin_inset Quotes erd
\end_inset

 from the old 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 objects into the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 objects.
 They are now often refered to as 
\begin_inset Quotes eld
\end_inset

mesh regions
\begin_inset Quotes erd
\end_inset

 since they can hold set of convex faces, but also sets of convexes.
\end_layout

\begin_layout Standard
The old @@gf_solve@@ function is now deprecated, and replaced by the 
\begin_inset Quotes eld
\end_inset

model bricks
\begin_inset Quotes erd
\end_inset

 of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

.
 Since these brick act as a black-box, some low-level examples have been
 kept for educational purposes.
\end_layout

\begin_layout Standard
The sparse matrices and sparse solvers of getfem are now available in the
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfi
\end_layout

\end_inset

 (these where required by the python interface since python does not have
 any sparse matrix routines).
 Note that these solvers (cg, superlu, etc) are often faster than the matlab
 ones.
\end_layout

\begin_layout Section
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
Gfm
\end_layout

\end_inset

 organization
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 toolbox is just a convenient interface to the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 library: you must have a working 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 installed on your computer.
 This toolbox provides a big 
\family typewriter
mex-file
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mex
\end_layout

\end_inset

 (c++ binary callable from 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

) and some additional 
\family typewriter
m-files
\family default
 (documentation and extra-functionalities).
 All the functions of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
Gfm
\end_layout

\end_inset

 are prefixed by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

gf_
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 (hence typing 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

gf_
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 at the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 prompt and then pressing the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

<tab>
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 key is a quick way to obtain the list of getfem functions).
\end_layout

\begin_layout Subsection
Functions
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="45" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="none" valignment="top" width="70text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_workspace 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
workspace management
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gfutil 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
miscellanous utility functions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_delete 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
destroy a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 object (
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mesh
\end_layout

\end_inset

 , 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 , 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mim
\end_layout

\end_inset

 etc..)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gfcvstructget 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
cvstruct
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_geotrans 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
define a geometric transformation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_geotransget 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gt
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
creates a new 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mesh
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mesh
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mesh
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_eltm 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
define an elementary matrix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_fem 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
define a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
fem
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_femget 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
fem
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_integ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
define a integration method
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_integget 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
integ
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_fem 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
creates a new 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_fem_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_fem_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_im 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
creates a new 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mim
\end_layout

\end_inset

 object 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_im_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mim
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mesh_im_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mim
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_slice 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create a new 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_slice_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve informations from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_slice_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset

 object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_spmat 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
spmat
\end_layout

\end_inset

 object 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_spmat_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
perform computations with the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
spmat
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_spmat_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
spmat
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_precond 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
precond
\end_layout

\end_inset

 object 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_precond_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
perform computations with the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
precond
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_linsolve 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
interface to various linear solvers provided by getfem (
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
SuperLU
\end_layout

\end_inset

, conjugated gradient etc.) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_asm 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
assembly routines
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_solve 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
various solvers for usual PDEs (obsoleted by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mdbrick
\end_layout

\end_inset

 objects)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_compute 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
computations involving the solution of a PDE (norm, derivative, etc..)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mdbrick 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create a 
\begin_inset Quotes eld
\end_inset

model brick
\begin_inset Quotes erd
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mdbrick_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve information from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mdbrick
\end_layout

\end_inset

 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mdbrick_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mdbrick
\end_layout

\end_inset

 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mdstate 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create a 
\begin_inset Quotes eld
\end_inset

model state
\begin_inset Quotes erd
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mdstate_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve information from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mdstate
\end_layout

\end_inset

 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_mdstate_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mdstate
\end_layout

\end_inset

 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_model 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
create a 
\begin_inset Quotes eld
\end_inset

model
\begin_inset Quotes erd
\end_inset

 object 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
NEW
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_model_get 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
retrieve information from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
model
\end_layout

\end_inset

 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_model_set 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modify a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
model
\end_layout

\end_inset

 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_plot_mesh 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
plotting of mesh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_plot 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
plotting of 2D and 3D fields
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_plot_1D 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
plotting of 1D fields
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
##gf_plot_slice 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
plotting of a mesh slice
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Objects
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
T
\end_layout

\end_inset

 
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "8cm"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Graphics
	filename hierarchy.eps
	width 8cm

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlimg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

hierarchy.png
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

objects relations
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
T
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
T
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hspace{.3cm}
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
T
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
T
\end_layout

\end_inset

 
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "12cm"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
 
\shape italic
\size small
GEOTRANS
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
geometric transformation
\end_layout

\end_inset

: geometric transformations (defines the shape/position of the convexes),
 created with ##gf_geotrans
\begin_inset Newline newline
\end_inset

 
\shape italic
MESH
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh
\end_layout

\end_inset

: mesh structure (nodes, convexes, geometric transformations for each convex),
 created with ##gf_mesh
\begin_inset Newline newline
\end_inset

 
\shape italic
INTEG
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
integration method
\end_layout

\end_inset

: integration method (exact, quadrature formula\SpecialChar \ldots{}
).
 Although not linked directly to GEOTRANS, an integration method is usually
 specific to a given convex structure.
 Created with ##gf_integ 
\begin_inset Newline newline
\end_inset

 
\shape italic
FEM
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
FEM
\end_layout

\end_inset

: the finite element method (one per convex, can be PK, QK, HERMITE, etc\SpecialChar \ldots{}
).
 Created with ##gf_fem 
\begin_inset Newline newline
\end_inset

 
\shape italic
CVSTRUCT
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
convex structure
\end_layout

\end_inset

: stores formal information convex structures (nb.
 of points, nb.
 of faces which are themselves convex structures).
\begin_inset Newline newline
\end_inset

 
\shape italic
MESHFEM
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_fem
\end_layout

\end_inset

: object linked to a mesh, where each convex has been assigned an FEM.
 Created with ##gf_mesh_fem.
\begin_inset Newline newline
\end_inset

 
\shape italic
MESHIM
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_im
\end_layout

\end_inset

: object linked to a mesh, where each convex has been assigned an integration
 method.
 Created with ##gf_mesh_im.
\begin_inset Newline newline
\end_inset

 
\shape italic
MESHSLICE
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
slice
\end_layout

\end_inset

: object linked to a mesh, very similar to a P1-discontinuous 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

.
 Used for fast interpolation and plotting.
\begin_inset Newline newline
\end_inset

 
\shape italic
MDBRICK
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdbrick
\end_layout

\end_inset

: 
\begin_inset Quotes eld
\end_inset

model brick
\begin_inset Quotes erd
\end_inset

 , an abstraction of a part of solver (for example, the part which build
 the tangent matrix, the part which handles the dirichlet conditions, etc.).
 These objects are stacked to build a complete solver for a wide variety
 of problems.
 They typically use a number of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mim
\end_layout

\end_inset

 etc.
\begin_inset Newline newline
\end_inset

 
\shape italic
MDSTATE
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdstate
\end_layout

\end_inset

: 
\begin_inset Quotes eld
\end_inset

model state
\begin_inset Quotes erd
\end_inset

, holds the global data for a stack of mdbricks (global tangent matrix,
 right hand side etc.).
 
\shape italic
MODEL
\shape default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
model
\end_layout

\end_inset

: 
\begin_inset Quotes eld
\end_inset

model
\begin_inset Quotes erd
\end_inset

, holds the global data, variables and description of a model.
 Evolution of 
\begin_inset Quotes eld
\end_inset

model state
\begin_inset Quotes erd
\end_inset

 object for 4.0 version of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
T
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
T
\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
Gfi
\end_layout

\end_inset

 objects hierarchy
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:hierarchy"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Various 
\begin_inset Quotes eld
\end_inset

objects
\begin_inset Quotes erd
\end_inset

 can be manipulated by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 toolbox, see fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:hierarchy"

\end_inset

.
 The MESH and MESHFEM objects are the two most important objects.
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 toolbox uses its own memory management
\begin_inset Index
status collapsed

\begin_layout Plain Layout
memory management
\end_layout

\end_inset

.
 Hence 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 objects are not cleared when a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

clear all
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 is issued at the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 prompt, but instead the function 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 gf_workspace('clear all') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 should be used.
 The various 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 object can be accessed via 
\shape italic
handles
\shape default
 (or 
\shape italic
descriptors
\shape default
), which are just 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 structures containing 32-bits integer identifiers to the real objects.
 Hence the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 command 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

whos
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 does not report the memory consumption of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 objects (except the marginal space used by the handle).
 Instead, you should use 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 gf_workspace('stats') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are two kinds of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 objects: 
\end_layout

\begin_layout Itemize
static ones, which can not be deleted: ELTM, FEM, INTEG, GEOTRANS and CVSTRUCT.
 Hopefully their memory consumption is very low.
 
\end_layout

\begin_layout Itemize
dynamic ones, which can be destroyed, and are handled by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

gf_workspace
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 function: MESH, MESHFEM, MESHIM, SLICE, SPMAT, PRECOND.
 
\end_layout

\begin_layout Standard
The objects MESH and MESHFEM are not independent: a MESHFEM object is always
 linked to a MESH object, and a MESH object can be used by several MESHFEM
 objects.
 Hence when you request the destruction of a MESH object, its destruction
 might be delayed until it is not used anymore by any MESHFEM (these objects
 waiting for deletion are listed in the 
\shape italic
anonymous workspace
\shape default
 section of @@gf_workspace('stats')@@).
\end_layout

\begin_layout Section
Examples
\end_layout

\begin_layout Subsection
A step-by-step basic example
\end_layout

\begin_layout Standard
This example shows the basic usage of getfem, on the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

ü
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

ber-canonical problem above all others: solving the Laplacian
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Laplacian
\end_layout

\end_inset

, 
\begin_inset Formula $\Delta u+f=0$
\end_inset

 on a square, with the Dirichlet condition 
\begin_inset Formula $u=g(x)$
\end_inset

 on the domain boundary.
 
\begin_inset CommandInset label
LatexCommand label
name "laplacianexample"

\end_inset


\end_layout

\begin_layout Standard
The first step is to 
\series bold
create a mesh
\series default
.
 Since 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 does not come with its own mesher, one has to rely on an external mesher
 (see @@gfmesh('import')@@), or use very simple meshes.
 For this example, we just consider a regular mesh
\begin_inset Index
status collapsed

\begin_layout Plain Layout
cartesian mesh
\end_layout

\end_inset

 whose nodes are 
\begin_inset Formula $\{x_{i=0\ldots10,j=0..10}=(i/10,j/10)\}$
\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% creation of a simple cartesian mesh
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 m = gfmesh('cartesian',[0:.1:1],[0:.1:1]) m = id: 0 cid: 0 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 If you try to look at the value of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, you'll notice that it appears to be a structure containing two integers.
 The first one is its identifier, the second one is its class-id, i.e.
 an identifier of its type.
 This small structure is just an 
\begin_inset Quotes eld
\end_inset

handle
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

descriptor
\begin_inset Quotes erd
\end_inset

 to the real object, which is stored in the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 memory and cannot be represented via 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
Slab
\end_layout

\end_inset

 data structures.
 Anyway, you can still inspect the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 objects via the command @@gf_workspace('stats')@@.
\end_layout

\begin_layout Standard
Now we can try to have a 
\series bold
look at the mesh
\series default
, with its vertices numbering and the convexes numbering: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% we enable vertices and convexes labels
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 gf_plot_mesh(m, 'vertices', 'on', 'convexes', 'on'); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 As you can see, the mesh is regular, and the numbering of its nodes and
 convexes is also regular (this is guaranteed for cartesian meshes, but
 do not hope a similar numbering for the degrees of freedom).
\end_layout

\begin_layout Standard
The next step is to 
\series bold
create a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object
\series default
.
 This one links a mesh with a set of FEM.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 mf = gfmeshfem(m,1); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% create a 
\backslash
tmf of for a field of dimension 1 (i.e.
 a scalar field)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 gf_mesh_fem_set(mf,'fem',gf_fem('FEMQK(2,2)')); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 The first instruction builds a new 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object, the second argument specifies that this object will be used to
 interpolate scalar fields (since the unknown is a scalar field).
 The second instruction assigns the 
\begin_inset Formula $Q^{2}$
\end_inset

 FEM to every convex (each basis function is a polynomial of degree 4, remember
 that 
\begin_inset Formula $P^{k}\Rightarrow$
\end_inset

 polynomials of degree 
\begin_inset Formula $k$
\end_inset

, while 
\begin_inset Formula $Q^{k}\Rightarrow$
\end_inset

 polynomials of degree 
\begin_inset Formula $2k$
\end_inset

).
 As 
\begin_inset Formula $Q^{2}$
\end_inset

 is a polynomial FEM, you can view the expression of its basis functions
 on the reference convex: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 gffemget(gffem('FEMQK(2,2)'), 'polystr') ans = '1 - 3*x - 3*y + 2*x2 +
 9*x*y + 2*y2 - 6*x2*y - 6*x*y2 + 4*x2*y2' '4*x - 4*x2 - 12*x*y + 12*x2*y
 + 8*x*y2 - 8*x2*y2' '-x + 2*x2 + 3*x*y - 6*x2*y - 2*x*y2 + 4*x2*y2' '4*y
 - 12*x*y - 4*y2 + 8*x2*y + 12*x*y2 - 8*x2*y2' '16*x*y - 16*x2*y - 16*x*y2
 + 16*x2*y2' '-4*x*y + 8*x2*y + 4*x*y2 - 8*x2*y2' '-y + 3*x*y + 2*y2 - 2*x2*y
 - 6*x*y2 + 4*x2*y2' '-4*x*y + 4*x2*y + 8*x*y2 - 8*x2*y2' 'x*y - 2*x2*y
 - 2*x*y2 + 4*x2*y2' 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is also possible to make use of the 
\begin_inset Quotes eld
\end_inset

object oriented
\begin_inset Quotes erd
\end_inset

 features of matlab.
 As you may have noticed, when a class 
\begin_inset Quotes eld
\end_inset

foo
\begin_inset Quotes erd
\end_inset

 is provided by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfi
\end_layout

\end_inset

 , it is build with the function @@gffoo@@ , and manipulated with the functions
 @@gf_foo_get@@ and @@gffooset@@.
 But (with matlab 6.x and better) you may also create the object with the
 @@gfFoo@@ constructor , and manipulated with the @@get(..)@@ and @@set(..)@@
 methods.
 For example, the previous steps could have been: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 gfFem('FEMQK(2,2)') gfFem object ID=0 dim=2, targetdim=1, nbdof=9,[EQUIV,
 POLY, LAGR], est.degree=4 -> FEMQK(2,2) 
\begin_inset Quotes ald
\end_inset

 m=gfMesh('cartesian', 0:.1:1, 0:.1:1) gfMesh object ID=0 [16512 bytes], dim=2,
 nbpts=121, nbcvs=100 
\begin_inset Quotes ald
\end_inset

 mf=gfMeshFem(m,1) gfMeshFem object: ID=1 [804 bytes], qdim=1, nbdof=0,
 linked gfMesh object: dim=2, nbpts=121, nbcvs=100 
\begin_inset Quotes ald
\end_inset

 set(mf, 'fem', gfFem('FEMQK(2,2)')) 
\begin_inset Quotes ald
\end_inset

 mf gfMeshFem object: ID=1 [1316 bytes], qdim=1, nbdof=441, linked gfMesh
 object: dim=2, nbpts=121, nbcvs=100 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now, in order to perform numerical integrations on @@mf@@, we need to 
\series bold
build a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object
\series default
: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% assign the same integration method on all convexes 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 mim=gfmeshim(m, gf_integ('IMEXACTPARALLELEPIPED(2)')); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 The integration method will be used to compute the various integrals on
 each element: here we choose to perform exact computations (no quadrature
 formula
\begin_inset Index
status collapsed

\begin_layout Plain Layout
quadrature formulas
\end_layout

\end_inset

), which is possible since the geometric transformation of these convexes
 from the reference convex is linear (this is true for all simplices, and
 this is also true for the parallelepipeds of our regular mesh, but it is
 not true for general quadrangles), and the chosen FEM is polynomial.
 Hence it is possible to analytically integrate every basis function/product
 of basis functions/gradients/etc.
 There are many alternative FEM methods and integration methods (see 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www-gmm.insa-toulouse.fr/getfem/doc
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

the description of finite element and integration methods
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
Note however that in the general case, approximate integration methods are
 a better choice than exact integration methods.
\end_layout

\begin_layout Standard
Now we have to 
\series bold
find the 
\begin_inset Quotes eld
\end_inset

boundary
\begin_inset Quotes erd
\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
boundary
\end_layout

\end_inset

 of the domain
\series default
, in order to set a 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Dirichlet
\end_layout

\end_inset

 condition.
 A mesh object has the ability to store some sets of convexes and convex
 faces.
 These sets (called 
\begin_inset Quotes eld
\end_inset

regions
\begin_inset Quotes erd
\end_inset

) are accessed via an integer #id: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 border = gfmeshget(m,'outer faces'); 
\begin_inset Quotes ald
\end_inset

 gfmeshset(m, 'region', 42, border); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% create the region 
\backslash
#42
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 gfplotmesh(m, 'regions', [42]); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the boundary edges appears in red
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 Here we find the faces of the convexes which are on the boundary of the
 mesh (i.e.
 the faces which are not shared by two convexes).
 
\shape italic
remark:
\shape default
 we could have used @@gfmeshget(m, 'OuTErfaCes')@@ , as the interface is
 case-insensitive, and whitespaces can be replaced by underscores.
 The array 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

border
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 has two rows, on the first row is a convex number, on the second row is
 a face number (which is local to the convex, there is no global numbering
 of faces).
 Then this set of faces is assigned to the region number 42
\begin_inset Index
status collapsed

\begin_layout Plain Layout
boundary number
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
At this point, we just have to stack some model bricks and run the solver
 to get the solution! The 
\begin_inset Quotes eld
\end_inset

model bricks
\begin_inset Quotes erd
\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdbrick
\end_layout

\end_inset

 are created with the @@gf_mdbrick@@ (or @@gfMdBrick@@) constructor.
 A model brick is basically an object which modifies a global linear system
 (tangent matrix for non-linear problems) and its associated right hand
 side.
 Typical modifications are insertion of the stiffness matrix for the problem
 considered (linear elasticity, laplacian, etc), handling of a set of contraints
, Dirichlet condition, addition of a source term to the right hand side
 etc.
 The global tangent matrix and its right hand side are stored in a 
\begin_inset Quotes eld
\end_inset

model state
\begin_inset Quotes erd
\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdstate
\end_layout

\end_inset

 structure, created with the @@gfmdstate@@ constructor.
\end_layout

\begin_layout Standard
Let us build a problem with an easy solution: 
\begin_inset Formula $u=x(x-1)y(y-1)+x^{5}$
\end_inset

, then we have 
\begin_inset Formula $\Delta u=2(x^{2}+y^{2})-2(x+y)+20x^{3}$
\end_inset

 (the FEM won't be able to catch the exact solution since we use a 
\begin_inset Formula $Q^{2}$
\end_inset

 method).
\end_layout

\begin_layout Standard
We start with a 
\begin_inset Quotes eld
\end_inset

generic elliptic
\begin_inset Quotes erd
\end_inset

 brick, which handles 
\begin_inset Formula $-div(A\nabla u)=\ldots$
\end_inset

 problems, where 
\begin_inset Formula $A$
\end_inset

 can be a scalar field, a matrix field, or an order 4 tensor field.
 By default, 
\begin_inset Formula $A=1$
\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 b0=gfmdbrick('generic elliptic',mim,mf) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each brick embeds a number of parameter fields.
 In the case of the generic elliptic brick, there is only one parameter
 field, the 
\begin_inset Formula $A(x)$
\end_inset

 coefficient in 
\begin_inset Formula $-div(A\nabla u)=\ldots$
\end_inset

.
 It is possible to view the list of parameters of the brick with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 gfmdbrickget(b0, 'param list') ans =
\end_layout

\begin_layout Standard
'A' 
\begin_inset Quotes ald
\end_inset

 gfmdbrickget(b0, 'param', 'A')
\end_layout

\begin_layout Standard
ans =
\end_layout

\begin_layout Standard
1 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next we add a Dirichlet condition on the domain boundary: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 b1=gfmdbrick('dirichlet',b0,42,mf,'penalized') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 Here the number @@42@@ is the region number to which the dirichlet condition
 is applied.
 The @@'penalized'@@ says that the Dirichlet condition should be imposed
 via a penalization technique.
 Other ways are possible (augmented system, direct elimination).
 A 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 argument is also required, as the Dirichlet condition 
\begin_inset Formula $u=r$
\end_inset

 is imposed in a weak form 
\begin_inset Formula $\int_{\Gamma}u(x)v(x)=\int_{\Gamma}r(x)v(x)\forall v$
\end_inset

 where 
\begin_inset Formula $v$
\end_inset

 is taken in the space of multipliers given by here by @@mf@@.
\end_layout

\begin_layout Standard
By default, the Dirichlet brick imposes 
\begin_inset Formula $u=0$
\end_inset

 on the specified boundary.
 We change this to 
\begin_inset Formula $u=(x-.5)^{2}+(y-.5)^{2}+x/5-y/3$
\end_inset

: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 R=gfmeshfemget(mf, 'eval', {'(x-.5).2 + (y-.5).2 + x/5 - y/3'}); 
\begin_inset Quotes ald
\end_inset

 gfmdbrickset(b1, 'param', 'R', mf, R); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 
\shape italic
Remark:
\shape default
 the polynomial expression was interpolated on @@mf@@.
 It is possible only if @@mf@@ is of Lagrange type.
 In this first example we use the same 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 for the unknown and for the data such as @@R@@, but in the general case,
 @@mf@@ won't be Lagrangian and another (Lagrangian) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 will be used for the description of Dirichlet conditions, source terms
 etc.
\end_layout

\begin_layout Standard
A 
\begin_inset Quotes eld
\end_inset

model state
\begin_inset Quotes erd
\end_inset

 variable is created, and the solver is launched: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 mds=gfmdstate('real') 
\begin_inset Quotes ald
\end_inset

 gfmdbrickget(b1, 'solve', mds) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The model state now contains the solution (as well as other things, such
 as the linear system which was solved).
 It is extracted, a display into a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 figure.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 U=gfmdstateget(mds, 'state'); 
\begin_inset Quotes ald
\end_inset

 gfplot(mf, U, 'mesh','on'); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Another Laplacian with exact solution
\end_layout

\begin_layout Standard
This is the 
\family typewriter
tests/matlab/demolaplacian.m
\family default
 example.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "demolaplacian.tex"

\end_inset


\end_layout

\begin_layout Subsection
Linear and non-linear elasticity
\end_layout

\begin_layout Standard
This example 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
tripod
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
linear elasticity
\end_layout

\end_inset

 uses a mesh that was generated with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://gid.cimne.upc.es
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

GiD
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
GiD
\end_layout

\end_inset

.
 The object is meshed with quadratic tetrahedrons.
 You can find the 
\family typewriter
m-file
\family default
 of this example under the name 
\family typewriter
demotripod.m
\family default
 in the directory 
\family typewriter
tests/matlab
\family default
 of the toolbox distribution.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "demotripod.tex"

\end_inset


\end_layout

\begin_layout Standard
Here is the final figure, displaying the Von Mises stress
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Von Mises
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Graphics
	filename tripodvonmiseswithmesh.png
	width 7cm

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlimg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

tripodvonmiseswithmeshsmall.png
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

deformed tripod
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\begin_layout Subsection
Avoiding the bricks framework
\end_layout

\begin_layout Standard
The model bricks are very convenient, as they hide most of the details of
 the assembly of the final linear systems.
 However it is also possible to stay at a lower level, and handle the assembly
 of linear systems, and their resolution, directly in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

.
 For example, the demonstration 
\family typewriter
demo_tripod_alt.m
\family default
 is very similar to the 
\family typewriter
demo_tripod.m
\family default
 except that the assembly is explicit:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 nbd=get(mfd, 'nbdof'); F = gfasm('boundarysource', 1, mim, mfu, mfd, repmat([0;
-10;0],1,nbd)); K = gfasm('linearelasticity', mim, mfu, mfd, ...
 lambda*ones(1,nbd),mu*ones(1,nbd));
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% handle Dirichlet condition
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

[H,R]=gfasm('dirichlet', 2, mim, mfu, mfd, repmat(eye(3),[1,1,nbd]), zeros(3,
 nbd)); [N,U0]=gfspmatget(H, 'dirichletnullspace', R); KK=N'*K*N; FF=N'*F;
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% solve ...
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

disp('solving...'); t0 = cputime; lsolver = 1 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% change this to compare the different solvers
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

if (lsolver == 1), 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% conjugate gradient
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 P=gfPrecond('ildlt',KK); UU=gflinsolve('cg',KK,FF,P,'noisy','res',1e-9);
 elseif (lsolver == 2), 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% superlu
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 UU=gflinsolve('superlu',KK,FF); else 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the matlab "slash" operator 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 UU=KK 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb+
\backslash
+ FF;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\begin_layout Plain Layout

disp(sprintf('linear system solved in 
\backslash
%.2f sec', cputime-t0));
\end_layout

\begin_layout Plain Layout

U=(N*UU).'+
\end_layout

\end_inset

U0; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfi
\end_layout

\end_inset

, the assembly of vectors, and matrices is done via the @@gf_asm@@ function.
 The Dirichlet condition 
\begin_inset Formula $u(x)=r(x)$
\end_inset

 is handled in the weak form 
\begin_inset Formula $\int(h(x)u(x)).v(x)=\int r(x).v(x)\quad\forall v$
\end_inset

 (where 
\begin_inset Formula $h(x)$
\end_inset

 is a 
\begin_inset Formula $3\times3$
\end_inset

 matrix field -- here it is constant and equal to the identity).
 The reduced system @@KK UU = FF@@ is then built via the elimination of
 Dirichlet constraints from the original system.
 Note that it might be more efficient (and simpler) to deal with Dirichlet
 condition via a penalization technique.
\end_layout

\begin_layout Subsection
Other examples
\end_layout

\begin_layout Itemize
the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demorefine.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh refinement
\end_layout

\end_inset

 script shows a simple 2D or 3D bar whose extremity is clamped.
 An adaptative refinement is used to obtain a better approximation in the
 area where the stress is singular (the transition between the clamped area
 and the neumann boundary).
\end_layout

\begin_layout Itemize
the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demononlinearelasticity.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 script shows a 3D bar which is is bended and twisted.
 This is a quasi-static problem as the deformation is applied in many steps.
 At each step, a non-linear (large deformations) elasticity problem is solved.
\end_layout

\begin_layout Itemize
the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demostokes3Dtank.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 script shows a Stokes (viscous fluid) problem in a tank.
 The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demostokes3Dtankdraw.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 shows how to draw a nice plot of the solution, with mesh slices and stream
 lines.
 Note that the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demostokes3Dtankalt.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is the old example, which uses the deprecated @@gfsolve@@ function.
\end_layout

\begin_layout Itemize
the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demobilaplacian.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 script is just an adaption of the getfem++ example 
\family typewriter
tests/bilaplacian.cc
\family default
.
 Solve the bilaplacian (or a Kirchhoff-Love plate model) on a square.
\end_layout

\begin_layout Itemize
the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demoplasticity.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 script is an adaptation of the getfem++ example 
\family typewriter
tests/plasticity.cc
\family default
: a 2D or 3D bar is bended in many steps, and the plasticity of the material
 is taken into account (plastification occurs when the material's Von Mises
 exceeds a given threshold).
\end_layout

\begin_layout Itemize
the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

demowave2D.m
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is a 2D scalar wave equation example (diffraction of a plane wave by a
 cylinder), with high order geometric transformations and high order FEMs.
 
\end_layout

\begin_layout Subsection
Using Matlab Object-Oriented features
\end_layout

\begin_layout Standard
The basic functions of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 toolbox do not use any advanced 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 features (except that the handles to getfem objects are stored in a small
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 structure).
 But the toolbox comes with a set of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
Slab
\end_layout

\end_inset

 objects
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Matlab objects
\end_layout

\end_inset

, which encapsulate the handles and make them look as real 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 objects.
 The aim is not to provide extra-functionalities, but to have a better integrati
on of the toolbox with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Here is an example of its use: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 m=gfmesh('cartesian',0:.1:1,0:.1:1) m = id: 0 cid: 0
\end_layout

\begin_layout Standard
\begin_inset Quotes ald
\end_inset

 m2=gfMesh('cartesian',0:.1:1,0:.1:1) gfMesh object ID=1 [17512 bytes], dim=2,
 nbpts=121, nbcvs=100 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% while 
\backslash
kw{m} is a simple structure, 
\backslash
kw{m2} has been flagged by 
\backslash
slab
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% as  an object of class gfMesh.
  Since the 
\backslash
texttt{display} method for 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% these  objects  have  been  overloaded,  the  toolbox  displays  some
 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% information about the mesh instead of the content of the structure.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 gfmeshget(m,'nbpts') ans = 121 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% pseudo member access (which calls ##gf_mesh_get(m2,'nbpts'))
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 m2.nbpts ans = 121 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 Refer to the OO-commands reference 
\begin_inset CommandInset ref
LatexCommand ref
reference "OOcommands"

\end_inset

 for more details.
\end_layout

\begin_layout Section
Command reference
\end_layout

\begin_layout Subsection
Types
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

typelist
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 The expected type of each function argument is indicated in this reference.
 Here is a list of these types: 
\begin_inset Tabular
<lyxtabular version="3" rows="20" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="none" valignment="top" width="70text%">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer value 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a handle
\begin_inset Index
status collapsed

\begin_layout Plain Layout
handle
\end_layout

\end_inset

 for any 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 object.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
scalar value 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vector of integer values 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vector 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matrix of integer values 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matrix 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sparse matrix (both scilab native sparse matrices, and getfem sparse matrices)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tprecond
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
getfem preconditioner object
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mesh object descriptor (or ##gfMesh object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mesh_fem object descriptor (or ##gfMeshFem object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mesh_im object descriptor( or ##gfMeshIm object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mesh_slice object descriptor (or ##gfSlice object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
non-modifiable mesh object (
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

can be used everywhere a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

is required) 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
convex structure descriptor (or ##gfCvStruct object) 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
geometric transformation descriptor (or ##gfGeoTrans object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fem descriptor (or ##gfFem object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
elementary matrix descriptor (or ##gfEltm object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integration method descriptor (or ##gfInteg object) 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Arguments listed between square brackets are optional.
 Lists between braces indicate that the argument must match one of the elements
 of the list.
 For example 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 [X,Y]=dummy(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 i, {'foo' | 'bar'} [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 v]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 means that the dummy function takes two or three arguments, its first being
 an integer value, the second a string which is either 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

foo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

bar
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, and a third optional argument.
 It returns two values (with the usual 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 meaning, i.e.
\begin_inset space \space{}
\end_inset

the caller can always choose to ignore them).
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_WORKSPACE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_workspace
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfworkspace
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 workspace management function
\begin_inset Index
status collapsed

\begin_layout Plain Layout
memory management
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gf_workspace('push') gfworkspace('pop' [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 i, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 j,..]) gfworkspace('stat') gfworkspace('stats') gfworkspace('keep', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 i[,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 j, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 k..]) gfworkspace('clear') gfworkspace('clear all') gfworkspace('class name',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 i) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 Getfem uses its own workspaces in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Slab
\end_layout

\end_inset

, independently of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 workspaces.
 The reason for that is the lack of a notion of destructor in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

.
 Hence, only descriptors to the real object are manipulated in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

workspaces, while the real data is managed by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 functions.
 The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 workspaces can be stacked with the commands 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

push
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

pop
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 By default, all getfem variables belong to the root getfem workspace.
 A function can create its own workspace by invoking @@gf_workspace('push')@@
 at its beginning.
 When exiting, this function MUST invoke @@gf_workspace('pop')@@ (you can
 use 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

exception handling to do this cleanly when the function exits on an error,
 see the example below).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('push')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a new temporary workspace on the workspace stack.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('pop' [,i,j,..])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : leave the current workspace, destroying all getfem variables belonging
 to it, except the one listed after 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

pop
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, and the ones which were moved to the parent workspace by @@gf_workspace('keep'
)@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('stat')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : print informations about variables in current workspace.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('stats')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : print informations about all getfem variables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('keep', i[,j,k..])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : prevent the listed variables i from being deleted when the command @@gf_works
pace('pop')@@ will be called.
 This is accomplished by moving this variable in the parent workspace.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('clear')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : clear the current workspace.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('clear all')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : clear every workspace, and return to the main workspace.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_workspace('class name', i)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the class name of object @@i@@ (if @@I@@ is a mesh handle, it
 returns @@'gfMesh'@@ etc..).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 If you want to create 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 object within one of your own m-files, you should follow this template
 in order to avoid memory leaks 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 function [a]=foo(x,y,z) gfworkspace('push'); try \SpecialChar \ldots{}
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% some work here 
\backslash
ldots
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 a = gfmeshfem(m); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% create a 
\backslash
gf object
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 b = gfmesh(x); gfworkspace('keep', a); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% b will be automatically destroyed at the 
\backslash
str@{pop@}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 \SpecialChar \ldots{}
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% other work
\backslash
ldots
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 catch gfworkspace('pop'); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% cleanup before error
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 error(lasterr); end; gfworkspace('pop'); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 You should be aware that this won't prevent memory leaks if you interrupt
 the function foo with Ctrl-C.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_delete, gf_mesh, gf_mesh_fem@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_DELETE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_delete
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfdelete
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Deletion of a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

@@gfdelete(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 I,[
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 J,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset

 K,\SpecialChar \ldots{}
])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_delete(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

I,[
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

J, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thobj
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

K,...])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : delete an existing getfem object from memory.
 @@I@@ should be a descriptor given by @@gfmesh()@@, @@gfmeshim()@@, @@gfslice()
@@ etc.
\end_layout

\begin_layout Standard
Note that if another object uses @@I@@, then object @@I@@ will be deleted
 only when both have been asked for deletion.
\end_layout

\begin_layout Standard
Only objects listed in the output of @@gfworkspace('stats')@@ can be deleted
 (for example gffem objects cannot be destroyed).
\end_layout

\begin_layout Standard
You may also use @@gfworkspace('clear all')@@ to erase everything at once.
\end_layout

\begin_layout Standard

\shape italic
remark:
\shape default
 instead of passing a list of handles, you may pass an array of object handles.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_workspace, gf_mesh, gf_mesh_fem@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_UTIL
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_util
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfutil
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Various functions.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gfutil('save matrix',
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 fmt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 A) A = gfutil('load matrix',
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 fmt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename) gfutil('trace level', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 level) gfutil('warning level', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 level) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfutil('save matrix', fmt, filename, A)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 exports a sparse matrix into the file named @@filename@@, using Harwell-Boeing
 (@@fmt='hb'@@)
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Harwell-Boeing
\end_layout

\end_inset

 or Matrix-Market (@@fmt='mm'@@)
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Matrix Market
\end_layout

\end_inset

 formatting.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@A=gfutil('load matrix', fmt, filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : imports a sparse matrix from a file.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfutil('trace level', level)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : set the verbosity of some getfem++ routines (typically the messages printed
 by the model bricks), 0 means no trace message (default is 3).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfutil('warning level', level)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : filter the less important warnings displayed by getfem.
 0 means no warnings, default level is 3.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_GEOTRANS
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_geotrans
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfgeotrans
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Return the handle of a geometric transformation object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
geometric transformation
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

@@I = gfgeotrans(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The geometric transformation must be used when you are building a custom
 mesh convex by convex (see the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

add convex
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 sub-command of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

gf_mesh_set
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

): it also defines the kind of convex (triangle, hexahedron, prism, etc..).
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

name
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 argument contains the specification of the geometric transformation as
 a string, which may be:
\begin_inset Newline newline
\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_PK(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
geometric transformation of a simplex of dimension N , degree K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_QK(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
geometric transformation of a parallelepiped of dimension N, degree K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_PRISM(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
geometric transformation of a prism of dimension N, degree K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_PRODUCT(a,b)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tensorial product of two geometric transformations 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

a
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

b
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_LINEAR_PRODUCT(a,b)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
linear tensorial product of two geometric transformations 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

a
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

b
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Geometric transformations of an existing mesh can be obtained with @@gfmeshget(M
,'geotrans')@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 In order to get the geometric transformation for a prism of dimension 3,
 you could use 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 gt = gfgeotrans(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_PRISM(3,1)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\family roman
or
\family default
 gt = gfgeotrans(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_PRODUCT(GTPK(2,1),GTPK(1,1))
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 If you want the geometric transformation for a curved triangle, you might
 choose 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 gt = gfgeotrans(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GTPK(2,2)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% 6-noded triangle
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 If you want to use a cartesian mesh, then it is preferable to use 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 gt = gfgeotrans(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GT_LINEAR_PRODUCT(GT_PK(1,1), GT_PK(1,1))
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\family roman
instead of
\family default
 gfgeotrans(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GTQK(2,1)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\family roman
or
\family default
 gfgeotrans(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

GTPRODUCT(GT_PK(1,1), GT_PK(1,1))
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

), 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 since the geometric transformation for parallelepipeds is linear
\begin_inset Index
status collapsed

\begin_layout Plain Layout
linear geometric transformation
\end_layout

\end_inset

, and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 can take advantage of it (exact integration method
\begin_inset Index
status collapsed

\begin_layout Plain Layout
exact integration
\end_layout

\end_inset

, direct inversion of the geometrical transformation,\SpecialChar \ldots{}
).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh_set(M,'add convex'), gfmeshget(M,'geotrans'), gfGeoTrans@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_GEOTRANS_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_geotransget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfgeotransget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Query information on a geometric transformation
\begin_inset Index
status collapsed

\begin_layout Plain Layout
geometric transformation
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gfgeotransget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT, 'dim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gfgeotransget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT, 'islinear') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 n = gfgeotransget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT, 'nbpts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 P = gfgeotransget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT, 'pts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 N = gfgeotransget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT, 'normals') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 Pts2 = gfgeotransget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT, 'transform', G, Pts) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 s = gfgeotransget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT, 'char') @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfgeotransget(GT, 'dim')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is the dimension of the geometric transformation.
 This is the dimension of the source space, i.e.
 the dimension of the reference convex: @@gfgeotransget(gfgeotrans('GTPK(x,K)'))
==x@@.
 The dimension of the target space is the dimension of the mesh object using
 the geometric transformation.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfgeotransget(GT, 'islinear')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return 1 if the geometric transformation is linear
\begin_inset Index
status collapsed

\begin_layout Plain Layout
linear geometric transformation
\end_layout

\end_inset

, or 0 if it is not.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfgeotransget(GT, 'nbpts')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of points of the geometric transformation, and @@gfgeotrans
get(GT, 'pts')@@ return the list of the points (in the reference convex)
 stored in the columns of an array.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfgeotransget(GT,'normals')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : output the normals on each face of the reference convex
\begin_inset Index
status collapsed

\begin_layout Plain Layout
face normals
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfgeotransget(GT, 'transform', G, Pts)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : apply the geometric transformation to the points @@pts@@: @@G@@ is the
 set of vertices of the real convex, @@pts@@ is the set of points (in the
 reference convex) that are to be transformed.
 The corresponding set of points in the real convex is returned.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfgeotransget(GT,'char')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : give a string description of the geometric transformation.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 gt=gfgeotrans('GTPK(2,1)'); gfgeotransget(gt,'pts') ans = 0 1 0 0 0 1 
\begin_inset Quotes ald
\end_inset

 gt=gfgeotrans('GTQK(2,2)'); gfgeotransget(gt,'pts') ans = 0 0.5 1 0 0.5 1
 0 0.5 1 0 0 0 0.5 0.5 0.5 1 1 1 
\begin_inset Quotes ald
\end_inset

 gfgeotransget(gt,'char') ans = GTQK(2,1) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gfgeotrans, gf_mesh_set(M,'add convex'), gfmeshget(M,'geotrans')@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
gf_cvstructget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfcvstructget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Query information on a convex structure object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
convex structure
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I=gfcvstructget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 cs, 'nbpts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I=gfcvstructget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 cs, 'dim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 cs=gfcvstructget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 cs, 'basic structure') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 cs=gfcvstructget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 cs, 'face', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 F) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 I=gfcvstructget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 cs, 'facepts', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 F) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The convex structures are internal structures of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

.
 They do not contain points positions.
 These structures are recursive, since the faces of a convex structures
 are convex structures.
 The dimension is returned by @@gfcvstructget(cs, 'dim')@@, and the number
 of points is given by @@gfcvstructget(cs, 'nbpts')@@.
 Note that a triangle structure may have 6 points, if it is a structure
 associated to a @@'GTPK(2,2)'@@ geometric transformation.
 But the canonical 3-noded triangle structure would be returned by @@gfcvstructg
et(cs, 'basic
\begin_inset space ~
\end_inset

structure')@@.
 The structure of the 
\shape italic
ith
\shape default
 face can be obtained with gfcvstructget(cs, 'face', i), and the indices
 of its points are returned by @@gfcvstructget(cs, 'facepts', i)@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gfgeotrans, gfmeshget(M,'cvstruct'), gfCvStruct@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh, gfMesh
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmesh
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Creation of mesh objects
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh object
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@M = gfmesh('empty', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 dim) M = gfmesh('cartesian', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 X[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Y[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Z,..]]) M = gfmesh('triangles grid', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 X, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Y) M = gfmesh('regular simplices', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 X[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Y[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Z,.., ]][, 'degree', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 K]['noised']) M = gfmesh('curved', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset

 M0, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 F) M = gfmesh('prismatic', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset

 M0, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 K) M = gfmesh('pt2D', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 p, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 t[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 n]) M = gfmesh('ptND', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 p, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 t) M = gfmesh('load', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename) M = gfmesh('from string', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 s) M = gfmesh('import', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 format, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename) M = gfmesh('clone', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset

 M0) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The function @@gf_mesh@@ (or @@gfMesh@@) creates a new mesh object.
 The @@gf_mesh@@ version returns a scilab structure, which can be manipulated
 with @@gf_mesh_get(M,...)@@ and @@gf_mesh_set(M,...)@@, while the @@gfMesh@@
 version returns an 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

 (in the scilab sense) @@M@@ which can also be manipulated with @@get(M,
 ...)@@ and @@set(M, ...)@@.
\end_layout

\begin_layout Standard
The first argument specifies the kind of operation which will create the
 mesh.
 The returned value, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

M
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, is an identifier (of type 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

uint32
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) to the new object.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('empty', dim)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a new empty mesh, whose nodes have @@dim@@ coordinates.
 This mesh can be later populated with e.g.
 @@gf_mesh_set('add convex',\SpecialChar \ldots{}
)@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('cartesian', X[, Y,\SpecialChar \ldots{}
])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
cartesian mesh
\end_layout

\end_inset

 can be used to build quickly a cartesian mesh (with a linear geometric
 transformation, see @@gf_geotrans@@.
 The vectors @@X@@,@@Y@@,\SpecialChar \ldots{}
 contain the vertices coordinates along each axis.
 The regular numbering of points and convexes is guaranteed by this functions
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('triangles grid', X, Y)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a regular 2D mesh, similar to a cartesian grid where each rectangle
 is split in two triangles.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('regular simplices', X, \SpecialChar \ldots{}
)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : is a generalization to arbitrary dimensions of the triangles grid.
 For example, @@gfMesh('regular simplices',0:10, 0:10, 'degree', 2, 'noised')@@
 will build a mesh of quadratic triangles (of irregular shape).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('curved', M0, F)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build a curved (
\begin_inset Formula $n+1$
\end_inset

)-dimensions mesh from a 
\begin_inset Formula $n$
\end_inset

-dimensions mesh @@M0@@: the new mesh has one additional dimension.
 The additional coordinate is given by the vector @@F@@.
 This can be used to obtain meshes for shells.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('prismatic', M0, K)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
prismatic mesh
\end_layout

\end_inset

 extrude a prismatic mesh @@M@@ from a mesh @@M0@@.
 In the additional dimension there are @@K@@ layers of elements stacked
 in the range 
\begin_inset Formula $[0..1]$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('pt2D', p, t[, n])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build quickly a planar mesh from a points array @@p@@ and a triangulation
 @@t@@.
 This can be used to convert a pdetool
\begin_inset Index
status collapsed

\begin_layout Plain Layout
pdetool
\end_layout

\end_inset

 mesh exported in variables @@p@@ and @@t@@ into a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 mesh @@M@@.
 @@n@@ is optional and is a zone number.
 If @@n@@ is specified only triangle belonging to the zone number @@n@@
 are created in the mesh.
 The points array 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw@@p@@
\end_layout

\end_inset

 is assumed to be a 
\begin_inset Formula $2\times N_{\text{points}}$
\end_inset

 matrix, and the triangles array should be a 
\begin_inset Formula $3\times nb_{\text{tri}}$
\end_inset

 matrix, or a 
\begin_inset Formula $4\times nb_{\text{tri}}$
\end_inset

 if a zone number is used.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('ptND', p, t[, n])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 this is a more general form of @@'pt2d'@@.
 It builds a simplex mesh from a given triangulation.
 The dimension of the mesh will be the number of rows of @@p@@, and the
 dimension of the simplexes will be the number of rows of @@t@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh('load', filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 load a mesh from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 mesh file (which may have been created by @@gf_mesh_get(M,'save',filename)@@.
 @@gfmesh('from string', s)@@ is very similar, but the mesh is loaded from
 a string instead of a file.
 The content of this string may be set by @@s=gfmeshget(M,'char')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmesh('import', format, filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh import
\end_layout

\end_inset

 import a mesh from a file.
 For the moment, only three formats are supported: 
\end_layout

\begin_layout Itemize
mesh objects created with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www.geuz.org/gmsh
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

gmsh
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
gmsh
\end_layout

\end_inset

 (GPL meshing/post processing tool): @@gfmesh('import', 'gmsh', filename)@@.
 Note that gmsh meshes always use 3D points, even for planar meshes.
 However, you can remove the z-component of the planar mesh with @@gfmeshset(m,
 'transform', [1 0 0; 0 1 0])@@.
 Use @@gfmesh('import', 'gmshv2', filename)@@ for gmsh file-format version
 2.0.
 
\end_layout

\begin_layout Itemize
mesh objects created with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://gid.cimne.upc.es
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

GiD
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
GiD
\end_layout

\end_inset

 (only limited version is free, but it is able to generate quadratic elements):
 @@gfmesh('import', 'gid', filename)@@.
 
\end_layout

\begin_layout Itemize
2D triangular meshes from 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://pauillac.inria.fr/cdrom/www/emc2/fra.htm
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

emc2
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
emc2
\end_layout

\end_inset

, saved with the am_fmt format: @@gfmesh('import', 'amfmt', filename)@@.
 
\end_layout

\begin_layout Standard
Support for other file-formats should be quickly available.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmesh('clone', M0)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return a copy of the mesh @@M0@@.
 Note that @@m = gfmesh('clone', m0)@@ is different from doing @@m = m0@@
 since in the latter case, @@m@@ and @@m0@@ still refer the same getfem
 mesh object!
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh_set, gf_mesh_get, gfMesh@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 Building a small 
\begin_inset Formula $5\times3$
\end_inset

 cartesian mesh: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 m = gf_mesh(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

cartesian
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

,[0:.2:1], [0:3]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 Making a curved mesh with 
\begin_inset Formula $z=x^{2}+y^{2}$
\end_inset

: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 pts = gfmeshget(m, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

pts coords
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

); V = pts(1,:).2 + pts(2,:)2; m2 = gfmesh(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

curved
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, m, V); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_get
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General mesh inquiry function.
 As this function does not modify the mesh object, a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

object handle can be used instead of a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

handle
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh object
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gfmeshget(M, 'dim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N = gf_mesh_get(M, 'nbpts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N = gf_mesh_get(M, 'nbcvs') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 PT = gf_mesh_get(M, 'pts'[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 PIDLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 PTID = gf_mesh_get(M, 'pid') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVID = gf_mesh_get(M, 'cvid') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gf_mesh_get(M, 'max pid') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gf_mesh_get(M, 'max cvid') [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 PID,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 IDX] = gf_mesh_get(M, 'pid from cvid'[,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 V = gf_mesh_get(M, 'pid from coords', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 PT) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 V = gf_mesh_get(M, 'cvid from pid', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 PTID) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 V = gf_mesh_get(M, 'orphaned pid') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 V = gf_mesh_get(M, 'faces from pid', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 PTID) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 CVFACELST = gf_mesh_get(M, 'faces from cvid', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST[, 'merge']) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 CVFACELST = gf_mesh_get(M, 'outer faces' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 BLST = gf_mesh_get(M, 'regions') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 CVFLST = gf_mesh_get(M, 'region', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 rnum) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 E[,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 C] = gf_mesh_get(M, 'edges' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST][,'merge']) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 E[,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 C] = gf_mesh_get(M, 'curved edges', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N, [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 T = gfmeshget(M, 'triangulated surface', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N, [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 N = gfmeshget(M, 'normal of face', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 CV, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 F[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 FPTNUM]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 N = gfmeshget(M, 'normal of faces', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 CVFLST) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Q = gfmeshget(M, 'quality',[CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 A = gfmeshget(M, 'convex area',[CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcvstruct
\end_layout

\end_inset

 CVS[, CV2STRUC] = gfmeshget(M, 'cvstruct',[CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset

 GT[, GT2STRUC] = gfmeshget(M, 'geotrans',[CVLST]) gf_mesh_get(M, 'save',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 FILENAME) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 s = gf_mesh_get(M, 'char') gfmeshget(M,'exporttovtk', filename, ...
 [,'ascii'][,'quality']) gfmeshget(M,'exporttodx', filename, ...[,'ascii'][,'append
'][,'as', name,[,'serie', seriename]][,'edges']) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 m = gfmeshget(M, 'memsize') @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'dim')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the dimension of the mesh (2 for a planar mesh, etc\SpecialChar \ldots{}
).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'nbpts')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of points of the mesh.
 Please note that these points might not be numbered from 1 to @@N@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'nbcvs')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of convexes of the mesh.
 Please note that these convexes might not be numbered from 1 to @@N@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@PT = gf_mesh_get(M, 'pts' [, PIDLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of point coordinates of the mesh @@M@@, each point being
 stored in a column of @@PT@@.
 If @@PIDLST@@ is specified, only those points are listed.
 Otherwise, @@PT@@ will have @@gf_mesh_get(M, 'max pid')@@ rows, which might
 be greater than @@gf_mesh_get(M, 'nbpts')@@ (if you destroyed some convexes
 or points in the mesh for example).
 The columns corresponding to inexistent points will be filled with NaN.
 You can use @@gf_mesh_get(M, 'pid')@@ to filter such invalid points.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'pid')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
pid
\end_layout

\end_inset

 : return the list of point numbers stored in @@M@@ (their numbering is
 not supposed to be contiguous from 1 to @@gf_mesh_get(M,'nbpts')@@, especially
 if you destroyed some convexes) in a row vector.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'cvid')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
cvid
\end_layout

\end_inset

 : return the list of convex numbers composing M (their numbering is not
 supposed to be contiguous from 1 to @@gf_mesh_get('nbcvs')@@, especially
 if you destroyed some convexes) in a row vector.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'max pid')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the highest point ID in the mesh (this is the same value as @@MAX(gf_m
esh_get(M, 'pts id'))@@, but it won't be equal to @@gf_mesh_get(M, 'nbpts')@@
 if some points have been destroyed and the mesh was not 
\begin_inset Quotes eld
\end_inset

repacked
\begin_inset Quotes erd
\end_inset

 with @@gf_mesh_set(M, 'optimize structure')@@).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'max cvid')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the maximum ID of all convexes in the mesh (see @@'max pid'@@).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[PID,IDX]=gf_mesh_get(M, 'pid from cvid'[, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 can be used in order to find the points of the convexes listed in @@CVLST@@
 (if not used, then the points of all convexes will be returned, which is
 equivalent to @@CVLST=1:gf_mesh_get(M,'max cvid')@@).
 Since the convexes might have different number of points, the result is
 stored as an indirect sparse array: @@IDX@@ is a row vector, which length
 is equal to @@length(CVLST)+1@@, and @@PID@@ is a row vector containing
 the concatenated list of points of each convex in cvlst.
 Each entry of @@IDX@@ is the position of the corresponding convex point
 list in @@PID@@.
 For example, the list of points of the second convex is @@PID(IDX(2):IDX(3)-1)@
@.
\end_layout

\begin_layout Standard
If you specified convex numbers which do not exist in @@CVLST@@, their point
 list will be empty.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@V=gf_mesh_get(M, 'pid from coords', PT)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 can be used to retrieve the point indices from their coordinates.
 @@PT@@ is an array containing a list of these point coordinates.
 On return, @@V@@ is a row vector containing the id of the points which
 are part of the mesh, and -1 for those which where not found in the mesh
 (a small error of about 1e-6 is allowed in the coordinates -- this might
 be important if your mesh is very small!).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'cvid from pid', PTID)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of convexes that share the points numbers given in @@PTID@@
 in a row vector (possibly empty).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'faces from pid', PTID)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of convexes faces of which every vertex is in @@PTID@@.
 On return, the first row of @@V@@ contains the convex number, and the second
 row contains the face number.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M, 'faces from cvid', CVLST,[ 'merge'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of convex faces from a list of convex numbers, and optionally
 merges the common faces of two convexes from @@CVLST@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'outer faces' [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of faces which are not shared by two convexes (i.e.
 the faces on the boundary of the mesh).
 The search can be restricted to the optional argument @@CVLST@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'regions')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
boundary
\end_layout

\end_inset

 return the list of valid regions (created with @@gfmeshset(M,'region')@@).
 Regions are sets of convexes and/or convexes faces, stored in the mesh,
 and refered by a simple region number.
 They are typically used for the application of boundary conditions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@CVFLST=gf_mesh_get(M, 'region', rnum)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of faces on the boundary @@rnum@@.
 On output, the first row of @@CVFLST@@ contains the convex numbers, and
 the second row contains the face numbers (0 when the whole convex is is
 the region).
 See also @@gf_mesh_fem_get(MF, 'basic dof on region')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@E=gf_mesh_get(M, 'edges' [, CVLST][, 'merge'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
warning{
\end_layout

\end_inset

This function has been obsoleted by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset

 objects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@E=gf_mesh_get(M, 'curved edges', N, [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
warning{
\end_layout

\end_inset

This function has been obsoleted by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset

 objects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@T=gfmeshget(M, 'triangulated surface', N, [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
warning{
\end_layout

\end_inset

This function has been obsoleted by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset

 objects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M, 'normal of face', CV, F[, FPTNUM])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M, 'normal of faces', CVFLST)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 evaluates the normal of convex faces.
 The first form returns the normal of convex CV for its face F, evaluated
 at the @@FPTNUM@@th point of the face.
 If @@FPTNUM@@ is not specified, then the normal is evaluated at each geometrica
l node of the face.
 The second form returns the normal for a set of faces of convex, each normal
 being computed at the center of the face (@@CVFLST@@ is supposed to contain
 convex numbers at its first row and convex face number in its second row).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M, 'quality',[CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return an estimate of the convex quality (in a finite element sense).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M, 'convex area',[CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return an estimate the convex areas.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[CVS,CV2STRUC]=gfmeshget(M, 'cvstruct',[CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
convex structure
\end_layout

\end_inset

 return an array of all the convex structure used in the mesh (optionally
 restricted to the convexes of @@CVLST@@), and a second optional output
 vector @@CV2STRUCT@@ which maps the convexes indices in @@CVLST@@ to the
 indice of its structure in @@CVS@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[GT,GT2STRUCT]=gfmeshget(M, 'geotrans',[CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
geometric transformation
\end_layout

\end_inset

 return an array of the geometric transformations (similar to @@gfmeshget(M,
 'cvstruct'@@).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_get(M, 'save', filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : save the mesh object to an ASCII file.
 This mesh can be restored later with @@gf_mesh('load', filename)@@.
 You may also use 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gfmeshget(M, 'char')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 to obtain a string description of the mesh M, that can be saved to files,
 or restored with @@gfmesh('from string')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M,'exporttovtk', filename, ...
 [,'ascii'][,'quality'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export a mesh to a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
VTK
\end_layout

\end_inset

 file .
 If 'quality' is specified, an estimation of the quality of each convex
 will be written to the file (see @@gfsliceget('exporttovtk')@@ for more
 details).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M,'exporttodx', filename, ...[,'ascii'] [,'append'] [,'as', name,[,'ser
ie', seriename]][,'edges'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export a mesh to an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
OpenDX
\end_layout

\end_inset

 file (see @@gfsliceget('exporttodx')@@ for more details).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshget(M, 'memsize')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the amount of memory (in bytes) used by the mesh object.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh, gf_mesh_set, gfplotmesh, gfMesh@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_SET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_set
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General function for modification of a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

object.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 IDX = gf_mesh_set(M, 'add point', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

PT) gf_mesh_set(M, 'del point', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

IDX) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 IDX = gf_mesh_set(M, 'add convex', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tgeotrans
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

GT,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

CVPTS) gf_mesh_set(M, 'del convex', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

IDX) gf_mesh_set(M, 'del convex of dim', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

DIM) gf_mesh_set(M, 'region', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 bnum, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 CVFLST) gf_mesh_set(M, 'region intersect', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 R1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 R2) gf_mesh_set(M, 'region merge', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 R1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 R2) gf_mesh_set(M, 'region subtract', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 R1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 R2) gf_mesh_set(M, 'delete region', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 blst) gf_mesh_set(M, 'translate', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

V) gf_mesh_set(M, 'transform', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

T) gf_mesh_set(M, 'merge', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

M2) gf_mesh_set(M, 'optimize structure') gf_mesh_set(M 'refine' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 CVLST]) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@IDX = gf_mesh_set(M, 'add point', PT)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : insert new points in the mesh.
 @@PT@@ should be an 
\begin_inset Formula $n\times m$
\end_inset

 matrix , where 
\begin_inset Formula $n$
\end_inset

 is the mesh dimension, and 
\begin_inset Formula $m$
\end_inset

 is the number of points that will be added to the mesh.
 On output, @@IDX@@ contains the indices of these new points.
\end_layout

\begin_layout Standard
Remark: if some points are already part of the mesh, they won't be inserted
 again, be @@IDX@@ will contains the previously assigned indices of the
 points.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'del point', IDX)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : remove one or more points from the mesh.
 @@IDX@@ should contain the point indexes, such as the one returned by the
 @@'add point'@@ command.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@IDX=gf_mesh_set(M, 'add convex', GT, CVPTS)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add a new convex of structure @@GT@@ (obtained with @@gf_geotrans@@),
 and whose point coordinates are given by the columns of @@CVPTS@@.
 On return, @@IDX@@ contains the convex ID.
 @@CVPTS@@ might be a three dimensional array 
\begin_inset Formula $(convex,point,coord)$
\end_inset

 in order to insert more than one convex (or a two dimensional array correctly
 shaped).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'del convex', IDX)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : remove one or more convexes from the mesh.
 @@IDX@@ should contain the convexes IDs, such as the ones returned by the
 'add convex' command.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'del convex of dim', DIM)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Remove all convexes of dimension listed in DIM.
 For example @@gf_mesh_set(M, 'del convex of dim', [1,2])@@ removes all
 line segments, triangles and quadrangles.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'region', bnum, CVFLST)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'boundary', bnum, CVFLST)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
boundary
\end_layout

\end_inset

 assign the boundary number @@bnum@@ to the convex faces stored in each
 column of the matrix @@CVFLST@@ (i.e.
 the first row of @@CVFLST@@ contains a convex number, and the second row
 contains a face number in the convex).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'delete region', blst)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'delete boundary', blst)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : remove the region listed in @@blst@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'region intersect', R1, R2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : replace the region number @@R1@@ with its intersection with region number
 @@R2@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'region merge', R1, R2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : merge region number @@R2@@ into region number @@R1@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'region subtract', R1, R2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : replace the region number @@R1@@ with its difference with region number
 @@R2@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'translate', V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : translate each point of the mesh from @@V@@, and @@gf_mesh_set(M, 'transform'
, T)@@ applies the matrix T to each point of the mesh.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'merge', M2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : merge the mesh @@M2@@ in the mesh @@M@@ (overlapping points won't be
 duplicated).
 If @@M2@@ is a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

object, its linked mesh will be used.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'optimize structure')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : renumber points and convexes numbering, and ensures that there is no
 
\begin_inset Quotes eld
\end_inset

hole
\begin_inset Quotes erd
\end_inset

 is the numbering.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_set(M, 'refine', CVLST)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : refine
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh     refinement
\end_layout

\end_inset

 the convexes listed in @@CVLST@@, with a Bank strategy.
 If CVLST is not given, the whole mesh is refined.
 Note that the regions, and the finite element methods and integration methods
 of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 objects linked to this mesh will be automagically refined.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh, gf_mesh_get@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_ELTM
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_eltm
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfeltm
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Generate a descriptor for an elementary matrix type
\begin_inset Index
status collapsed

\begin_layout Plain Layout
elementary matrix
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 ELTM = gf_eltm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

base
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

FEM) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 ELTM = gf_eltm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

grad
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

FEM) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 ELTM = gf_eltm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

hessian
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

FEM) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 ELTM = gf_eltm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

normal
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 ELTM = gf_eltm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

gradgeotrans
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 ELTM = gf_eltm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

gradgeotransinv
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 ELTM = gf_eltm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

product
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

A, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

B) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 If you have very particular assembling needs, or if you just want to check
 the content of an elementary matrix, this function might be useful.
 But the generic assembly abilities of @@gfasm@@ should suit most needs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_eltm('base', FEM)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a descriptor for the integration of shape functions on elements,
 using the fem 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_eltm('grad', FEM)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a descriptor for the integration of the gradient of shape functions
 on elements, using the fem FEM.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_eltm('hessian', FEM)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a descriptor for the integration of the hessian of shape functions
 on elements, using the fem FEM.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfeltm('normal')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a descriptor for the unit normal of convex faces.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfeltm('gradgeotrans')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gfeltm('gradgeotransinv')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return a descriptor to the gradient matrix of the geometric transformation,
 or its inverse (this is rarely used).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_eltm('product', A, B)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a descriptor for the integration of the tensorial product of elementar
y matrices A and B.
\end_layout

\begin_layout Standard
In order to obtain a numerical value of these matrices, see @@gf_mesh_im_get('e
ltm')@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh_im_get('eltm'), gfasm@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_FEM
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_fem
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gffem
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Returns a handle to one of the various Finite Elements Method defined in
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
FEM
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 = gf_fem(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 fem_name) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The @@fem_name@@ should contain a description of the finite element method.
 Please refer to the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 manual (especially the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www-gmm.insa-toulouse.fr/getfem/doc
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

description of finite element and integration methods
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) for a complete reference.
\end_layout

\begin_layout Standard
Here is a list of some of them:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="none" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PK(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
classical Lagrange element PK on a simplex 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PK_DISCONTINUOUS(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
discontinuous Lagrange element PK on a simplex 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_QK(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
classical Lagrange element QK on a parallelepiped 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PK_PRISM(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
classical Lagrange element PK on a prism 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PRODUCT(FEM1,FEM2)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tensorial product of two polynomial elements 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_HERMITE(N)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hermite element on the simplex of dimension N=1,2 or 3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_ARGYRIS
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Argyris 
\begin_inset Formula $\mathcal{C}^{1}$
\end_inset

 element on the triangle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_HCTTRIANGLE
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HCT composite 
\begin_inset Formula $\mathcal{C}^{1}$
\end_inset

 element on the triangle
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PK_HIERARCHICAL(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PK element with a hierarchical basis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_QK_HIERARCHICAL(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
QK element with a hierarchical basis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PK_PRISM_HIERARCHICAL(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PK element on a prism with a hierarchical basis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_STRUCTURED_COMPOSITE(FEM, K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Composite fem on a grid with K divisions
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PK_HIERARCHICAL_COMPOSITE(N,K,S)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PK composite element on a grid with S subdivisions and with a hierarchical
 basis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_PK_FULL_HIERARCHICAL_COMPOSITE(N,K,S)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PK composite element with S subdivisions and a hierarchical basis on both
 degree and subdivision
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_RT0(N)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Raviart-Thomas element of order 0 on a simplex of dimension N.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

FEM_NEDELEC(N)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nedelec edge element of order 0 on a simplex of dimension N.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Of course, you have to ensure that the selected fem is compatible with the
 geometric transformation: a PK fem has no meaning on a quadrangle.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 To get a fem of degree 2 on a quadrangle: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 fem = gf_fem('FEM_QK(2,2)'); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textrm@
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

or@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 fem = gf_fem('FEM_PRODUCT(FEM_PK(1,1),FEM_PK(1,1))'); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 function @@sprintf@@ might be useful if you need to build the PK fem with
 @@k@@ and @@n@@ as arguments: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 fem = gf_fem(sprintf('FEM_PK(%d,%d)', k, n)); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gffemget, gf_integ, gf_mesh_fem_set(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

, 'fem', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

), gf_mesh_fem_get('fem'), gfFem@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_FEM_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_femget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gffemget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Obtain informations about an FEM handle @@F@@
\begin_inset Index
status collapsed

\begin_layout Plain Layout
FEM
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'nbdof') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'dim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'targetdim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 P = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'pts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'isequivalent') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'islagrange') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'ispolynomial') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'estimateddegree') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 V = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'basevalue', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 X) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 V = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'gradbasevalue', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 X) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 V = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'hessbasevalue', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 X) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'polystr') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S = gffemget(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 F,'char') @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The number of degrees of freedom
\begin_inset Index
status collapsed

\begin_layout Plain Layout
degrees of freedom
\end_layout

\end_inset

 of a specific fem @@F@@ are returned by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'nbdof')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, while its dimension (i.e.
 the dimension of the reference convex) is given by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'dim')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The target dimension, i.e.
 the dimension of the target space (denoted 
\begin_inset Formula $Q$
\end_inset

 in the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www-gmm.insa-toulouse.fr/getfem/doc
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

introduction to the finite element kernel
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) is returned by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'target dim')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 (it is always 1 except for vector FEM).
\end_layout

\begin_layout Standard
The geometrical nodes (on the reference convex) associated with each degree
 of freedom of the fem is given in the columns of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'pts')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gffemget(F,'is equivalent')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'is lagrange')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'is polynomial')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 gives some important properties of an FEM (a polynomial fem is a necessary
 condition for an exact integration method, and a interpolation a function
 of a Lagrangian fem is easy).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gffemget(F,'estimateddegree')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return an estimation of the polynomial degree of a fem (this is an estimation
 for fem which are not polynomials).
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gffemget(F,'basevalue',X)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 evaluate the values of all basis functions
\begin_inset Index
status collapsed

\begin_layout Plain Layout
basis functions
\end_layout

\end_inset

 of the FEM at point @@X@@ (@@X@@ is supposed to be in the reference convex!).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'gradbasevalue',X)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F,'hessbasevalue',X)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 evaluate respectively the first and second derivative of the basis functions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gffemget(F, 'char')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return the canonical name of the FEM in getfem, and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gffemget(F, 'polystr')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return the polynomial expression of its basis functions in the reference
 convex (of course this will fail on non-polynomial FEMs).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 Plotting the basis functions of the 
\begin_inset Formula $P_{5}$
\end_inset

 fem on a segment:
\begin_inset Newline newline
\end_inset

 
\begin_inset Box Frameless
position "b"
hor_pos "c"
has_inner_box 1
inner_pos "b"
use_parbox 0
width "8cm"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 f=gffem('FEMPK(1,5)'); n=100; M=zeros(gffemget(f,'nbdof'),n); for i=1:n,
 M(:,i)=gffemget(f,'basevalue',(i-1)/(n-1)); end; plot((0:n-1)/n,M); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename fempk51.pdf
	width 4cm

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlimg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

fempk51.png
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

basis functions of the P5 fem
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Viewing the basis function of the Argyris FEM: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 f=gffem('FEMARGYRIS'); gffemget(f, 'polystr') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gffem@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_INTEG
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_integ
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfinteg
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General function for obtaining handles to various integrations methods
 on convexes (used when the elementary matrices are built)
\begin_inset Index
status collapsed

\begin_layout Plain Layout
integration method
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 IM = gf_integ(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 method) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 Here is a list of some integration methods defined in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 (see the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www-gmm.insa-toulouse.fr/getfem/doc
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

description of finite element and integration methods
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 for a complete reference):
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_EXACT_SIMPLEX(N)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exact integration on simplices.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_PRODUCT(a, b)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
product of two integration methods
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_EXACT_PARALLELEPIPED(N)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exact integration on parallelepipeds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_EXACT_PRISM(n)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
exact integration on prisms
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_GAUSS1D(K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gauss method on the segment, order K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_NC(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Newton-Cotes approximative integration on simplices, order K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_NC_PARALLELEPIPED(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
product of Newton-Cotes integration on parallelepipeds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_NC_PRISM(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
product of Newton-Cotes integration on prisms
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_GAUSS_PARALLELEPIPED(N,K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
product of Gauss1D integration on parallelepipeds
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_TRIANGLE(K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gauss methods on triangles 
\begin_inset Formula $(K=1,3,5,6,7,8,9,10,13,17,19)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

IM_TETRAHEDRON(K)
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Gauss methods on tetrahedrons (K=1, 2, 3, 5, 6 or 8)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

Note that 'exact integration' should be avoided in general, since they only
 apply to linear geometric transformations, are quite slow, and subject
 to numerical stability problems for high degree FEMs.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_fem, gf_mesh_im, gfInteg@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_INTEG_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_integget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfintegget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Gives access to various internal informations of an Integration Method
 handle @@IM@@
\begin_inset Index
status collapsed

\begin_layout Plain Layout
integration method
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gfintegget(IM,'isexact') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gfintegget(IM,'dim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gfintegget(IM,'nbpts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 gfintegget(IM,'pts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 gfintegget(IM,'coeffs') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 gfintegget(IM,'facepts', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 F) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 gfintegget(IM,'facecoeffs',
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 F) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S=gfintegget(IM,'char') @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfintegget(IM,'isexact')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is non-null if the integration method is exact (i.e.
 integrates analytically polynomials).
 In that case there is not much information to obtain, except the dimension
 of the space on which it operates.
 For non-exact integration methods, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gfintegget(IM,'pts')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gfintegget(IM,'coeffs')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 returns the points and coefficients of the quadrature formula for integrations
 over the whole convex, while 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gfintegget(IM,'facepts', F)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gfintegget(IM,'facecoeffs',F)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return the points and coefficients used for integrations over the face
 @@F@@ of the convex.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfintegget(IM,'char')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a string describing the integration method (similar to the one
 passed to @@gfinteg@@ for the creation of an integration method.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gfinteg@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_FEM
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_fem
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshfem
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General constructor for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object.
 Returns a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 handle to the newly created 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_fem
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF = gf_mesh_fem(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 Qdim=1]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF[,M] = gf_mesh_fem('load', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename[,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF[,M] = gf_mesh_fem('from string', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF = gf_mesh_fem('clone', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF0) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 This function creates a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object.
 These objects hold the finite element basis functions on a mesh : a finite
 element is assigned to each convex of the mesh, and the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 takes care of connecting them across the convexes and enumerating the degrees
 of freedom.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem(M,Qdim)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 creates a new 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object linked to the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 @@M@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 objects can be used everywhere a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset

 object is required (its linked mesh is automatically used).
 The argument 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

Qdim
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
Qdim
\end_layout

\end_inset

 specifies the dimension of the unknown on this mesh.
 If the unknown is a scalar field, then 
\begin_inset Formula $\kw{Qdim}=1$
\end_inset

, if it is a 2D vector field then 
\begin_inset Formula $\kw{Qdim}=2$
\end_inset

 etc\SpecialChar \ldots{}
: this is independent of the mesh dimension.
\end_layout

\begin_layout Standard
The load command can restore a previously saved 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object.
 If you don't specify the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 argument, it is assumed that the mesh was saved in the same file that the
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (with @@gf_mesh_fem_get(mf, 'save with mesh')@@).
 The @@'from string'@@ command is very similar, but loads the object from
 a string instead of a file.
\end_layout

\begin_layout Standard
And finally, it is possible to build a copy of a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object with the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hil{
\end_layout

\end_inset

@@gf_mesh_fem('clone', MF0)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 command (see also the @@gfmesh('clone')@@ command).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh_fem_get, gf_mesh_fem_set, gfMeshFem@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_FEM_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_fem_get
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshfemget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General inquiry function for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 objects
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_fem
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N = gf_mesh_fem_get(MF, 'nbdof') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N = gf_mesh_fem_get(MF, 'nb basic dof') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOF = gf_mesh_fem_get(MF, 'basic dof from cv', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 [DOF,CV2DOF] = gf_mesh_fem_get(MF, 'basic dof from cvid', [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOF = gf_mesh_fem_get(MF, 'non conformal basic dof' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 FEMLST[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CV2F] = gf_mesh_fem_get(MF, 'fem' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST = gf_mesh_fem_get(MF, 'convex_index') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N = gf_mesh_fem_get(MF, 'qdim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 I = gf_mesh_fem_get(MF, {'is_lagrangian' | 'is_equivalent' | 'is_polynomial'}
 [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 N = gf_mesh_fem_get(MF, 'is_reduced') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 R = gf_mesh_fem_get(MF, 'reduction_matrix') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 R = gf_mesh_fem_get(MF, 'extension_matrix') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOFLST = gf_mesh_fem_get(MF, 'basic dof on region', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 rlist) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOFLST = gf_mesh_fem_get(MF, 'dof on region', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 rlist) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 DOF_XY = gf_mesh_fem_get(MF, 'basic dof nodes'[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOFLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOFP = gf_mesh_fem_get(MF, 'dof partition') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U = gf_mesh_fem_get(MF, 'interpolate convex data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Ucv) gf_mesh_fem_get(MF, 'save', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename, ['with mesh']) gf_mesh_fem_get(MF,'exporttovtk', filename, ...
 ['ascii'], U, 'name'...) gfmeshfemget(MF,'exporttodx', filename, ...
 ['as', meshname][,'edges']['serie',seriename][,'ascii'][,'append'], U,
 'name'...) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S=gfmeshfemget(M, 'char' [,'with mesh']) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M=gfmeshfemget(MF, 'linked mesh') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U=gfmeshfemget(MF, 'eval', expr [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOFLST]) M=gfmeshfemget(MF, 'memsize') @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'nbdof')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of degrees of freedom of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 @@MF@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'nb basic dof')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of basic degrees of freedom of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 @@MF@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'basic dof from cv', CVLST)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
dof
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
degrees of freedom
\end_layout

\end_inset

 return the basic dof IDs attached to the convexes listed in @@CVLST@@.
 WARNING: the Degrees of Freedom might be returned in ANY order, do not
 use this function in your assembly routines.
 Use @@'basic dof from cvid'@@ instead.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'dof from cv', rlist)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Deprecated function.
 Use @@gf_mesh_fem_get(MF, 'basic dof from cv', rlist)@@ instead.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'basic dof from cvid' [, CVLST])
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

@@ : return the degrees of freedom attached to each convex of the mesh,
 allowing to map a convex number to the list of its associated degrees of
 freedom.
 It is similar to @@gf
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mesh
\end_layout

\end_inset

_get(M, 'pid from cvid')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'dof from cvid', rlist)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Deprecated function.
 Use @@gf_mesh_fem_get(MF, 'basic dof from cvid', rlist)@@ instead.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'non conformal basic dof' [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of basic DoF which are located on the border of a convex
 and which belong to only one convex, except those who lie on the border
 of the mesh.
 For example, if the convex 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 share a common face, 
\begin_inset Formula $a$
\end_inset

 has a P1 FEM, and 
\begin_inset Formula $b$
\end_inset

 has a P2 FEM, then the basic dof on the middle of the common face will
 be returned by this function (this can be useful when searching the interfaces
 between classical fems and hierarchical fem).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'non conformal dof', rlist)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Deprecated function.
 Use @@gf_mesh_fem_get(MF, 'non conformal basic dof', rlist)@@ instead.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

Qdim
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
Qdim
\end_layout

\end_inset

 : return the dimension @@Q@@ of the fields interpolated by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (1 for scalar fields, 2 for 2D vector fields etc..)..
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@FEMLST[, CV2F] = gf_mesh_fem_get(MF, 'fem' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
FEM
\end_layout

\end_inset

 return a list of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 objects: @@FEMLST@@ is an array of all 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 objects found in the convexes given in @@CVLST@@.
 If @@CV2F@@ was supplied as an output argument, it contains, for each convex
 listed in @@CVLST@@, the index of its corresponding 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 in @@FEMLST@@.
\end_layout

\begin_layout Standard
Convexes which are not part of the mesh, or convexes which do not have any
 FEM have their correspounding entry in CV2F set to -1.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'convex_index')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of convexes who have an FEM.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, {'is_lagrangian' | 'is_equivalent' | 'is_polynomial'},[,
 CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Lagrangian
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
equivalent FEM
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
polynomial FEM
\end_layout

\end_inset

 test the properties of the FEM of the convexes listed in @@CVLST@@.
 If @@CVLST@@ is omitted, it returns 1 if all convexes in the mesh which
 are lagrangian (resp.
 equivalents, resp.
 polynomials), or 0.
 If @@CVLST@@ is present, returns the convex numbers (with respect to @@CVLST@@)
 which are lagrangian (resp.
 etc..)
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'is_reduced')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return 1 if the optional reduction matrix is applied to the dofs
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'reduction_matrix')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the optional reduction matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'extension_matrix')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the optional extension matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'basic dof on region', rlist)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of basic dof (i.e.
 before optional reduction) whose support is non-null on one of the regions
 whose ids are listed in @@rlist@@ (note that for boundary regions, some
 basic dof nodes may not lie exactly on the boundary, for example the dof
 of @@FEMPK(n,0)@@ lies on the center of the convex, but the base function
 in not null on the convex border).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'dof on region', rlist)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of dof (i.e.
 after optional reduction) whose support is non-null on one of the regions
 whose ids are listed in @@rlist@@ (note that for boundary regions, some
 basic dof nodes may not lie exactly on the boundary, for example the dof
 of @@FEMPK(n,0)@@ lies on the center of the convex, but the base function
 in not null on the convex border).
\end_layout

\begin_layout Standard
For a reduced mesh_fem a dof is lying on a region if its potential corresponding
 shape function is nonzero on this region.
 The extension matrix is used to make the correspondance between basic and
 reduced dofs
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'dof on region', rlist)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Deprecated function.
 Use @@gf_mesh_fem_get(MF, 'basic dof on region', rlist)@@ instead.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'basic dof nodes'[, DOFLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of interpolation points for the specified basic dof IDs
 in @@DOFLST@@ (if @@DOFLST@@ is omitted, all basic dof are considered).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'dof nodes', rlist)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Deprecated function.
 Use @@gf_mesh_fem_get(MF, 'basic dof nodes', rlist)@@ instead.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'dof partition')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the array which associates an integer (the partition number) to
 each convex of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

.
 By default, it is an all-zero array.
 The degrees of freedom of each convex are connected only to the dof of
 neighbouring convexes which have the same partition number, hence it is
 possible to create partially discontinuous meshfem very easily.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'interpolate convex data', Ucv)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is a convenient function to interpolate quickly some data that is given
 on the mesh convexes (for example the output of @@gf_mesh_get(m, 'quality')@@)
 on @@MF@@ (a similar function also exists for slices).
 Note that it works better if @@MF@@ is a discontinuous 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (for example @@'FEMPK(N,0)'@@), or the result will be 
\begin_inset Quotes eld
\end_inset

smoothed
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF, 'save', filename [,'with mesh'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : save the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

in a text file (which can be loaded later with @@gf_mesh_fem(m, 'load',
 filename)@@.
 Please note that the associated mesh is not saved, except if you use the
 @@'with mesh'@@ option! @@gfmeshfemget(M, 'char' [,'with mesh'])@@ is similar,
 but saves the content of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 in a string.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshfemget(MF, 'char')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : get a string description of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_get(MF,'exporttovtk', filename, ...
 ['ascii'], U, 'name'...)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 and some fields to a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
VTK
\end_layout

\end_inset

 file.
 The FEM and geometric transformations will be mapped to order 1 or 2 isoparamet
ric PK (or QK) FEMs (as 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
VTK
\end_layout

\end_inset

 does not handle higher order elements).
 If you need to represent high- order FEMs or high-order geometric transformatio
ns, you should consider @@gfsliceget(sl,'exporttovtk')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshfemget(MF,'exporttodx', filename, ...
 ['as', meshname][,'edges']['serie',seriename][,'ascii'][,'append'], U,
 'name'...)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export a meshfem and some fields to an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
OpenDX
\end_layout

\end_inset

 file.
 This function will fail if the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mixes different convex types (i.e.
 quads and triangles), or if 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
OpenDX
\end_layout

\end_inset

 does not handle a specific element type (i.e.
 prism connections are not known by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
OpenDX
\end_layout

\end_inset

).
 The FEM will be mapped to order 1 PK (or QK) FEMs.
 If you need to represent high-order FEMs or high-order geometric transformation
s, you should consider @@gfsliceget(sl,'exporttodx')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshfemget(MF, 'linked mesh')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 return an handle to the mesh object linked to @@MF@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshfemget(MF, 'eval', expr [,DOFLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : call @@gfmeshfemgeteval@@.
 This function interpolates an expression on a lagrangian 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (for all dof except if @@DOFLST@@ is specified).
 The expression can be a numeric constant, or a cell array containing numeric
 constants, string expressions or function handles.
 For example: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 U1=gfmeshfemget(mf,'eval',1) U2=gfmeshfemget(mf,'eval',[1;0]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% output has two rows
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

U3=gfmeshfemget(mf,'eval',[1 0]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% output has one row, only valid if qdim(mf)==2
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

U4=gfmeshfemget(mf,'eval',{'x';'y.*z';4;@myfunctionofxyz}) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshfemget(M, 'memsize')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the amount of memory (in bytes) used by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object (the linked mesh is not counted).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kwl{
\end_layout

\end_inset

gfmeshget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

gf_mesh_get
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kwl{
\end_layout

\end_inset

gfmeshset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

gf_mesh_set
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_FEM_SET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_fem_set
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshfemset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General function for editing 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

objects
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_fem
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gf_mesh_fem_set(MF, 'fem', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 fem [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVIDX]) gf_mesh_fem_set(MF, 'classical fem', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 fem, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 K [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVIDX]) gf_mesh_fem_set(MF, 'classical discontinuous fem', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tfem
\end_layout

\end_inset

 fem, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 K [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVIDX]) gf_mesh_fem_set(MF, 'qdim', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 Qdim) gf_mesh_fem_set(MF, 'reduction', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 s) gf_mesh_fem_set(MF, 'reduction matrices', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 R, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 E) gf_mesh_fem_set(MF, 'dof partition', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOFP) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_set(MF, 'fem', fem [, CVIDX])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
FEM
\end_layout

\end_inset

 set the finite element method to @@fem@@ for all the convexes listed in
 @@CVIDX@@ in the mesh linked to @@MF@@.
 If @@CVIDX@@ is not used, the @@fem@@ is assigned to all convexes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_set(MF, 'classical fem', fem, K , [, CVIDX])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : set the classical fem (polynomial and Lagrange) of order @@K@@ on the
 listed convexes (
\begin_inset Formula $P_{K}$
\end_inset

 for simplexes, 
\begin_inset Formula $Q_{K}$
\end_inset

 for parallelepipeds, etc..).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_set(MF, 'classical discontinuous fem', K [, CVIDX])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is similar to the previous one, but for discontinuous (i.e.
 @@'FEMPKDISCONTINUOUS'@@ etc) FEMs.
 This can be useful to interpolate the gradient of a continuous 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (which will be discontinuous across elements, except if you are using a
 C1 element such as Argyris or HCT).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_set(MF, 'qdim', Qdim)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Qdim
\end_layout

\end_inset

 change the @@Q@@ dimension of the field that is interpolated by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

.
 @@Q=1@@ means that the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 describes a scalar field, @@Q=N@@ means that the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 describes a vector field of dimension @@N@@ (see @@gfmeshfemset('Qdim')@@).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_set(MF, 'reduction', s)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Set or unset the use of reduction/extension matrices.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_set(MF, 'reduction matrices', R, E)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Set the reduction and extension matrices and valid their use.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_fem_set(MF, 'dof partition', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 DOFP)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : change the array which associates an integer (the partition number) to
 each convex of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (see @@gf_mesh_fem_get(MF, 'dof partition')@@).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 Building a discontinuous 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 @@mfdu@@ to compute the gradient @@DU@@ of a field @@U@@ defined on a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 @@mf@@: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 mfdu=gfMeshFem(m); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% use polynomials of degree 2, and no integration method
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

gfmeshfemset(mfdu,'classical discontinuous fem',2); DU=gfcompute(mf,U,'gradient'
,mfdu); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh_fem, gfmeshfemset, gffem, gfinteg@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_IM
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_im
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshim
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General constructor for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object.
 Return a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 handle to the newly created 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_im
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM = gf_mesh_im(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M [, { 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 | 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 }]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM[,M] = gf_mesh_im('load', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename[,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM[,M] = gf_mesh_im('from string', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM = gf_mesh_im('clone', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM0) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 This function creates a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object.
 These objects hold integration methods defined over a mesh: an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object is required for each operation with needs integration of something
 over the mesh (assembly functions, etc.).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_im(M [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 IM | 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 IMDEGREE
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 creates a new 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object linked to the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 @@M@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 objects can be used everywhere a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tcmesh
\end_layout

\end_inset

 object is required (its linked mesh is automatically used).
\end_layout

\begin_layout Standard
As a convenience, an integration method can be applied immediately to all
 convexes of the mesh if the optional argument @@IM@@ or @@IMDEGREE@@ is
 used (@@IMDEGREE@@ let getfem choose a suitable integration method that
 is able to exactly integrate polynomials of degree less or equal to @@IMDEGREE@
@.
\end_layout

\begin_layout Standard
The load command can restore a previously saved 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object.
 If you don't specify the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 argument, it is assumed that the mesh was saved in the same file that the
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 (with @@gf_mesh_im_get(mf, 'save with mesh')@@).
 The @@'from string'@@ command is very similar, but loads the object from
 a string instead of a file.
\end_layout

\begin_layout Standard
@@gf_mesh_im('clone', MIM0)@@ return a copy of @@MIM0@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_mesh_im_get, gf_mesh_im_set, gfMeshIm@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_IM_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_im_get
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshimget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General inquiry function for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 objects
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_im
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 IMLST[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CV2IM] = gf_mesh_im_get(MIM, 'integ' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST = gf_mesh_im_get(MIM, 'convex_index') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 M = gf_mesh_fem_get(MIM, 'eltm', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
teltm
\end_layout

\end_inset

 MET, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 CV [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 FACE]) gf_mesh_im_get(MIM, 'save', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename, ['with mesh']) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S=gfmeshimget(M, 'char' [,'with mesh']) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M=gfmeshimget(MIM, 'linked mesh') M=gfmeshimget(MIM, 'memsize') @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@IMLST[,CV2IM]=gf_mesh_im_get(MIM, 'integ' [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
integration method
\end_layout

\end_inset

 return a list of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 objects: @@IMLST@@ is an array of all 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 objects found in the convexes given in @@CVLST@@.
 If @@CV2IM@@ was supplied as an output argument, it contains, for each
 convex listed in @@CVLST@@, the index of its corresponding 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 in @@IMLST@@.
\end_layout

\begin_layout Standard
Convexes which are not part of the mesh, or convexes which do not have any
 integration method have their correspounding entry in CV2I set to -1.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_im_get(MIM, 'convex_index')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of convexes who have a integration method.
 Convexes who have the dummy @@IMNONE@@ method are not listed.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_im_get(MIM, 'eltm', MET, CV [,F])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
elementary matrix
\end_layout

\end_inset

 return the elementary matrix (or tensor) integrated on the convex @@CV@@
 for the elementary matrix type @@MET@@ (created with @@gfeltm@@).
 If @@F@@ is given, the elementary matrix is integrated on the face @@F@@
 of convex @@CV@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_im_get(MIM, 'save', filename [,'with mesh'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : save the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

in a text file (which can be loaded later with @@gf_mesh_im(m, 'load', filename)
@@.
 Please note that the associated mesh is not saved, except if you use the
 @@'with mesh'@@ option! @@gfmeshimget(M, 'char' [,'with mesh'])@@ is similar,
 but saves the content of the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 in a string.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshimget(MIM, 'linked mesh')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return an handle to the mesh object linked to @@MIM@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmeshimget(MIM, 'memsize')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the amount of memory (in bytes) used by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 object (the linked mesh is not counted).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MESH_IM_SET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mesh_im_set
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmeshimset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General function for editing 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

objects
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mesh_im
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gf_mesh_im_set(MIM, 'integ', { 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tinteg
\end_layout

\end_inset

 im | 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 IMDEGREE }, [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVIDX])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_im_set(MIM, 'integ', im [, CVIDX])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
IM
\end_layout

\end_inset

 set @@im@@ as the integration method for all the convexes listed in @@CVIDX@@
 in the mesh linked to @@MF@@.
 If @@CVIDX@@ is not used, the @@im@@ is assigned to all convexes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_mesh_im_set(MIM, 'integ', IM_DEGREE [, CVIDX])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : assign a classical approximate integration method of order at least @@IMDEGRE
E@@ on the listed convexes.
 If @@IMDEGREE@@=-1, then the dummy integration method @@'IMNONE'@@ is used.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 mim=gfMeshIm(m); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% set an integration method of order 5 on all convexes
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

gfmeshimset(mim,'integ',5); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% change the integration for convexes 5 6 9
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

gfmeshimset(mim,'integ',gfinteg('IMTRIANGLE(13)'),[6 5 9]); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MDBRICK
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mdbrick
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmdbrick
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General constructor for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 objects.
 Return a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 handle to the newly created 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdbrick
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gfmdbrick('constraint', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 CTYPE [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('dirichlet', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFMULT, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 CTYPE [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('dirichlet on normal component', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFMULT, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 CTYPE [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('dirichlet on normal derivative', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFMULT, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 CTYPE [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('generalized dirichlet', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('source term', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM=-1[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]]) gfmdbrick('normal source term', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('normal derivative source term', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('neumann KirchhoffLove source term', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('qu term', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]]) gfmdbrick('mass matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfu [,'real'|'complex']) gfmdbrick('generic elliptic', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfu [,'scalar'|'matrix'|'tensor'][,'real'|'complex']) gfmdbrick('helmholtz',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfu [,'real'|'complex']) gfmdbrick('isotropic linearized elasticity', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfu) gfmdbrick('linear incompressibility term', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfp [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('nonlinear elasticity', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfu, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 lawname) gfmdbrick('nonlinear elasticity incompressibility term', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfp [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('small deformations plasticity', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfu, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 THRESHOLD) gfmdbrick('bilaplacian', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfu, ['Kirchhoff-Love'])
\end_layout

\begin_layout Standard
gfmdbrick('isotropiclinearizedplate', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIMSUB, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFUT, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFU3, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFTHETA, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 EPSILON) gfmdbrick('mixedisotropiclinearizedplate', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFUT, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFU3, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFTHETA, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 EPSILON) gfmdbrick('platesourceterm', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM=-1[, int numfem]]) gfmdbrick('platesimplesupport', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 CTYPE [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('plateclampedsupport', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 CTYPE[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem]) gfmdbrick('plateclosing', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem])
\end_layout

\begin_layout Standard
@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 Many of the bricks take a @@numfem@@ optional parameter, which is the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 number in the stack of parent bricks (by default @@numfem=0@@, i.e.
 it refers to the first meshfem in the stack of bricks).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('constraint', parent, CTYPE [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build a generic constraint brick.
\end_layout

\begin_layout Standard
It may be useful in some situations, such as the Stokes problem where the
 pressure in defined modulo a constant.
 In such a situation, this brick can be used to add an additional constraint
 on the pressure value.
 @@CTYPE@@ has to be chosen among @@'augmented'@@, @@'penalized'@@, and
 @@'eliminated'@@.
 The constraint can be specified with @@gfmdbrickset('constraints')@@.
 Note that Dirichlet bricks (except the 'generalized Dirichlet' one) are
 also specializations of the 'constraint' brick.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('dirichlet', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 parent, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 BNUM, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFMULT, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 CTYPE [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build a Dirichlet condition brick which impose the value of a field along
 a mesh boundary.
\end_layout

\begin_layout Standard
The @@BNUM@@ parameter selects on which mesh region the Dirichlet condition
 is imposed.
 @@CTYPE@@ has to be chosen among @@'augmented'@@, @@'penalized'@@, and
 @@'eliminated'@@.
 The @@MFMULT@@ may generally be taken as the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 of the unknown, but for 'augmented' Dirichlet conditions, you may have
 to respect the Inf-Sup condition and choose an adequate 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('dirichlet on normal component', parent, BNUM, MFMULT, CTYPE
 [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build a Dirichlet condition brick which imposes the value of the normal
 component of a vector field.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('dirichlet on normal derivative', parent, BNUM, MFMULT, CTYPE
 [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build a Dirichlet condition brick which imposes the value of the normal
 derivative of the unknown.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('generalized dirichlet', parent, BNUM [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : this is the "old" Dirichlet brick of getfem.
\end_layout

\begin_layout Standard
This brick can be used to impose general Dirichlet conditions 
\begin_inset Formula $h(x)u(x)=r(x)$
\end_inset

 , however it may have some issues with elaborated FEM (such as Argyris,
 etc).
 It should be avoided when possible.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('source term', parent, [, BNUM=-1[, numfem]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add a boundary or volumic source term ( 
\begin_inset Formula $\int B.v$
\end_inset

 ).
\end_layout

\begin_layout Standard
If @@BNUM@@ is omitted (or set to -1) , the brick adds a volumic source
 term on the whole mesh.
 For @@BNUM >= 0@@, the source term is imposed on the mesh region @@BNUM@@.
 Use @@gfmdbrickset('param','source term',mf,B)@@ to set the source term
 field.
 The source term is expected as a vector field of size Q (with Q = qdim).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('normal source term', parent, BNUM [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add a boundary source term ( 
\begin_inset Formula $\int(Bn).v$
\end_inset

 ).
\end_layout

\begin_layout Standard
The source term is imposed on the mesh region @@BNUM@@ (which of course
 is not allowed to be a volumic region, only boundary regions are allowed).
 Use @@gfmdbrickset('param','source term',mf,B)@@ to set the source term
 field.
 The source term @@B@@ is expected as tensor field of size 
\begin_inset Formula $QxN$
\end_inset

 (with 
\begin_inset Formula $Q$
\end_inset

 = qdim, 
\begin_inset Formula $N$
\end_inset

 = mesh dim).
 For example, if you consider an elasticity problem, this brick may be used
 to impose a force on the boundary with @@B@@ as the stress tensor.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('normal derivative source term', parent, BNUM [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add a boundary source term ( 
\begin_inset Formula $\int(\partial_{n}B).v$
\end_inset

 ).
\end_layout

\begin_layout Standard
The source term is imposed on the mesh region @@BNUM@@.
 Use @@gfmdbrickset('param','source term',mf,B)@@ to set the source term
 field, which is expected as a vector field of size 
\begin_inset Formula $Q$
\end_inset

 (with 
\begin_inset Formula $Q$
\end_inset

 = qdim).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('neumann KirchhoffLove source term', parent, BNUM [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add a boundary source term for neumann Kirchhoff-Love plate problems
 (should be used with the Kirchhoff-Love flavour of the bilaplacian brick).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('qu term', parent, [, BNUM [, numfem]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : update the tangent matrix with a 
\begin_inset Formula $\int(Qu).v$
\end_inset

 term.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $Q(x)$
\end_inset

 parameter is a matrix field of size @@qdim x qdim@@.
 An example of use is for the "iku" part of Robin boundary conditions 
\begin_inset Formula $\partial_{n}u+iku=...$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('mass matrix', mim, mfu [,'real'|'complex'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build a mass-matrix brick.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('generic elliptic', MIM, mfu [,'scalar'|'matrix'|'tensor'][,'real'|'
complex'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : setup a generic elliptic problem ( 
\begin_inset Formula $\int(A(x)\nabla u).\nabla v$
\end_inset

 )
\end_layout

\begin_layout Standard
The brick parameter @@'A'@@ may be a scalar field, a matrix field, or a
 tensor field (default is scalar, and 
\begin_inset Formula $A=1$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('helmholtz', MIM, mfu [,'real'|'complex'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : setup a Helmholtz problem.
 The brick has one parameter, @@'wavenumber'@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('isotropic linearized elasticity', MIM, mfu)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : setup a linear elasticity problem.
 The brick has two scalar parameter, @@'lambda'@@ and @@'mu'@@ (the Lamé
 coefficients).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('linear incompressibility term', parent, mfp [, numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add an incompressibily constraint (
\begin_inset Formula $\nabla.u=0$
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('nonlinear elasticity', MIM, mfu, lawname)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : setup a nonlinear elasticity (large deformations) problem.
\end_layout

\begin_layout Standard
The material law can be chosen among 
\end_layout

\begin_layout Itemize
@@'SaintVenant Kirchhoff'@@ (linearized material law) 
\end_layout

\begin_layout Itemize
@@'Mooney Rivlin'@@ (to be used with the nonlinear incompressibily term)
 
\end_layout

\begin_layout Itemize
@@'Ciarlet Geymonat'@@ 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('nonlinear elasticity incompressibility term', parent, mfp [,
 numfem])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add an incompressibily constraint to a large strain elasticity problem.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('small deformations plasticity', MIM, mfu, @scalar THRESHOLD)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : setup a plasticity problem (with small deformations).
\end_layout

\begin_layout Standard
The @@THRESHOLD@@ parameter is the maximum value of the Von Mises stress
 before 
\begin_inset Quotes eld
\end_inset

plastification
\begin_inset Quotes erd
\end_inset

 of the material.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrick('bilaplacian', MIM, mfu, ['Kirchhoff-Love'])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : setup a bilaplacian problem.
\end_layout

\begin_layout Standard
If the Kirchhoff-Love option is specified, the Kirchhoff-Love plate model
 is used.
\end_layout

\begin_layout Standard
@@gfmdbrick('isotropiclinearizedplate', MIM, MIMSUB, MFUT, MFU3, MFTHETA,
 EPSILON)@@
\end_layout

\begin_layout Standard
setup a linear plate model brick (for moderately thick plates, using the
 Reissner-Mindlin model).
 @@EPSILON@@ is the plate thinkness, the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 @@MFUT@@ and @@MFU3@@ are used respectively for the membrane displacement
 and the transverse displacement of the plate.
 The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 @@MFTHETA@@ is the rotation of the normal ("section rotations").
 The second integration method @@MIMSUB@@ can be chosen equal to @@MIM@@,
 or different if you want to perform sub-integration on the transverse shear
 term (mitc4 projection).
 This brick has two parameters "lambda" and "mu" (the Lamé coefficients)
\end_layout

\begin_layout Standard
@@gfmdbrick('mixedisotropiclinearizedplate', MIM, MFUT, MFU3, MFTHETA, EPSILON)@
@
\end_layout

\begin_layout Standard
setup a mixed linear plate model brick (for thin plates, using Kirchhoff-Love
 model).
 For a non-mixed version, use the bilaplacian brick.
\end_layout

\begin_layout Standard
@@gfmdbrick('platesourceterm', parent, [, BNUM=-1[, numfem]])@@
\end_layout

\begin_layout Standard
add a boundary or a volumic source term to a plate problem.
 This brick has two parameters: "B" is the displacement (ut and u3) source
 term, "M" is the moment source term (i.e.
 the source term on the rotation of the normal).
\end_layout

\begin_layout Standard
@@gfmdbrick('platesimplesupport', parent, BNUM, CTYPE [, numfem])@@
\end_layout

\begin_layout Standard
add a "simple support" boundary condition to a plate problem (homogeneous
 Dirichlet condition on the displacement, free rotation).
 @@CTYPE@@ specifies how the constraint is enforced ('penalized', 'augmented'
 or 'eliminated').
\end_layout

\begin_layout Standard
@@gfmdbrick('plateclampedsupport', parent, BNUM, CTYPE[, numfem])@@
\end_layout

\begin_layout Standard
add a "clamped support" boundary condition to a plate problem (homogeneous
 Dirichlet condition on the displacement and on the rotation).
\end_layout

\begin_layout Standard
@@gfmdbrick('plateclosing', parent [, numfem])@@ add a free edges condition
 for the mixed plate model brick.
 This brick is required when the mixed linearized plate brick is used.
 It must be inserted after all other boundary conditions (the reason is
 that the brick has to inspect all other boundary conditions to determine
 the number of disconnected boundary parts which are free edges).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MDBRICK_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mdbrickget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmdbrickget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Query information on a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdbrick
\end_layout

\end_inset

 object @@b@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 n = gfmdbrickget(b,'nbdof') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 n = gfmdbrickget(b, 'dim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 gfmdbrickget(b, 'islinear') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 gfmdbrickget(b, 'issymmetric') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 gfmdbrickget(b, 'iscoercive') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 gfmdbrickget(b, 'iscomplex') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 I=gfmdbrickget(b, 'mixedvariables') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 gfmdbrickget(b, 'subclass') LST=gfmdbrickget(b, 'paramlist') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 gfmdbrickget(b,'param', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 parametername) gfmdbrickget(b,'solve', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdstate
\end_layout

\end_inset

 mds [,...]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 VM=gfmdbrickget(b, 'vonmises', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdstate
\end_layout

\end_inset

 mds, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFVM) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 VM=gfmdbrickget(b, 'tresca', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdstate
\end_layout

\end_inset

 mds, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MFVM)@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'nbdof')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : et the total number of dof of the current problem.
 This is the sum of the brick specific dof plus the dof of the parent bricks.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'dim')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : get the dimension of the main mesh (2 for a 2D mesh, etc).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'islinear')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return true if the problem (this brick plus its parent bricks) is linear.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'issymmetric')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return true if the problem (this brick plus its parent bricks) is symmetric.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'iscoercive')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return true if the problem (this brick plus its parent bricks) is coercive.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'iscomplex')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return true if the problem uses complex numbers.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'mixedvariables')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : identify the indices of mixed variables (typically the pressure, etc.)
 in the tangent matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'subclass')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : get the typename of the brick.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'paramlist')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : get the list of parameters names.
 Each brick embeds a number of parameters (the Lam coefficients for the
 linearized elasticity brick, the wave number for the Helmholtz brick,...),
 described as a (scalar, or vector, tensor etc) field on a meshfem.
 You can read/change the parameter values with @@gfmdbrickget(b,'param')@@
 and @@gfmdbrickset(b,'param')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'param', string parametername)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : get the parameter value.
 When the parameter has been assigned a specific meshfem, it is returned
 as a large array (the last dimension being the meshfem dof).
 When no meshfem has been assigned, the parameter is considered to be constant
 over the mesh.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickget(b,'solve', mds [,...])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : run the standard getfem solver.
 Note that you should be able to use your own solver if you want (it is
 possible to obtain the tangent matrix and its right hand side with the
 gfmdstateget(b,'tangentmatrix') etc.).
 Various options can be specified: 
\end_layout

\begin_layout Itemize
@@'noisy'@@ or @@'very noisy'@@ : the solver will display some information
 showing the progress (residual values etc.).
 
\end_layout

\begin_layout Itemize
@@'maxiter', NIT@@ : set the maximum iterations numbers.
 
\end_layout

\begin_layout Itemize
@@'maxres', RES@@ : set the target residual value.
 
\end_layout

\begin_layout Itemize
@@'lsolver', SOLVERNAME@@ : select explicitely the solver used for the linear
 systems (the default value is 'auto', which lets getfem choose itself).
 Possible values are 'superlu', 'mumps' (if supported), 'cg/ildlt', 'gmres/ilu'
 and 'gmres/ilut'.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@VM=gfmdbrickget(b,'vonmises', mds, MFVM)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the Von Mises stress on the meshfem MFVM.
 Only available on bricks where it has a meaning: linearized elasticity,
 plasticity, nonlinear elasticity..
 Note that in 2D it is not the "real" Von Mises (which should take into
 account the 'plane stress' or 'plane strain' aspect), but a pure 2D Von
 Mises.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@VM=gfmdbrickget(b,'tresca', mds, MFVM)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the Tresca stress criterion on the meshfem MFVM.
 Only available on bricks where it has a meaning: linearized elasticity,
 plasticity, nonlinear elasticity..
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MDBRICK_SET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mdbrickset
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmdbrickset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Modify a model brick 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdbrick
\end_layout

\end_inset

 object @@b@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gfmdbrickset(b,'param', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF,V | V
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

) gfmdbrickset(b,'constraints', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 H, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 R) gfmdbrickset(b,'constraintsrhs', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 H, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 R) gfmdbrickset(b,'penalizationcoef', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 eps)@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickset(b,'param', name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

MF,V | V
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : change the value of a brick parameter.
 V should contain the new parameter value.
 If a meshfem is given , V should hold the field values over that meshfem
 (i.e.
 its last dimension should be @@gfmeshfemget(MF,'nbdof')@@).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickset(b,'constraints', H, R)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : set the constraints imposed by a constraint brick.
 This is only applicable to the bricks which inherit from the constraint
 brick, such as the Dirichlet ones.
 Imposes @@HU=R@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickset(b,'constraintsrhs', H, R)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : set the right hand side of the constraints imposed by a constraint brick.
 This is only applicable to the bricks which inherit from the constraint
 brick, such as the Dirichlet ones.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdbrickset(b,'penalizationcoef', eps)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : change the penalization coefficient of a constraint brick.
 This is only applicable to the bricks which inherit from the constraint
 brick, such as the Dirichlet ones.
 And of course it is not effective when the constraint is enforced via direct
 elimination or via Lagrange multipliers.
 The default value of @@eps@@ is 1e-9.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MDSTATE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mdstate
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmdstate
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General constructor for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdstate
\end_layout

\end_inset

 objects.
 Return a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 handle to the newly created 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdstate
\end_layout

\end_inset

 object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdstate
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@mds=gfmdstate(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 b) mds=gfmdstate('real') mds=gfmdstate('complex')@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset Quotes eld
\end_inset

Model State
\begin_inset Quotes erd
\end_inset

 variables store the state data for a set of model bricks.
 This includes the global tangent matrix, the right hand side and the constraint
s.
 There are two sorts of model states, the 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

complex
\begin_inset Quotes erd
\end_inset

 models states.
 The constructor @@gfmdstate(b)@@ chooses the correct one from the brick
 complexity (@@gfmdbrickget('iscomplex')@@) .
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MDSTATE_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mdstateget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmdstateget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Query information on a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdstate
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdstate
\end_layout

\end_inset

 object @@mds@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gfmdstateget(mds,'iscomplex') gfmdstateget(mds,'tangentmatrix') gfmdstateget(
mds,'constraintsmatrix') gfmdstateget(mds,'reducedtangentmatrix') gfmdstateget(m
ds,'constraintsnullspace') gfmdstateget(mds,'state') gfmdstateget(mds,'residual'
) gfmdstateget(mds,'reducedresidual') gfmdstateget(mds,'unreduce', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U) gfmdstateget(mds,'memsize')@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'iscomplex')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return 0 if the model state is real, 1 if it is complex.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'tangentmatrix')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the tangent matrix stored in the model state.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'constraintsmatrix')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the constraints matrix stored in the model state.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'reducedtangentmatrix')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the reduced tangent matrix (i.e.
 the tangent matrix after elimination of the constraints).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'constraintsnullspace')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the nullspace of the constraints matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'state')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the vector of unknowns, which contains the solution after @@gfmdbrickg
et('solve')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'residual')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the residual.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'reducedresidual')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the residual on the reduced system.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'unreduce', U)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : reinsert the constraint eliminated from the system.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateget(mds,'memsize')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the amount of memory (in bytes) used by the model state.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MDSTATE_SET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_mdstateset
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmdstateSet
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Modify a model state 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mdstate
\end_layout

\end_inset

 object @@mds@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gfmdstateset(mds,'computereducedsystem') gfmdstateset(mds,'computereducedresi
dual') gfmdstateset(mds,'computeresidual', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 B) gfmdstateset(mds,'computetangentmatrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 B) gfmdstateset(mds,'state', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U) gfmdstateset(mds,'clear')@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateset(mds,'computereducedsystem')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the reduced system from the tangent matrix and constraints.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateset(mds,'computereducedresidual')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the reduced residual from the residual and constraints.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateset(mds,'computeresidual', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 B)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the residual for the brick B.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateset(mds,'computetangentmatrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmdbrick
\end_layout

\end_inset

 B)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : update the tangent matrix from the brick B.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateset(mds,'state', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : update the internal state with the vector U.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmdstateset(mds,'clear')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : clear the model state.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MODEL
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_model
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmodel
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General constructor for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmodel
\end_layout

\end_inset

 objects.
 Return a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 handle to the newly created 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmodel
\end_layout

\end_inset

 object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
model
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@mds=gfmodel('real') mds=gfmodel('complex')@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 version 4.0 : 
\begin_inset Quotes eld
\end_inset

Model
\begin_inset Quotes erd
\end_inset

 variables store the variables, the data and the description of a model.
 This includes the global tangent matrix, the right hand side and the constraint
s.
 There are two sorts of models, the 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

complex
\begin_inset Quotes erd
\end_inset

 models.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MODEL_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_modelget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmodelget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Query information on a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmodel
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
model
\end_layout

\end_inset

 object @@md@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@b=gfmodelget(md,'iscomplex') M=gfmodelget(md,'tangentmatrix') V=gfmodelget(md
,'rhs') gfmodelget(md,'listvar') gfmodelget(md,'listbricks') size=gfmodelget(md,
'memsize') V=gfmodelget(md,'variable', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter]) name=gfmodelget(md,'mult varname Dirichlet', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick) V=gfmodelget(md,'from variables') gfmodelget(md,'assembly'[,
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 option]) gfmodelget(md,'solve' [,...]) V = gfmodelget(md,'compute isotropic
 linearized Von Mises or Tresca', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamelambda, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamemu, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfvm[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 version])@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@b=gfmodelget(md,'iscomplex')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return 0 if the model is real, 1 if it is complex.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfmodelget(md,'tangentmatrix')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the tangent matrix stored in the model.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@V=gfmodelget(md,'rhs')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the right hand side of the tangent problem.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelget(md,'listvar')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : print to the output the list of variables and data of the model.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelget(md,'listbricks')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : print to the output the list of bricks of the model.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@size=gfmodelget(md,'memsize')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the amount of memory (in bytes) used by the model state.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@V=gfmodelget(md,'variable', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the vector value of the variable `name`.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@name=gfmodelget(md,'mult varname Dirichlet', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Gives the name of the multiplier variable for a Dirichlet brick.
 If the brick is not a Dirichlet condition with multiplier brick, this function
 has an undefined behavior.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@V=gfmodelget(md,'from variables')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Return the vector of all the degrees of freedom of the model consisting
 of the concatenation of the variables of the model (useful solve your
 problem with you own solver).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelget(md,'assembly'[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 option])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Assembly of the tangent system taking into account the terms from all
 bricks.
 @@option@@, if specified, should be 'build all', 'build rhs' or 'build
 matrix'.
 The default is to build the whole tangent linear system (matrix and rhs).
 This function is useful to solve your problem with you own solver.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelget(md,'solve' [,...])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : run the standard getfem solver.
 Note that you should be able to use your own solver if you want (it is
 possible to obtain the tangent matrix and its right hand side with the
 gfmodelget(md,'tangentmatrix') etc.).
 Various options can be specified: 
\end_layout

\begin_layout Itemize
@@'noisy'@@ or @@'very noisy'@@ : the solver will display some information
 showing the progress (residual values etc.).
 
\end_layout

\begin_layout Itemize
@@'maxiter', NIT@@ : set the maximum iterations numbers.
 
\end_layout

\begin_layout Itemize
@@'maxres', RES@@ : set the target residual value.
 
\end_layout

\begin_layout Itemize
@@'lsolver', SOLVERNAME@@ : select explicitely the solver used for the linear
 systems (the default value is 'auto', which lets getfem choose itself).
 Possible values are 'superlu', 'mumps' (if supported), 'cg/ildlt', 'gmres/ilu'
 and 'gmres/ilut'.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@V = gfmodelget(md,'compute isotropic linearized Von Mises or Tresca',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamelambda, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamemu, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfvm[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 version])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Compute the Von-Mises stress or the Tresca stress of a field (only valid
 for isotropic linearized elasticity in 3D).
 `version` should be 'Von Mises' or 'Tresca' ('Von Mises' is the default).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_MODEL_SET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_modelset
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfmodelset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Modify a model state 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
model
\end_layout

\end_inset

 object @@md@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@ gfmodelset(md,'variable', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter]) gfmodelset(md,'clear') gfmodelset(md,'add fem variable', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter]) gfmodelset(md,'add variable' 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 size[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter]) gfmodelset(md,'add fem data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter]) gfmodelset(md,'add initialized fem data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V) gfmodelset(md,'add data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V) gfmodelset(md,'add initialized data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V) gfmodelset(md,'add multiplier', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 primalname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter]) gfmodelset(md,'to variables', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V) indbrick=gfmodelset(md,'add Laplacian brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]) indbrick=gfmodelset(md,'add generic elliptic brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]) indbrick=gfmodelset(md,'add source term brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 directdataname ]]) indbrick=gfmodelset(md,'add normal source term brick',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region) indbrick=gfmodelset(md,'add Dirichlet condition with multiplier',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region) indbrick=gfmodelset(md,'add Dirichlet condition with penalization',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 coeff, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname ]) gfmodelset(md,'change penalization coeff', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 coeff) indbrick=gfmodelset(md,'add Helmholtz brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]) indbrick=gfmodelset(md,'add Fourier Robin brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region) indbrick=gfmodelset(md,'add constraint with penalization', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 coeff, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L) indbrick=gfmodelset(md,'add constraint with multipliers, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 multname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L) indbrick=gfmodelset(md,'add explicit matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname2, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 issymmetric[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 iscoercive]]) indbrick=gfmodelset(md,'add explicit rhs', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L) gfmodelset(md,'set private matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B) gfmodelset(md,'set private rhs', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L) gfmodelset(md,'disable bricks', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 indbricks) gfmodelset(md,'enable bricks', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 indbricks) indbrick=gfmodelset(md,'add isotropic linearized elasticity
 brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamelambda, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamemu[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]) indbrick=gfmodelset(md,'add linear incompressibility brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 multnamepressure[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamecoeff]]) indbrick=gfmodelset(md,'add mass brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamerho[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]]) indbrick=gfmodelset(md,'add basic d on dt brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamerho[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]]) indbrick=gfmodelset(md,'add basic d2 on dt2 brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameV, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamealpha[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamerho[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]]) gfmodelset(md,'add theta method dispatcher', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 bricksindices, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 theta) gfmodelset(md,'add midpoint dispatcher', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 bricksindices) gfmodelset(md,'velocity update for order two theta method',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanameV, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanametheta) gfmodelset(md,'velocity update for Newmark scheme', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 id2dt2brick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanameV, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanametwobeta, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamegamma) gfmodelset(md,'first iter') gfmodelset(md,'next iter') @@
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(mds,'variable', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : update the value vector of a variable with @@U@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'clear')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : clear the model.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add fem variable', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a variable to the model linked to a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

.
 @@name@@ is the variable name and @@niter@@ is the optional number of copy
 of the variable for time integration schemes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add variable', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 size[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a fixed size variable to the model.
 @@name@@ is the variable name, @@size@@ is the fixed size and @@niter@@
 is the optional number of copy of the variable for time integration schemes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add fem data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a data to the model linked to a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

.
 @@name@@ is the data name and @@niter@@ is the optional number of copy
 of the data for time integration schemes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add initialized fem data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a data to the model linked to a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

.
 @@name@@ is the data name.
 The data is initiakized with @@V@@.
 The data can be a scalar or vector field.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 size[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a data to the model of constant size.
 @@name@@ is the data name and @@niter@@ is the optional number of copy
 of the data for time integration schemes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add initialized data', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a fixed size data to the model linked to a @tmf.
 @@name@@ is the data name, @@V@@ is the value of the data.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add multiplier', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 name, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 primalname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 niter])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a particular variable linked to a fem being a multiplier with respect
 to a primal variable.
 The dof will be filtered with the gmm::rangebasis function applied on the
 terms of the model which link the multiplier and the primal variable.
 This in order to retain only linearly independant constraints on the primal
 variable.
 Optimized for boundary multipliers.
 niter is the number of version of the data stored, for time integration
 schemes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'to variables', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V))@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Set the value of the variables of the model with the vector @@V@@.
 Typically, the vector @@V@@ results of the solve of the tangent linear
 system (useful to solve your problem with you own solver).
 @*/
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add Laplacian brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a Laplacian term to the model relatively to the variable @@varname@@.
 If this is a vector valued variable, the Laplacian term is added componentwise.
 @@region@@ is an optional mesh region on which the term is added.
 If it is not specified, it is added on the whole mesh.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add generic elliptic brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a generic elliptic term to the model relatively to the variable @@varname
@@.
 The shape of the elliptic term depends both on the variable and the data.
 This corresponds to a term 
\begin_inset Formula $-\text{div}(a\nabla u)$
\end_inset

 where 
\begin_inset Formula $a$
\end_inset

 is the data and 
\begin_inset Formula $u$
\end_inset

 the variable.
 The data can be a scalar, a matrix or an order four tensor.
 The variable can be vector valued or not.
 If the data is a scalar or a matrix and the variable is vector valued then
 the term is added componentwise.
 An order four tensor data is allowed for vector valued variable only.
 The data can be constant or describbed on a fem.
 Of course, when the data is a tensor describe on a finite element method
 (a tensor field) the data can be a huge vector.
 The components of the matrix/tensor have to be stored with the fortran
 order (columnwise) in the data vector (compatibility with blas).
 The symmetry of the given matrix/tensor is not verified (but assumed).
 If this is a vector valued variable, the Laplacian term is added componentwise.
 @@region@@ is an optional mesh region on which the term is added.
 If it is not specified, it is added on the whole mesh.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add source term brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 directdataname ]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a source term to the model relatively to the variable @@varname@@.
 The source term is represented by the data @@dataname@@ which could be
 constant or described on a fem.
 @@region@@ is an optional mesh region on which the term is added.
 An additional optional data @@directdataname@@ can be provided.
 The corresponding data vector will be directly added to the right hand
 side without assembly.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add normal source term brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a source term on the variable @@varname@@ on a boundary @@region@@.
 The source term is represented by the data @@dataname@@ which could be
 constant or described on a fem.
 A scalar product with the outward normal unit vector to the boundary is
 performed.
 The main aim of this brick is to represent a Neumann condition with a vector
 data without performing the scalar product with the normal as a pre-processing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add Dirichlet condition with multiplier', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 multname | 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfmult | 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 degree, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname ])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a Dirichlet condition on the variable @@varname@@ and the mesh region
 @@region@@.
 This region should be a boundary.
 The Dirichlet condition is prescribed with a multiplier variable which
 can be either directly given by @@multname@@ (should be first declared
 as a multiplier variable on the mesh region in the model) or added by the
 function and buld on the given finite element method @@mfmult@@ (it will
 be restricted to the mesh region @@region@@ and eventually some conflicting
 dofs with some other multiplier variables will be suppressed) or added
 by the function and build on a standard finite element method of degree
 @@degree@@.
 @@dataname@@ is the optional right hand side of the Dirichlet condition.
 It could be constant or described on a fem; scalar or vector valued, depending
 on the variable on which the Dirichlet condition is prescribed.
 Return the brick index in the model.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add Dirichlet condition with penalization', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 coeff, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname ])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a Dirichlet condition on the variable @@varname@@ and the mesh region
 @@region@@.
 This region should be a boundary.
 The Dirichlet condition is prescribed with penalization.
 The penalization coefficient is intially @@coeff@@ and will be added to
 the data of the model.
 @@dataname@@ is the optional right hand side of the Dirichlet condition.
 It could be constant or described on a fem; scalar or vector valued, depending
 on the variable on which the Dirichlet condition is prescribed.
 Return the brick index in the model.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'change penalization coeff', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 coeff)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Change the penalization coefficient of a Dirichlet condition with penalizatio
n brick.
 If the brick is not of this kind, this function has an undefined behavior.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add Helmholtz brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a Helmholtz term to the model relatively to the variable `varname`.
 `dataname` should contain the wave number.
 `region` is an optional mesh region on which the term is added.
 If it is not specified, it is added on the whole mesh.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add Fourier Robin brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 dataname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a Fourier-Robin term to the model relatively to the variable `varname`.
 this corresponds to a weak term of the form 
\begin_inset Formula $\int(qu).v$
\end_inset

.
 `dataname` should contain the parameter 
\begin_inset Formula $q$
\end_inset

 of the Fourier-Robin condition.
 `region` is the mesh region on which the term is added.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add constraint with multipliers, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 coeff, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add an additional explicit constraint on the variable `varname` thank
 to a multiplier `multname` peviously added to the model (should be a fixed
 size variable).
 The constraint is 
\begin_inset Formula $BU=L$
\end_inset

 with `B` being a rectangular sparse matrix.
 It is possible to change the constraint at any time with the methods 'set
 private matrix' and 'set private rhs'
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add constraint with penalization', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 coeff, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add an additional explicit penalized constraint on the variable `varname`.
 The constraint is 
\begin_inset Formula $BU=L$
\end_inset

 with `B` being a rectangular sparse matrix.
 Be aware that `B` should not contain a plain row, otherwise the whole tangent
 matrix will be plain.
 It is possible to change the constraint at any time with the methods 'set
 private matrix' and 'set private rhs'.
 The method 'change penalization coeff' can be used.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add explicit matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname2, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 issymmetric[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 iscoercive]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a brick reprenting an explicit matrix to be added to the tangent
 linear system relatively to the variables 'varname1' and 'varname2'.
 The given matrix should have has many rows as the dimension of 'varname1'
 and as many columns as the dimension of 'varname2'.
 If the two variables are different and if `issymmetric' is set to 1 then
 the transpose of the matrix is also added to the tangent system (default
 is 0).
 set `iscoercive` to 1 if the term does not affect the coercivity of the
 tangent system (default is 0).
 The matrix can be changed by the command 'set private matrix'.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add explicit rhs', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a brick reprenting an explicit right hand side to be added to the
 right hand side of the tangent linear system relatively to the variable
 'varname'.
 The given vector should have the same size than the dimension of 'varname'.
 Its value can be changed after the creation of the brick by the command
 'set private rhs'.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'set private matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 B)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : For some specific bricks having an internal sparse matrix (constraint
 brick), set this matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'set private rhs', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 indbrick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 L)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : For some specific bricks having an internal right hand side vector (constrain
t brick), set this rhs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'disable bricks', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 indbricks)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Disable a brick (the brick will no longer participate to the building
 of the tangent linear system).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'enable bricks', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 indbricks)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Enable a disabled brick.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add isotropic linearized elasticity brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamelambda, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamemu[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add an isotropic linearized elasticity term to the model relatively to
 the variable `varname`.
 `datanamelambda` and `datanamemu` should contain the Lamé coefficients.
 `region` is an optional mesh region on which the term is added.
 If it is not specified, it is added on the whole mesh.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add linear incompressibility brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 multnamepressure[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamecoeff]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add an linear incompressibility condition on `variable`.
 `multnamepressure` is a variable which represent the pressure.
 Be aware that an inf-sup condition between the finite element method describing
 the rpressure and the primal variable has to be satisfied.
 `region` is an optional mesh region on which the term is added.
 If it is not specified, it is added on the whole mesh.
 `datanamecoeff` is an optional penalization coefficient for nearly incompressib
le elasticity for instance.
 In this case, it is the inverse of the Lamé coefficient 
\begin_inset Formula $\lambda$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add mass brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varname[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamerho[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add mass term to the model relatively to the variable `varname`.
 If specified, the data `datanamerho` should contain the density (1 if omitted).
 `region` is an optional mesh region on which the term is added.
 If it is not specified, it is added on the whole mesh.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add basic d on dt brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamerho[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add the standard discretization of a first order time derivative on `varnameU
`.
 The parameter 
\begin_inset Formula $rho$
\end_inset

 is the density which could be omitted (the defaul value is 1).
 This brick should be used in addition to a time dispatcher for the other
 terms.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@indbrick=gfmodelset(md,'add basic d2 on dt2 brick', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameV, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamealpha[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamerho[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 region]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add the standard discretization of a second order time derivative on
 `varnameU`.
 `datanameV` is a data represented on the same finite element method as
 U which represents the time derivative of U.
 The parameter 
\begin_inset Formula $rho$
\end_inset

 is the density which could be omitted (the defaul value is 1).
 This brick should be used in addition to a time dispatcher for the other
 terms.
 The time derivative 
\begin_inset Formula $v$
\end_inset

 of the variable 
\begin_inset Formula $u$
\end_inset

 is preferably computed as a post-traitement which depends on each scheme.
 The parameter `datanamealpha` depends on the time integration scheme.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add theta method dispatcher', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 bricksindices, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 theta)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Add a theta-method time dispatcher to a list of bricks.
 For instance, a matrix term 
\begin_inset Formula $K$
\end_inset

 will be replaced by 
\begin_inset Formula $\theta KU^{n+1}+(1-\theta)KU^{n}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'add midpoint dispatcher', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 bricksindices)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : ind = MODEL:SET('add midpoint dispatcher', @ivec bricksindices) Add a
 midpoint time dispatcher to a list of bricks.
 For instance, a nonlinear term 
\begin_inset Formula $K(U)$
\end_inset

 will be replaced by 
\begin_inset Formula $K((U^{n+1}+U^{n})/2)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'velocity update for order two theta method', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanameV, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanametheta)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Function which udpate the velocity 
\begin_inset Formula $v^{n+1}$
\end_inset

 after the computation of the displacement 
\begin_inset Formula $u^{n+1}$
\end_inset

 and before the next iteration.
 Specific for theta-method and when the velocity is included in the data
 of the model.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'velocity update for Newmark scheme', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 id2dt2brick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 varnameU, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanameV, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamedt, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanametwobeta, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 datanamegamma)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : Function which udpate the velocity 
\begin_inset Formula $v^{n+1}$
\end_inset

 after the computation of the displacement 
\begin_inset Formula $u^{n+1}$
\end_inset

 and before the next iteration.
 Specific for Newmark scheme and when the velocity is included in the data
 of the model.
 This version inverts the mass matrix by a conjugate gradient.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'first iter')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : To be executed before the first iteration of a time integration scheme.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfmodelset(md,'next iter')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : To be executed at the end of each iteration of a time integration scheme.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_SLICE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_slice
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfslice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General constructor for 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 objects.
 Return a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 handle to the newly created 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 object
\begin_inset Index
status collapsed

\begin_layout Plain Layout
slice
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@sl = gfslice(sliceop, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 m, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 refine [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 CVFLST]) sl = gfslice(sliceop, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 refine [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 CVFLST]) sl = gfslice(sliceop, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 SL) sl = gfslice('streamlines', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 MF, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 seeds) sl = gfslice('points', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 M, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 pts) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 This function creates a mesh slice.
 Mesh slices are very similar to a P1-discontinuous 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 on which interpolation is very fast.
 The slice is built from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mesh
\end_layout

\end_inset

 object, and a description of the slicing operation, for example, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 sl = gfslice({'planar',+1,[0;0],[1;0]}, m, 5); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 cuts the original mesh with the half space 
\begin_inset Formula $\{y>0\}$
\end_inset

.
 Each convex of the original mesh @@m@@ is simplexified (for example a quadrangl
e is split into 2 triangles), and each simplex is refined 5 times.
\end_layout

\begin_layout Standard
Slicing operations can be:
\end_layout

\begin_layout Itemize
cutting with a plane, a sphere or a cylinder 
\end_layout

\begin_layout Itemize
intersection or union of slices 
\end_layout

\begin_layout Itemize
taking the boundary of the mesh, or shrinking each convex..
 
\end_layout

\begin_layout Itemize
iso-values surfaces/volumes, contour lines 
\end_layout

\begin_layout Itemize
"points", "streamlines" (see below) 
\end_layout

\begin_layout Standard
If the first argument is a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 instead of a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mesh
\end_layout

\end_inset

, and if it is followed by a field @@U@@ (with @@size(U,1) == gfmeshfemget(mf,U)
@@), then the deformation @@U@@ will be applied to the mesh before the slicing
 operation.
\end_layout

\begin_layout Standard
The first argument can also be a slice.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash

\backslash
[1cm]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent

\shape smallcaps
Slicing operations
\shape default
 (@@sliceop@@):
\begin_inset Newline newline
\end_inset

 Always specify them between braces (i.e.
 in a cell array).
 The first argument is the name of the operation, followed the slicing options.
\end_layout

\begin_layout Itemize
@@{'none'}@@
\end_layout

\begin_deeper
\begin_layout Standard
does not cut the mesh.
\end_layout

\end_deeper
\begin_layout Itemize
@@{'planar', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 orient, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 p, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 n}@@
\end_layout

\begin_deeper
\begin_layout Standard
planar cut.
 @@p@@ and @@n@@ define a half-space, @@p@@ being a point belong to the
 boundary of the half-space, and @@n@@ being its normal.
 If @@orient@@ is equal to -1 (resp.
 0, +1), then the slicing operation will cut the mesh with the "interior"
 (resp.
 "boundary", "exterior") of the half-space.
 @@orient@@ may also be set to +2 which means that the mesh will be sliced,
 but both the outer and inner parts will be kept: it just makes sure that
 no simplex crosses the slice boundary.
\end_layout

\end_deeper
\begin_layout Itemize
@@{'ball', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 orient, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 c, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 r}@@
\end_layout

\begin_deeper
\begin_layout Standard
cut with a ball of center @@c@@ and radius @@r@@.
\end_layout

\end_deeper
\begin_layout Itemize
@@{'cylinder', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 orient, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 p1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 p2, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 r}@@
\end_layout

\begin_deeper
\begin_layout Standard
cut with a cylinder whose axis is the line (@@p1@@,@@p2@@) and whose radius
 is @@r@@.
\end_layout

\end_deeper
\begin_layout Itemize
@@{'isovalues', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 orient, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 V}@@
\end_layout

\begin_deeper
\begin_layout Standard
cut using the isosurface of the field @@U@@ (defined on the meshfem MF).
 The result is the set 
\begin_inset Formula $\{x$
\end_inset

such that @@U@@
\begin_inset Formula $(x)<=$
\end_inset

@@V@@
\begin_inset Formula $\}$
\end_inset

 or 
\begin_inset Formula $\{x$
\end_inset

such that @@U@@
\begin_inset Formula $(x)==$
\end_inset

@@V@@
\begin_inset Formula $\}$
\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

x such that U(x) <= V
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 depending on the value of @@orient@@.
\end_layout

\end_deeper
\begin_layout Itemize
@@{'boundary'[, sliceop]}@@
\end_layout

\begin_deeper
\begin_layout Standard
returns the boundary of the result of @@sliceop@@, where @@sliceop@@ is
 any slicing operation.
 If @@sliceop@@ is not specified, then the whole mesh is considered (i.e.
 it is equivalent to @@{'boundary',{'none'}}@@).
\end_layout

\end_deeper
\begin_layout Itemize
@@{'explode', c}@@ build an 
\begin_inset Quotes eld
\end_inset

exploded
\begin_inset Quotes erd
\end_inset

 view of the mesh: each convex is shrinked (
\begin_inset Formula $0<c\leq1$
\end_inset

).
 In the case of 3D convexes, only their faces are kept.
\end_layout

\begin_layout Itemize
@@{'union', sliceop1, sliceop2}@@ 
\end_layout

\begin_layout Itemize
@@{'intersection', sliceop1, sliceop2}@@ 
\end_layout

\begin_layout Itemize
@@{'comp', sliceop}@@ 
\end_layout

\begin_layout Itemize
@@{'diff', sliceop1, sliceop2}@@
\end_layout

\begin_deeper
\begin_layout Standard
perform boolean operations: returns the union, intersection, complementary
 or difference of slicing operations.
\end_layout

\end_deeper
\begin_layout Itemize
@@{'mesh', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 m}@@
\end_layout

\begin_deeper
\begin_layout Standard
builds a slice which is the intersection of the sliced mesh with another
 mesh @@m@@.
 The slice is such that all of its simplexes are stricly contained into
 a convex of each mesh.
\end_layout

\end_deeper
\begin_layout Standard
\noindent

\shape smallcaps
Special slices:
\shape default

\begin_inset Newline newline
\end_inset

 There are also some special calls to gfslice:
\end_layout

\begin_layout Standard
@@gfslice('streamlines',
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 seeds)@@ computes streamlines of the (vector) field @@U@@, with seed points
 given by the columns of @@seeds@@.
\end_layout

\begin_layout Standard
@@gfslice('points', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 m, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 P)@@ returns the "slice" composed of points given by the columns of @@P@@
 (useful for interpolation on a given set of sparse points, see @@gfcompute(mf,U
,'interpolate on',sl)@@).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Apply the deformation given by @@mf,U@@ on the mesh, then slice it with
 the 
\begin_inset Formula $z+$
\end_inset

 half-space, and keep only the part where @@U2(x) > 0@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 sl = gfslice(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

intersection',
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

'planar',+1,[0;0;0],[0;0;1]
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

,...
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

'isovalues',-1,mf2,U2,0
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

,mf,U,5); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
View the convex quality of a 2D or 3D mesh m: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 gfplotslice(gfSlice(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

'explode', 0.7
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, m, 2), 'convexdata',...
 gfmeshget(m,'quality')); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 See the @@gfplotslice@@ usage example for more slices.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gfsliceget, gfsliceset, gfplotslice@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_SLICE_GET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_sliceget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfsliceget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General inquiry on a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
slice
\end_layout

\end_inset

 object @@sl@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 I = gfsliceget(sl, 'dim') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 I = gfsliceget(sl, 'area') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 cvlst = gfsliceget(sl, 'cvs') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 n = gfsliceget(sl, 'nbpts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 P = gfsliceget(sl, 'pts') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 NS = gfsliceget(sl, 'nbsplxs') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 NS = gfsliceget(sl, 'nbsplxs',
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 dim) [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
timat
\end_layout

\end_inset

 S, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CV2SPLX] = gfsliceget(sl, 'splxs', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 dim) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 E = gfsliceget(sl, 'edges') [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 P, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 E1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 E2] = gfsliceget(sl, 'edges') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Usl=gfsliceget(sl, 'interpolateconvexdata', Ucv) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 m = gfsliceget(sl, 'linked mesh') gfsliceget(sl,'exporttovtk', filename
 ...
 [, 'ascii'][, 'edges'],...) gfsliceget(sl,'exporttopov', filename, ...) gfsliceget(sl
,'exporttodx', filename, ...[, 'ascii'][, 'edges'][, 'append']) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 ms=gfsliceget(sl, 'memsize')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'linked mesh')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the mesh on which the slice was taken.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'dim')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the dimension of the points of the slice (2 for a 2D mesh, etc..).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'area')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the area of the slice.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'cvs')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of convexes contained in the slice (these convex numbers
 refer to the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmesh
\end_layout

\end_inset

 object returned by @@gfsliceget(sl, 'linked mesh')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'nbpts')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of points in the slice, and their list can be obtained
 with @@gfsliceget(sl, 'pts')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'nbsplxs' [, dim])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of simplexes in the slice.
 Since the slice may contain points (simplexes of dimension 0), segments
 (simplexes of dimension 1), triangles etc, the result is a vector of size
 @@gfsliceget(sl, 'dim')+1@@ , except if the optional argument @@dim@@ is
 used.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[S,CV2SPLX]=gfsliceget(sl, 'splxs', dim)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the list of simplexes of dimension @@dim@@.
 On output, @@S@@ has @@dim+1@@ rows, each column contains the point numbers
 of a simplex.
 The vector CV2SPLX can be used to find the list of simplexes for any convex
 stored in the slice.
 For example @@S(:,CV2SPLX(4):CV2SPLX(5)-1)@@ give the list of simplexes
 for the fourth convex.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[P,E1,E2]=gfsliceget(sl, 'edges')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return also the edges of the linked mesh, but in a different style: @@P@@
 contains the list of all edge vertices, @@E1@@ contains the indices of
 each mesh edge in @@P@@, and @@E2@@ contains the indices of each "edges"
 which is on the border of the slice (used by @@gfplotslice@@).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'interpolateconvexdata', Ucv)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 should be used to map some data that is given on each convex of the mesh
 (for example the output of @@gf_mesh_get(m, 'quality')@@) to the slice
 nodes.
 The input array Ucv may have any number of dimensions, but its last dimension
 should be equal to @@gf_mesh_get(m,'maxcvid')@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl,'exporttovtk', filename ...
 [, 'ascii'][, 'edges'],...)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export a slice to 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
VTK
\end_layout

\end_inset

.
 Following the file name, you may use any of the following options: 
\end_layout

\begin_layout Itemize
if 'ascii' is not used, the file will contain binary data (non portable,
 but fast).
\end_layout

\begin_layout Itemize
if 'edges' is used, the edges of the original mesh will be written instead
 of the slice content.
 More than one dataset may be written, just list them.
 
\end_layout

\begin_layout Standard
Each dataset consists of either a field interpolated on the slice, followed
 by an optional name, or a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 and a field, followed by an optional name.
 The field might be a scalar field, a vector field or a tensor field.
\end_layout

\begin_layout Standard
For example: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 gfsliceget(sl,'exporttovtk', 'test.vtk', Uslice, 'firstdataset', ...
 mf, U2, 'seconddataset') gfsliceget(sl,'exporttovtk', 'test.vtk', 'ascii',
 mf, U2) gfsliceget(sl,'exporttovtk', 'test.vtk', 'edges', 'ascii', Uslice)
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl,'exporttopov', filename, ...)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export the triangles of the slice to POV-RAY.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl,'exporttodx', string FILENAME, ...)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export a slice to 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
OpenDX
\end_layout

\end_inset

.
 Following the file name, you may use any of the following options: 
\end_layout

\begin_layout Itemize
if 'ascii' is not used, the file will contain binary data (non portable,
 but fast).
\end_layout

\begin_layout Itemize
if 'edges' is used, the edges of the original mesh will be written instead
 of the slice content.
 More than one dataset may be written, just list them.
 
\end_layout

\begin_layout Itemize
if 'append' is used, the opendx file will not be overwritten, and the new
 data will be added at the end of the file.
 
\end_layout

\begin_layout Standard
More than one dataset may be written, just list them.
 Each dataset consists of either a field interpolated on the slice (scalar,
 vector or tensor), followed by an optional name, or a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 and a field, followed by an optional name.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfsliceget(sl, 'memsize')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the amount of memory (in bytes) used by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 object.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gfslice, gfsliceset, gfplotslice@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_SLICE_SET
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_sliceset
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfsliceset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General function for editing 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 objects
\begin_inset Index
status collapsed

\begin_layout Plain Layout
slice
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

@@gf_slice_set(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 sl, 'pts', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 P)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_slice_set(sl,'pts',P)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 replaces the original points of the slice @@sl@@ with new points given
 in the matrix @@P@@ (stored in the columns).
 Note that you can use the function in order to apply a deformation to a
 slice, or to change the dimension of the slice (i.e.
 the number of rows of @@P@@ is not required to be equal to @@gfsliceget(sl,'dim
'))@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gfslice, gfsliceget, gfplotslice@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_ASM
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_asm
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfasm
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General assembly function
\begin_inset Index
status collapsed

\begin_layout Plain Layout
assembly
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 F = gf_asm('volumic source', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 F) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 F = gf_asm('boundary source',
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 boundary_num, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 G) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M = gf_asm('mass matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf1[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf2]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M = gf_asm('laplacian', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 A) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 K = gf_asm('linear elasticity', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 lambda_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 mu_d) [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 K,B] = gf_asm('stokes', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_p, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 visc) [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 H,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 R] = gf_asm('dirichlet', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 boundary_num, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 Hd, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 Rd) M = gf_asm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

boundary qu term
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 boundary_num, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 Q) [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 Q, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 G,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 H,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 R,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 F]=gf_asm('pdetool boundary conditions', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_u, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf_d, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 b, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 e[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 f_expr]) [\SpecialChar \ldots{}
] = gfasm('volumic'[, CVLST], 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 expr, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim.., [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf1[, mf2,..]][,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 data...]) [\SpecialChar \ldots{}
] = gfasm('boundary', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 bnum, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 expr, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 mim.., [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf1[, mf2,..]][,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 data...]) M = gfasm('interpolation matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf2) M = gfasm('extrapolation matrix', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf1, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf2) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 These assembly procedures all take an @@mf_u@@ argument, which is the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

descriptor for the main unknown of the PDE.
 They usually take an 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kw{
\end_layout

\end_inset

mf_d
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 argument, which describes the 
\shape italic
data
\shape default
 FEM (i.e.
 Lam
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

é
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 coefficients for linear elasticity, fluid viscosity for stokes equation,
 etc\SpecialChar \ldots{}
).
 Data 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 are always expected to be scalar (i.e.
 @@Qdim==1@@)
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Qdim
\end_layout

\end_inset

, if they are used to describe a vector field @@V@@, then it is expected
 to have @@Q@@ rows (and @@gfmeshfemget(mfd,'nbdof')@@ columns).
\end_layout

\begin_layout Standard
If you are not using exact integration methods, please make sure that the
 integration has a sufficiently high order (don't forget to take into account
 the degree of the geometrical transformation).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@Fv=gf_asm('volumic source', mim, mf_u, mf_d, F)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
volumic source
\end_layout

\end_inset

 assemble a volumic source term, on @@mf_u@@, using the data vector @@F@@
 defined on the data 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 @@mf_d@@: 
\begin_inset Formula \[
@@Fv@@=\int_{\Omega}\varphi^{i}(x)F(x)~dx\quad\text{with\ }F(x)=\sum_{j}F_{j}\psi^{j}(x)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@Fb=gf_asm('boundary source', bnum, mim, mf_u, mf_d, F)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
boundary source
\end_layout

\end_inset

 is very similar, except that the integral is evaluated on the boundary
 @@bnum@@ instead of the whole domain 
\begin_inset Formula $\Omega$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gf_asm('mass matrix', mim, mf1 [, mf2])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
mass     matrix
\end_layout

\end_inset

 build the mass matrix 
\begin_inset Formula \[
\int_{\Omega}\varphi^{i}(x).\psi^{j}(x)~dx.\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gf_asm(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
str{
\end_layout

\end_inset

laplacian
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, mim, mf_u, mf_d, A)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Laplacian
\end_layout

\end_inset

 do the assembly of elementary matrices for the Laplacian 
\begin_inset Formula $\nabla.(a(x)\nabla u(x))$
\end_inset

: 
\begin_inset Formula \[
\int a(x)(\nabla\varphi_{u}(x).\nabla\varphi_{u}(x))\quad\text{with~}a(x)=\sum A_{i}\psi^{i}(x)\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_asm('linear elasticity', mim, mf_u, mf_d, lambda_d, mu_d)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
linear elasticity
\end_layout

\end_inset

 return the linear elasticity stiffness matrix: 
\begin_inset Formula $\nabla.\sigma(x)$
\end_inset

, where the stress tensor 
\begin_inset Formula $\sigma$
\end_inset

 is 
\begin_inset Formula $\sigma(x)=C_{ijrs}\varepsilon_{rs}$
\end_inset

 and the strain tensor 
\begin_inset Formula $\varepsilon$
\end_inset

 is 
\begin_inset Formula $\varepsilon_{rs}(u)=(\partial_{r}u_{s}+\partial_{s}u_{r})/2$
\end_inset

 and 
\begin_inset Formula $C_{ijrs}=\lambda\delta_{ij}\delta_{rs}+\mu(\delta_{ir}\delta_{js}+\delta_{is}\delta_{jr})$
\end_inset

 (
\begin_inset Formula $\lambda$
\end_inset

 and 
\begin_inset Formula $\mu$
\end_inset

 are the Lam
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

é
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 coefficients).
 The 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 
\begin_inset Formula $mf_{u}$
\end_inset

 is expected to be such that @@gfmeshfemget(mfu,'Qdim') == gfmeshget(mfu,'dim')@
@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[K,B]=gf_asm('stokes', mim, mf_u, mf_p, mf_d, visc)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Stokes equation
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
viscous incompressible fluid
\end_layout

\end_inset

 : do the assembly of elementary matrices for the Stokes equation (viscous
 incompressible fluid) 
\begin_inset Formula $\nu\Div~(\varepsilon(u))\Delta u-\Grad~p=0,\Div~u=0$
\end_inset

.
 On output, @@B@@ is a sparse matrix corresponding to 
\begin_inset Formula \[
\int_{\Omega}p(x).\Div~v(x)~dx\]

\end_inset

, and @@K@@ is the linear elasticity stiffness matrix for 
\begin_inset Formula $\lambda=0$
\end_inset

 and 
\begin_inset Formula $2\mu=@@visc@@$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[H,R]=gf_asm('dirichlet', bnum, mim, mf_u, mf_d, Hd, Rd)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Dirichlet conditions
\end_layout

\end_inset

 assemble 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Dirichlet
\end_layout

\end_inset

 conditions of type 
\begin_inset Formula $h(x).u(x)=r(x)$
\end_inset

 where h is a small square matrix (of any rank) whose size is equal to @@gfmeshf
emget(mfu,'Qdim')@@.
 This matrix is stored in @@Hd@@, one column per dof in @@mf_d@@, each column
 containing the values of the matrix 
\begin_inset Formula $h$
\end_inset

 stored in Fortran order: for example 
\begin_inset Formula $@@Hd(:,j)@@=[h_{11}(x_{j})h_{21}(x_{j})h_{12}(x_{j})h_{22}(x_{j})]$
\end_inset

 if 
\begin_inset Formula $u$
\end_inset

 is a 2D vector field.
\end_layout

\begin_layout Standard
Of course, if the unknown 
\begin_inset Formula $u$
\end_inset

 is a scalar field, @@Hd@@ is just a row vector
\end_layout

\begin_layout Standard
You may wonder why assembling Dirichlet conditions: these are usually expressed
 on a convenient 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (i.e.
 a Lagrangian one), while the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 of 
\begin_inset Formula $u$
\end_inset

 might be more complex (i.e.
 non Lagrangian).
 Hence we need to project the constraints on the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 of 
\begin_inset Formula $u$
\end_inset

.
 This is basically identical to 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 H = gf_asm('boundary qu term',bnum, mim, mfu, mfd, Hd); R = gfasm('boundary
 source',bnum, mim, mfu, mfd, Rd); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 except that this function is smarter, in the sense that it tries to produce
 a 
\begin_inset Quotes eld
\end_inset

better
\begin_inset Quotes erd
\end_inset

 (more diagonal) constraints matrix @@HH@@ (when possible): if it was not
 the case, @@H@@ would be (in the general case) tridiagonal on 2D meshes
 when @@Hd@@ is diagonal.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%  
\backslash
textit{CAUTION: the behavior of this function is currently not
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%  very satisfactory with high order FEMs ($P^4$ and more).
 High degree
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%  polynomials means higher numerical noise, which means spurious non-null
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%  terms in the matrix @@H@@, which cause ``non-existent'' Dirichlet
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%  conditions to appear.
 This issue will be solved in a future release.}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that the rank of @@H@@ still needs to be determined: @@[N,U0]=gf_spmat_get(
H'dirichlet nullspace', R)@@ 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Dirichlet nullspace
\end_layout

\end_inset

 does this.
 It solves the 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Dirichlet
\end_layout

\end_inset

 conditions @@HU=R@@, returning a solution @@U0@@ which has a minimum 
\begin_inset Formula $L^{2}$
\end_inset

-norm.
 The sparse matrix @@N@@ contains an orthogonal basis of the kernel of the
 constraints matrix @@H@@ (hence, the PDE linear system should be solved
 on this subspace):
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
the initial problem
\begin_inset Newline newline
\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%  
\backslash
begin{gif}{dirichletconstr}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Formula \[
KU=B\quad\text{with constraints}\quad HU=R\]

\end_inset

 is replaced by 
\begin_inset Formula \[
\begin{array}{ll}
(N^{T}KN)V & =N^{T}*B-N^{T}*K*U_{0}\\
U & =N*V+U_{0}\end{array}\]

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% 
\backslash
end{gif}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gf_asm('boundary qu term', boundary_num, mim, mf_u, mf_d, Q)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
boundary qu term
\end_layout

\end_inset

 assemble the term 
\begin_inset Formula $\int_{\Gamma}(Q(x)\varphi(x)).\psi(x)~dx$
\end_inset

 where 
\begin_inset Formula $Q$
\end_inset

 is a square matrix of size 
\begin_inset Formula $@@Qdim@@\times@@Qdim@@$
\end_inset

, @@Qdim@@ being the dimension of the unknown 
\begin_inset Formula $u$
\end_inset

 (that is set when creating the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

).
 This is a kind of general boundary mass matrix.
\end_layout

\begin_layout Standard
The supplied argument @@Q@@ should be a 
\begin_inset Formula $(@@Qdim@@^{2})\times N$
\end_inset

 array, where @@N@@ is the number of degree of freedom of @@mf_d@@.
 Each column of @@Q@@ contains the coefficients stored in the Fortran (and
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 order), for example if 
\begin_inset Formula $@@Qdim@@=2$
\end_inset

, 
\begin_inset Formula $@@Q(:,i)@@=q_{11},q_{21},q_{12},q_{22}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[Q,G,H,R,F]=gf_asm('pdetool boundary conditions', mim, mf_u, mf_d, b,
 e[, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

f_expr])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
pdetool
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
boundary     conditions
\end_layout

\end_inset

 is an easy way to assemble boundary conditions obtained from 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
pdetool
\end_layout

\end_inset

: @@b@@ is the boundary matrix exported by the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
pdetool
\end_layout

\end_inset

, and @@e@@ is the edges array.
 @@f_expr@@ is an optional expression (or vector) for the volumic term.
 On return @@Q@@,@@G@@,@@H@@,@@R@@,@@F@@ contain the assembled boundary
 conditions (@@Q@@ and @@H@@ are matrices), similar to the ones returned
 by the function @@assemb@@ from 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
pdetool
\end_layout

\end_inset

, and the solution @@U@@ satisfies 
\begin_inset Formula $(@@K@@+@@Q@@)@@U@@=@@F@@+@@G@@$
\end_inset

 under the constraints 
\begin_inset Formula $@@HU@@=@@R@@$
\end_inset

 (@@K@@ is the stiffness matrix of the PDE considered).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[...]=gfasm({ 'volumic'[,CVLST] | 'boundary',bnum }, expr, mim1,..,[mf1[, mf2,..]][,
 data...])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is the generic assembly
\begin_inset Index
status collapsed

\begin_layout Plain Layout
generic assembly
\end_layout

\end_inset

 procedure for volumic and boundary assembly.
 The expression @@expr@@ is evaluated over the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 listed in the arguments (with optional data) and assigned to the output
 arguments.
 For details about the syntax of assembly expressions, please refer to the
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www-gmm.insa-toulouse.fr/getfem/doc
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

getfem user manual
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 (or look at the file 
\family typewriter
getfem_assembling.h
\family default
 in the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gf
\end_layout

\end_inset

 sources).
\end_layout

\begin_layout Standard
For example, the 
\begin_inset Formula $L^{2}$
\end_inset

 norm of a field can be computed with @@gfcompute(mf,U,'L2
\begin_inset space ~
\end_inset

norm')@@ or with: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 gfasm('volumic','u=data(#1); V()+=u(i).u(j).comp(Base(#1).Base(#1))(i,j)',mim,mf,U
) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Laplacian stiffness matrix can be evaluated with @@gfasm('Laplacian',mim,
 mf, A)@@ or equivalently with: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 gfasm('volumic',['a=data(#2); ',\SpecialChar \ldots{}
 'M(#1,#1)+=sym(comp(Grad(#1).Grad(#1).Base(#2))(
:,i,:,i,j).a(j))'], mim, mf, A); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfasm('interpolation matrix', mf1, mf2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : build the interpolation matrix from a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 onto another one (assumed to be Lagrangian).
 The returned sparse matrix @@M@@ is such that @@V=M*U=gf_compute(mf1,U,'interpo
lateon', mf1)@@.
 This might be useful for repeated interpolations.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfasm('extrapolation matrix', mf1, mf2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is similar, but performs 
\begin_inset Quotes eld
\end_inset

light
\begin_inset Quotes erd
\end_inset

 extrapolation:,if some degrees of freedom of mf2 are slightly outside @@mf1@@,
 their value will be extrapolated from the values of the nearest D.o.F.
 of @@mf1@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kwl{
\end_layout

\end_inset

gfsolve
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

gf_solve
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kwl{
\end_layout

\end_inset

gfcompute
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

gf_compute('interpolate on')
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_SPMAT
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_spmat
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfspmat
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General constructor for getfem sparse matrices
\begin_inset Index
status collapsed

\begin_layout Plain Layout
sparse matrices
\end_layout

\end_inset

 (i.e.
 sparse matrices which are stored in the getfem workspace, not the Scilab
 sparse matrices).
 Note however that @@gfspmatget@@, @@gflinsolve@@ and @@gfprecond@@ can
 be used directly with Scilab sparse matrices.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@M=gfspmat('empty', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 m [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 n]) M=gfspmat('identity', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 n) M=gfspmat('copy', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 K [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 I [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 J]]) M=gfspmat('mult', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 A, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 B) M=gfspmat('add', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 A, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 B) M=gfspmat('harwell-boeing', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename) M=gfspmat('matrix-market', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The sparse matrix can be stored as CSC (compressed column sparse), which
 is the format used by Scilab, or they can be stored as WSC (internal format
 to getfem).
 The CSC matrices are not writable (it would be very inefficient), but they
 are optimized for multiplication with vectors, and memory usage.
 The WSC are writable, they are very fast with respect to random read/write
 operation.
 However their memory overhead is higher than CSC matrices, and they are
 a little bit slower for matrix-vector multiplications.
\end_layout

\begin_layout Standard
By default, all newly created matrices are build as WSC matrices.
 This can be changed later with @@gfspmatset(sm,'tocsc')@@, or may be changed
 automatically by getfem (for example @@gflinsolve()@@ converts the matrices
 to CSC).
\end_layout

\begin_layout Standard
The matrices may store REAL or COMPLEX values.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfspmat('empty', m, n)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a new empty (i.e.
 full of zeros) sparse matrix, of dimensions 
\begin_inset Formula $m\times n$
\end_inset

.
 If n is ommited, the matrix dimension is 
\begin_inset Formula $m\times m$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfspmat('identity', n)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a 
\begin_inset Formula $n\times n$
\end_inset

 identity matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfspmat('copy', K [, I [, J]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : duplicate a matrix @@K@@ (which might be a @@gfSpmat@@ or a native scilab
 sparse matrix).
 If @@I@@ and/or @@J@@ are given, the matrix @@M@@ will be a submatrix of
 @@K@@.
 For example @@M = gfspmat('copy', sprand(50,50,.1), 1:40, [6 7 8 3 10])@@
 will return a 40x5 matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfspmat('mult', A, B)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a sparse matrix as the product of the sparse matrices @@A@@ and
 @@B@@.
 It requires that @@A@@ and @@B@@ be both real or both complex, you may
 have to use @@gfspmatset(..,'tocomplex')@@
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfspmat('add', @spmat A, @spmat B)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a sparse matrix as the sum of the sparse matrices @@A@@ and @@B@@.
 Adding a real matrix with a complex matrix is possible.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfspmat('hb', filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or @@gfspmat('harwell-boeing', filename)@@ read a sparse matrix from an
 Harwell-Boeing file.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@M=gfspmat('mm', filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or @@gfspmat('matrix-market', filename)@@ read a sparse matrix from a Matrix-Ma
rket file.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_util@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
gf_spmatget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfspmatget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Extract information from a getfem sparse matrix
\begin_inset Index
status collapsed

\begin_layout Plain Layout
sparse matrices
\end_layout

\end_inset

.
 @@M@@ might also be a native Scilab sparse matrix.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 gfspmatget(M,'size') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 gfspmatget(M,'nnz') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 gfspmatget(M,'iscomplex') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S=gfspmatget(M,'storage') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmat
\end_layout

\end_inset

 fM=gfspmatget(M,'full'[,I [,J]]) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 tMV=gfspmatget(M,'mult', V) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 MV=gfspmatget(M,'tmult', V) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 D=gfspmatget(M,'diag'[, E]) [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 JC,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 IR]=gfspmatget(M,'cscind') [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V]=gfspmatget(M,'cscval') [
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 N, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 U0]=gfspmatget(H,'dirichletnullspace', @vec R) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S=gfspmatget(sl,'info') gfspmatget(sl,'save', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 format, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'size')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a vector @@[ni, nj]@@ where @@ni@@ and @@nj@@ are the dimensions
 of the matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'nnz')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the number of non-null values stored in the sparse matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'iscomplex')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return 1 if the matrix contains complex values.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'storage')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the storage type currently used for the matrix.
 The storage is returned as a string, either @@'CSC'@@ or @@'WSC'@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'full'[,I [,J]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a full (sub-)matrix of @@M@@.
 The optional arguments @@I@@, are the sub- intervals for the rows and columns
 that are to be extracted.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'mult', V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : give the product of the sparse matrix @@K@@ with a vector @@V@@.
 For matrix-matrix multiplications, see @@gfspmat('mult')@@
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'tmult', V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 give the product of @@M@@ transposed (conjugated if @@M@@ is complex) with
 the vector V.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(M,'diag'[, E])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the diagonal of @@M@@ as a vector.
 If @@E@@ is used, return the sub-diagonals whose ranks are given in @@E@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[JC,IR]=gfspmatget(M,'cscind')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the two usual index arrays of CSC storage.
 If @@K@@ is not stored as a CSC matrix, it is converted into CSC.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[V]=gfspmatget(M,'cscval')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return the array of values of all non-zero entries of @@M@@.
 If M is not stored as a CSC matrix, it is converted into CSC.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[N,U0]=gfspmatget(H,'dirichletnullspace', @vec R)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : solve the (under-determined) linear system @@HU=R@@.
 A solution @@U0@@ which has a minimum L2-norm is returned, with a sparse
 matrix @@N@@ containing an orthogonal basis of the kernel of the constraints
 matrix H : the initial problem @@KU = B@@ with constraints @@HU=R@@ is
 replaced by @@(N'*K*N)*UU = N'*B@@ and the solution is @@U = N*UU + U0@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@S=gfspmatget(sl,'info')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a string contains a short summary on the sparse matrix (dimensions,
 filling, ..).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatget(sl,'save', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 format, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 filename)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : export the sparse matrix.
 The format of the file may be @@'hb'@@ for Harwell- Boeing, or @@'mm'@@
 for Matrix-Market.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
gf_spmatset
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfspmatset
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Modification of the content of a getfem sparse matrix
\begin_inset Index
status collapsed

\begin_layout Plain Layout
sparse matrices
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gfspmatset(M,'clear'[, I[, J]]) gfspmatset(M,'scale', V) gfspmatset(M,'transp
ose') gfspmatset(M,'conjugate') gfspmatset(M,'transconj') gfspmatset(M,'tocsc')
 gfspmatset(M,'towsc') gfspmatset(M,'tocomplex') gfspmatset(M,'diag', mat
 D [, ivec E]) gfspmatset(M,'assign', ivec I, ivec J, V) gfspmatset(M,'add',
 I, J, V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'clear'[, I[, J]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : erase the non-zero entries of the matrix.
 The optional arguments @@I@@ and @@J@@ may be specified to clear a sub-matrix
 instead of the entire matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'scale', V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : multiplie the matrix by a scalar value @@V@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'transpose')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : transposition of the matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'conjugate')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : conjugate each element of the matrix (does nothing for REAL matrices).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'transconj')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : transpose and conjugate the matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'tocsc')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : convert the matrix to CSC storage.
 CSC storage is recommended for the speed of matrix-vector multiplications.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'towsc')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : convert the matrix to WSC storage.
 Read and write operation are quite fast with WSC storage.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'tocomplex')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : store complex numbers.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'diag', mat D [, ivec E])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : change the diagonal (or sub-diagonals) of the matrix.
 If @@E@@ is given, @@D@@ might be a matrix and each column of @@E@@ will
 contain the sub-diagonal number that will be filled with the corresponding
 column of @@D@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'assign', ivec I, ivec J, V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : copy @@V@@ into the sub-matrix @@M(I,J)@@.
 @@V@@ might be a sparse matrix or a full matrix.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfspmatset(M,'add', I, J, V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : add @@V@@ to the sub-matrix @@M(I,J)@@.
 @@V@@ might be a sparse matrix or a full matrix.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_PRECOND
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_precond
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfprecond
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Constructor for getfem preconditioners
\begin_inset Index
status collapsed

\begin_layout Plain Layout
sparse matrices
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
preconditioners
\end_layout

\end_inset

 (which can be used with @@gflinsolve@@).
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gfprecond('identity') gfprecond('cidentity') gfprecond('diagonal', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 D) gfprecond('ildlt', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M) gfprecond('ilu', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M) gfprecond('ildltt', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 fillin [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 threshold]]) gfprecond('ilut', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 fillin [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tscal
\end_layout

\end_inset

 threshold]]) gfprecond('superlu', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The preconditioners may store REAL or COMPLEX values.
 They accept getfem sparse matrices and Scilab sparse matrices.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('identity')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a REAL identity precondioner.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('cidentity')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a COMPLEX identity precondioner.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('diagonal', @dcvec D)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a diagonal precondioner.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('ildlt', M)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create an ILDLT (Cholesky) preconditioner for the (symmetric) sparse
 matrix @@M@@.
 This preconditioner has the same sparsity pattern than @@M@@ (no fill-in).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('ilu', M)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create an ILU (Incomplete LU) preconditioner for the sparse matrix @@M@@.
 This preconditioner has the same sparsity pattern than @@M@@ (no fill-in).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('ildlt', M [, fillin [, threshold]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create an ILDLT (Cholesky with filling) preconditioner for the (symmetric)
 sparse matrix @@M@@.
 The preconditioner may add at most @@fillin@@ additional non-zero entries
 on each line.
 The default value for @@fillin@@ is 10, and the default threshold is @@1e-7@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('ilut', M [, fillin [, threshold]])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create an ILUT (Incomplete LU with filling) preconditioner for the sparse
 matrix @@M@@.
 The preconditioner may add at most @@fillin@@ additional non-zero entries
 on each line.
 The default value for @@fillin@@ is 10, and the default threshold is @@1e-7@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecond('superlu', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : uses 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
SuperLU
\end_layout

\end_inset

 to build an exact factorization of the sparse matrix @@M@@.
 This preconditioner is only available if the getfem-interface was built
 with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
SuperLU
\end_layout

\end_inset

 support.
 Note that LU factorization is likely to eat all your memory for 3D problems.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_linsolve@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection
gf_precondget
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfprecondget
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Apply a precondioner to a vector.
 sparse matrix.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 PV=gfprecondget(P,'mult', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 tPV=gfprecondget(P,'tmult', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 V) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S=gfprecondget(P,'type') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 gfprecondget('size') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 gfprecondget(P,'iscomplex') 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tstr
\end_layout

\end_inset

 S=gfprecondget(P,'info')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecondget(P,'mult', V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : apply the preconditioner to the supplied vector.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecondget(P,'tmult', V)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : apply the transposed preconditioner to the supplied vector.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecondget(P,'type')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a string describing the type of the preconditioner (@@'ilu'@@,
 @@'ildlt'@@,..).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecondget(P,'iscomplex')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return 1 if the preconditioner stores complex values.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gfprecondget(P,'info')@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : return a short informative string about the preconditioner.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_LINSOLVE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_linsolve
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gflinsolve
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Use one of the linear solvers provided by getfem.
 For large linear systems, these solvers with the adequate preconditioner
 are often faster than their Scilab equivalent.
 For small linear systems, the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
SuperLU
\end_layout

\end_inset

 solver is also typically faster than the Scilab 
\begin_inset Quotes eld
\end_inset

slash
\begin_inset Quotes erd
\end_inset

 operator.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@gflinsolve('gmres', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 b [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tint
\end_layout

\end_inset

 restart=50][, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tprecond
\end_layout

\end_inset

 P][, 'noisy'][,'res', r][,'maxiter', n]) gflinsolve('cg', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 b [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tprecond
\end_layout

\end_inset

 P][, 'noisy'][,'res', r][,'maxiter', n]) gflinsolve('bicgstab', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 b [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tprecond
\end_layout

\end_inset

 P][, 'noisy'][,'res', r][,'maxiter', n]) [U,cond] = gflinsolve('lu'|'superlu',
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tspmat
\end_layout

\end_inset

 M, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tvec
\end_layout

\end_inset

 b [, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tprecond
\end_layout

\end_inset

 P])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gflinsolve('gmres', M, b [, restart][, P])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : solve @@MX=b@@ with the generalized minimum residuals method, using @@P@@
 as a preconditioner.
 The @@restart@@ parameter is the usual gmres max size of the Krylov basis.
 The noisy option will cause the solver to display a message after each
 iteration.
 The @@'res'@@ option can be used to change the default target residual
 value.
 The @@'maxiter'@@ option can be used to change the default maximum number
 of iterations.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gflinsolve('cg', M, b [, P])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : solve @@MX=b@@ with the conjugated gradient method, using @@P@@ as a
 preconditioner.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gflinsolve('bicgstab', M, b [, P])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : solve @@MX=b@@ with the bi-conjugated gradient stabilized method, using
 @@P@@ as a preconditioner.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[U,cond] = gflinsolve('lu', M, b [, P])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 or @@[U,cond] = gflinsolve('superlu', M, b [, P])@@ apply the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
SuperLU
\end_layout

\end_inset

 solver (sparse LU factorization).
 The condition number estimate is returned with the solution.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_SOLVE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_solve
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfsolve
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Solve PDEs.
 
\series bold
THIS FUNCTION IS DEPRECATED, USE THE MODEL BRICKS INSTEAD
\series default
 -- the model bricks are much more powerful and fast, however they act as
 black-boxes, so for now the @@gf_solve@@ function is left in the getfem-interfa
ce, for educational purposes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

@@U[,pde]=gf_solve(pde)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The aim of this function is not to provide a general fast solver for all
 kinds of PDEs, but to serve as an example of use of the previous functions
 (especially assembly routines), and to provide an easy way to solve some
 basic PDEs.
\end_layout

\begin_layout Standard
There are currently three PDEs handled by @@gfsolve@@: 
\end_layout

\begin_layout Itemize
the Laplacian
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Laplacian
\end_layout

\end_inset

: 
\begin_inset Formula $\Div~(a(x)\Grad~u(x))+f=0$
\end_inset

; 
\end_layout

\begin_layout Itemize
the linear elasticity
\begin_inset Index
status collapsed

\begin_layout Plain Layout
linear elasticity
\end_layout

\end_inset

: 
\begin_inset Formula $\Div~\sigma(u)+f=0$
\end_inset

, with 
\begin_inset Formula $\sigma_{ij}=\lambda\varepsilon_{\ell\ell}+2\mu\varepsilon_{ij}$
\end_inset

; 
\end_layout

\begin_layout Itemize
and the Stokes equation
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Stokes equation
\end_layout

\end_inset

: 
\begin_inset Formula $\nu\Delta u-\nabla p+f=0.$
\end_inset

 
\end_layout

\begin_layout Standard
The argument @@pde@@ is a structure
\begin_inset Index
status collapsed

\begin_layout Plain Layout
pde structure
\end_layout

\end_inset

 describing the PDE that is to be solved.
 The member @@pde.type@@ can be @@'laplacian'@@, @@'linear elasticity'@@
 or @@'stokes'@@.
 The member @@pde.mfu@@ and @@pde.mfd@@ must be 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 handles to the chosen 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 (if the stokes solver is to be used, then one has to set also @@pde.mfp@@,
 for the pressure).
\end_layout

\begin_layout Standard
The coefficient (dependent of the PDE) must also be set.
 For the Laplacian, it is @@pde.lambda@@.
 For the linear elasticity, it is @@pde.lambda@@ and @@pde.mu@@ (Lam
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

é
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 coefficients).
 For Stokes, it is @@pde.viscos@@.
\end_layout

\begin_layout Standard
These coefficients can be expressed in various forms: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 pde.viscos = { 1 }; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% constant coefficient
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.viscos = { 'x.2+y.2' } 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% string expression
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

f=inline('x.2+y.2'); pde.viscos = { @f } 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% function handle
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.viscos = ones(1,gfmeshfemget(1,pde.mfd)) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% dof values
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 Note the use of braces, this allows to express non-scalar coefficients
 with heterogeneous expressions such as @@{ 1, 'x.*y' }@@.
\end_layout

\begin_layout Standard
The volumic term must be set in @@pde.F@@.
\end_layout

\begin_layout Standard
If the boundary condition were obtained from 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
pdetool
\end_layout

\end_inset

, one just has to set 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 pde.pdetool.b = b; pde.pdetool.e = e; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 and @@gfsolve@@ will set the boundary numbers itself.
 For the general case, you will have to express the boundary conditions
 yourself, i.e.
 define the boundaries with @@gfmeshset(m,'boundary')@@, and fill the array
 pde.bound.
\end_layout

\begin_layout Standard
For example, if the @@Qdim@@
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Qdim
\end_layout

\end_inset

 of @@mfu@@ is equal to 2, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Dirichlet condition HU=R on the boundary number 1
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.bound(1).type = 'Dirichlet'; pde.bound(1).R = { 0, 0 }; pde.bound(1).H = {
 1, 0; 0, 1 } 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% optional, if not set H will be eye(Qdim)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Neumann condition (+optional boundary mass matrix) on the boundary number
 2
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.bound(1).type = 'Neumann'; pde.bound(1).G = { 0,0 }; pde.bound(1).Q = { 1,
 0; 0, 1 } 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% optional, if not set Q will be zeros(Qdim)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% Mixed condition
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.bound(1).type = 'Mixed'; pde.bound(1).R = { 'x', 0 }; pde.bound(1).H = { 1,
 1; 0, 0 } 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% hence we impose $u_x+u_y=x$
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.bound(1).G = { 0, 1 } 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On output, the solution of the pde is returned, an the pde structure can
 also been returned (filled with assembled matrices and vectors in its field
 @@pde.asm@@).
 Note that if this structure is passed again as an argument to @@gfsolve@@,
 nothing will be computed, since @@gfsolve@@ does the assembly of elements
 which are not found in the structure @@pde.asm@@.
\end_layout

\begin_layout Standard
The solver itself is (for the moment) the slash operator of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 (i.e.
 LU-factorization), except for the stokes problem where a conjugate gradient
 is used for the pressure.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 Solving the stokes equation, using boundary condition and mesh from the
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
pdetool
\end_layout

\end_inset

: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 pde.type = 'stokes'; pde.viscos=1.0; pde.pdetool.b = b; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% b and e were exported from the pdetool
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.pdetool.e = e; pde.F = { 0, 0 }; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% volumic source term
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

m=gf_mesh('pt2D',p,t); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% mesh creation from the p and t arrays exported by 
\backslash
pdetool
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.mf_u=gf_mesh_fem(m,2); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the displacement u is a vector field
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.mf_p=gf_mesh_fem(m,1); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the pressure is a scalar field
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

pde.mf_d=gf_mesh_fem(m,2); pde.mim=gf_mesh_im(m, gf_integ('IM_EXACT_SIMPLEX(2)'));
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% we set the FEMs
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

gf_mesh_fem_set(pde.mf_u,'fem',gf_fem('FEM_PK(2,3)')); gf_mesh_fem_set(pde.mf_d,'f
em',gf_fem('FEM_PK(2,3)')); gf_mesh_fem_set(pde.mf_p,'fem',gf_fem('FEM_PK_DISCONT
INUOUS(2,1)'));
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% and now we let the solver do its job
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

[U,P]=gf_solve(pde); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_asm@@, introduction Laplacian example 
\begin_inset CommandInset ref
LatexCommand ref
reference "laplacianexample"

\end_inset

.
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
hlnk{laplacianexample}{introduction Laplacian example}.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF
\backslash
_COMPUTE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_compute
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfcompute
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Various computations involving the solution U of the finite element problem.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@N = gf_compute(mf, U, 'L2 norm', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) N = gf_compute(mf, U, 'H1 semi norm', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM [,CVLST]) N = gf_compute(mf, U, 'H1 norm', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) N = gf_compute(mf, U, 'H2 semi norm', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM [,CVLST]) N = gf_compute(mf, U, 'H2 norm', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM [,
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tivec
\end_layout

\end_inset

 CVLST]) DU = gf_compute(mf, U, 'gradient', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfgrad) D2U = gf_compute(mf, U, 'hessian', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mfhess) U2 = gf_compute(mf, U, 'interpolate on', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf2) U2 = gf_compute(mf, U, 'interpolate on', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 sl) [U2[,mf2,[,X[,Y[,Z]]]]] = gf_compute(mf,U,'interpolate on Q1 grid',
 {'regular h', hxyz | 'regular N',Nxyz | X[,Y[,Z]]}) U2 = gf_compute(mf,
 U, 'extrapolate on', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 mf2) E = gf_compute(mf, U, 'error estimate', 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmim
\end_layout

\end_inset

 MIM) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The first two arguments of this function are always @@mf@@ and @@U@@, where
 @@U@@ is a field defined on the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

@@mf@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_compute(mf, U, 'L2 norm', mim, [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
norm
\end_layout

\end_inset

 compute the 
\begin_inset Formula $L^{2}$
\end_inset

 norm of @@U@@.
 If @@CVLST@@ is indicated, the norm will be computed only on the listed
 convexes.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_compute(mf, U, 'H1 semi norm', mim [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the 
\begin_inset Formula $L^{2}$
\end_inset

 norm of 
\begin_inset Formula $\nabla@@U@@$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_compute(mf, U, 'H1 norm', mim [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the 
\begin_inset Formula $H^{1}$
\end_inset

 norm of @@U@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_compute(mf, U, 'H2 semi norm', mim, [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the 
\begin_inset Formula $L^{2}$
\end_inset

 norm of 
\begin_inset Formula $\nabla^{2}@@U@@$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@gf_compute(mf, U, 'H2 norm', mim [, CVLST])@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the 
\begin_inset Formula $H^{2}$
\end_inset

 norm of @@U@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@DU=gf_compute(mf, U, 'gradient', mfgrad)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
gradient
\end_layout

\end_inset

 compute the gradient of the field @@U@@ defined on 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

@@mf@@.
 The gradient is interpolated on the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

@@mfgrad@@, and returned in @@DU@@.
 In most of the cases, you should choose a discontinuous FEM of @@mfgrad@@,
 since the derivative of @@U@@ won't be (in the general case) continuous
 across element faces.
 For example, if @@U@@ is defined on a P2 mesh_fem, @@DU@@ should be evaluated
 on a P1-discontinuous 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

.
 @@mf@@ and @@mfgrad@@ should share the same mesh.
 If they also have the same @@Qdim@@, then @@size(DU)==mdim
\begin_inset Formula $\times$
\end_inset

nbdof(mfgrad)@@, where @@mdim@@ is the dimension of the common mesh.
 But if @@qdim(mfgrad)==1@@ and @@qdim(mf) ̃=1@@, then DU is given as a
 3D array of dimensions @@mdim@@
\begin_inset Formula $\times$
\end_inset

@@qdim(mf)@@
\begin_inset Formula $\times$
\end_inset

@@nbdof(MFGRAD)@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@D2U=gf_compute(mf, U, 'hessian', mfhess)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : compute the second derivative of the field @@U@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@U2 = gf_compute(mf, U, 'interpolate on', mf2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
interpolation
\end_layout

\end_inset

 interpolate a field defined on 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

mf on another (lagrangian) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

@@mf2@@.
 If @@mf@@ and @@mf2@@ share the same mesh object, the interpolation will
 be much faster.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@U2 = gf_compute(mf, U, 'interpolate on', sl)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : interpolate a field defined on 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

mf on a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset

 (similar to interpolation on a refined P1-discontinuous mesh).
 This can also be used (with @@gfslice('points')@@) to obtain field values
 at a given set of points.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@[U2[,mf2,[,X[,Y[,Z]]]]] = gf_compute(mf,U, 'interpolate on Q1 grid', {'regular
 h', hxyz | 'regular N',Nxyz | X[,Y[,Z]]})@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : create a cartesian Q1 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset


\begin_inset space \space{}
\end_inset

@@mf2@@ and interpolates @@U@@ on it.
 The returned field @@U2@@ is organized in a matrix such that it can be
 drawn via the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 command @@pcolor@@.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@U2 = gf_compute(mf, U, 'extrapolate on', mf2)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 : 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
extrapolation
\end_layout

\end_inset

 If the mesh of @@mf2@@ is stricly included in the mesh of @@mf@@, this
 function does stricly the same job as @@gf_compute('interpolate on')@@.
 However, if the mesh of @@mf2@@ is not exactly included in @@mf@@ (imagine
 interpolation between a curved refined mesh and a coarse mesh), then values
 which are slightly outside @@mf@@ will be extrapolated.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
sep{
\end_layout

\end_inset

@@E = gf_compute(mf, U, 'error estimate', mim)@@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 can be used to obtain an a posteriori error estimation on each convex of
 the mesh.
 Currently there is only error estimator which is available: for each convex,
 the jump of the normal derivative is integrated on its faces.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 Using the error estimate to refine the worst convexes: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 E=gfcompute(mf, U, 'errorestimate', mim); gfmeshset(m, 'refine', find(E
 < 1e-3)); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_PLOT
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_plot
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfplot
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 General plotting function for 2D and 3D fields.
\begin_inset Index
status collapsed

\begin_layout Plain Layout
plotting
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@[hsurf, hcontour, hquiver, hmesh, hdefmesh]=gfplot(mf,U[, options\SpecialChar \ldots{}
]) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 This function only works (for the moment) with 2D faces.
\end_layout

\begin_layout Standard
The function expects @@U@@ to be a row vector.
 If @@U@@ is a scalar field, then @@gf_plot(mf,U)@@ will fill the mesh with
 colors representing the values of @@U@@.
 If @@U@@ is a vector field, then the default behavior of @@gfplot@@ is
 to draw vectors representing the values of @@U@@.
 The various pairs of 
\begin_inset Quotes eld
\end_inset

option name
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes eld
\end_inset

option value
\begin_inset Quotes erd
\end_inset

 that can be used are:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="19" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="none" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'zplot',{'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
values of @@U@@ are mapped on the 
\begin_inset Formula $z$
\end_inset

-axis (only possible when qdim=1, mdim=2)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'norm', {'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if qdim 
\begin_inset Formula $\geq2$
\end_inset

, color-plot the norm of the field.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'dir',[] @@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if qdim 
\begin_inset Formula $\geq2$
\end_inset

, color-plot the scalar product of the field with @@dir@@ (@@dir@@ can be
 a vector, or @@'x'@@, @@'y'@@, etc..)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'refine',8@@
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of refinements for curved edges and surface plots.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'interpolated',{'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if the color of triangular patches is interpolated between vertices, or
 flat.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'pcolor',{'on' | 'off'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if the field is scalar, a color plot of its values is plotted.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'quiver',{'on' | 'off'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if the field is vector, enable arrows plot.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'quiverdensity',50@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
specify the density of arrows in quiver plots.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'quiverscale',1.0@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
specify the scaling of arrows (0
\begin_inset Formula $\Rightarrow$
\end_inset

scaling disabled).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'mesh',{'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
show the mesh ?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshopts',{cell(0)}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cell array of options passed to @@gfplotslice@@ for the mesh visualization
 (you may prefer to use @@hold on@@ and call explicitly @@gfplotslice@@
 or @@gfplotmesh@@).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'deformedmesh', {'off'|'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
shows the deformed mesh (only possible when qdim == mdim).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'deformedmeshopts', {cell(0)}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cell array of options passed to @@gfplotslice@@ for the deformed mesh.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'deformation',[]@@
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if non-empty, enables the plot on the deformed object.
 The option argument is used as the deformation field.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'deformationmf',[] @@
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
specify the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 on which the deformation field is defined.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'deformationscale','10%'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
indicate the amplitude of the deformation.
 Can be a percentage of the mesh width if given as a string, or an absolute
 value if given as a number.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'cvlst',[]@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
list of convexes to plot (empty 
\begin_inset Formula $\Rightarrow$
\end_inset

 all convexes).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'title',[] @@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
set the title.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'contour',[] @@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
list of contour values.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
For example, plotting a scalar field on the border of a 3D mesh can be done
 with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% load the 'strange.mesh_fem' (found in the getfem_scilab/tests directory)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

mf=gfmeshfem('load', 'strange.meshfem') U=rand(1, gfmeshfemget(mf, 'nbdof'));
 # random field that will be drawn gfplot(mf, U, 'refine', 25, 'cvlst',
 gfmeshget(mf,'outer faces'), 'mesh','on'); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_plot_mesh@@, @@gfplotslice@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_PLOT_1D
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_plot1D
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfplot1d
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Simple plotting function for 1D data.
\begin_inset Index
status collapsed

\begin_layout Plain Layout
plotting
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@[hline]=gfplot1D(mf,U,...) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 This function will plot the scalar field associated with a 1D 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The options are given by pairs 
\begin_inset Quotes eld
\end_inset

option name, option value
\begin_inset Quotes erd
\end_inset

: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="none" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'style','bo-'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the line style and dof marker style (same syntax as in the scilab command
 
\begin_inset Quotes eld
\end_inset

plot
\begin_inset Quotes erd
\end_inset

).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'color', []@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
override the line color.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'dofcolor', [1,0,0]@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
color of the markers for the degrees of freedom.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'width', 2@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
line width.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gf_plot@@, @@gfplotslice@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_PLOT_MESH
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_plot_mesh
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfplotmesh
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Mesh plotting function.
\begin_inset Index
status collapsed

\begin_layout Plain Layout
plotting mesh
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@[hmesh,hbound,hfill,hvert,hconv,hdof]=gfplotmesh(M, \SpecialChar \ldots{}
) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 The various options are expected as a list pair 
\begin_inset Quotes eld
\end_inset

option name
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes eld
\end_inset

option value
\begin_inset Quotes erd
\end_inset

.
 These options are: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="2">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="none" valignment="top" width="50text%">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'vertices', {'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
displays also vertices numbers.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'convexes', {'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
displays also convexes numbers.
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'dof',{'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
displays also finite element nodes.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'boundaries',blst@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
displays the boundaries listed in @@blst@@.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'cvlst',cvlst@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
display only the listed convexes.
 If @@cvlst@@ has two rows, display only the faces listed in the second
 row.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'edges', {'on' | 'off'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
display edges ?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'faces',{'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
fills each 2D-face of the mesh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'curved',{'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
displays curved edges (useful for quadratic meshes)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'refine',N@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
refine curved edges and filled faces @@N@@ times 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'deformation', Udef@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
optional deformation applied to the mesh (@@M@@ must be a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tmf
\end_layout

\end_inset

 object)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'edgescolor',[.6 .6 1]@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RGB values for the color of edges
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'edgeswidth',1@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'facescolor',[.75 .75 .75])@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RGB values for the color of faces
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'quality', {'off' | 'on'}@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
show the quality of the mesh
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
This function can be used with any mesh in any dimension (except if the
 @@'faces'@@ options is turned on).
\end_layout

\begin_layout Standard
On output, this function returns the handles to the various graphical objects
 created: @@hmesh@@ is the handles to the mesh lines, @@hbound@@ is the
 handles to the edges of the boundaries, @@hfill@@ is the handle of the
 patch objects of faces, @@hvert@@ (resp @@hconv@@,@@hdof@@) is the handles
 of the vertices (resp.
 convexes, dof) labels.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 Displaying a donut 
\begin_inset Index
status collapsed

\begin_layout Plain Layout
donut
\end_layout

\end_inset

 (meshed with quadratic tetrahedrons) created with 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://gid.cimne.upc.es
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

GiD
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% the mesh is in the tests directory of the distribution
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

m=gfmesh('import','gid','donutwithquadratictetra314elements.msh'); gfplotmesh(m,'
refine',15,'cvlst',gfmeshget(m,'outer faces'),'faces','on',\SpecialChar \ldots{}
 'facescolor',[1.
 .9 .2],'curved','on','edgeswidth',2); camlight 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% turn on the light!
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Graphics
	filename donut.png
	width 6cm

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlimg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

donutsmall.png
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

a donut
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

 you can notice that the mesh has a small default on some elements.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
kwl{
\end_layout

\end_inset

gfplot
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

gf_plot
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%%%%%%%%%%%%%%%%%%%%%%% GF_PLOT_SLICE
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
gf_plot_slice
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfplotslice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 Plots a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slc
\end_layout

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
plotting slice
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{purpose}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{synopsis}
\end_layout

\end_inset

 @@[hfaces, htube, hquiver, hmesh]=gfplotslice(
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
tslc
\end_layout

\end_inset

 sl, \SpecialChar \ldots{}
) @@
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{synopsis}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmddescription}
\end_layout

\end_inset

 This function can be used to plot mesh slices.
 It is also used by the @@gfplotmesh@@ and @@gfplot@@ functions.
 The various options are expected as a list pair 
\begin_inset Quotes eld
\end_inset

option name
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes eld
\end_inset

option value
\begin_inset Quotes erd
\end_inset

.
 These options are: 
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="3">
<features>
<column alignment="right" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="none" valignment="top" width="50text%">
<row>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'data'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@[]@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
the data to be plotted (expected as a row vector or matrix such that @@size(D,2)
==gfsliceget(sl,'nbpts')@@).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'mesh'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'auto'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'on'@@ 
\begin_inset Formula $\to$
\end_inset

 show the mesh (faces of edges), @@'off'@@ 
\begin_inset Formula $\to$
\end_inset

 ignore mesh.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshedges'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'on'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
show mesh edges ? (ignored if @@'mesh'@@ is off).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshedgescolor'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@[.6 .6 1]@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
color (rgb or color name) of the mesh edges.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshedgeswidth'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@.7@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
width of mesh edges.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshsliceedges'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'on'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
also plot 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

 of the sliced part of the mesh ?
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshsliceedgescolor'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@[.7 0 0]@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshsliceedgeswidth'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@.5@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshfaces'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'off'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if @@'on'@@, fill the mesh faces (otherwise they are transparent).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'meshfacescolor'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@[.75 .75 .75]@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
color of mesh faces (ignored if data is not empty).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'pcolor'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'on'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if the data field is scalar, a color plot of its values is plotted.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'quiver'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'on'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
if the field is vector, represent arrows.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'quiverdensity'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@50@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
density of arrows in quiver plot.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'quiverscale'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@1@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
scaling of arrows in quiver plot.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'tube'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'on'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
use tube plot for 'filar' (1D) parts of the slice.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'tubecolor'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'red'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
color of tubes (ignored if 'data' is not empty and 'pcolor' is on).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'tuberadius'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'0.5%'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
tube radius; you can use a constant, or a percentage (of the mesh size)
 or a vector of nodal values (similar to the data field).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'showoptions'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@@'on'@@ 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
display the list of options before plotting.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
On output, this function returns the handles to the various graphical objects
 created: @@hmesh@@ is the handles to the mesh lines, @@hfaces@@ is the
 handles to 2D faces created (patch objects), @@htube@@ is the handle of
 the tube plot (surface object), @@hquiver@@ is the handle obtained with
 the 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 function @@quiver@@.
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmddescription}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{cmdexamples}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Graphics
	filename cuve3Dstreamlines.png
	width 50text%

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlonly
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlimg
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

cuve3Dstreamlinessmall.png
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

streamlines of the fluid in a tank
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

 
\end_layout

\begin_layout Standard
Consider that you have a 3D 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

 @@mf@@ and a vector field @@U@@ defined on this 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
mf
\end_layout

\end_inset

, solution of the Stokes problem in a tank (see the demo 
\family typewriter
demostokes3Dtankdraw.m
\family default
 in the 
\family typewriter
tests
\family default
 directory).
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{mcode}
\end_layout

\end_inset

 figure; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% slice the mesh with two half spaces, and take the boundary of the resulting
 quarter-cylinder
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

sl=gfslice({'boundary',{'intersection',{'planar',+1,[0;0;0],[0;1;0]},\SpecialChar \ldots{}
 {'planar',
+1,[0;0;0],[1;0;0]}}},m,6); Usl=gfcompute(pde.mfu,U,'interpolate on', sl);
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% interpolate the solution on the slice
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% show the norm of the displacement on this slice
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

gfplotslice(sl,'mesh','on','data',sqrt(sum(Usl.2,1)),'meshsliceedges','off');
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% another slice: now we take the lower part of the mesh
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

sl=gfslice({'boundary',{'intersection',{'planar',+1,[0;0;6],[0;0;-1]},\SpecialChar \ldots{}
 {'planar'
,+1,[0;0;0],[0;1;0]}}},m,6); Usl=gfcompute(pde.mfu,U,'interpolate on', sl);
 hold on; gfplotslice(sl,'mesh','on','data',sqrt(sum(Usl.2,1)),'meshsliceedges','
off');
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% this slice contains the transparent mesh faces displayed on the picture
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

sl2=gfslice({'boundary',{'planar',+1,[0;0;0],[0;1;0]}},\SpecialChar \ldots{}
 m,6,setdiff(allfaces',TO
Pfaces','rows')'); gfplotslice(sl2,'meshfaces','off','mesh','on','pcolor','off')
;
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% last step is to plot the streamlines
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

hh=[1 5 9 12.5 16 19.5]; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% vertical position of the different starting points of the streamlines
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

H=[zeros(2,numel(hh));hh];
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% compute the streamlines
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

tsl=gfslice('streamlines',pde.mfu,U,H); Utsl=gfcompute(pde.mfu,U,'interpolate
 on', tsl);
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% render them with "tube plot"
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

[a,h]=gfplotslice(tsl,'mesh','off','tuberadius',.2,'tubecolor','white');
 hold off; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% use a nice colormap
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

caxis([0 .7]); c=[0 0 1; 0 .5 1; 0 1 .5; 0 1 0; .5 1 0; 1 .5 0; 1 .4 0; 1 0 0;
 1 .2 0; 1 .4 0; 1 .6 0; 1 .8 0]; colormap(c); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{mcode}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{cmdexamples}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{gfseealso}
\end_layout

\end_inset

 @@gfslice@@ 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{gfseealso}
\end_layout

\end_inset

 
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 OO-commands
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "OOcommands"

\end_inset


\end_layout

\begin_layout Standard
The toolbox comes with a set of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Slab
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
WEB{
\end_layout

\end_inset

http://www.mathworks.com/access/helpdesk/help/techdoc/matlabprog/ch14oop.shtml
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

objects
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 (look at the 
\family typewriter
@gf*
\family default
 sub-directories in the toolbox directory).
 These object are no more than the getfem object handles, which are flagged
 by 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 as objects.
\end_layout

\begin_layout Standard
In order to use these objects, you have to call their constructors: @@gfMesh@@,
 @@gfMeshFem@@, @@gfGeoTrans@@, @@gfFem@@, @@gfInteg@@.
 These constructor just call the corresponding 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
gfm
\end_layout

\end_inset

 function (i.e.
 @@gfmesh@@, @@gfmeshfem@@, \SpecialChar \ldots{}
), and convert the structure returned by these
 function into a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 object.
 There is also a 
\family typewriter
gfObject
\family default

\begin_inset Index
status collapsed

\begin_layout Plain Layout
gfObject
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfObject
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 function which converts any getfem handle into the corresponding 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 object.
\end_layout

\begin_layout Standard
With such object, the most interesting feature is that you do not have to
 call the 
\begin_inset Quotes eld
\end_inset

long
\begin_inset Quotes erd
\end_inset

 functions names @@gfmeshfemget(obj,\SpecialChar \ldots{}
)@@, @@gfsliceset(obj,\SpecialChar \ldots{}
)@@ etc., instead
 you just call the shorter @@get(obj,\SpecialChar \ldots{}
)@@ or @@set(obj,\SpecialChar \ldots{}
)@@ whatever the type
 of @@obj@@ is.
\end_layout

\begin_layout Standard
A small number of 
\begin_inset Quotes eld
\end_inset

pseudo-properties
\begin_inset Quotes erd
\end_inset

 are also defined on these objects, for example if @@m@@ is a @@gfMesh@@
 object, you can use directly @@m.nbpts@@ instead of @@get(m, 'nbpts')@@.
\end_layout

\begin_layout Standard
As an example, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% classical creation of a mesh object
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 m=gfmesh('load', 'manyelement.meshfem') m = id: 2 cid: 0 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% conversion to a scilab object.
 the display function is overloaded for gfMesh.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 mm=gfMesh(m) gfMesh object ID=2 [11544 bytes], dim=3, nbpts=40, nbcvs=7
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% direct creation of a gfMesh object.
 Arguments are the same than those of gf_mesh
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 m=gfMesh('load', 'manyelement.meshfem') gfMesh object ID=3 [11544 bytes],
 dim=3, nbpts=40, nbcvs=7 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% get(m, 'pid_from_cvid') is redirected to gf_mesh_get(m,'pid from cvid')
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 get(m, 'pidfromcvid', 3) ans = 8 9 11 15 17 16 18 10 12 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% m.nbpts is directly translated into gf_mesh_get(m,'nbpts')   
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 m.nbpts ans = 40
\end_layout

\begin_layout Standard
\begin_inset Quotes ald
\end_inset

 mf=gfMeshFem('load','manyelement.meshfem') gfMeshFem object: ID=5 [1600
 bytes], qdim=1, nbdof=99, linked gfMesh object: dim=3, nbpts=40, nbcvs=7
 
\begin_inset Quotes ald
\end_inset

 mf.mesh gfMesh object ID=4 [11544 bytes], dim=3, nbpts=40, nbcvs=7 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% accessing the linked mesh object
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 mf.mesh.nbpts ans = 40 
\begin_inset Quotes ald
\end_inset

 get(mf.mesh, 'pidfromcvid', 3) ans = 8 9 11 15 17 16 18 10 12
\end_layout

\begin_layout Standard
\begin_inset Quotes ald
\end_inset

 mf.nbdof ans = 99
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% access to fem of convex 1
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset Quotes ald
\end_inset

 mf.fem(2) gfFem object ID=0 dim=2, targetdim=1, nbdof=9,[EQUIV, POLY, LAGR],
 est.degree=4 -> FEMQK(2,2) 
\begin_inset Quotes ald
\end_inset

 mf.mesh.geotrans(1) gfGeoTrans object ID= 0 dim=2, nbpts= 6 : GTPK(2,2) 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although this interface seems more convenient, you must be aware that this
 always induce a call to a mex-file, and additional 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 code: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{scilab}
\end_layout

\end_inset

 
\begin_inset Quotes ald
\end_inset

 tic; j=0; for i=1:1000, j=j+mf.nbdof; end; toc elapsedtime = 0.6060 
\begin_inset Quotes ald
\end_inset

 tic; j=0; for i=1:1000, j=j+gfmeshfemget(mf,'nbdof'); end; toc elapsedtime
 = 0.1698 
\begin_inset Quotes ald
\end_inset

 tic; j=0;n=mf.nbdof; for i=1:1000, j=j+n; end; toc elapsedtime = 0.0088 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{scilab}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hence you should always try to store data in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
slab
\end_layout

\end_inset

 arrays instead of repetitively calling the getfem functions.
\end_layout

\begin_layout Standard
Avalaible object types are 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfCvStruct
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfCvStruct, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfGeoTrans
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfGeoTrans, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfEltm
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfEltm, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfInteg
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfInteg, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfFem
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfFem, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfMesh
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfMesh, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfMeshFem
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfMeshFem, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfMeshIm
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfMeshIm, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfMdBrick
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfMdBrick, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfMdState
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfMdState, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfModel
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfModel, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfSpmat
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfSpmat, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfPrecond
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

gfPrecond, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
hypertarget{
\end_layout

\end_inset

gfSlice
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

and gfSlice.
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
section{Various problems}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
item ill conditioned system: check the eigenvalues on a small mesh.
 Check that the integration method is precise enough (or exact).
 Check your boundary conditions.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
W
\end_layout

\end_inset

 
\end_layout

\begin_layout Section*
Index
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
htmlonly{
\backslash
HlxSection{-5}{}*{
\backslash
indexname}
\backslash
label{gfmindex}}%
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
texorhtml
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset include
LatexCommand input
filename "gfm.ind"

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "gfmindex"

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
htmlprintindex
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 
\end_layout

\end_body
\end_document
