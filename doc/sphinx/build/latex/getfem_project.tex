%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



% begin user_preamble:
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amssymb}
% end user_preamble


\title{Description of the Project}
\date{Dec 24, 2020}
\release{5.4.1}
\author{Yves Renard, Julien Pommier, Konstantinos Poulios}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{logogetfem.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{project/index::doc}}



\chapter{Introduction}
\label{\detokenize{project/intro:introduction}}\label{\detokenize{project/intro:dp-intro}}\label{\detokenize{project/intro::doc}}
The aim of this document is to report details of the internal of \sphinxstyleemphasis{GetFEM}
useful for developers that have no place in the user documentation.
It is also to outline the main prospects for the future development
of \sphinxstyleemphasis{GetFEM}. A list of modifications to be done and main tasks is updated
on Savannah \sphinxhref{https://savannah.nongnu.org/task/?group=getfem}{\sphinxurl{https://savannah.nongnu.org/task/?group=getfem}}.

The \sphinxstyleemphasis{GetFEM} project focuses on the development of an open source generic
finite element library.
The goal is to provide a finite element framework which allows to
easily build numerical code for the modelisation of system described
by partial differential equations (p.d.e.). A special attention is paid
to the flexibility of the use of the library in the sense that the
switch from a method offered by the library to another is made as easy
as possible.

The major point allowing this, compared to traditional finite element
codes, is the complete separation between the description of p.d.e.
models and finite element methods. Moreover, a separation is made
between integration methods (exact or approximated), geometric
transformations (linear or not) and finite element methods of
arbitrary degrees described on a reference element. \sphinxstyleemphasis{GetFEM} can
be used to build very general finite elements codes, where the
finite elements, integration methods, dimension of the meshes,
are just some parameters that can
be changed very easily, thus allowing a large spectrum of experimentations.
Numerous examples are available in the \sphinxcode{\sphinxupquote{tests}} directory of the
distribution.

The goal is also to make the addition of new finite element method
as simple as possible. For standard method, a description of the
finite element shape functions and the type of connection of degrees
of freedom on the reference element is sufficient. Extensions are
provided for Hermite elements, piecewise polynomial, non\sphinxhyphen{}polynomial,
vectorial elements and XFem. Examples of predefined
available methods are \(P_k\) on simplices in arbitrary degrees and
dimensions, \(Q_k\) on parallelepipeds, \(P_1\), \(P_2\)
with bubble functions, Hermite elements, elements with hierarchic
basis (for multigrid methods for instance),
discontinuous \(P_k\) or \(Q_k\), XFem, Argyris, HCT, Raviart\sphinxhyphen{}Thomas.

The library also includes the usual tools for finite elements such as assembly
procedures for classical PDEs, interpolation methods, computation of norms,
mesh operations, boundary conditions, post\sphinxhyphen{}processing tools such as
extraction of slices from a mesh …

The aim of the \sphinxstyleemphasis{GetFEM} project is not to provide a ready to use
finite element code allowing for instance structural mechanics
computations with a graphic interface. It is basically a library
allowing the build of C++  finite element codes.
However, the Python, Scilab and matlab interfaces allows to easily build application
coupling the definition of the problem, the finite element methods
selection and the graphical post\sphinxhyphen{}processing.

Copyright © 2004\sphinxhyphen{}2020 \sphinxstyleemphasis{GetFEM} project.

The text of the \sphinxstyleemphasis{GetFEM} website and the documentations are available for modification and reuse under the terms of the \sphinxhref{http://www.gnu.org/licenses/fdl.html}{GNU Free Documentation License}

GetFEM  is  free software;  you  can  redistribute  it  and/or modify it
under  the  terms  of the  GNU  Lesser General Public License as published
by  the  Free Software Foundation;  either version 3 of the License,  or
(at your option) any later version along with the GCC Runtime Library
Exception either version 3.1 or (at your option) any later version.
This program  is  distributed  in  the  hope  that it will be useful,  but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or  FITNESS  FOR  A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License and GCC Runtime Library Exception for more details.
You  should  have received a copy of the GNU Lesser General Public License
along  with  this program;  if not, write to the Free Software Foundation,
Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110\sphinxhyphen{}1301, USA.


\chapter{How to contribute / Git repository on Savannah}
\label{\detokenize{project/contribute:how-to-contribute-git-repository-on-savannah}}\label{\detokenize{project/contribute:dp-contribute}}\label{\detokenize{project/contribute::doc}}
\sphinxstyleemphasis{GetFEM} is an  open source finite element library based on a collaborative development. If you intend to make some contributions, you can ask for membership of the project there. Contributions of all kinds are welcome: documentation, bug reports, constructive comments, changes suggestions, bug fix, new models, etc …

Contributors are of course required to be careful that their changes do not affect the proper functioning of the library and that these changes follow a principle of backward compatibility.

See \sphinxhref{https://savannah.nongnu.org/task/?group=getfem}{here} for a list of task and discussions about \sphinxstyleemphasis{GetFEM} development.

\sphinxstylestrong{IMPORTANT} : a contributor implicitly accepts that his/her contribution will be distributed under the LGPL licence of \sphinxstyleemphasis{GetFEM}.

The main repository of \sphinxstyleemphasis{GetFEM} is on Savannah, the software forge of the Free Software Foundation (see \sphinxhref{https://savannah.gnu.org}{Savannah}). The page of the project on Savannah is \sphinxhref{https://savannah.nongnu.org/projects/getfem}{Getfem on Savannah}. See also \sphinxhref{http://git.savannah.nongnu.org/gitweb/?p=getfem.git;a=tree}{Getfem sources on Savannah}.


\section{How to get the sources}
\label{\detokenize{project/contribute:how-to-get-the-sources}}
If you just want the sources and do not intend to make some contributions, you can just use the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone https://git.savannah.nongnu.org/git/getfem.git
\end{sphinxVerbatim}

If you intend to make some contributions, the first step is to ask for the inclusion in the \sphinxstyleemphasis{GetFEM} project (for this you have to create a Savannah account). You have also to register a ssh key (see \sphinxhref{http://savannah.gnu.org/maintenance/UsingGit/}{git on Savannah}) and then use the command

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone ssh://savannah\PYGZhy{}login@git.sv.gnu.org:/srv/git/getfem.git
\end{sphinxVerbatim}


\section{How to contribute}
\label{\detokenize{project/contribute:how-to-contribute}}
Before modifying any file, you have to create a \sphinxstyleemphasis{development branch} because it is \sphinxstyleemphasis{not allowed to make a modification directly in the master branch}. It is recommended that the branch name is of the type \sphinxtitleref{devel\sphinxhyphen{}name\sphinxhyphen{}subject} where name is your name or login and subject the main subject of the changes. For instance, if you chose \sphinxtitleref{devel\sphinxhyphen{}me\sphinxhyphen{}rewrite\sphinxhyphen{}fem\sphinxhyphen{}kernel} as the branch name, the creation of the branch reads

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git branch devel\PYGZhy{}me\PYGZhy{}rewrite\PYGZhy{}fem\PYGZhy{}kernel
git checkout devel\PYGZhy{}me\PYGZhy{}rewrite\PYGZhy{}fem\PYGZhy{}kernel
\end{sphinxVerbatim}

The first command create the branch and the second one position you on your branch. After that you are nearly ready to makes some modifications. You can specify your contact name and e\sphinxhyphen{}mail with the following commands in order to label your changes

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git config \PYGZhy{}\PYGZhy{}global user.name \PYGZdq{}Your Name Comes Here\PYGZdq{}
git config \PYGZhy{}\PYGZhy{}global user.email you@yourdomain.example.com
\end{sphinxVerbatim}


\section{Specific branch for doc improvements and typo\sphinxhyphen{}fixes}
\label{\detokenize{project/contribute:specific-branch-for-doc-improvements-and-typo-fixes}}
If you want to contribute to the documentation only, it is not necessary to build a specific branch. You can just checkout to the \sphinxcode{\sphinxupquote{fixmisspell}} branch which has been created for this purpose with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git checkout fixmisspell
\end{sphinxVerbatim}


\section{Locally commit your changes}
\label{\detokenize{project/contribute:locally-commit-your-changes}}
Once you made some modifications of a file or you added a new file, say \sphinxtitleref{src/toto.cc}, the local commit is done with the commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git add src/toto.cc
git commit \PYGZhy{}m \PYGZdq{}Your extensive commit message here\PYGZdq{}
\end{sphinxVerbatim}

At this stage the commit is done on your local repository but not in the Savannah one.


\section{Push you changes in the Savannah repository}
\label{\detokenize{project/contribute:push-you-changes-in-the-savannah-repository}}
You can now transfer your modifications to the Savannah repository with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git push origin devel\PYGZhy{}me\PYGZhy{}rewrite\PYGZhy{}fem\PYGZhy{}kernel
\end{sphinxVerbatim}

where of course \sphinxstyleemphasis{devel\sphinxhyphen{}me\sphinxhyphen{}rewrite\sphinxhyphen{}fem\sphinxhyphen{}kernel} is still the name of your branch. At this stage your modifications are registered in the branch \sphinxstyleemphasis{devel\sphinxhyphen{}me\sphinxhyphen{}rewrite\sphinxhyphen{}fem\sphinxhyphen{}kernel} of Savannah repository.
Your role stops here, since you are not allowed to modify the master branch of \sphinxstyleemphasis{GetFEM}.


\section{Ask for an admin to merge your modifications to the master branch of \sphinxstyleemphasis{GetFEM}}
\label{\detokenize{project/contribute:ask-for-an-admin-to-merge-your-modifications-to-the-master-branch-of-gf}}
Once you validated your modifications with sufficient tests, you can ask an admin of \sphinxstyleemphasis{GetFEM} to merge your modifications. For this, contact one of them directly, or send an e\sphinxhyphen{}mail to \sphinxstyleemphasis{getfem\sphinxhyphen{}commits@nongnu.org} with the message : “please merge branch devel\sphinxhyphen{}me\sphinxhyphen{}rewrite\sphinxhyphen{}fem\sphinxhyphen{}kernel” with eventually a short description of the modifications. IMPORTANT : by default, your branch will be deleted after the merge, unless you express the need to keep it.


\section{Merge modifications done by other contributors}
\label{\detokenize{project/contribute:merge-modifications-done-by-other-contributors}}
You can run a

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git pull origin master
git merge master
\end{sphinxVerbatim}

in order to integrate the modifications which has been validated and integrated to the master branch. This is recommended to run this command before any request for integration of a modification in the master branch.


\section{Some useful git commands}
\label{\detokenize{project/contribute:some-useful-git-commands}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
git status  : status of your repository / branch

git log \PYGZhy{}\PYGZhy{}follow \PYGZdq{}filepath\PYGZdq{}   : Show all the commits modifying the specified file (and follow the eventual change of name of the file).

gitk \PYGZhy{}\PYGZhy{}follow filename : same as previous but with a graphical interface
\end{sphinxVerbatim}


\section{Contributing to document translation}
\label{\detokenize{project/contribute:contributing-to-document-translation}}
The recommended way for new contributors to translate document is to join \sphinxhref{https://www.transifex.com/getfem-doc}{Getfem translation team on Transifex} . For contribution, please make account in \sphinxhref{https://www.transifex.com}{transifex} and click request language and fill form . After translation, pull translated po file from site by using transifex\sphinxhyphen{}client. You need api token which you can get in transifex site.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd doc/sphinx
tx pull \PYGZhy{}l \PYGZlt{}lang\PYGZgt{}
\end{sphinxVerbatim}

Set code for your native language to \textless{}lang\textgreater{} (see \sphinxhref{https://www.sphinx-doc.org/en/latest/usage/configuration.html\#confval-language}{Currently supported languages by Sphinx are} ).

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxstylestrong{DO NOT} tx push to transifex. It will have some trouble. You can upload file one by one in team page.
\end{sphinxadmonition}

After pulling translated po files, set \textless{}lang\textgreater{} to LANGUAGE in \sphinxtitleref{doc/sphinx/Makefile.am} .

\begin{sphinxVerbatim}[commandchars=\\\{\}]
LANGUAGE      = \PYGZlt{}lang\PYGZgt{}
SPHINXOPTS    = \PYGZhy{}D language=\PYGZdl{}(LANGUAGE)
\end{sphinxVerbatim}

Then, you can run a following commands in order to make html localization document.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cd doc/sphinx
make html
\end{sphinxVerbatim}

If you want to make pdf file in your language, you can run a

\begin{sphinxVerbatim}[commandchars=\\\{\}]
make latex
cd build/latex
make all\PYGZhy{}pdf\PYGZhy{}\PYGZlt{}lang\PYGZgt{}
\end{sphinxVerbatim}

See details in \sphinxhref{http://www.sphinx-doc.org/en/stable/intl.html}{Sphinx Internationalization} .

You can see translated document at \sphinxhref{https://getfem.readthedocs.io}{Read the Docs} by switch language.


\chapter{The FEM description in \sphinxstyleemphasis{GetFEM}}
\label{\detokenize{project/femdesc:the-fem-description-in-gf}}\label{\detokenize{project/femdesc:dp-femdesc}}\label{\detokenize{project/femdesc::doc}}
The aim of this section is to briefly introduce the FEM description in \sphinxstyleemphasis{GetFEM}
mainly in order to fix the notation used in the rest of the document (definition
of element, reference element, geometric transformation, gradient of the
geometric transformation …).


\section{Convex structures}
\label{\detokenize{project/femdesc:convex-structures}}
Finite element methods are defined on small convex domains called elements. The
simplest element on which a finite element method can be defined is a segment
(simplex of dimension 1), other possibilities are triangles, tetrahedrons
(simplices of dimension 2 and 3), prisms, parallelepiped, etc. In \sphinxstyleemphasis{GetFEM}, a type of
element (for us, a convex) is described by the object \sphinxcode{\sphinxupquote{bgeot::convex\_structure}} defined in the file
\sphinxcode{\sphinxupquote{bgeot\_convex\_structure.h}}.

It describes only the structure of the convex not the coordinates of the
vertices. This structure is not to be manipulated by itself, because it is not
necessary that more than one structure of this type describe the same type of
convex. What will be manipulated is a pointer on such a descriptor which has to
be declared with the type \sphinxcode{\sphinxupquote{bgeot::pconvex\_structure}}

The following functions give a pointer onto the descriptor of the usual type of
elements:
\index{bgeot::simplex\_structure (C++ function)@\spxentry{bgeot::simplex\_structure}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot17simplex_structureE8dim_type}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{simplex\_structure}}}{dim\_type \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
description of a simplex of dimension \sphinxcode{\sphinxupquote{d}}.

\end{fulllineitems}

\index{bgeot::parallelepiped\_structure (C++ function)@\spxentry{bgeot::parallelepiped\_structure}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot24parallelepiped_structureE8dim_type}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{parallelepiped\_structure}}}{dim\_type \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
description of a parallelepiped of dimension \sphinxcode{\sphinxupquote{d}}.

\end{fulllineitems}

\index{bgeot::convex\_product\_structure (C++ function)@\spxentry{bgeot::convex\_product\_structure}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot24convex_product_structureEN5bgeot17pconvex_structureE17pconvex_structure}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{convex\_product\_structure}}}{bgeot::pconvex\_structure \sphinxstyleemphasis{p1}, pconvex\_structure \sphinxstyleemphasis{p2}}{}%
\pysigstopmultiline
description of the direct product of \sphinxcode{\sphinxupquote{p1}} and \sphinxcode{\sphinxupquote{p2}}.

\end{fulllineitems}

\index{bgeot::prism\_P1\_structure (C++ function)@\spxentry{bgeot::prism\_P1\_structure}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot18prism_P1_structureE8dim_type}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{prism\_P1\_structure}}}{dim\_type \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
description of a prism of dimension \sphinxcode{\sphinxupquote{d}}.

\end{fulllineitems}


For instance if one needs the description of a square, one can call
equivalently:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{bgeot}\PYG{o}{:}\PYG{o}{:}\PYG{n}{parallelepiped\PYGZus{}structure}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

or:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p} \PYG{o}{=} \PYG{n}{bgeot}\PYG{o}{:}\PYG{o}{:}\PYG{n}{convex\PYGZus{}product\PYGZus{}structure}\PYG{p}{(}\PYG{n}{bgeot}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simplex\PYGZus{}structure}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}
                                    \PYG{n}{bgeot}\PYG{o}{:}\PYG{o}{:}\PYG{n}{simplex\PYGZus{}structure}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The descriptor contains in particular the number of faces (\sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}nb\_faces()}}),
the dimension of the convex (\sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}dim()}}), for the number of vertices
(\sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}nb\_points()}}). Other information is the number of vertices of each face,
the description of a face and the eventual reference to a more basic description
(used for the description of geometric transformations).

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.6]{{getfemelemelem}.png}
\caption{usual elements}\label{\detokenize{project/femdesc:id1}}\label{\detokenize{project/femdesc:dp-fig-elem}}\end{figure}


\section{Convexes of reference}
\label{\detokenize{project/femdesc:convexes-of-reference}}
A convex of reference is a particular real element, i.e. a structure of convex
with a list of vertices. It describes the particular element from which a finite
element method is defined. In the file \sphinxcode{\sphinxupquote{bgeot\_convex\_ref.h}} the object
\sphinxcode{\sphinxupquote{bgeot::convex\_of\_reference}} makes this description. The library keeps only one description for each
type of convex. So what will be manipulated is a pointer of type \sphinxcode{\sphinxupquote{bgeot::pconvex\_ref}} on the
descriptor.

The following functions build the descriptions:
\index{bgeot::simplex\_of\_reference (C++ function)@\spxentry{bgeot::simplex\_of\_reference}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot20simplex_of_referenceE8dim_type}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{simplex\_of\_reference}}}{dim\_type \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
description of the simplex of reference of dimension \sphinxcode{\sphinxupquote{d}}.

\end{fulllineitems}

\index{bgeot::simplex\_of\_reference (C++ function)@\spxentry{bgeot::simplex\_of\_reference}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot20simplex_of_referenceE8dim_type10short_type}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{simplex\_of\_reference}}}{dim\_type \sphinxstyleemphasis{d}, short\_type \sphinxstyleemphasis{k}}{}%
\pysigstopmultiline
description of the simplex of reference of dimension \sphinxcode{\sphinxupquote{d}} with degree \sphinxcode{\sphinxupquote{k}}
Lagrange grid.

\end{fulllineitems}

\index{bgeot::convex\_ref\_product (C++ function)@\spxentry{bgeot::convex\_ref\_product}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot18convex_ref_productE11pconvex_ref11pconvex_ref}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{convex\_ref\_product}}}{pconvex\_ref \sphinxstyleemphasis{a}, pconvex\_ref \sphinxstyleemphasis{b}}{}%
\pysigstopmultiline
description of the direct product of two convexes of reference.

\end{fulllineitems}

\index{bgeot::parallelepiped\_of\_reference (C++ function)@\spxentry{bgeot::parallelepiped\_of\_reference}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/femdesc:_CPPv4N5bgeot27parallelepiped_of_referenceE8dim_type}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{bgeot\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{parallelepiped\_of\_reference}}}{dim\_type \sphinxstyleemphasis{d}}{}%
\pysigstopmultiline
description of the parallelepiped of reference of dimension \sphinxcode{\sphinxupquote{d}}.

\end{fulllineitems}


The vertices correspond to the classical vertices for such reference element. For
instance the vertices for the triangle are \((0, 0)\), \((1, 0)\) and
\((0, 1)\). It corresponds to the configuration shown in Figure
{\hyperref[\detokenize{project/femdesc:dp-fig-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{usual elements}}}}

If \sphinxcode{\sphinxupquote{p}} is of type \sphinxcode{\sphinxupquote{bgeot::pconvex\_ref}} then \sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}structure()}} is the corresponding convex
structure. Thus for instance \sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}structure()\sphinxhyphen{}\textgreater{}nb\_points()}} gives the number of
vertices. The function \sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}points()}} give the array of vertices and
\sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}points(){[}0{]}}} is the first vertex. The function \sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}is\_in(const base\_node
\&pt)}} return a real which is negative or null if the point \sphinxcode{\sphinxupquote{pt}} is in the
element. The function \sphinxcode{\sphinxupquote{p\sphinxhyphen{}\textgreater{}is\_in\_face(short\_type f, const base\_node \&pt)}} return
a real which is null if the point \sphinxcode{\sphinxupquote{pt}} is in the face \sphinxcode{\sphinxupquote{f}} of the element.
Other functions can be found in \sphinxcode{\sphinxupquote{bgeot\_convex\_ref.h}} and
\sphinxcode{\sphinxupquote{bgeot\_convex.h}}.


\section{Shape function type}
\label{\detokenize{project/femdesc:shape-function-type}}
Most of the time the shape functions of finite element methods are polynomials,
at least on the convex of reference. But, the possibility is given to have other
types of elements. It is possible to define other kind of base functions such as
piecewise polynomials, interpolant wavelets, etc.

To be used by the finite element description, a shape function type must be able
to be evaluated on a point (\sphinxcode{\sphinxupquote{a = F.eval(pt)}}, where \sphinxcode{\sphinxupquote{pt}} is a \sphinxcode{\sphinxupquote{base\_node}})
and must have a method to compute the derivative with respect to the ith variable
(\sphinxcode{\sphinxupquote{F.derivative(i)}}).

For the moment, only polynomials and piecewise polynomials are defined in the
files \sphinxcode{\sphinxupquote{bgeot\_poly.h}} and \sphinxcode{\sphinxupquote{bgeot\_poly\_composite.h}}.


\section{Geometric transformations}
\label{\detokenize{project/femdesc:geometric-transformations}}\label{\detokenize{project/femdesc:dp-transgeo}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.6]{{getfemtransgeo}.png}
\caption{geometric transformation}\label{\detokenize{project/femdesc:id2}}\label{\detokenize{project/femdesc:dp-fig-transgeo}}\end{figure}

A geometric transformation is a polynomial application:
\begin{equation*}
\begin{split}\tau : \widehat{T} \subset \rm I\hspace{-0.15em}R^P \longrightarrow T \subset \rm I\hspace{-0.15em}R^N,\end{split}
\end{equation*}
which maps the reference element \(\widehat{T}\) to the real element \(T\). The
geometric nodes are denoted:
\begin{equation*}
\begin{split}g^i, i = 0, \ldots, n_g - 1.\end{split}
\end{equation*}
The geometric transformation is described thanks to a \(n_g\) components
polynomial vector (In fact, as an extention, non polynomial geometric
transformation can also be supported by \sphinxstyleemphasis{GetFEM}, but this is very rarely used)
\begin{equation*}
\begin{split}{\cal N}(\widehat{x}),\end{split}
\end{equation*}
such that
\begin{equation*}
\begin{split}\tau(\widehat{x}) = \sum_{i = 0}^{n_g - 1}{\cal N}_i(\widehat{x}) g^i.\end{split}
\end{equation*}
Denoting
\begin{equation*}
\begin{split}G = (g^0; g^1; ...; g^{n_g - 1}),\end{split}
\end{equation*}
the \(N\times n_g\) matrix containing of all the geometric nodes, one has
\begin{equation*}
\begin{split}\fbox{$\tau(\widehat{x}) = G\cdot{\cal N}(\widehat{x})$.}\end{split}
\end{equation*}
The derivative of \(\tau\) is then
\begin{equation*}
\begin{split}\fbox{$K(\widehat{x}) := \nabla\tau(\widehat{x}) = G\cdot\nabla {\cal N}(\widehat{x})$,}\end{split}
\end{equation*}
where \(K(\widehat{x}) = \nabla\tau(\widehat{x})\) is a \(N\times P\) matrix and
\(\nabla {\cal N}(\widehat{x})\) a \(n_g\times P\) matrix. The (transposed)
pseudo\sphinxhyphen{}inverse of \(\nabla\tau(\widehat{x})\) is a \(N\times P\) matrix denoted
\(B(\widehat{x})\):
\begin{equation*}
\begin{split}\fbox{$B(\widehat{x}) := K(\widehat{x})(K(\widehat{x})^T K(\widehat{x}))^{-1}$,}\end{split}
\end{equation*}
Of course, when \(P=N\), one has \(B(\widehat{x})=K(\widehat{x})^{-T}\).

Pointers on a descriptor of a geometric transformation can be obtained by the
following function defined in the file \sphinxcode{\sphinxupquote{bgeot\_geometric\_trans.h}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{bgeot}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pgeometric\PYGZus{}trans} \PYG{n}{pgt} \PYG{o}{=} \PYG{n}{bgeot}\PYG{o}{:}\PYG{o}{:}\PYG{n}{geometric\PYGZus{}trans\PYGZus{}descriptor}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name of trans}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where \sphinxcode{\sphinxupquote{"name of trans"}} can be chosen among the following list.
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{"GT\_PK(n,k)"}}

Description of the simplex transformation of dimension \sphinxcode{\sphinxupquote{n}} and degree \sphinxcode{\sphinxupquote{k}}
(Most of the time, the degree 1 is used).

\item {} 
\sphinxcode{\sphinxupquote{"GT\_QK(n,k)"}}

Description of the parallelepiped transformation of dimension \sphinxcode{\sphinxupquote{n}} and degree
\sphinxcode{\sphinxupquote{k}}.

\item {} 
\sphinxcode{\sphinxupquote{"GT\_PRISM(n,k)"}}

Description of the prism transformation of dimension \sphinxcode{\sphinxupquote{n}} and degree \sphinxcode{\sphinxupquote{k}}.

\item {} 
\sphinxcode{\sphinxupquote{"GT\_PRODUCT(a,b)"}}

Description of the direct product of the two transformations \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}.

\item {} 
\sphinxcode{\sphinxupquote{"GT\_LINEAR\_PRODUCT(a,b)"}}

Description of the direct product of the two transformations \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}
keeping a linear transformation (this is a restriction of the previous
function). This allows, for instance, to use exact integrations on regular
meshes with parallelograms.

\end{itemize}


\section{Finite element methods description}
\label{\detokenize{project/femdesc:finite-element-methods-description}}
A finite element method is defined on a reference element
\(\widehat{T}\subset\rm I\hspace{-0.15em}R^P\) by a set of \(n_d\) nodes \(a^i\) and
corresponding base functions
\begin{equation*}
\begin{split}(\widehat{\varphi})^i : \widehat{T}\subset\rm I\hspace{-0.15em}R^P \longrightarrow \rm I\hspace{-0.15em}R^Q\end{split}
\end{equation*}
Denoting
\begin{equation*}
\begin{split}\psi^i(x) = (\widehat{\varphi})^i(\widehat{x}) = (\widehat{\varphi})^i(\tau^{-1}(x)),\end{split}
\end{equation*}
a supplementary linear transformation is allowed for the real base function
\begin{equation*}
\begin{split}\varphi^i(x) = \sum_{j = 0}^{n_d - 1} M_{ij} \psi^j(x),\end{split}
\end{equation*}
where \(M\) is a \(n_d \times n_d\) matrix possibly depending on the
geometric transformation (i.e. on the real element). For basic elements as
Lagrange elements this matrix is the identity matrix (it is simply ignored). In
this case, we will say that the element is \(\tau\)\sphinxhyphen{}equivalent.

This approach allows to define hermite elements (Argyris for instance) in a
generic way, even with non linear transformations (i.e. mainly for curved
boundaries). We denote \([\widehat{\varphi}(\widehat{x})]\) the \(n_d \times Q\) matrix
whose ith line is \((\widehat{\varphi})^i(\widehat{x})\). Whis this notation, for a function is
defined by
\begin{equation*}
\begin{split}f(x) = \sum_{i = 0}^{n_d - 1} \alpha_i \varphi^i(x),\end{split}
\end{equation*}
one has
\begin{equation*}
\begin{split}\fbox{$f(\tau(\widehat{x})) = \alpha^T M [\widehat{\varphi}(\widehat{x})]$,}\end{split}
\end{equation*}
where \(\alpha\) is the vector whose ith component is \(\alpha_i\).

A certain number of description of classical finite element method are defined in
the file \sphinxcode{\sphinxupquote{getfem\_fem.h}}. See \DUrole{xref,std,std-ref}{ud\sphinxhyphen{}appendixa} for an exhaustive list of
available finite element methods.

A pointer to the finite element descriptor of a method is obtained using the
function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{getfem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{pfem} \PYG{n}{pfe} \PYG{o}{=} \PYG{n}{getfem}\PYG{o}{:}\PYG{o}{:}\PYG{n}{fem\PYGZus{}descriptor}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name of method}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

We refer to the file \sphinxcode{\sphinxupquote{getfem\_fem.cc}} for how to define a new finite element
method.


\chapter{Description of the different parts of the library}
\label{\detokenize{project/libdesc:description-of-the-different-parts-of-the-library}}\label{\detokenize{project/libdesc:dp-libdesc}}\label{\detokenize{project/libdesc::doc}}
Figure {\hyperref[\detokenize{project/libdesc:dp-fig-diagram}]{\sphinxcrossref{\DUrole{std,std-ref}{Diagram of GetFEM library}}}} describes the diagram of the different modules of
the \sphinxstyleemphasis{GetFEM} library. The current state and perspective for each module is
described in section {\hyperref[\detokenize{project/libdesc:dp-libdesc}]{\sphinxcrossref{\DUrole{std,std-ref}{Description of the different parts of the library}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=1.0]{{getfem_structure}.png}
\caption{Diagram of \sphinxstyleemphasis{GetFEM} library}\label{\detokenize{project/libdesc:id1}}\label{\detokenize{project/libdesc:dp-fig-diagram}}\end{figure}


\section{Gmm library}
\label{\detokenize{project/libdesc_gmm:gmm-library}}\label{\detokenize{project/libdesc_gmm:dp-libdesc-gmm}}\label{\detokenize{project/libdesc_gmm::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_gmm:description}}
\sphinxstyleemphasis{Gmm++} is a template linear algebra library which was originally designed to make an
interface between the need in linear algebra procedures of \sphinxstyleemphasis{GetFEM} and existing free
linear algebra libraries (MTL, Superlu, Blas, Lapack originally). It rapidly
evolves to an independent self\sphinxhyphen{}consistent library with its own vector and matrix
types. It is now used as a base linear algebra library by several other projects.

However, it preserves the characteristic to be a potential interface for more
specific packages. Any vector or matrix type having the minimum of compatibility
can be used by generic algorithms of \sphinxstyleemphasis{Gmm++} writing a \sphinxcode{\sphinxupquote{linalg\_traits}} structure.

A \sphinxstyleemphasis{Gmm++} standalone version is distributed since release 1.5 of \sphinxstyleemphasis{GetFEM}. It is
however developed inside the \sphinxstyleemphasis{GetFEM} project even though since release 3.0 it is
completely independent of any \sphinxstyleemphasis{GetFEM} file.

In addition to the linear algebra procedures, it furnishes also the following
utilities to \sphinxstyleemphasis{GetFEM}.
\begin{itemize}
\item {} 
Fix some eventual compatibility problems in \sphinxcode{\sphinxupquote{gmm\_std.h}}.

\item {} 
Error, warning and trace management in \sphinxcode{\sphinxupquote{gmm\_except.h}}.

\item {} 
Some extended math definitions in \sphinxcode{\sphinxupquote{gmm\_def.h}}.

\end{itemize}

See \DUrole{xref,std,std-ref}{gmm} documenation for more details.


\subsection{Files}
\label{\detokenize{project/libdesc_gmm:files}}
All files in src/gmm


\subsection{State}
\label{\detokenize{project/libdesc_gmm:state}}
For the moment, \sphinxstyleemphasis{Gmm++} cover the needs of \sphinxstyleemphasis{GetFEM} concerning the basic linear algebra
procedures.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_gmm:perspectives}}
There is potentially several points to be improved in \sphinxstyleemphasis{Gmm++} (partial
introduction of expression template for some base types of matrix and vectors,
think about the way to represent in a more coherent manner sparse sub\sphinxhyphen{}vectors
and sub\sphinxhyphen{}matrices, introduction of C++ concepts, etc.). However, since \sphinxstyleemphasis{Gmm++}
globally cover the needs of \sphinxstyleemphasis{GetFEM} and since there exists some other project like
\sphinxhref{http://glas.sourceforge.net/}{Glas} to build a reference C++ library for
linear algebra, a global change seem to be unnecessary. This part
is considered to be stabilized.

The current vocation of \sphinxstyleemphasis{Gmm++} is to continue to collect generic algorithms and
interfaces to some other packages (DIFFPACK for instance) in order to cover new needs of the whole
project. The library is now frequently used as a separate package and has also
the vocation to collect the contribution of any person who propose some
improvements, new algorithms or new interfaces.


\section{Dal library}
\label{\detokenize{project/libdesc_dal:dal-library}}\label{\detokenize{project/libdesc_dal:dp-libdesc-dal}}\label{\detokenize{project/libdesc_dal::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_dal:description}}
In the very begining of \sphinxstyleemphasis{GetFEM} (the first files was written in 1995) the S.T.L. was
not available and the containers defined in the \sphinxcode{\sphinxupquote{dal}} namespace was used
everywhere. Now, in \sphinxstyleemphasis{GetFEM}, the S.T.L. containers are mainly used. The remaining
uses of \sphinxcode{\sphinxupquote{dal}} containers are eather historical or due to the specificities of
these containers. It is however clear that this is not the aim of the \sphinxstyleemphasis{GetFEM}
project to develop new container concept. So, the use of the \sphinxcode{\sphinxupquote{dal}} containers
has to be as much as possible reduced.

Furthermore, \sphinxcode{\sphinxupquote{dal}} contains a certain number of basic algorithms to deal with static stored objects (description of finite element methods, intermediary structures for auxiliary computations …).


\subsection{Files}
\label{\detokenize{project/libdesc_dal:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{dal\_config.h}}
&
Mainly load \sphinxstyleemphasis{Gmm++} header files
\\
\hline
\sphinxcode{\sphinxupquote{dal\_basic.h}}
&
A variable size array container, dal::dynamic\_array\textless{}T\textgreater{}.
\\
\hline
\sphinxcode{\sphinxupquote{dal\_bit\_vector.h}} and \sphinxcode{\sphinxupquote{dal\_bit\_vector.cc}}
&
A improved bit vector container based on dal::dynamic\_array\textless{}T\textgreater{}.
\\
\hline
\sphinxcode{\sphinxupquote{dal\_tas.h}}
&
A heap container based on dal::dynamic\_array\textless{}T\textgreater{}.
\\
\hline
\sphinxcode{\sphinxupquote{dal\_tree\_sorted.h}}
&
A balanced tree stored array based on dal::dynamic\_array\textless{}T\textgreater{}.
\\
\hline
\sphinxcode{\sphinxupquote{dal\_static\_stored\_objects.h}} and \sphinxcode{\sphinxupquote{dal\_static\_stored\_objects.cc}}
&
Allows to store some objects and dependencies between some objects. Used to store many things in \sphinxstyleemphasis{GetFEM} (finite element methods, integration methods, pre\sphinxhyphen{}computations, …).
\\
\hline
\sphinxcode{\sphinxupquote{dal\_naming\_system.h}}
&
A generic object to associate a name to a method descriptor and store the method descriptor. Used for finite element methods, integration methods and geometric transformations. Uses dal::static\_stored\_object.
\\
\hline
\sphinxcode{\sphinxupquote{dal\_shared\_ptr.h}}
&
A simplified version of boost::shared\_ptr.
\\
\hline
\sphinxcode{\sphinxupquote{dal\_singleton.h}} and \sphinxcode{\sphinxupquote{dal\_singleton.cc}}
&
A simple singleton implementation which has been made thread safe for OpenMP (singletons are replicated n each thread).
\\
\hline
\sphinxcode{\sphinxupquote{dal\_backtrace.h}} and \sphinxcode{\sphinxupquote{dal\_backtrace.cc}}
&
For debugging, dump glibc backtrace.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_dal:state}}
Stable, not evolving too much.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_dal:perspectives}}
No plan.


\section{Miscellaneous algorithms}
\label{\detokenize{project/libdesc_misc:miscellaneous-algorithms}}\label{\detokenize{project/libdesc_misc:dp-libdesc-misc}}\label{\detokenize{project/libdesc_misc::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_misc:description}}
A set of miscellaneous basic algorithms and definitions used in \sphinxstyleemphasis{GetFEM}.


\subsection{Files}
\label{\detokenize{project/libdesc_misc:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_comma\_init.h}}
&
Allow to init  container with a list of values, from boost init.hpp.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_ftool.h}} and \sphinxcode{\sphinxupquote{bgeot\_ftool.cc}}
&
Small language allowing to read a parameter file with a Matlab syntax like. Used also for structured meshes.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_kdtree.h}} and \sphinxcode{\sphinxupquote{bgeot\_kdtree.cc}}
&
Balanced N\sphinxhyphen{}dimensional tree. Store a list of points and allows a quick search of points lying in a given box.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_rtree.h}} and \sphinxcode{\sphinxupquote{bgeot\_rtree.cc}}
&
Rectangle tree. Store a list of N\sphinxhyphen{}dimensional rectangles and allows a quick search of rectangles containing a given point.
\\
\hline
\sphinxcode{\sphinxupquote{permutations.h}}
&
Allows to iterate on permutations. Only used in \sphinxcode{\sphinxupquote{getfem\_integration.cc}}.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_small\_vector.h}} and \sphinxcode{\sphinxupquote{bgeot\_small\_vector.cc}}
&
Defines a vector of low dimension mainly used to represent mesh nodes. Optimized operations.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_tensor.h}}
&
Arbitrary order tensor. Used in assembly.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_sparse\_tensors.h}} and \sphinxcode{\sphinxupquote{bgeot\_sparse\_tensors.cc}}
&
Arbitrary order sparse tensor. Used in the low\sphinxhyphen{}level generic assembly.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_omp.h}} and \sphinxcode{\sphinxupquote{getfem\_omp.cc}}
&
Tools for multithreaded, OpenMP and Boost based parallelization.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_export.h}} and \sphinxcode{\sphinxupquote{getfem\_export.cc}}
&
Export in pos and vtk formats
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_superlu.h}} and \sphinxcode{\sphinxupquote{getfem\_superlu.cc}}
&
Interface with Superlu (the included version or an external one)
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_misc:state}}

\subsection{Perspectives}
\label{\detokenize{project/libdesc_misc:perspectives}}

\section{Events management}
\label{\detokenize{project/libdesc_event:events-management}}\label{\detokenize{project/libdesc_event:dp-libdesc-event}}\label{\detokenize{project/libdesc_event::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_event:description}}
The \sphinxcode{\sphinxupquote{mesh}}, \sphinxtitleref{mesh\_fem}, \sphinxtitleref{mesh\_im} and \sphinxtitleref{model} description are linked together in the sense
that there is some dependencies between them. For instance, when an element is
suppressed to a mesh, the \sphinxtitleref{mesh\_fem} object has to react.


\subsection{Files}
\label{\detokenize{project/libdesc_event:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_context.h}} and \sphinxcode{\sphinxupquote{getfem\_context.cc}}
&
Define a class \sphinxtitleref{context\_dependencies} from which all object has to derive in order to manage events.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_event:state}}
The main tool to deal with simple dependence of object is in
\sphinxcode{\sphinxupquote{getfem\_context.h}}. An object \sphinxcode{\sphinxupquote{context\_dependencies}} is defined there. In
order to deal with the dependencies of an object, the object
\sphinxcode{\sphinxupquote{context\_dependencies}} needs to be a parent class of this object. It adds the
following methods to the object:
\index{getfem::context\_dependencies::add\_dependency (C++ function)@\spxentry{getfem::context\_dependencies::add\_dependency}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/libdesc_event:_CPPv4N6getfem20context_dependencies14add_dependencyE2ct}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{getfem::context\_dependencies\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{add\_dependency}}}{ct}{}%
\pysigstopmultiline
Add an object (which has to have \sphinxcode{\sphinxupquote{context\_dependencies}} as a parent class)
to the list of objects from which the current object depend.

\end{fulllineitems}

\index{getfem::context\_dependencies::touch (C++ function)@\spxentry{getfem::context\_dependencies::touch}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/libdesc_event:_CPPv4N6getfem20context_dependencies5touchEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{getfem::context\_dependencies\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{touch}}}{}{}%
\pysigstopmultiline
Indicates to the dependent objects that something has change in the object.

\end{fulllineitems}

\index{getfem::context\_dependencies::context\_check (C++ function)@\spxentry{getfem::context\_dependencies::context\_check}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/libdesc_event:_CPPv4N6getfem20context_dependencies13context_checkEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{getfem::context\_dependencies\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{context\_check}}}{}{}%
\pysigstopmultiline
Check if the object has to be updated. if it is the case it makes first a
check to the dependency list and call the update function of the object. (the
update function of the dependencies are called before the update function of
the current object).

\end{fulllineitems}

\index{getfem::context\_dependencies::context\_valid (C++ function)@\spxentry{getfem::context\_dependencies::context\_valid}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{project/libdesc_event:_CPPv4N6getfem20context_dependencies13context_validEv}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{getfem::context\_dependencies\sphinxcode{\sphinxupquote{::}}}}\sphinxbfcode{\sphinxupquote{context\_valid}}}{}{}%
\pysigstopmultiline
Says if the object has still a valid context, i.e. if the object in the
dependency list still exist.

\end{fulllineitems}


Moreover, the object has to define a method:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
``void update\PYGZus{}from\PYGZus{}context(void) const``
\end{sphinxVerbatim}

which is called after a \sphinxcode{\sphinxupquote{context\_check()}} if the context has changed.

An additional system is present in the object \sphinxtitleref{mesh}. Each individual element has a
version number in order for the objects \sphinxtitleref{mesh\_fem} and \sphinxtitleref{mesh\_im} to detect which element
has changed between two calls.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_event:perspectives}}
The event management of some objects should be analysed with care. This is the case for instance of \sphinxtitleref{mesh\_level\_set}, \sphinxtitleref{mesh\_fem\_level\_set}, \sphinxtitleref{partial\_mesh\_fem}, etc.

The event management still have to be improved to be a fully reactive system.


\section{Mesh module}
\label{\detokenize{project/libdesc_mesh:mesh-module}}\label{\detokenize{project/libdesc_mesh:dp-libdesc-mesh}}\label{\detokenize{project/libdesc_mesh::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_mesh:description}}
This part of the library has the role to store and manage the meshes, i.e. a
collection of elements (real elements) connected to each other by some of their
faces. For that, it develops concepts of elements, elements of reference,
structure of meshes, collection of nodes, geometric transformations, subpart of
the boundary or subzone of the mesh.

There is no really effective meshing capabilities available for the moment in
\sphinxstyleemphasis{GetFEM}. The meshes of complex objects must be imported from existing meshers such
as \sphinxhref{http://www.geuz.org/gmsh}{Gmsh} or \sphinxhref{http://gid.cimne.upc.es}{GiD}. Some importing functions of meshes have been written and
can be easily extended for other formats.

The object which represents a mesh declared in the file \sphinxcode{\sphinxupquote{getfem\_mesh.h}} and
which is used as a basis for handling of the meshes in \sphinxstyleemphasis{GetFEM} manages also the
possibility for the structures depending on a mesh (see MESHFEM and MESHIM
modules) to react to the evolution of the mesh (addition or removal of elements,
etc.).


\subsection{Files}
\label{\detokenize{project/libdesc_mesh:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_convex\_structure.h}} and \sphinxcode{\sphinxupquote{bgeot\_convex\_structure.cc}}
&
Describes the structure of an element disregarding the coordinates of its vertices.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_mesh\_structure.h}} and \sphinxcode{\sphinxupquote{bgeot\_mesh\_structure.cc}}
&
Describes the structure of a mesh disregarding the coordinates of the nodes.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_node\_tab.h}} and \sphinxcode{\sphinxupquote{bgeot\_node\_tab.cc}}
&
A node container allowing the fast search of a node and store nodes identifying the too much close nodes.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_convex.h}}
&
Describes an element with its vertices.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_convex\_ref.h}} and \sphinxcode{\sphinxupquote{bgeot\_convex\_ref.cc}} and \sphinxcode{\sphinxupquote{bgeot\_convex\_structure.cc}}
&
Describe reference elements.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_mesh.h}}
&
Describes a mesh with the collection of node (but without the description of geometric transformations).
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_region.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_region.cc}}
&
Object representing a mesh region (boundary or part of a mesh).
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_geometric\_trans.h}} and \sphinxcode{\sphinxupquote{bgeot\_geometric\_trans.cc}}
&
Describes geometric transformations.
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_geotrans\_inv.h}} and \sphinxcode{\sphinxupquote{bgeot\_geotrans\_inv.cc}}
&
A tool to invert geometric transformations.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh.cc}}
&
Fully describes a mesh (with the geometric transformations, subparts of the mesh, support for parallelization). Includes the Bank algorithm to refine a mesh.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_deformable\_mesh.h}}
&
defines an object capable to deform a mesh with respect to a displacement field and capable to restore it
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesher.h}} and \sphinxcode{\sphinxupquote{getfem\_mesher.cc}}
&
An experimental mesher, in arbitrary dimension. To be used with care and  quite slow (because of node optimization). It meshes geometries defined by some level sets.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_import.h}} and \sphinxcode{\sphinxupquote{getfem\_import.cc}}
&
Import mesh files in various formats
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_regular\_meshes.h}} and \sphinxcode{\sphinxupquote{getfem\_regular\_meshes.cc}}
&
Produces structured meshes
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_slicers.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_slicers.cc}}
&
A slice is built from a mesh, by applying some slicing operations (cut the mesh with a plane, intersect with a sphere, take the boundary faces, etc..). They are used for post\sphinxhyphen{}treatment (exportation of results to VTK or OpenDX,  etc.).
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_slice.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_slice.cc}}
&
Store mesh slices.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_mesh:state}}
Stable and not evolving so much.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_mesh:perspectives}}
For the moment, the module is split into two parts which lie into two different
namespaces. Of course, It would be more coherent to gather the module in only one
namespace (\sphinxcode{\sphinxupquote{getfem}}).

\begin{sphinxadmonition}{note}{Note:}
The file \sphinxcode{\sphinxupquote{bgeot\_mesh.h}} could be renamed \sphinxcode{\sphinxupquote{getfem\_basic\_mesh.h}}.
\end{sphinxadmonition}

A  bibliographical review on how to efficiently store a mesh and implement the main operations (add a node, an element, deal with faces, find the neighbour elements, the isolated faces …) would be interesting to make the mesh structure evolve.

A senstive algorithm is the one (in bgeot\_node\_tab.cc) which identify the too much close nodes. More investigations (and documentation) are probably necessary.


\section{Fem module}
\label{\detokenize{project/libdesc_fem:fem-module}}\label{\detokenize{project/libdesc_fem:dp-libdesc-fem}}\label{\detokenize{project/libdesc_fem::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_fem:description}}
The Fem module is the part of \sphinxstyleemphasis{GetFEM} which describes the finite elements at the
element level and the degrees of freedom. Finite element methods can be of
different types. They could be scalar or vectorial, polynomial, piecewise
polynomial or non\sphinxhyphen{}polynomial, equivalent via the geometric transformation or not.
Moreover, the description of the degrees of freedom have to be such that it is
possible to gather the compatible degrees of freedom between two neighbour
elements in a generic way (for instance connecting a Lagrange 2D element to
another Lagrange 1D element).


\subsection{Files}
\label{\detokenize{project/libdesc_fem:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{bgeot\_poly.h}} and \sphinxcode{\sphinxupquote{bgeot\_poly\_composite.h}} and \sphinxcode{\sphinxupquote{bgeot\_poly.cc}} and \sphinxcode{\sphinxupquote{bgeot\_poly\_composite.cc}}
&
Some classes to represent polynomials and piecewise polynomials in order to describe shape functions of a finite element method on the reference element.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_fem.h}} and \sphinxcode{\sphinxupquote{getfem\_fem.cc}} and \sphinxcode{\sphinxupquote{getfem\_fem\_composite.cc}}
&
Descriptors for finite element and a degree of freedom. Polynomial finite elements are defined in \sphinxcode{\sphinxupquote{getfem\_fem.cc}} and piecewise polynomial finite elements in \sphinxcode{\sphinxupquote{getfem\_fem\_composite.cc}}
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_fem\_global\_function.h}} and \sphinxcode{\sphinxupquote{getfem\_fem\_global\_function.cc}}
&
Defines a fem with base functions defined as global functions given by the user. Useful for enrichment with singular functions and for implementation of meshless methods.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_projected\_fem.h}} and \sphinxcode{\sphinxupquote{getfem\_projected\_fem.cc}}
&
Defines a fem which is the projection of a finite element space (represented by a mesh\_fem) on a different mesh. Note that the high\sphinxhyphen{}generic assembly language offers also this functionality by means of the interpolated transformations.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_interpolated\_fem.h}} and \sphinxcode{\sphinxupquote{getfem\_interpolated\_fem.cc}}
&
Dfines a fem which is the interpolation of a finite element space (represented by a mesh\_fem) on a different mesh. Note that the high\sphinxhyphen{}generic assembly language offers also this functionality by means of the interpolated transformations.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_fem:state}}
The two files \sphinxcode{\sphinxupquote{getfem\_fem.cc}} and \sphinxcode{\sphinxupquote{getfem\_fem\_composite.cc}} mainly
contains all the finite element description for basic elements. A exhaustive list
of the defined finite elements is given in \DUrole{xref,std,std-ref}{ud\sphinxhyphen{}appendixa}.

Some other files define some specific finite element such as
\sphinxcode{\sphinxupquote{getfem\_fem\_level\_set.h}} which is a complex construction which allows to
“cut” a existing element by one or several level sets.

The manner to describe the degrees of freedom globally satisfies the needing
(connecting dof from an element to another in a generic way) but is a little bit
obscure and too much complicated.

Conversely, the way to represent non\sphinxhyphen{}equivalent elements with the supplementary
matrix \sphinxcode{\sphinxupquote{M}} has proven its efficiency on several elements (Hermites elements,
Argyris, etc.).


\subsection{Perspectives}
\label{\detokenize{project/libdesc_fem:perspectives}}
The principal dissatisfaction of this module is that description of the degrees
of freedom is not completely satisfactory. It is the principal reason why one
documentation on how to build an element from A to Z was not made for the moment
because description of the degrees of freedom was conceived to be temporary. An
effort of design is thus to be provided to completely stabilize this module
mainly thus with regard to the description of degrees of freedom but also perhaps
the description of finite elements which could be partially externalized in a
similar way to the cubature methods , at least for the simplest finite elements
(equivalent and polynomial finite elements).


\section{Integ module}
\label{\detokenize{project/libdesc_im:integ-module}}\label{\detokenize{project/libdesc_im:dp-libdesc-im}}\label{\detokenize{project/libdesc_im::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_im:description}}
The CUBATURE module gives access to the numerical integration methods on
reference elements. In fact it does not only contain some cubature formulas
because it also give access to some exact integration methods. However, the exact
integration methods are only usable for polynomial element and affine geometric
transformations. This explain why exact integration methods are not widely used.
The description of cubature formulas is done either directly in the file
\sphinxcode{\sphinxupquote{getfem\_integration.h}} or via a description file in the directory
\sphinxcode{\sphinxupquote{cubature}} of \sphinxstyleemphasis{GetFEM}. The addition of new cubature formulas is then very simple,
it suffices to reference the element on which it is defined and the list of Gauss
points in a file and add it to this directory. Additionally, In order to
integrate terms defined on a boundary of a domain, the description should also
contains the reference to a method of same order on each face of the element.


\subsection{Files}
\label{\detokenize{project/libdesc_im:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_integration.h}} and \sphinxcode{\sphinxupquote{getfem\_integration.cc}} and \sphinxcode{\sphinxupquote{getfem\_integration\_composite.cc}}
&
Structure of integration methods, basic integration methods, product of integration method and composite methods.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_im\_list.h}}
&
file generated by \sphinxcode{\sphinxupquote{cubature/make\_getfem\_list}} with the integration methods defined in cubature directory. This gives the possibility to define a new integration method just listing the Gauss points and weigth in a text file.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_im:state}}
This module meets the present needs for the project and is considered as
stabilized. The list of available cubature formulas is given in
\DUrole{xref,std,std-ref}{ud\sphinxhyphen{}appendixb}.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_im:perspectives}}
No change needed for the moment. An effort could be done on the documentation to
describe completely how to add a new cubature formula (format of descritption
files).


\section{MeshFem module}
\label{\detokenize{project/libdesc_meshfem:meshfem-module}}\label{\detokenize{project/libdesc_meshfem:dp-libdesc-mesh-fem}}\label{\detokenize{project/libdesc_meshfem::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_meshfem:description}}
The MeshFem module aims to represent a finite element method (space) with respect to a given mesh. The mesh\_fem object will be permanently linked to the given mesh and will be able to react to  changes in the mesh (addition or deletion of elements, in particular). A mesh\_fem object may associate a different finite element method on each element of the mesh even though of course, the most common case it that all the element share the same finite element method.


\subsection{Files}
\label{\detokenize{project/libdesc_meshfem:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_fem.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_fem.cc}}
&
Defines the structure representing a finite element on a whole mesh. Each element of the mesh is associated with a finite element method. This is a quite complex structure which perform dof identification and numbering, allows a global linear reduction.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_global\_function.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_global\_function.cc}}
&
Defines mesh\_fem with fem defined as a fem\_global\_function. It provides convenience methods for updating the list of base functions in the linked fem\_global\_function.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_product.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_product.cc}}
&
Produces a mesh\_fem object which is a kind of direct product of two finite element method. Useful for Xfem enrichment.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_sum.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_sum.cc}}
&
Produces a mesh\_fem object which is a kind of direct sum of two finite element method. Useful for Xfem enrichment.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_partial\_mesh\_fem.h}} and \sphinxcode{\sphinxupquote{getfem\_partial\_mesh\_fem.cc}}
&
Produces a mesh\_fem with a reduced number of dofs
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_interpolation.h}} and \sphinxcode{\sphinxupquote{getfem\_interpolation.cc}}
&
Interpolation between two finite element methods, possibly between different meshes. The interpolation facilities of the high\sphinxhyphen{}level generic assembly can be used instead.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_derivatives.h}}
&
Interpolation of some derivatives of a finite element field on a (discontinuous) Lagrange finite element. The interpolation facilities of the high\sphinxhyphen{}level generic assembly can be used instead.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_inter\_element.h}} and \sphinxcode{\sphinxupquote{getfem\_inter\_element.cc}}
&
An attempt to make framework for inter\sphinxhyphen{}element computations (jump in normal derivative for instance). To be continuated and perhaps integrated into the generic assembly language.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_error\_estimate.h}} and \sphinxcode{\sphinxupquote{getfem\_error\_estimate.cc}}
&
An attempt to make framework for computation of error estimates. To be continuated and perhaps integrated into the generic assembly language.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_crack\_sif.h}}
&
Crack support functions for computation of SIF(stress intensity factors).
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_torus.h}} and \sphinxcode{\sphinxupquote{getfem\_torus.cc}}
&
Adapt a mesh\_fem object which extends a 2D dimensional structure with a radial dimension.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_meshfem:state}}
Stable. Not evolving so much.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_meshfem:perspectives}}
Parallelisation of dof numbering to be done. An optimal (an simple) algorithm
exists.


\section{MeshIm module}
\label{\detokenize{project/libdesc_mim:meshim-module}}\label{\detokenize{project/libdesc_mim:dp-libdesc-mim}}\label{\detokenize{project/libdesc_mim::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_mim:description}}
Defines an integration method on a whole mesh.


\subsection{Files}
\label{\detokenize{project/libdesc_mim:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_im.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_im.cc}}
&
Object which defines an integration method on each element of the mesh. Reacts to the main mesh changes (add or deletion of elements).
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_im\_data.h}} and \sphinxcode{\sphinxupquote{getfem\_im\_data.cc}}
&
Define an object representing a scalar, a vector or a tensor on each Gauss point of a mesh\_im object. Used for instance in plasticity approximation. Interpolation of arbitrary expressions can be made thanks to the weak form language.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_mim:state}}
Stable, not evolving so much.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_mim:perspectives}}

\section{Level\sphinxhyphen{}set module}
\label{\detokenize{project/libdesc_levelset:level-set-module}}\label{\detokenize{project/libdesc_levelset:dp-libdesc-levelset}}\label{\detokenize{project/libdesc_levelset::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_levelset:description}}
Define level\sphinxhyphen{}set objects and cut meshes, integration method and finite element method with respect to one or several level\sphinxhyphen{}set.


\subsection{Files}
\label{\detokenize{project/libdesc_levelset:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_level\_set.h}} and \sphinxcode{\sphinxupquote{getfem\_level\_set.cc}}
&
Define a level\sphinxhyphen{}set function (scalar field defined on a Lagrange fem) with an optional secondary level\sphinxhyphen{}set function.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_level\_set.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_level\_set.cc}}
&
Cut a mesh with respect to one or several level\sphinxhyphen{}sets.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_fem\_level\_set.h}} and \sphinxcode{\sphinxupquote{getfem\_fem\_level\_set.cc}}
&
Define a special finite element method which depends on the element and which is cut by one or several level\sphinxhyphen{}sets.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_level\_set.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_fem\_level\_set.cc}}
&
Produces a mesh\_fem object with shape functions cut by one or several level\sphinxhyphen{}sets.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mesh\_im\_level\_set.h}} and \sphinxcode{\sphinxupquote{getfem\_mesh\_im\_level\_set.cc}}
&
Produce a mesh\_im representing an intergration method cut by the level set and being on on side of level\sphinxhyphen{}set, the oter side, both or only on the levelset itself.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_level\_set\_contact.h}} and \sphinxcode{\sphinxupquote{getfem\_level\_set\_contact.cc}}
&
A level set based large sliding contact algorithm for an easy analysis of implant positioning.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_convect.h}}
&
Compute the convection of a quantity with respect to a vector field. Used to computate the evolution of a level\sphinxhyphen{}set function for instance. Galerkin characteristic method.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_levelset:state}}
Stable.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_levelset:perspectives}}
Clarify the algorithm computing the different zones.


\section{The high\sphinxhyphen{}level generic assembly module in \sphinxstyleemphasis{GetFEM}}
\label{\detokenize{project/libdesc_high_gen_assemb:the-high-level-generic-assembly-module-in-gf}}\label{\detokenize{project/libdesc_high_gen_assemb:dp-libdesc-high-assemb}}\label{\detokenize{project/libdesc_high_gen_assemb::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_high_gen_assemb:description}}
The high level generic assembly module of \sphinxstyleemphasis{GetFEM} and its generic weak form language (GWFL) is a key module which allows to describe weak formulation of partial differential equation problems. See the description of the language in the user documentation section \DUrole{xref,std,std-ref}{ud\sphinxhyphen{}gasm\sphinxhyphen{}high}.


\subsection{Files}
\label{\detokenize{project/libdesc_high_gen_assemb:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_generic\_assembly.h}}
&
Main header for exported definitions. Only this header has to be included to use the generic assembly. Other headers of the module are for internal use only.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_tree.h}} and \sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_tree.cc}}
&
Definition of the tree structure and basic operations on it, including reading an assembly string and transform it in a syntax tree and make the invert transformation of a tree into a string.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_function\_and\_operators.h}} and \sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_function\_and\_operators.cc}}
&
Definition of redefined function and nonlinear operator of GWFL.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_semantic.h}} and \sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_semantic.cc}}
&
Semantic analysis and enrichment of the syntax tree. Include some operations such as making the derivation of a tree with respect to a variable or computing the tree corresponding to the gradient of an expression.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_workspace.cc}}
&
Methodes of the workspace object (defined in \sphinxcode{\sphinxupquote{getfem\_generic\_assembly.h}}).
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_compile\_and\_exec.h}} and \sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_compile\_and\_exec.cc}}
&
Definition of the optimized instructions, compilation into a sequel of optimize instructions and execution of the instructions on Gauss point/interpolation points.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_generic\_assembly\_interpolation.cc}}
&
Interpolation operations and interpolate transformations.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{A few implementation details}
\label{\detokenize{project/libdesc_high_gen_assemb:a-few-implementation-details}}
The assembly string is transformed in an assembly tree by a set of function in \sphinxcode{\sphinxupquote{src/getfem\_generic\_assembly.cc}}. The process has 6 steps:
\begin{itemize}
\item {} 
Lexical analysis with the procedure \sphinxcode{\sphinxupquote{ga\_get\_token(...)}}.

\item {} 
Syntax analysis and transformation into a syntax tree by \sphinxcode{\sphinxupquote{ga\_read\_string(...)}}.

\item {} 
Semantic analysis, simplification (pre\sphinxhyphen{}computation) of constant expressions and enrichment of the tree by \sphinxcode{\sphinxupquote{ga\_semantic\_analysis(...)}}.

\item {} 
Symbolic (automatic) differentiation of an assembly tree by \sphinxcode{\sphinxupquote{ga\_derivative(...)}}

\item {} 
Symbolic (automatic) gradient computation of an assembly tree by \sphinxcode{\sphinxupquote{ga\_gradient(...)}}

\item {} 
Compilation in a sequence of instructions with optimizations by \sphinxcode{\sphinxupquote{ga\_compile(...)}}.

\item {} 
Execution of the sequence of instructions and assembly by \sphinxcode{\sphinxupquote{ga\_exec(...)}}.

\end{itemize}

These steps are performed only once at the beginning of the assembly. The final tree is compiled in a sequence of optimized instructions which are executed on each Gauss point of each element. The compilation performed some optimizations : repeated terms are automatically detected and evaluated only once, simplifications if the mesh has uniform type of elements, simplifications for vectorized fnite element methods.

Moreover, there is specifics function for interpolation operations (ga\_interpolation(…), ga\_interpolation\_exec(…), ga\_interpolation\_Lagrange\_fem, ga\_interpolation\_mti, ga\_interpolation\_im\_data, …)


\subsection{Assembly tree}
\label{\detokenize{project/libdesc_high_gen_assemb:assembly-tree}}
Assembly strings are transformed into assembly trees by \sphinxcode{\sphinxupquote{ga\_read\_string(...)}}. Assembly trees are syntax trees that are progressively enriched in information in the differents steps (semantic analysis, derivation, compilation).

The object \sphinxcode{\sphinxupquote{ga\_tree}} represents an assembly tree. It is a copyable object that only contains a pointer to the root of the tree. Each tree node is an object \sphinxcode{\sphinxupquote{ga\_tree\_node}} that contains the main following information:
\begin{itemize}
\item {} 
node\_type (function, variable value, variable gradient, operation …)

\item {} 
operation type for operation nodes.

\item {} 
assembly tensor: used at execution time by optimized instructions to compute the intermediary results. The final result is in the assembly string of the root node at the end of the execution (for each Gauss point).

\item {} 
term type: value, order one term (ith order one test functions),
order two term (with order two test functions) or with both order one and
order two test functions (tangent term).

\item {} 
variable name of tests functions for order 1 or 2 terms.

\item {} 
pointer to the parent node.

\item {} 
pointers to the children nodes.

\end{itemize}

For example, the assembly tree for the assembly string “a*Grad\_Test2\_u.Grad\_Test\_u” for the stiffness matrix of a Laplacian problem can be represented as follows with its assembly tensors at each node:

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[scale=0.75]{{tree_simple_laplace_tan}.png}
\end{figure}


\subsection{Assembly tensors}
\label{\detokenize{project/libdesc_high_gen_assemb:assembly-tensors}}
Assembly tensors are represented on each node by a \sphinxcode{\sphinxupquote{bgeot::tensor\textless{}double\textgreater{}}} object. However, there is a specific structure in \sphinxcode{\sphinxupquote{src/getfem\_generic\_assembly.cc}} for assembly tensors because there is several format of assembly tensors :
\begin{itemize}
\item {} 
Normal tensor. The first and second indices may represent the test function local indices if the node represent a first or second order term. Remember that in \sphinxstyleemphasis{GetFEM} all tensors are stored with a Fortran order. This means that for instance t for a \(N\times P\times Q\) tensor one has \sphinxcode{\sphinxupquote{t(i, j, k) = t{[}i + j*N + k*N*P{]}}}.

\item {} 
Copied tensor. When a node is detected to have exactly the same expression compared to an already compiled one, the assembly tensor will contain a pointer to the assembly tensor of the already compiled node. The consequence is that no unnecessary copy is made.

\item {} 
Sparse tensor with a listed sparsity. When working with a vector field, the finite element method is applied on each component. This results on vector base functions having only one nonzero component and some components are duplicated. The tensor are fully represented because it would be difficul to gain in efficiency with that kind of small sparse tensor format. However, some operation can be optimized with the knoledge of a certain sparsity (and duplication). This can change the order of complexity of a reduction. In order to allows this gain in efficiency, the tensor are labellised with some known sparsity format (vectorisation and format coming from operation applied on vectorized tensors). This results in a certain number of sparsity formats that are listed below:
\begin{itemize}
\item {} 
1: Vectorized base sparsity format: The tensor represent a vectorized
value. Each value of the condensed tensor is repeated on \(Q\)
components of the vectorized tensor. The mesh dimensions is denoted
\(N\). For instance if \(\varphi_i\) are the \(M\) local
base functions on an element and the evaluation is on a Gauss point
\(x\), then the non vectorized tensor is
\(\bar{t}(i) = \varphi_i(x)\) and the vectorized one is
\(t(j,k) = \varphi_{j/Q}(x) \delta_{k, j \mbox{ mod } Q}\)
where \(j/M\) is the integer division. For \(M=2\),
\(Q=2\) and \(N=3\) the components of the two tensors are
represented in the following table


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{5}{17}|\X{12}{17}|}
\hline
\sphinxstyletheadfamily 
Scalar tensor
&\sphinxstyletheadfamily 
Vectorized tensor
\\
\hline
\(\bar{t}(i) = \varphi_i(x)\)
&
\(t(j,k) = \varphi_{j/Q}(x) \delta_{k, (j \mbox{ mod } Q)}\)
\\
\hline
\([\varphi_0(x), \varphi_1(x)]\)
&
\([\varphi_0(x), 0, \varphi_1(x), 0, 0, \varphi_0(x), 0, \varphi_1(x)]\)
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\item {} 
2: Grad condensed format


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{5}{17}|\X{12}{17}|}
\hline
\sphinxstyletheadfamily 
Scalar tensor
&\sphinxstyletheadfamily 
Vectorized tensor
\\
\hline
\(\bar{t}(i,j) = \partial_j\varphi_i(x)\)
&
\(t(k,l,m) = \partial_m\varphi_{k/Q}(x) \delta_{l, (m \mbox{ mod } Q)}\)
\\
\hline
\([\partial_0\varphi_0(x), \partial_0\varphi_1(x),\) \(\partial_1\varphi_0(x), \partial_1\varphi_1(x),\) \(\partial_2\varphi_0(x), \partial_2\varphi_1(x)]\)
&\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}

\item {} 
3: Hessian condensed format

\item {} 
10: Vectorized mass: the tensor represent a scalar product of two
vectorised base functions. This means a tensor \(t(\cdot,\cdot)\)
where \(t(i*Q+k, j*Q+l) = 0\) for \(k \ne l\) and
\(t(i*Q+k, j*Q+k)\) are equals for \(0 \le k < Q\).

\end{itemize}

\end{itemize}


\subsection{Optimized instructions}
\label{\detokenize{project/libdesc_high_gen_assemb:optimized-instructions}}
Optimized instructions for variable evaluation, operations, vector and matrix assembly … to be described.


\subsection{Predefined functions}
\label{\detokenize{project/libdesc_high_gen_assemb:predefined-functions}}\begin{description}
\item[{Some predefined scalar functions are available in GWFL in order to describe a weak formulation (or also to make basic algebraic computations). This is limited to scalar functions of one or two arguments. Due to the automatic differentiation used to obtain the tangent system of described problems, the derivative each function have to be available. The principle retained is the following: For each predefined function is available:}] \leavevmode\begin{itemize}
\item {} 
A C++ function which computes the value given the argument(s).

\item {} 
The support of the function in the first each argument in term of a
(possibly infinite) interval (this is for simplification of expressions).

\item {} 
The string corresponding of the derivative in terms of already known
functions

\end{itemize}

\end{description}

A new predefined function is easy to add. See init\_predefined\_functions() in file \sphinxcode{\sphinxupquote{src/getfem\_generic\_assembly.cc}}. + describe how to give the derivative …


\subsection{Predefined nonlinear operators}
\label{\detokenize{project/libdesc_high_gen_assemb:predefined-nonlinear-operators}}
to be described …


\subsection{State}
\label{\detokenize{project/libdesc_high_gen_assemb:state}}
Stable.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_high_gen_assemb:perspectives}}\begin{itemize}
\item {} 
Is a certain extension to complex data possible ?

\item {} 
More simplifications : study the possibility to automatically factorize some terms (for instance scalar ones) to reduce the number of operations.

\end{itemize}


\section{The low\sphinxhyphen{}level generic assembly module in \sphinxstyleemphasis{GetFEM}}
\label{\detokenize{project/libdesc_low_gen_assemb:the-low-level-generic-assembly-module-in-gf}}\label{\detokenize{project/libdesc_low_gen_assemb:dp-libdesc-low-assemb}}\label{\detokenize{project/libdesc_low_gen_assemb::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_low_gen_assemb:description}}
First version of the generic assembly. Base on tensor reduction. Not very convenient for nonlinear terms. The high\sphinxhyphen{}level generic assembly have to be prefered now.


\subsection{Files}
\label{\detokenize{project/libdesc_low_gen_assemb:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mat\_elem\_type.h}} and :file:\textasciigrave{} getfem\_mat\_elem\_type.cc
&
Defines base type for components of an elementary matrix.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_mat\_elem.h}} and :file:\textasciigrave{} getfem\_mat\_elem.cc
&
Describes an compute elementary matrices.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_assembling\_tensors.h}} and \sphinxcode{\sphinxupquote{getfem\_assembling\_tensors.cc}}
&
Performs the assembly.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_assembling.h}}
&
Various assembly terms (linear elasticity, generic elliptic term, Dirichlet condition …
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_low_gen_assemb:state}}
Stable.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_low_gen_assemb:perspectives}}
Will not evolve since the efforts are now focused on the high\sphinxhyphen{}level generic assembly.


\section{Model module}
\label{\detokenize{project/libdesc_model:model-module}}\label{\detokenize{project/libdesc_model:dp-libdesc-model}}\label{\detokenize{project/libdesc_model::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_model:description}}
Describe a model (variable, data and equation terms linking the variables).


\subsection{Files}
\label{\detokenize{project/libdesc_model:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_models.h}} and \sphinxcode{\sphinxupquote{getfem\_models.cc}}
&
Defines the object models, its internal and the standard bricks (linear elasticity, generic elliptic brick, Dirichlet boundary conditions …).
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_model\_solvers.h}} and \sphinxcode{\sphinxupquote{getfem\_model\_solvers.cc}}
&
Defines the the standard solvers for the model object.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_common.h}} and \sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_common.cc}}
&
Common algorithms for contact/friction conditions on deformable bodies
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_integral.h}} and \sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_integral.cc}}
&
Small sliding contact/friction bricks of integral type.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_large\_sliding.h}} and \sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_large\_sliding.cc}}
&
Large sliding contact/friction bricks.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_nodal.h}} and \sphinxcode{\sphinxupquote{getfem\_contact\_and\_friction\_nodal.cc}}
&
Small sliding nodal contact/friction bricks.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_Navier\_Stokes.h}}
&
An attempt for Navier\sphinxhyphen{}Stokes bricks. To be improved.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_fourth\_order.h}} and \sphinxcode{\sphinxupquote{getfem\_fourth\_order.cc}}
&
Bilaplacian and Kirchhoff\sphinxhyphen{}Love plate bricks
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_linearized\_plates.h}} and \sphinxcode{\sphinxupquote{getfem\_linearized\_plates.cc}}
&
Mindlin\sphinxhyphen{}Reissner plate brick
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_nonlinear\_elasticity.h}} and \sphinxcode{\sphinxupquote{getfem\_nonlinear\_elasticity.cc}}
&
Large deformation elasticity bricks.
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_plasticity.h}} and \sphinxcode{\sphinxupquote{getfem\_plasticity.cc}}
&
Plasticity bricks.
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_model:state}}
Constant evolution to includes next models.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_model:perspectives}}
More plate, load and shell bricks, plasticity in large deformation, …


\section{Continuation module}
\label{\detokenize{project/libdesc_cont:continuation-module}}\label{\detokenize{project/libdesc_cont:dp-libdesc-cont}}\label{\detokenize{project/libdesc_cont::doc}}

\subsection{Description}
\label{\detokenize{project/libdesc_cont:description}}
Allows to follow a solution with respect to a parameter (continuation method), detect a bifurcation and allow branching. Work for low regularity problems (Lipschitz regularity). Use an adapted Moore\sphinxhyphen{}Penrose continuation method.


\subsection{Files}
\label{\detokenize{project/libdesc_cont:files}}

\begin{savenotes}\sphinxattablestart
\centering
\begin{tabular}[t]{|\X{8}{23}|\X{15}{23}|}
\hline
\sphinxstyletheadfamily 
File(s)
&\sphinxstyletheadfamily 
Description
\\
\hline
\sphinxcode{\sphinxupquote{getfem\_continuation.h}} and \sphinxcode{\sphinxupquote{getfem\_continuation.cc}}
&
The generic continuation and branching method
\\
\hline
\end{tabular}
\par
\sphinxattableend\end{savenotes}


\subsection{State}
\label{\detokenize{project/libdesc_cont:state}}
Have already generic and advanced functionalities.


\subsection{Perspectives}
\label{\detokenize{project/libdesc_cont:perspectives}}
Still in developement.


\section{Interface with scripts languages (Python, Scilab and Matlab)}
\label{\detokenize{project/libdesc_interface:interface-with-scripts-languages-python-scilab-and-matlab}}\label{\detokenize{project/libdesc_interface:dp-libdesc-interface}}\label{\detokenize{project/libdesc_interface::doc}}
A simplified (but rather complete) interface of \sphinxstyleemphasis{GetFEM} is provided, so that it is possible to use getfem in some script languages.


\subsection{Description}
\label{\detokenize{project/libdesc_interface:description}}
All sources are located in the \sphinxcode{\sphinxupquote{interface/src}} directory. The interface is
composed of one large library \sphinxcode{\sphinxupquote{getfemint}} (which stands for getfem
interaction), which acts as a layer above the \sphinxstyleemphasis{GetFEM} library, and is used by
the python, matlab and scilab interfaces.

This interface is not something that is generated automatically from c++ sources
(as that could be the case with tools such as swig). It is something that has
been designed as a simplified and consistent interface to getfem. Adding a new
language should be quite easy (assuming the language provides some structures
for dense arrays manipulations).


\subsection{Files}
\label{\detokenize{project/libdesc_interface:files}}
All the files in the directory \sphinxcode{\sphinxupquote{interfacesrc}}. A short description of main files:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{getfem\_interface.cc}}.

This is the bridge between the script language and the getfem interface. The
function getfem\_interface\_main is exported as an \sphinxcode{\sphinxupquote{extern "C"}} function, so
this is a sort of c++ barrier between the script language and the getfem
interface (exporting only a C interface avoids many compilation problems).

\item {} 
\sphinxcode{\sphinxupquote{matlab/gfm\_mex.c}}.

The matlab interface. The only thing it knows about getfem is in
\sphinxcode{\sphinxupquote{getfem\_interface.h}}.

\item {} 
\sphinxcode{\sphinxupquote{python/getfem\_python.c}}.

The python interface. The only thing it knows about getfem is in
\sphinxcode{\sphinxupquote{getfem\_interface.h}}.

\item {} 
\sphinxcode{\sphinxupquote{gfi\_array.h}}, \sphinxcode{\sphinxupquote{gfi\_array.c}}.

Both \sphinxcode{\sphinxupquote{gfm\_mex.c}} and \sphinxcode{\sphinxupquote{getfem\_python.c}} need a simple convention on
how to send and receive arrays, and object handles, from
\sphinxcode{\sphinxupquote{getfem\_interface\_main()}}. This file provide such functionnality.

\item {} 
\sphinxcode{\sphinxupquote{getfemint\_gsparse.h}}, \sphinxcode{\sphinxupquote{getfemint\_precond.h}}, etc.

Files specific to an interfaced object if needed.
(getfemint\_gsparse which export some kind of mutable sparse matrix that can
switch between different storage types, and real of complex elements).

\item {} 
\sphinxcode{\sphinxupquote{gf\_workspace.cc}}, \sphinxcode{\sphinxupquote{gf\_delete.cc}}.

Memory management for getfem objects. There is a layer which handles the
dependency between for example a \sphinxcode{\sphinxupquote{mesh}} and a \sphinxcode{\sphinxupquote{mesh\_fem}}.
It makes sure that no object
will be destroyed while there is still another getfem\_object using it.
The goal
is to make sure that under no circumstances the user is able to crash getfem
(and the host program, matlab, scilab or python) by passing incorrect
argument to the getfem interface.

It also provides a kind of workspace stack, which was designed to simplify
handling and cleaning of many getfem objects in matlab (since matlab does not
have “object destructors”).

\item {} 
\sphinxcode{\sphinxupquote{getfemint.h}}, \sphinxcode{\sphinxupquote{getfemint.cc}}.

Define the \sphinxcode{\sphinxupquote{mexarg\_in}}, \sphinxcode{\sphinxupquote{mexarg\_out}} classes, which are used to parse the
list of input and output arguments to the getfem interface functions.
The name  is not adequate anymore since any reference to “mex”
has been moved into
\sphinxcode{\sphinxupquote{gfm\_mex.c}}.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh.cc}}, \sphinxcode{\sphinxupquote{gf\_mesh\_get.cc}}, \sphinxcode{\sphinxupquote{gf\_mesh\_set.cc}},
\sphinxcode{\sphinxupquote{gf\_fem.cc}}, etc.

All the functions exported be the getfem interfaces, sorted by object type
(\sphinxcode{\sphinxupquote{gf\_mesh*}}, \sphinxcode{\sphinxupquote{gf\_mesh\_fem*}}, \sphinxcode{\sphinxupquote{gf\_fem*}}), and then organized as one for
the object construction (\sphinxcode{\sphinxupquote{gf\_mesh}}), one for the object modification
(\sphinxcode{\sphinxupquote{gf\_mesh\_set}}), and one for the object inquiry (\sphinxcode{\sphinxupquote{gf\_mesh\_get}}). Each of
these files contain one main function, that receives a \sphinxcode{\sphinxupquote{mexargs\_in}} and
\sphinxcode{\sphinxupquote{mexargs\_out}} stack of arguments. It parses then, and usually interprets the
first argument as the name of a subfunction (\sphinxcode{\sphinxupquote{gf\_mesh\_get(\textquotesingle{}nbpts\textquotesingle{})}} in
matlab, or \sphinxcode{\sphinxupquote{Mesh.nbpts()}} in python).

\item {} 
\sphinxcode{\sphinxupquote{matlab/gfm\_rpx\_mexint.c}}.

An alternative to \sphinxcode{\sphinxupquote{gfm\_mex.c}} which is used when the
\sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}matlab\sphinxhyphen{}rpc}} is passed to the \sphinxcode{\sphinxupquote{./configure}} script. The main use
for that is debugging the interface, since in that case, the matlab interface
communicates via sockets with a “getfem\_server” program, so it is possible to
debug that server program, and identify memory leaks or anything else without
having to mess with matlab (it is pain to debug).

\item {} 
\sphinxcode{\sphinxupquote{python/getfem.py}}.

The python interface is available as a “\sphinxcode{\sphinxupquote{getfem.py}}” file which is
produced during compilation by the python script
“\sphinxcode{\sphinxupquote{bin/extract\_doc.py}}”.

\end{itemize}


\subsection{Objects, methods and functions of the interface}
\label{\detokenize{project/libdesc_interface:objects-methods-and-functions-of-the-interface}}
The main concepts manipulated by the interface are a limited number of objects
(Fem, Mesh, MeshFem, Model …), the associated methods and some functions defined on these objects.

A special effort has been done to facilitate the addition of new objects, methods and functions to the interface without doing it separately for each part supported script language (Python, Scilab, Octave, Matlab).

All the information needed to build the interface for the different objects, methods and functions is contained in the files \sphinxtitleref{interface/src/gf*.cc}. A python script (\sphinxtitleref{bin/extract\_doc}) produces all the necessary files from the information it takes there. In particular, it produces the python file getfem.py, the matlab m\sphinxhyphen{}files for the different functions and objects (including subdirectories) and it also produces the automatic documentations.

To make all the things work automatically, a certain number of rules have to be respected:
\begin{itemize}
\item {} 
An object have to be defined by three files on the interface
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{gf\_objectname.cc}} : contains the constructors of the object

\item {} 
\sphinxcode{\sphinxupquote{gf\_objectname\_get.cc}} : contains the methods which only get some information about the object (if any).

\item {} 
\sphinxcode{\sphinxupquote{gf\_objectname\_set.cc}} : contains the methods which transform the object (if any).

\end{itemize}

\item {} 
A list of function is defined by only one file \sphinxcode{\sphinxupquote{gf\_commandname.cc}}.
It contains a list of sub\sphinxhyphen{}commands.

\item {} 
For each file, the main commentary on the list of functions or methods is delimited by the tags ‘/\sphinxstyleemphasis{@GFDOC’ and ‘@}/’. For a file corresponding to the constructors of an object, the commentary should correspond to the description of the object.

\item {} 
Each non trivial file gf\_*.cc contains a macro allowing to define the
methods of the object or the sub\sphinxhyphen{}commands. In particular, this system
allows to have a efficient search of the called method/function.
This macro allows to declare
a new method/function with the following syntax:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*@GET val = (\PYGZsq{}method\PYGZhy{}name\PYGZsq{}, params, ...)}
\PYG{c+cm}{   Documention of the method/function.}
\PYG{c+cm}{@*/}
\PYG{n}{sub\PYGZus{}command}
\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{method\PYGZhy{}name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
  \PYG{n}{body} \PYG{n}{of} \PYG{n}{the} \PYG{n}{method}\PYG{o}{/}\PYG{n}{function}
  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The first three line are a c++ commentary which describes the call of the
method/function with a special syntax and also gives a description of the
method/function which will be included in the documentations. The first
line of this commentary is important since it will be analyzed to produce
the right interface for Python, Octave, Matlab and Scilab.

The syntax for the description of the call of a method/function is the
following: After \sphinxcode{\sphinxupquote{/*@}} a special keyword should be present. It is either
\sphinxcode{\sphinxupquote{INIT}}, \sphinxcode{\sphinxupquote{GET}}, \sphinxcode{\sphinxupquote{SET}}, \sphinxcode{\sphinxupquote{RDATTR}} or \sphinxcode{\sphinxupquote{FUNC}}. The keyword
\sphinxcode{\sphinxupquote{INIT}} means that
this is the description of a constructor of an object. \sphinxcode{\sphinxupquote{RDATTR}} is for
a short method allowing to get an attribute of an object. \sphinxcode{\sphinxupquote{GET}} is for a
method of an object which does not modify it. \sphinxcode{\sphinxupquote{SET}} is for a method which
modifies an object and \sphinxcode{\sphinxupquote{FUNC}} is for the sub\sphinxhyphen{}command of a function list.

If the method/function returns a value, then a name for the return value
is given (which is arbitrary) followed by \sphinxcode{\sphinxupquote{=}}.

The parameters of the method/function are described. For a method, the
object itself is not mentionned. The first parameter should be the method
or sub\sphinxhyphen{}command name between single quotes (a special case is when
this name begins with a dot; this means that it corresponds to a
method/function where the command name is not required).

The other parameters, if any, should be declared with a type. Predefined
types are the following:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{@CELL}}   : a cell array,

\item {} 
\sphinxcode{\sphinxupquote{@imat}}   : matrix of integers,

\item {} 
\sphinxcode{\sphinxupquote{@ivec}}   : vector of integers,

\item {} 
\sphinxcode{\sphinxupquote{@cvec}}   : vector of complex values,

\item {} 
\sphinxcode{\sphinxupquote{@dcvec}}  : vector of complex values,

\item {} 
\sphinxcode{\sphinxupquote{@dvec}}   : vector of real values,

\item {} 
\sphinxcode{\sphinxupquote{@vec}}    : vector of real or complex values,

\item {} 
\sphinxcode{\sphinxupquote{@dmat}}   : matrix of real values,

\item {} 
\sphinxcode{\sphinxupquote{@mat}}    : matrix of real or complex values,

\item {} 
\sphinxcode{\sphinxupquote{@str}}    : a string,

\item {} 
\sphinxcode{\sphinxupquote{@int}}    : an integer,

\item {} 
\sphinxcode{\sphinxupquote{@bool}}   : a boolean,

\item {} 
\sphinxcode{\sphinxupquote{@real}}   : a real value,

\item {} 
\sphinxcode{\sphinxupquote{@scalar}} : a real or complex value,

\item {} 
\sphinxcode{\sphinxupquote{@list}}   : a list.

\end{itemize}

Moreover, \sphinxcode{\sphinxupquote{@tobj}} refers to an object defined by the interface.
For instance, ou can refer to \sphinxcode{\sphinxupquote{@tmesh}}, \sphinxcode{\sphinxupquote{@tmesh\_fem}}, \sphinxcode{\sphinxupquote{@tfem}}, etc.
There are some authorized abbreviations:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{@tcs}}  for  \sphinxcode{\sphinxupquote{@tcont\_struct}}

\item {} 
\sphinxcode{\sphinxupquote{@tmf}}  for  \sphinxcode{\sphinxupquote{@tmesh\_fem}}

\item {} 
\sphinxcode{\sphinxupquote{@tgt}}  for  \sphinxcode{\sphinxupquote{@tgeotrans}}

\item {} 
\sphinxcode{\sphinxupquote{@tgf}}  for  \sphinxcode{\sphinxupquote{@tglobal\_function}}

\item {} 
\sphinxcode{\sphinxupquote{@tmo}}  for  \sphinxcode{\sphinxupquote{@tmesher\_object}}

\item {} 
\sphinxcode{\sphinxupquote{@tmls}}  for  \sphinxcode{\sphinxupquote{@tmesh\_levelset}}

\item {} 
\sphinxcode{\sphinxupquote{@tmim}}  for  \sphinxcode{\sphinxupquote{@tmesh\_im}}

\item {} 
\sphinxcode{\sphinxupquote{@tls}}  for  \sphinxcode{\sphinxupquote{@tlevelset}}

\item {} 
\sphinxcode{\sphinxupquote{@tsl}}  for  \sphinxcode{\sphinxupquote{@tslice}}

\item {} 
\sphinxcode{\sphinxupquote{@tsp}}  for  \sphinxcode{\sphinxupquote{@tspmat}}

\item {} 
\sphinxcode{\sphinxupquote{@tpre}}  for  \sphinxcode{\sphinxupquote{@tprecond}}

\end{itemize}

Three dots at the end of the parameter list (\sphinxcode{\sphinxupquote{...}}) mean that
additional parameters are possible. Optional parameters can be described
with brackets. For instance \sphinxcode{\sphinxupquote{/*@SET v = (\textquotesingle{}name\textquotesingle{}{[}, @int i{]})}}. But
be careful how it is interpreted by the \sphinxcode{\sphinxupquote{extract\_doc}} script
to build the python interface.

The second to fifth parameters of the macro correspond respectively to
the minimum number of input arguments, the maximum one, the minimum
number of output arguments and the maximum number of output arguments. It
is dynamically verified.

Additional parameters for the function lists ….

For unknown reasons, the body of the function cannot contain multiple
declarations such as \sphinxcode{\sphinxupquote{int a, b;}} (c++ believes that it is an additional
parameter of the macro).

\end{itemize}
\begin{itemize}
\item {} 
The parts of documentation included in the c++ commentaries should be in
\sphinxhref{http://docutils.sourceforge.net/rst.html}{reStructuredText} format. In particular, math formulas can be included
with :math:\textasciigrave{}f(x) = 3x\textasciicircum{}2+2x+4\textasciigrave{} or with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{.}\PYG{p}{.} \PYG{n}{math}\PYG{o}{:}\PYG{o}{:}

  \PYG{n}{f}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{n}{x}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{n}{x}\PYG{o}{+}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

It is possible to refer to another method or function of the interface
with the syntax \sphinxcode{\sphinxupquote{INIT::OBJNAME(\textquotesingle{}method\sphinxhyphen{}name\textquotesingle{}, ...)}},
\sphinxcode{\sphinxupquote{GET::OBJNAME(\textquotesingle{}method\sphinxhyphen{}name\textquotesingle{}, ...)}}, \sphinxcode{\sphinxupquote{SET::OBJNAME(\textquotesingle{}method\sphinxhyphen{}name\textquotesingle{}, ...)}},
\sphinxcode{\sphinxupquote{FUNC::FUNCNAME(\textquotesingle{}subcommand\sphinxhyphen{}name\textquotesingle{}, ...)}}. This will be replaced with
the right syntax depending on the language (Octave, Matlab, Scilab or Python).

\item {} 
Still in the documentations, parts for a specific language can be added by
\sphinxcode{\sphinxupquote{@MATLAB\{specific part ...\}}}, \sphinxcode{\sphinxupquote{@SCILAB\{specific part ...\}}} and
\sphinxcode{\sphinxupquote{@PYTHON\{specific part ...\}}}.
If a method/sub\sphinxhyphen{}command is specific to an interface, it can be added,
for instance for Matlab,
replacing \sphinxtitleref{GET} by \sphinxtitleref{MATLABGET}, \sphinxtitleref{FUNC} by \sphinxtitleref{MATLABFUNC}, etc.
If a specific code is needed for this additional function, it can be added
with the tags \sphinxcode{\sphinxupquote{/*@MATLABEXT}}, \sphinxcode{\sphinxupquote{/*@SCILABEXT}}, \sphinxcode{\sphinxupquote{/*@PYTHONEXT}}. See
for instance the file \sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get.cc}}.

\item {} 
For Python and the Matlab object, if a \sphinxtitleref{SET} method has the same name as
a \sphinxtitleref{GET} method, the \sphinxtitleref{SET} method is prefixed by \sphinxtitleref{set\_}.

\end{itemize}


\subsection{Adding a new function or object method to the getfem interface}
\label{\detokenize{project/libdesc_interface:adding-a-new-function-or-object-method-to-the-getfem-interface}}
If one want to add a new function \sphinxcode{\sphinxupquote{gf\_mesh\_get(m, "foobar", .)}}, then the
main file to modify is \sphinxcode{\sphinxupquote{gf\_mesh\_get.cc}}. Remember to check every argument
passed to the function in order to make sure that the user cannot crash Scilab, Octave, Matlab or Python when using that function. Use the macro defined in \sphinxcode{\sphinxupquote{gf\_mesh\_get.cc}} to add your function.

Do not forget to add documentation for that function: in \sphinxcode{\sphinxupquote{gf\_mesh\_get.cc}},
this is the documentation that appears in the Octave/Matlab/Scilab/Python help files (that is when on
type “\sphinxcode{\sphinxupquote{help gf\_mesh\_get}}” at the matlab prompt), and in the getfem\_python
autogenerated documentation.

IMPORTANT. Note that the array indices start at 0 in Python and 1 in Octave, Matlab and Scilab. A specific function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{config}\PYG{o}{:}\PYG{o}{:}\PYG{n}{base\PYGZus{}index}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

whose value is 0 in python and 1 in Octave, Matlab and Scilab has to be used to exchange indices and array of indices. Take care not to make the correction twice. Some Array of indices are automatically shifted.


\subsection{Adding a new object to the getfem interface}
\label{\detokenize{project/libdesc_interface:adding-a-new-object-to-the-getfem-interface}}
In order to add a new object to the interface, you have to build the new corresponding sources \sphinxcode{\sphinxupquote{gf\_obj.cc}}, \sphinxcode{\sphinxupquote{gf\_obj\_get.cc}} and \sphinxcode{\sphinxupquote{gf\_obj\_set.cc}}. Of course you can take the existing ones as a model.

For the management of the object, you have to declare the class at the begining of \sphinxcode{\sphinxupquote{getfemint.h}} (with respect to the alphabetic order), and declare three functions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{bool} \PYG{n}{is\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZdq{}}\PYG{n}{\PYGZus{}object}\PYG{p}{(}\PYG{k}{const} \PYG{n}{mexarg\PYGZus{}in} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{id\PYGZus{}type} \PYG{n}{store\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZdq{}}\PYG{n}{\PYGZus{}object}\PYG{p}{(}\PYG{k}{const} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{shared\PYGZus{}ptr}\PYG{o}{\PYGZlt{}}\PYG{n}{object\PYGZus{}class}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{shp}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{object\PYGZus{}class} \PYG{o}{*}\PYG{n}{to\PYGZus{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZdq{}}\PYG{n}{\PYGZus{}object}\PYG{p}{(}\PYG{k}{const} \PYG{n}{mexarg\PYGZus{}in} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

where “name” is the name of the object in the interface and \sphinxcode{\sphinxupquote{object\_class}} is the class name in getfem (for instance  \sphinxcode{\sphinxupquote{getfem::mesh}} for the mesh object). Alternatively, for the object that are manipulated by a shared pointer in \sphinxstyleemphasis{GetFEM}, the third function can return a shared pointer.

IMPORTANT: In order to be interfaced, a \sphinxstyleemphasis{GetFEM} object has to derive from \sphinxcode{\sphinxupquote{dal::static\_stored\_object}}. However, if it is not the case, a wrapper class can be defined such as the one for \sphinxcode{\sphinxupquote{bgeot::base\_poly}} (see the end of \sphinxcode{\sphinxupquote{getfemint.h}}).

The previous three functions have to be implemented at the end of \sphinxcode{\sphinxupquote{getfemint.cc}}.It is possible to use one of the two macros defined in \sphinxcode{\sphinxupquote{getfemint.cc}}. The first macro is for a standard object and the second one for an object which is manipulated in \sphinxstyleemphasis{GetFEM} with a shared pointer.

You have also to complete functions \sphinxcode{\sphinxupquote{name\_of\_getfemint\_class\_id}} and \sphinxcode{\sphinxupquote{class\_id\_of\_object}} at the end of \sphinxcode{\sphinxupquote{getfemint.cc}}.

You have to add the call of the interface function in \sphinxcode{\sphinxupquote{getfem\_interface.cc}} and modifiy the file \sphinxcode{\sphinxupquote{bin/extract\_doc}} and run the configure file.

The methods \sphinxcode{\sphinxupquote{get(\textquotesingle{}char\textquotesingle{})}} and \sphinxcode{\sphinxupquote{get(\textquotesingle{}display\textquotesingle{})}} should be defined for each object. The first one should give a string allowing the object to be saved in a file and the second one is to give some information about the object. Additionaly, a constructor from a string is necessary to load the object from a file.

For the Scilab interface the file \sphinxcode{\sphinxupquote{sci\_gateway/c/builder\_gateway\_c.sce.in}} has to be modified and the files in the directory \sphinxcode{\sphinxupquote{macros/overload}}.


\subsection{State}
\label{\detokenize{project/libdesc_interface:state}}

\subsection{Perspectives}
\label{\detokenize{project/libdesc_interface:perspectives}}
The interface grows in conjunction with \sphinxstyleemphasis{GetFEM}. The main \sphinxstyleemphasis{GetFEM} functionalities are interfaced.


\chapter{Appendix A. Some basic computations between reference and real elements}
\label{\detokenize{project/appendixA:appendix-a-some-basic-computations-between-reference-and-real-elements}}\label{\detokenize{project/appendixA:dp-appendixa}}\label{\detokenize{project/appendixA::doc}}

\section{Volume integral}
\label{\detokenize{project/appendixA:volume-integral}}
One has
\begin{equation*}
\begin{split}\int_T f(x)\ dx = \int_{\widehat{T}} \widehat{f}(\widehat{x})
|\mbox{vol}\left(
\frac{\partial\tau(\widehat{x})}{\partial \widehat{x}_0};
\frac{\partial\tau(\widehat{x})}{\partial \widehat{x}_1};
\ldots;
\frac{\partial\tau(\widehat{x})}{\partial \widehat{x}_{P-1}}
\right)|\ d\widehat{x}.\end{split}
\end{equation*}
Denoting \(J_{\tau}(\widehat{x})\) the jacobian
\begin{equation*}
\begin{split}\fbox{$ J_{\tau}(\widehat{x}) :=
|\mbox{vol}\left(
\frac{\partial\tau(\widehat{x})}{\partial \widehat{x}_0};
\frac{\partial\tau(\widehat{x})}{\partial \widehat{x}_1};
\ldots;
\frac{\partial\tau(\widehat{x})}{\partial \widehat{x}_{P-1}}
\right)| =
(\mbox{det}(K(\widehat{x})^T K(\widehat{x})))^{1/2}$,}\end{split}
\end{equation*}
one finally has
\begin{equation*}
\begin{split}\fbox{$\int_T f(x)\ dx = \int_{\widehat{T}} \widehat{f}(\widehat{x}) J_{\tau}(\widehat{x})\ d\widehat{x}$.}\end{split}
\end{equation*}
When \(P = N\), the expression of the jacobian reduces to \(J_{\tau}(\widehat{x})
= |\mbox{det}(K(\widehat{x}))|\).


\section{Surface integral}
\label{\detokenize{project/appendixA:surface-integral}}
With \(\Gamma\) a part of the boundary of \(T\) a real element and
\(\widehat{\Gamma}\) the corresponding boundary on the reference element \(\widehat{T}\),
one has
\begin{equation*}
\begin{split}\fbox{$\int_{\Gamma} f(x)\ d\sigma =
\int_{\widehat{\Gamma}}\widehat{f}(\widehat{x}) \|B(\widehat{x})\widehat{n}\| J_{\tau}(\widehat{x})\ d\widehat{\sigma}$,}\end{split}
\end{equation*}
where \(\widehat{n}\) is the unit normal to \(\widehat{T}\) on \(\widehat{\Gamma}\). In a same
way
\begin{equation*}
\begin{split}\fbox{$\int_{\Gamma} F(x)\cdot n\ d\sigma =
\int_{\widehat{\Gamma}} \widehat{F}(\widehat{x})\cdot(B(\widehat{x})\cdot\widehat{n}) J_{\tau}(\widehat{x})\ d\widehat{\sigma}$,}\end{split}
\end{equation*}
For \(n\) the unit normal to \(T\) on \(\Gamma\).


\section{Derivative computation}
\label{\detokenize{project/appendixA:derivative-computation}}
One has
\begin{equation*}
\begin{split}\nabla f(x) = B(\widehat{x})\widehat{\nabla} \widehat{f}(\widehat{x}).\end{split}
\end{equation*}

\section{Second derivative computation}
\label{\detokenize{project/appendixA:second-derivative-computation}}
Denoting
\begin{equation*}
\begin{split}\nabla^2 f =
\left[\frac{\partial^2 f}{\partial x_i \partial x_j}\right]_{ij},\end{split}
\end{equation*}
the \(N \times N\) matrix and
\begin{equation*}
\begin{split}\widehat{X}(\widehat{x}) =
\sum_{k = 0}^{N-1}\widehat{\nabla}^2\tau_k(\widehat{x})\frac{\partial f}{\partial x_k}(x) =
\sum_{k = 0}^{N-1}\sum_{i = 0}^{P-1}
\widehat{\nabla}^2\tau_k(\widehat{x})B_{ki}\frac{\partial \widehat{f}}{\partial \widehat{x}_i}(\widehat{x}),\end{split}
\end{equation*}
the \(P \times P\) matrix, then
\begin{equation*}
\begin{split}\widehat{\nabla}^2 \widehat{f}(\widehat{x}) = \widehat{X}(\widehat{x}) + K(\widehat{x})^T \nabla^2 f(x) K(\widehat{x}),\end{split}
\end{equation*}
and thus
\begin{equation*}
\begin{split}\nabla^2 f(x) = B(\widehat{x})(\widehat{\nabla}^2 \widehat{f}(\widehat{x}) - \widehat{X}(\widehat{x})) B(\widehat{x})^T.\end{split}
\end{equation*}
In order to have uniform methods for the computation of elementary matrices, the
Hessian is computed as a column vector \(H f\) whose components are
\(\frac{\partial^2 f}{\partial x^2_0}, \frac{\partial^2 f}{\partial
x_1\partial x_0},\ldots, \frac{\partial^2 f}{\partial x^2_{N-1}}\). Then, with
\(B_2\) the \(P^2 \times P\) matrix defined as
\begin{equation*}
\begin{split}\left[B_2(\widehat{x})\right]_{ij} =
\sum_{k = 0}^{N-1}
\frac{\partial^2 \tau_k(\widehat{x})}{\partial \widehat{x}_{i / P} \partial \widehat{x}_{i\mbox{ mod }P}}
B_{kj}(\widehat{x}),\end{split}
\end{equation*}
and \(B_3\) the \(N^2 \times P^2\) matrix defined as
\begin{equation*}
\begin{split}\left[B_3(\widehat{x})\right]_{ij} =
B_{i / N, j / P}(\widehat{x}) B_{i\mbox{ mod }N, j\mbox{ mod }P}(\widehat{x}),\end{split}
\end{equation*}
one has
\begin{equation*}
\begin{split}\fbox{$H f(x) = B_3(\widehat{x})
\left(\widehat{H}\ \widehat{f}(\widehat{x}) - B_2(\widehat{x})\widehat{\nabla} \widehat{f}(\widehat{x})\right)$.}\end{split}
\end{equation*}

\section{Example of elementary matrix}
\label{\detokenize{project/appendixA:example-of-elementary-matrix}}
Assume one needs to compute the elementary “matrix”:
\begin{equation*}
\begin{split}t(i_0, i_1, \ldots, i_7) =
\int_{T}\varphi_{i_1}^{i_0}
\partial_{i_4}\varphi_{i_3}^{i_2}
\partial^2_{i_7/ P, i_7\mbox{ mod } P}\varphi_{i_6}^{i_5}\ dx,\end{split}
\end{equation*}
The computations to be made on the reference elements are
\begin{equation*}
\begin{split}\widehat{t}_0(i_0, i_1, \ldots,i_7) =
\int_{\widehat{T}}(\widehat{\varphi})_{i_1}^{i_0}
\partial_{i_4}(\widehat{\varphi})_{i_3}^{i_2}
\partial^2_{i_7 / P, i_7\mbox{ mod } P}(\widehat{\varphi})_{i_6}^{i_5} J(\widehat{x})\ d\widehat{x},\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}\widehat{t}_1(i_0, i_1, \ldots, i_7) =
\int_{\widehat{T}}(\widehat{\varphi})_{i_1}^{i_0}
\partial_{i_4}(\widehat{\varphi})_{i_3}^{i_2}
\partial_{i_7}(\widehat{\varphi})_{i_6}^{i_5} J(\widehat{x})\ d\widehat{x},\end{split}
\end{equation*}
Those two tensor can be computed once on the whole reference element if the
geometric transformation is linear (because \(J(\widehat{x})\) is constant). If the
geometric transformation is non\sphinxhyphen{}linear, what has to be stored is the value on
each integration point. To compute the integral on the real element a certain
number of reductions have to be made:
\begin{itemize}
\item {} 
Concerning the first term (\(\varphi_{i_1}^{i_0}\)) nothing.

\item {} 
Concerning the second term (\(\partial_{i_4}\varphi_{i_3}^{i_2}\)) a
reduction with respect to \(i_4\) with the matrix \(B\).

\item {} 
Concerning the third term (\(\partial^2_{i_7 / P, i_7\mbox{ mod }P}
\varphi_{i_6}^{i_5}\)) a reduction of \(\widehat{t}_0\) with respect to \(i_7\)
with the matrix \(B_3\) and a reduction of \(\widehat{t}_1\) with respect also
to \(i_7\) with the matrix \(B_3 B_2\)

\end{itemize}

The reductions are to be made on each integration point if the geometric
transformation is non\sphinxhyphen{}linear. Once those reductions are done, an addition of all
the tensor resulting of those reductions is made (with a factor equal to the load
of each integration point if the geometric transformation is non\sphinxhyphen{}linear).

If the finite element is non\sphinxhyphen{}\(\tau\)\sphinxhyphen{}equivalent, a supplementary reduction of the
resulting tensor with the matrix \(M\) has to be made.


\chapter{References}
\label{\detokenize{biblio:references}}\label{\detokenize{biblio:id1}}\label{\detokenize{biblio::doc}}
\begin{sphinxthebibliography}{Encyclop}
\bibitem[AB\sphinxhyphen{}ER\sphinxhyphen{}PI2018]{biblio:ab-er-pi2018}
M. Abbas, A. Ern, N. Pignet.
\sphinxstyleemphasis{Hybrid High\sphinxhyphen{}Order methods for finite deformations of hyperelastic materials}.
Computational Mechanics, 62(4), 909\sphinxhyphen{}928, 2018.
\bibitem[AB\sphinxhyphen{}ER\sphinxhyphen{}PI2019]{biblio:ab-er-pi2019}
M. Abbas, A. Ern, N. Pignet.
\sphinxstyleemphasis{A Hybrid High\sphinxhyphen{}Order method for incremental associative plasticity with small deformations}.
Computer Methods in Applied Mechanics and Engineering, 346, 891\sphinxhyphen{}912, 2019.
\bibitem[AL\sphinxhyphen{}CU1991]{biblio:al-cu1991}
P. Alart, A. Curnier.
\sphinxstyleemphasis{A mixed formulation for frictional contact problems prone to newton like solution methods}. Comput. Methods Appl. Mech. Engrg. 92, 353\textendash{}375, 1991.
\bibitem[Al\sphinxhyphen{}Ge1997]{biblio:al-ge1997}
E.L. Allgower and K. Georg.
\sphinxstyleemphasis{Numerical Path Following}, Handbook of Numerical Analysis, Vol. V (P.G. Ciarlet and J.L. Lions, eds.). Elsevier, pp. 3\sphinxhyphen{}207, 1997.
\bibitem[AM\sphinxhyphen{}MO\sphinxhyphen{}RE2014]{biblio:am-mo-re2014}
S. Amdouni, M. Moakher, Y. Renard,
\sphinxstyleemphasis{A local projection stabilization of fictitious domain method for elliptic boundary value problems}. Appl. Numer. Math., 76:60\sphinxhyphen{}75, 2014.
\bibitem[AM\sphinxhyphen{}MO\sphinxhyphen{}RE2014b]{biblio:am-mo-re2014b}
S. Amdouni, M. Moakher, Y. Renard.
\sphinxstyleemphasis{A stabilized Lagrange multiplier method for the enriched finite element approximation of Tresca contact problems of cracked elastic bodies}. Comput. Methods Appl. Mech. Engrg., 270:178\sphinxhyphen{}200, 2014.
\bibitem[bank1983]{biblio:bank1983}
R.E. Bank, A.H. Sherman, A. Weiser.
\sphinxstyleemphasis{Refinement algorithms and data structures for regular local mesh refinement}. In Scientific Computing IMACS, Amsterdam, North\sphinxhyphen{}Holland, pp 3\sphinxhyphen{}17, 1983.
\bibitem[ba\sphinxhyphen{}dv1985]{biblio:ba-dv1985}
K.J. Bathe, E.N. Dvorkin,
\sphinxstyleemphasis{A four\sphinxhyphen{}node plate bending element based on Mindlin\sphinxhyphen{}Reissner plate theory and a mixed interpolation}. Internat. J. Numer. Methods Engrg., 21, 367\sphinxhyphen{}383, 1985.
\bibitem[Be\sphinxhyphen{}Mi\sphinxhyphen{}Mo\sphinxhyphen{}Bu2005]{biblio:be-mi-mo-bu2005}
Bechet E, Minnebo H, Moës N, Burgardt B.
\sphinxstyleemphasis{Improved implementation and robustness study of the X\sphinxhyphen{}FEM for stress analysis around cracks}.
Internat. J. Numer. Methods Engrg., 64, 1033\sphinxhyphen{}1056, 2005.
\bibitem[BE\sphinxhyphen{}CO\sphinxhyphen{}DU2010]{biblio:be-co-du2010}
M. Bergot, G. Cohen, M. Duruflé.
\sphinxstyleemphasis{Higher\sphinxhyphen{}order finite elements for hybrid meshes using new nodal pyramidal elements}
J. Sci. Comput., 42, 345\sphinxhyphen{}381, 2010.
\bibitem[br\sphinxhyphen{}ba\sphinxhyphen{}fo1989]{biblio:br-ba-fo1989}
F. Brezzi, K.J. Bathe, M. Fortin.
\sphinxstyleemphasis{Mixed\sphinxhyphen{}interpolated element for Reissner\sphinxhyphen{}Mindlin plates}. Internat. J. Numer. Methods Engrg., 28, 1787\sphinxhyphen{}1801, 1989.
\bibitem[bu\sphinxhyphen{}ha2010]{biblio:bu-ha2010}
E. Burman, P. Hansbo.
\sphinxstyleemphasis{Fictitious domain finite element methods using cut elements: I. A stabilized Lagrange multiplier method}. Computer Methods in Applied Mechanics, 199:41\sphinxhyphen{}44, 2680\sphinxhyphen{}2686, 2010.
\bibitem[ca\sphinxhyphen{}re\sphinxhyphen{}so1994]{biblio:ca-re-so1994}
D. Calvetti, L. Reichel and D.C. Sorensen.
\sphinxstyleemphasis{An implicitly restarted Lanczos method for large symmetric eigenvalue problems}. Electronic Transaction on Numerical Analysis\}. 2:1\sphinxhyphen{}21, 1994.
\bibitem[ca\sphinxhyphen{}ch\sphinxhyphen{}er2019]{biblio:ca-ch-er2019}
K. Cascavita, F. Chouly and A. Ern
\sphinxstyleemphasis{Hybrid High\sphinxhyphen{}Order discretizations combined with Nitsche’s method for Dirichlet and Signorini boundary conditions}.
hal\sphinxhyphen{}02016378v2, 2019
\bibitem[CH\sphinxhyphen{}LA\sphinxhyphen{}RE2008]{biblio:ch-la-re2008}
E. Chahine, P. Laborde, Y. Renard.
\sphinxstyleemphasis{Crack\sphinxhyphen{}tip enrichment in the Xfem method using a cut\sphinxhyphen{}off function}. Int. J. Numer. Meth. Engng., 75(6):629\sphinxhyphen{}646, 2008.
\bibitem[CH\sphinxhyphen{}LA\sphinxhyphen{}RE2011]{biblio:ch-la-re2011}
E. Chahine, P. Laborde, Y. Renard.
\sphinxstyleemphasis{A non\sphinxhyphen{}conformal eXtended Finite Element approach: Integral matching Xfem}. Applied Numerical Mathematics, 61:322\sphinxhyphen{}343, 2011.
\bibitem[ciarlet1978]{biblio:ciarlet1978}
P.G. Ciarlet.
\sphinxstyleemphasis{The finite element method for elliptic problems}. Studies in Mathematics and its Applications vol. 4, North\sphinxhyphen{}Holland, 1978.
\bibitem[ciarlet1988]{biblio:ciarlet1988}
P.G. Ciarlet.
\sphinxstyleemphasis{Mathematical Elasticity}. Volume 1: Three\sphinxhyphen{}Dimensional Elasticity. North\sphinxhyphen{}Holland, 1988.
\bibitem[EncyclopCubature]{biblio:encyclopcubature}
R. Cools, \sphinxhref{http://www.cs.kuleuven.ac.be/~ines/research/ecf/ecf.html}{An Encyclopedia of Cubature Formulas}, J. Complexity.
\bibitem[Dh\sphinxhyphen{}Go\sphinxhyphen{}Ku2003]{biblio:dh-go-ku2003}
A. Dhooge, W. Govaerts and Y. A. Kuznetsov.
\sphinxstyleemphasis{MATCONT: A MATLAB Package for Numerical Bifurcation Analysis of ODEs}.
ACM Trans. Math. Software 31, 141\sphinxhyphen{}164, 2003.
\bibitem[Di\sphinxhyphen{}Er2015]{biblio:di-er2015}
D.A. Di Pietro, A. Ern.
\sphinxstyleemphasis{A hybrid high\sphinxhyphen{}order locking free method for linear elasticity on general meshes}.
Comput. Methods Appl. Mech. Engrg., 283:1\sphinxhyphen{}21, 2015
\bibitem[Di\sphinxhyphen{}Er2017]{biblio:di-er2017}
D.A. Di Pietro, A. Ern.
\sphinxstyleemphasis{Arbitrary\sphinxhyphen{}order mixed methods for heterogeneous anisotropic diffusion on general meshes}.
IMA Journal of Numerical Analysis, 37(1), 40\sphinxhyphen{}63. 2017
\bibitem[Duan2014]{biblio:duan2014}
H. Duan.
\sphinxstyleemphasis{A finite element method for Reissner\sphinxhyphen{}Mindlin plates}.
Math. Comp., 83:286, 701\sphinxhyphen{}733, 2014.
\bibitem[Dr\sphinxhyphen{}La\sphinxhyphen{}Ek2014]{biblio:dr-la-ek2014}
A. Draganis, F. Larsson, A. Ekberg.
\sphinxstyleemphasis{Finite element analysis of transient thermomechanical rolling contact using
an efficient arbitrary Lagrangian\sphinxhyphen{}Eulerian description}.
Comput. Mech., 54, 389\sphinxhyphen{}405, 2014.
\bibitem[Fa\sphinxhyphen{}Po\sphinxhyphen{}Re2015]{biblio:fa-po-re2015}
M. Fabre, J. Pousin, Y. Renard.
\sphinxstyleemphasis{A fictitious domain method for frictionless contact problems in elasticity using Nitsche’s method}. preprint, \sphinxurl{https://hal.archives-ouvertes.fr/hal-00960996v1}
\bibitem[Fa\sphinxhyphen{}Pa2003]{biblio:fa-pa2003}
F. Facchinei and J.\sphinxhyphen{}S. Pang.
\sphinxstyleemphasis{Finite\sphinxhyphen{}Dimensional Variational Inequalities and Complementarity Problems, Vol. II}.
Springer Series in Operations Research, Springer, New York, 2003.
\bibitem[Georg2001]{biblio:georg2001}
K. Georg.
\sphinxstyleemphasis{Matrix\sphinxhyphen{}free numerical continuation and bifurcation}. Numer. Funct. Anal. Optimization 22, 303\sphinxhyphen{}320, 2001.
\bibitem[GR\sphinxhyphen{}GH1999]{biblio:gr-gh1999}
R.D. Graglia, I.\sphinxhyphen{}L. Gheorma.
\sphinxstyleemphasis{Higher order interpolatory vector bases on pyramidal elements}
IEEE transactions on antennas and propagation, 47:5, 775\sphinxhyphen{}782, 1999.
\bibitem[GR\sphinxhyphen{}ST2015]{biblio:gr-st2015}
D. Grandi, U. Stefanelli.
\sphinxstyleemphasis{The Souza\sphinxhyphen{}Auricchio model for shape\sphinxhyphen{}memory alloys}
Discrete and Continuous Dynamical Systems, Series S, 8(4):723\sphinxhyphen{}747, 2015.
\bibitem[HA\sphinxhyphen{}WO2009]{biblio:ha-wo2009}
C. Hager, B.I. Wohlmuth.
\sphinxstyleemphasis{Nonlinear complementarity functions for plasticity problems with frictional contact}. Comput. Methods Appl. Mech. Engrg., 198:3411\sphinxhyphen{}3427, 2009
\bibitem[HA\sphinxhyphen{}HA2004]{biblio:ha-ha2004}
A Hansbo, P Hansbo.
\sphinxstyleemphasis{A finite element method for the simulation of strong and weak discontinuities in solid mechanics}. Comput. Methods Appl. Mech. Engrg. 193 (33\sphinxhyphen{}35), 3523\sphinxhyphen{}3540, 2004.
\bibitem[HA\sphinxhyphen{}RE2009]{biblio:ha-re2009}
J. Haslinger, Y. Renard.
\sphinxstyleemphasis{A new fictitious domain approach inspired by the extended finite element method}. Siam J. on Numer. Anal., 47(2):1474\sphinxhyphen{}1499, 2009.
\bibitem[HI\sphinxhyphen{}RE2010]{biblio:hi-re2010}
Hild P., Renard Y.
\sphinxstyleemphasis{Stabilized lagrange multiplier method for the finite element approximation of contact problems in elastostatics}. Numer. Math. 15:1, 101\textendash{}129, 2010.
\bibitem[KH\sphinxhyphen{}PO\sphinxhyphen{}RE2006]{biblio:kh-po-re2006}
Khenous H., Pommier J., Renard Y.
\sphinxstyleemphasis{Hybrid discretization of the Signorini problem with Coulomb friction, theoretical aspects and comparison of some numerical solvers}. Applied Numerical Mathematics, 56/2:163\sphinxhyphen{}192, 2006.
\bibitem[KI\sphinxhyphen{}OD1988]{biblio:ki-od1988}
N. Kikuchi, J.T. Oden.
\sphinxstyleemphasis{Contact problems in elasticity}. SIAM, 1988.
\bibitem[LA\sphinxhyphen{}PO\sphinxhyphen{}RE\sphinxhyphen{}SA2005]{biblio:la-po-re-sa2005}
Laborde P., Pommier J., Renard Y., Salaun M.
\sphinxstyleemphasis{High order extended finite element method for cracked domains}. Int. J. Numer. Meth. Engng., 64:354\sphinxhyphen{}381, 2005.
\bibitem[LA\sphinxhyphen{}RE\sphinxhyphen{}SA2010]{biblio:la-re-sa2010}
J. Lasry, Y. Renard, M. Salaun.
\sphinxstyleemphasis{eXtended Finite Element Method for thin cracked plates with Kirchhoff\sphinxhyphen{}Love theory}. Int. J. Numer. Meth. Engng., 84(9):1115\sphinxhyphen{}1138, 2010.
\bibitem[KO\sphinxhyphen{}RE2014]{biblio:ko-re2014}
K. Poulios, Y. Renard,
\sphinxstyleemphasis{An unconstrained integral approximation of large sliding frictional contact between deformable solids}. Computers and Structures, 153:75\sphinxhyphen{}90, 2015.
\bibitem[LA\sphinxhyphen{}RE2006]{biblio:la-re2006}
P. Laborde, Y. Renard.
\sphinxstyleemphasis{Fixed point strategies for elastostatic frictional contact problems}. Math. Meth. Appl. Sci., 31:415\sphinxhyphen{}441, 2008.
\bibitem[Li\sphinxhyphen{}Re2014]{biblio:li-re2014}
T. Ligurský and Y. Renard.
\sphinxstyleemphasis{A Continuation Problem for Computing Solutions of Discretised Evolution Problems with Application to Plane Quasi\sphinxhyphen{}Static Contact Problems with Friction}. Comput. Methods Appl. Mech. Engrg. 280, 222\sphinxhyphen{}262, 2014.
\bibitem[Li\sphinxhyphen{}Re2014hal]{biblio:li-re2014hal}
T. Ligurský and Y. Renard.
\sphinxstyleemphasis{Bifurcations in Piecewise\sphinxhyphen{}Smooth Steady\sphinxhyphen{}State Problems: Abstract Study and Application to Plane Contact Problems with Friction}. Computational Mechanics, 56:1:39\sphinxhyphen{}62, 2015.
\bibitem[Li\sphinxhyphen{}Re2015hal]{biblio:li-re2015hal}
T. Ligurský and Y. Renard.
\sphinxstyleemphasis{A Method of Piecewise\sphinxhyphen{}Smooth Numerical Branching}. Z. Angew. Math. Mech., 97:7:815\textendash{}827, 2017.
\bibitem[Mi\sphinxhyphen{}Zh2002]{biblio:mi-zh2002}
P. Ming and Z. Shi,
\sphinxstyleemphasis{Optimal L2 error bounds for MITC3 type element}. Numer. Math. 91, 77\sphinxhyphen{}91, 2002.
\bibitem[Xfem]{biblio:xfem}
N. Moës, J. Dolbow and T. Belytschko,
\sphinxstyleemphasis{A finite element method for crack growth without remeshing}.
Internat. J. Numer. Methods Engrg., 46, 131\sphinxhyphen{}150, 1999.
\bibitem[Nackenhorst2004]{biblio:nackenhorst2004}
U. Nackenhorst,
\sphinxstyleemphasis{The ALE formulation of bodies in rolling contact. Theoretical foundation
and finite element approach}.
Comput. Methods Appl. Mech. Engrg., 193:4299\sphinxhyphen{}4322, 2004.
\bibitem[NI\sphinxhyphen{}RE\sphinxhyphen{}CH2011]{biblio:ni-re-ch2011}
S. Nicaise, Y. Renard, E. Chahine,
\sphinxstyleemphasis{Optimal convergence analysis for the eXtended Finite Element Method}. Int. J. Numer. Meth. Engng., 86:528\sphinxhyphen{}548, 2011.
\bibitem[Pantz2008]{biblio:pantz2008}
O. Pantz
\sphinxstyleemphasis{The Modeling of Deformable Bodies with Frictionless (Self\sphinxhyphen{})Contacts}. Archive for Rational Mechanics and Analysis, Volume 188, Issue 2, pp 183\sphinxhyphen{}212, 2008.
\bibitem[SCHADD]{biblio:schadd}
L.F. Pavarino.
\sphinxstyleemphasis{Domain decomposition algorithms for the p\sphinxhyphen{}version finite element method for elliptic problems}. Luca F. Pavarino. PhD thesis, Courant Institute of Mathematical Sciences\}. 1992.
\bibitem[PO\sphinxhyphen{}NI2016]{biblio:po-ni2016}
K. Poulios, C.F. Niordson,
\sphinxstyleemphasis{Homogenization of long fiber reinforced composites including fiber bending effects}. Journal of the Mechanics and Physics of Solids, 94, pp 433\sphinxhyphen{}452, 2016.
\bibitem[GetFEM2020]{biblio:getfem2020}
Y. Renard, K. Poulios
\sphinxstyleemphasis{GetFEM: Automated FE modeling of multiphysics problems based on a generic weak form language}. Preprint, \sphinxurl{https://hal.archives-ouvertes.fr/hal-02532422/document}
\bibitem[remacle2003]{biblio:remacle2003}
J.\sphinxhyphen{}F. Remacle, M.S. Shephard;
\sphinxstyleemphasis{An algorithm oriented mesh database}. International Journal for Numerical Methods in Engineering, 58:2, pp 349\sphinxhyphen{}374, 2003.
\bibitem[SE\sphinxhyphen{}PO\sphinxhyphen{}WO2015]{biblio:se-po-wo2015}
A. Seitz, A. Popp, W.A. Wall,
\sphinxstyleemphasis{A semi\sphinxhyphen{}smooth Newton method for orthotropic plasticity and frictional contact at finite strains}. Comput. Methods Appl. Mech. Engrg. 285:228\sphinxhyphen{}254, 2015.
\bibitem[SI\sphinxhyphen{}HU1998]{biblio:si-hu1998}
J.C. Simo, T.J.R. Hughes.
\sphinxstyleemphasis{Computational Inelasticity}. Interdisciplinary Applied Mathematics, vol 7, Springer, New York 1998.
\bibitem[SO\sphinxhyphen{}PE\sphinxhyphen{}OW2008]{biblio:so-pe-ow2008}
E.A. de Souza Neto, D Perić, D.R.J. Owen.
\sphinxstyleemphasis{Computational methods for plasticity}. J. Wiley \& Sons, New York, 2008.
\bibitem[renard2013]{biblio:renard2013}
Y. Renard,
\sphinxstyleemphasis{Generalized Newton’s methods for the approximation and resolution of frictional contact problems in elasticity}.  Comput. Methods Appl. Mech. Engrg., 256:38\sphinxhyphen{}55, 2013.
\bibitem[SU\sphinxhyphen{}CH\sphinxhyphen{}MO\sphinxhyphen{}BE2001]{biblio:su-ch-mo-be2001}
Sukumar N., Chopp D.L., Moës N., Belytschko T.
\sphinxstyleemphasis{Modeling holes and inclusions by level sets in the extended finite\sphinxhyphen{}element method}. Comput. Methods Appl. Mech. Engrg., 190:46\sphinxhyphen{}47, 2001.
\bibitem[ZT1989]{biblio:zt1989}
Zienkiewicz and Taylor. \sphinxstyleemphasis{The finite element method}. 5th edition,
volume 3 : Fluids Dynamics.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}