%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



% begin user_preamble:
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amssymb}
% end user_preamble


\title{Python Interface}
\date{Nov 12, 2020}
\release{5.4.1}
\author{Luis Saavedra}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{logogetfem.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{python/index::doc}}



\chapter{Introduction}
\label{\detokenize{python/intro:introduction}}\label{\detokenize{python/intro:py-intro}}\label{\detokenize{python/intro::doc}}
This guide provides a reference about the \sphinxstyleemphasis{Python} interface of \sphinxstyleemphasis{GetFEM}. For a complete
reference of \sphinxstyleemphasis{GetFEM}, please report to the \sphinxhref{http://getfem.org/index.html}{specific guides}, but you should be able
to use the \sphinxstyleemphasis{getfem\sphinxhyphen{}interface}’s without any particular knowledge of the \sphinxstyleemphasis{GetFEM} internals,
although a basic knowledge about Finite Elements is required. This documentation
is however not self contained. You should in
particular refer to the \sphinxhref{http://getfem.org/userdoc/index.html}{user documentation} to have a more extensive
description of the structures algorithms and concepts used.

Copyright © 2004\sphinxhyphen{}2020 \sphinxstyleemphasis{GetFEM} project.

The text of the \sphinxstyleemphasis{GetFEM} website and the documentations are available for modification and reuse under the terms of the \sphinxhref{http://www.gnu.org/licenses/fdl.html}{GNU Free Documentation License}

GetFEM  is  free software;  you  can  redistribute  it  and/or modify it
under  the  terms  of the  GNU  Lesser General Public License as published
by  the  Free Software Foundation;  either version 3 of the License,  or
(at your option) any later version along with the GCC Runtime Library
Exception either version 3.1 or (at your option) any later version.
This program  is  distributed  in  the  hope  that it will be useful,  but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or  FITNESS  FOR  A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License and GCC Runtime Library Exception for more details.
You  should  have received a copy of the GNU Lesser General Public License
along  with  this program;  if not, write to the Free Software Foundation,
Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110\sphinxhyphen{}1301, USA.


\chapter{Installation}
\label{\detokenize{python/install:installation}}\label{\detokenize{python/install:ud-install-python}}\label{\detokenize{python/install::doc}}
If installing from sources, use the option \sphinxtitleref{\textendash{}enable\sphinxhyphen{}python} of the \sphinxtitleref{configure} script.

For the parallel version of the interface, see also \DUrole{xref,std,std-ref}{ud\sphinxhyphen{}parallel}.

See the \sphinxhref{../download.html}{download and install} page for the installation of \sphinxstyleemphasis{GetFEM} on different plateforms.


\chapter{Preliminary}
\label{\detokenize{python/pre:preliminary}}\label{\detokenize{python/pre:py-pre}}\label{\detokenize{python/pre::doc}}
This is just a short summary of the terms employed in this manual. If you are not
familiar with finite elements, this should be useful (but in any case, you should
definitively read the \DUrole{xref,std,std-ref}{dp}).

The \index{mesh@\spxentry{mesh}}\index{environment variable@\spxentry{environment variable}!mesh@\spxentry{mesh}}\sphinxcode{\sphinxupquote{mesh}} is composed of \index{convexes@\spxentry{convexes}}\index{environment variable@\spxentry{environment variable}!convexes@\spxentry{convexes}}\sphinxcode{\sphinxupquote{convexes}}. What we call convexes can be
simple line segments, prisms, tetrahedrons, curved triangles, of even something
which is not convex (in the geometrical sense). They all have an associated
\index{reference convex@\spxentry{reference convex}}\index{environment variable@\spxentry{environment variable}!reference convex@\spxentry{reference convex}}\sphinxcode{\sphinxupquote{reference convex}}: for segments, this will be the \([0,1]\) segment,
for triangles this will be the canonical triangle \((0,0)-(0,1)-(1,0)\), etc.
All convexes of the mesh are constructed from the reference convex through a
\index{geometric transformation@\spxentry{geometric transformation}}\index{environment variable@\spxentry{environment variable}!geometric transformation@\spxentry{geometric transformation}}\sphinxcode{\sphinxupquote{geometric transformation}}. In simple cases (when the convexes are
simplices for example), this transformation will be linear (hence it is easily
inverted, which can be a great advantage). In order to define the geometric
transformation, one defines \index{geometrical nodes@\spxentry{geometrical nodes}}\index{environment variable@\spxentry{environment variable}!geometrical nodes@\spxentry{geometrical nodes}}\sphinxcode{\sphinxupquote{geometrical nodes}} on the reference convex.
The geometrical transformation maps these nodes to the \index{mesh nodes@\spxentry{mesh nodes}}\index{environment variable@\spxentry{environment variable}!mesh nodes@\spxentry{mesh nodes}}\sphinxcode{\sphinxupquote{mesh nodes}}.

On the mesh, one defines a set of basis functions: the \index{FEM@\spxentry{FEM}}\index{environment variable@\spxentry{environment variable}!FEM@\spxentry{FEM}}\sphinxcode{\sphinxupquote{FEM}}. A FEM is
associated at each convex. The basis functions are also attached to some
geometrical points (which can be arbitrarily chosen). These points are similar to
the mesh nodes, but \sphinxstylestrong{they don’t have to be the same} (this only happens on very
simple cases, such as a classical \(P_1\) fem on a triangular mesh). The set
of all basis functions on the mesh forms the basis of a vector space, on which the
PDE will be solved. These basis functions (and their associated geometrical point)
are the \index{degrees of freedom@\spxentry{degrees of freedom}}\index{environment variable@\spxentry{environment variable}!degrees of freedom@\spxentry{degrees of freedom}}\sphinxcode{\sphinxupquote{degrees of freedom}} (contracted to \index{dof@\spxentry{dof}}\index{environment variable@\spxentry{environment variable}!dof@\spxentry{dof}}\sphinxcode{\sphinxupquote{dof}}). The FEM is
said to be \index{Lagrangian@\spxentry{Lagrangian}}\index{environment variable@\spxentry{environment variable}!Lagrangian@\spxentry{Lagrangian}}\sphinxcode{\sphinxupquote{Lagrangian}} when each of its basis functions is equal to one
at its attached geometrical point, and is null at the geometrical points of others
basis functions. This is an important property as it is very easy to
\index{interpolate@\spxentry{interpolate}}\index{environment variable@\spxentry{environment variable}!interpolate@\spxentry{interpolate}}\sphinxcode{\sphinxupquote{interpolate}} an arbitrary function on the finite elements space.

The finite elements method involves evaluation of integrals of these basis
functions (or product of basis functions etc.) on convexes (and faces of
convexes). In simple cases (polynomial basis functions and linear geometrical
transformation), one can evaluate analytically these integrals. In other cases,
one has to approximate it using \index{quadrature formulas@\spxentry{quadrature formulas}}\index{environment variable@\spxentry{environment variable}!quadrature formulas@\spxentry{quadrature formulas}}\sphinxcode{\sphinxupquote{quadrature formulas}}. Hence, at each
convex is attached an \index{integration method@\spxentry{integration method}}\index{environment variable@\spxentry{environment variable}!integration method@\spxentry{integration method}}\sphinxcode{\sphinxupquote{integration method}} along with the FEM. If you have
to use an approximate integration method, always choose carefully its order (i.e.
highest degree of the polynomials who are exactly integrated with the method): the
degree of the FEM, of the polynomial degree of the geometrical transformation, and
the nature of the elementary matrix have to be taken into account. If you are
unsure about the appropriate degree, always prefer a high order integration method
(which will slow down the assembly) to a low order one which will produce a
useless linear\sphinxhyphen{}system.

The process of construction of a global linear system from integrals of basis
functions on each convex is the \index{assembly@\spxentry{assembly}}\index{environment variable@\spxentry{environment variable}!assembly@\spxentry{assembly}}\sphinxcode{\sphinxupquote{assembly}}.

A mesh, with a set of FEM attached to its convexes is called a \index{mesh\_fem@\spxentry{mesh\_fem}}\index{environment variable@\spxentry{environment variable}!mesh\_fem@\spxentry{mesh\_fem}}\sphinxcode{\sphinxupquote{mesh\_fem}}
object in \sphinxstyleemphasis{GetFEM}.

A mesh, with a set of integration methods attached to its convexes is called a
\index{mesh\_im@\spxentry{mesh\_im}}\index{environment variable@\spxentry{environment variable}!mesh\_im@\spxentry{mesh\_im}}\sphinxcode{\sphinxupquote{mesh\_im}} object in \sphinxstyleemphasis{GetFEM}.

A \sphinxtitleref{mesh\_fem} can be used to approximate scalar fields (heat, pression, …), or vector
fields (displacement, electric field, …). A \sphinxtitleref{mesh\_im} will be used to perform
numerical integrations on these fields. Most of the finite elements implemented in
\sphinxstyleemphasis{GetFEM} are scalar (however, \(TR_0\) and edges elements are also available). Of
course, these scalar FEMs can be used to approximate each component of a vector
field. This is done by setting the \(Qdim\) of the \sphinxtitleref{mesh\_fem} to the dimension of
the vector field (i.e. \(Qdim=1\) \(\rm I\hspace{-0.15em}Rightarrow\) scalar field,
\(Qdim=2\) \(\rm I\hspace{-0.15em}Rightarrow\) 2D vector field etc.).

When solving a PDE, one often has to use more than one FEM. The most important one
will be of course the one on which is defined the solution of the PDE. But most
PDEs involve various coefficients, for example:
\begin{equation*}
\begin{split}\nabla\cdot(\lambda(x)\nabla u) = f(x).\end{split}
\end{equation*}
Hence one has to define an FEM for the main unknown \(u\), but also for the
data \(\lambda(x)\) and \(f(x)\) if they are not constant. In order to
interpolate easily these coefficients in their finite element space, one often
choose a Lagrangian FEM.

The convexes, mesh nodes, and dof are all numbered. We sometimes refer to the
number associated to a convex as its \index{convex id@\spxentry{convex id}}\index{environment variable@\spxentry{environment variable}!convex id@\spxentry{convex id}}\sphinxcode{\sphinxupquote{convex id}} (contracted to
\index{cvid@\spxentry{cvid}}\index{environment variable@\spxentry{environment variable}!cvid@\spxentry{cvid}}\sphinxcode{\sphinxupquote{cvid}}). Mesh node numbers are also called \index{point id@\spxentry{point id}}\index{environment variable@\spxentry{environment variable}!point id@\spxentry{point id}}\sphinxcode{\sphinxupquote{point id}} (contracted
to \index{pid@\spxentry{pid}}\index{environment variable@\spxentry{environment variable}!pid@\spxentry{pid}}\sphinxcode{\sphinxupquote{pid}}). Faces of convexes do not have a global numbering, but only a
local number in each convex. Hence functions which need or return a list of faces
will always use a two\sphinxhyphen{}rows matrix, the first one containing convex ids, and the
second one containing local face number.

While the dof are always numbered consecutively, \sphinxstylestrong{this is not always the case for
point ids and convex ids}, especially if you have removed points or convexes from
the mesh. To ensure that they form a continuous sequence (starting from 1), you
have to call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{m}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimize structure}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{\sphinxstyleemphasis{Python} \sphinxstyleemphasis{GetFEM} interface}
\label{\detokenize{python/pygf:py-gf-interface}}\label{\detokenize{python/pygf::doc}}

\section{Introduction}
\label{\detokenize{python/pygf:introduction}}
\sphinxstyleemphasis{GetFEM} provides an interface to the \sphinxstyleemphasis{Python} scripting language. \sphinxstyleemphasis{Python} is a nice,
cross\sphinxhyphen{}platform, and free language. With the addition of the numpy package,
python provides a subset of Matlab functionalities (i.e. dense arrays). The
\sphinxhref{https://vtk.org/Wiki/VTK\_XML\_Formats}{VTK} toolkit may provide visualization tools via its python interface (or
via \sphinxhref{http://mayavi.sourceforge.net}{MayaVi}), and data files for \sphinxhref{http://www.opendx.org}{OpenDX}  may be exported. In this guide,
nevertheless, to visualize the results, we will export to \sphinxhref{http://www.geuz.org/gmsh}{Gmsh}
post\sphinxhyphen{}processing format. The sparse matrix routines are provided by the getfem
interface.

The python interface is available via a python module getfem.py. In order to
use the interface you have to load it with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{getfem}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{getfem}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cartesian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

or:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{getfem} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{Mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cartesian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

If the getfem.py (and the internal \_getfem.so) module is not installed in a
standard location for python, you may have to set the \sphinxcode{\sphinxupquote{PYTHONPATH}}
environment variable to its location. For example with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.../getfem/getfem++/interface/src/python/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Parallel version}
\label{\detokenize{python/pygf:parallel-version}}
The python interface is the only one for the moment to interface the mpi based parallel version of Getfem. See \DUrole{xref,std,std-ref}{ud\sphinxhyphen{}parallel}.


\section{Memory Management}
\label{\detokenize{python/pygf:memory-management}}
A nice advantage over the Matlab interface is that you do not have to
explicitly delete objects that are not used any more, this is done
automagically. You can however inspect the content of the getfem workspace
with the function \sphinxcode{\sphinxupquote{getfem.memstats()}}.


\section{Documentation}
\label{\detokenize{python/pygf:documentation}}
The \sphinxtitleref{getfem} module is largely documented. This documentation has been
extracted into the {\hyperref[\detokenize{python/cmdref:api}]{\sphinxcrossref{\DUrole{std,std-ref}{API reference}}}}. The getfem\sphinxhyphen{}matlab user guide may also be used,
as 95\% of its content translates quite directly into python (with the exception
of the plotting functions, which are specific to matlab).


\section{\sphinxstyleemphasis{Python} \sphinxstyleemphasis{GetFEM} organization}
\label{\detokenize{python/pygf:py-gf-organization}}
The general organization of the python\sphinxhyphen{}interface is the following:
\begin{itemize}
\item {} 
Each class from the matlab interface has a corresponding class in the
python interface: the gfMesh class becomes the getfem.Mesh class in python,
the gfSlice becomes the getfem.Slice etc.

\item {} 
Each get and set method of the matlab interface has been translated into a
method of the corresponding class in the python interface. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{outer faces}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

becomes:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m}\PYG{o}{.}\PYG{n}{outer\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{pts}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Some methods have been renamed when there was ambiguity, for example
\sphinxcode{\sphinxupquote{gf\_mesh\_set(m, \textquotesingle{}pts\textquotesingle{}, P)}} is \sphinxcode{\sphinxupquote{m.set\_pts(P)}}.

\item {} 
The other getfem\sphinxhyphen{}matlab function have a very simple mapping to their python
equivalent:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

gf\_compute(mf,U,’foo’,…)
&
getfem.compute\_foo(mf,U) or
getfem.compute(‘foo’,…)
\\
\hline
gf\_asm(‘foobar’,…)
&
getfem.asm\_foobar(…) or
getfem.asm(‘foobar’,…)
\\
\hline
gf\_linsolve(‘gmres’,…)
&
getfem.linsolve\_gmres(…) or
getfem.linsolve(‘gmres’,…)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.75]{{hierarchy1}.png}
\caption{python\sphinxhyphen{}getfem interface main objects hierarchy.}\label{\detokenize{python/pygf:id1}}\end{figure}
\index{CvStruct (built\sphinxhyphen{}in class)@\spxentry{CvStruct}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:CvStruct}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CvStruct}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Descriptor for a convex structure objects, stores formal information convex
structures (nb. of points, nb. of faces which are themselves convex
structures)

\end{fulllineitems}

\index{GeoTrans (built\sphinxhyphen{}in class)@\spxentry{GeoTrans}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:GeoTrans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{GeoTrans}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Descriptor for geometric transformations objects (defines the shape/position
of the convexes).

\end{fulllineitems}

\index{Mesh (built\sphinxhyphen{}in class)@\spxentry{Mesh}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:Mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Mesh}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Descriptor for mesh structure (nodes, convexes, geometric transformations for
each convex).

\end{fulllineitems}

\index{Fem (built\sphinxhyphen{}in class)@\spxentry{Fem}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:Fem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Fem}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{fem\_name}}}{}
Descriptor for FEM (Finite Element Method) objects (one per convex, can be
PK, QK, HERMITE, etc…).

\end{fulllineitems}

\index{Integ (built\sphinxhyphen{}in class)@\spxentry{Integ}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:Integ}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Integ}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Descriptor for Integration Method objects (exact, quadrature formulaldots).
Although not linked directly to GeoTrans, an integration method is usually
specific to a given convex structure.

\end{fulllineitems}

\index{MeshFem (built\sphinxhyphen{}in class)@\spxentry{MeshFem}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:MeshFem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MeshFem}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Descriptor for object linked to a mesh, where each convex has been assigned
an FEM.

\end{fulllineitems}

\index{MeshIm (built\sphinxhyphen{}in class)@\spxentry{MeshIm}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:MeshIm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MeshIm}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Descriptor for object linked to a mesh, where each convex has been assigned
an integration method.

\end{fulllineitems}

\index{Model (built\sphinxhyphen{}in class)@\spxentry{Model}\spxextra{built\sphinxhyphen{}in class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/pygf:Model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Model}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Descriptor for \sphinxstyleemphasis{model} object, holds the global data, variables and
description of a model. Evolution of \sphinxstyleemphasis{model state} and \sphinxstyleemphasis{model brick}
object for 4.0 version of \sphinxstyleemphasis{GetFEM}.

\end{fulllineitems}



\chapter{Examples}
\label{\detokenize{python/examples:examples}}\label{\detokenize{python/examples:py-examples}}\label{\detokenize{python/examples::doc}}

\section{A step\sphinxhyphen{}by\sphinxhyphen{}step basic example}
\label{\detokenize{python/examples:a-step-by-step-basic-example}}\label{\detokenize{python/examples:py-laplacianexample}}
This example shows the basic usage of getfem, on the über\sphinxhyphen{}canonical problem above
all others: solving the \index{Laplacian@\spxentry{Laplacian}}\index{environment variable@\spxentry{environment variable}!Laplacian@\spxentry{Laplacian}}\sphinxcode{\sphinxupquote{Laplacian}}, \(-\Delta u = f\) on a square,
with the Dirichlet condition \(u = g(x)\) on the domain boundary. You can find
the \sphinxstylestrong{py\sphinxhyphen{}file} of this example under the name \sphinxstylestrong{demo\_step\_by\_step.py} in the
directory \sphinxcode{\sphinxupquote{interface/tests/python/}} of the \sphinxstyleemphasis{GetFEM} distribution.

The first step is to \sphinxstylestrong{create a Mesh object}. It is possible to create simple structured meshes or unstructured meshes for simple geometries (see \sphinxcode{\sphinxupquote{getfem.Mesh(\textquotesingle{}generate\textquotesingle{}, mesher\_object mo, scalar h)}}) or to rely on an external mesher (see \sphinxcode{\sphinxupquote{getfem.Mesh(\textquotesingle{}import\textquotesingle{},
string FORMAT, string FILENAME)}}), or use very simple meshes. For this example,
we just consider a regular meshindex\{cartesian mesh\} whose nodes are
\(\{x_{i=0\ldots10,j=0..10}=(i/10,j/10)\}\)

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} import basic modules}
\PYG{k+kn}{import} \PYG{n+nn}{getfem} \PYG{k}{as} \PYG{n+nn}{gf}

\PYG{c+c1}{\PYGZsh{} creation of a simple cartesian mesh}
\end{sphinxVerbatim}

The next step is to \sphinxstylestrong{create a MeshFem object}. This one links a mesh with a set
of FEM

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} create a MeshFem of for a field of dimension 1 (i.e. a scalar field)}
\PYG{n}{mf} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} assign the Q2 fem to all convexes of the MeshFem}
\end{sphinxVerbatim}

The first instruction builds a new MeshFem object, the second argument specifies
that this object will be used to interpolate scalar fields (since the unknown
\(u\) is a scalar field). The second instruction assigns the \(Q^2\) FEM
to every convex (each basis function is a polynomial of degree 4, remember that
\(P^k\rm I\hspace{-0.15em}Rightarrow\) polynomials of degree \(k\), while
\(Q^k\rm I\hspace{-0.15em}Rightarrow\) polynomials of degree \(2k\)). As \(Q^2\) is a
polynomial FEM, you can view the expression of its basis functions on the
reference convex:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} view the expression of its basis functions on the reference convex}
\end{sphinxVerbatim}

Now, in order to perform numerical integrations on \sphinxcode{\sphinxupquote{mf}}, we need to \sphinxstylestrong{build a
MeshIm object}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} an exact integration will be used}
\end{sphinxVerbatim}

The integration method will be used to compute the various integrals on each
element: here we choose to perform exact computations (no \index{quadrature formula@\spxentry{quadrature formula}}\index{environment variable@\spxentry{environment variable}!quadrature formula@\spxentry{quadrature formula}}\sphinxcode{\sphinxupquote{quadrature
formula}}), which is possible since the geometric transformation of these convexes
from the reference convex is linear (this is true for all simplices, and this is
also true for the parallelepipeds of our regular mesh, but it is not true for
general quadrangles), and the chosen FEM is polynomial. Hence it is possible to
analytically integrate every basis function/product of basis
functions/gradients/etc. There are many alternative FEM methods and integration
methods (see \DUrole{xref,std,std-ref}{ud}).

Note however that in the general case, approximate integration methods are a
better choice than exact integration methods.

Now we have to \sphinxstylestrong{find the} \textless{}\index{boundary@\spxentry{boundary}}\index{environment variable@\spxentry{environment variable}!boundary@\spxentry{boundary}}\sphinxcode{\sphinxupquote{boundary}}\textgreater{} \sphinxstylestrong{of the domain}, in order to
set a Dirichlet condition. A mesh object has the ability to store some sets of
convexes and convex faces. These sets (called \textless{}regions\textgreater{}) are accessed via an
integer \sphinxstyleemphasis{\#id}

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} detect the border of the mesh}
\PYG{n}{border} \PYG{o}{=} \PYG{n}{m}\PYG{o}{.}\PYG{n}{outer\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} mark it as boundary \PYGZsh{}42}
\end{sphinxVerbatim}

Here we find the faces of the convexes which are on the boundary of the mesh (i.e.
the faces which are not shared by two convexes).

The array \sphinxcode{\sphinxupquote{border}} has two rows, on the first row is a convex number, on the
second row is a face number (which is local to the convex, there is no global
numbering of faces). Then this set of faces is assigned to the region number 42.

At this point, we just have to describe the model and run the solver to get the
solution! The “\index{model@\spxentry{model}}\index{environment variable@\spxentry{environment variable}!model@\spxentry{model}}\sphinxcode{\sphinxupquote{model}}” is created with the Model constructor. A model
is basically an object which build a global linear system (tangent matrix for
non\sphinxhyphen{}linear problems) and its associated right hand side. Typical modifications are
insertion of the stiffness matrix for the problem considered (linear elasticity,
laplacian, etc), handling of a set of constraints, Dirichlet condition, addition of
a source term to the right hand side etc. The global tangent matrix and its right
hand side are stored in the “\index{model@\spxentry{model}}\index{environment variable@\spxentry{environment variable}!model@\spxentry{model}}\sphinxcode{\sphinxupquote{model}}” structure.

Let us build a problem with an easy solution: \(u = x(x-1)-y(y-1)\), then
we have \(-\Delta u = 0\) (the FEM won’t be able to catch the exact
solution since we use a \(Q^2\) method).

We start with an empty real model

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} empty real model}
\end{sphinxVerbatim}

(a model is either \sphinxcode{\sphinxupquote{\textquotesingle{}real\textquotesingle{}}} or \sphinxcode{\sphinxupquote{\textquotesingle{}complex\textquotesingle{}}}). And we declare that \sphinxcode{\sphinxupquote{u}} is an
unknown of the system on the finite element method \sphinxtitleref{mf} by

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} declare that \PYGZdq{}u\PYGZdq{} is an unknown of the system}
\PYG{c+c1}{\PYGZsh{} on the finite element method `mf`}
\end{sphinxVerbatim}

Now, we add a \sphinxtitleref{generic elliptic} brick, which handles \(-\nabla\cdot(A:\nabla
u) = \ldots\) problems, where \(A\) can be a scalar field, a matrix field, or
an order 4 tensor field. By default, \(A=1\). We add it on our main variable
\sphinxcode{\sphinxupquote{u}} with

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} add generic elliptic brick on \PYGZdq{}u\PYGZdq{}}
\end{sphinxVerbatim}

Next we add a Dirichlet condition on the domain boundary

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} add Dirichlet condition}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{mf}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x*(x\PYGZhy{}1) \PYGZhy{} y*(y\PYGZhy{}1)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}fem\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DirichletData}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)}
\end{sphinxVerbatim}

The two first lines defines a data of the model which represents the value of the
Dirichlet condition. The third one add a Dirichlet condition to the variable \sphinxcode{\sphinxupquote{u}}
on the boundary number \sphinxcode{\sphinxupquote{42}}. The dirichlet condition is imposed with lagrange
multipliers. Another possibility is to use a penalization. A MeshFem argument is
also required, as the Dirichlet condition \(u=g\) is imposed in a weak form
\(\int_\Gamma u(x)v(x) = \int_\Gamma g(x)v(x)\ \forall v\) where \(v\) is
taken in the space of multipliers given by here by \sphinxcode{\sphinxupquote{mf}}.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Remark:}

the polynomial expression was interpolated on \sphinxcode{\sphinxupquote{mf}}. It is possible only if
\sphinxcode{\sphinxupquote{mf}} is of Lagrange type. In this first example we use the same MeshFem for
the unknown and for the data such as \sphinxcode{\sphinxupquote{g}}, but in the general case, \sphinxcode{\sphinxupquote{mf}}
won’t be Lagrangian and another (Lagrangian) MeshFem will be used for the
description of Dirichlet conditions, source terms etc.
\end{sphinxShadowBox}

A source term can be added with (uncommented) the following lines

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} add source term}
\PYG{c+c1}{\PYGZsh{}f = mf.eval(\PYGZsq{}0\PYGZsq{})}
\PYG{c+c1}{\PYGZsh{}md.add\PYGZus{}initialized\PYGZus{}fem\PYGZus{}data(\PYGZsq{}VolumicData\PYGZsq{}, mf, f)}
\end{sphinxVerbatim}

It only remains now to launch the solver. The linear system is assembled and solve
with the instruction

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} solve the linear system}
\end{sphinxVerbatim}

The model now contains the solution (as well as other things, such as the linear
system which was solved). It is extracted

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} extracted solution}
\end{sphinxVerbatim}

Then export solution

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} export computed solution}
\end{sphinxVerbatim}

and view with \sphinxcode{\sphinxupquote{gmsh u.pos}}, see figure {\hyperref[\detokenize{python/examples:py-fig-sbs}]{\sphinxcrossref{\DUrole{std,std-ref}{Computed solution}}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{step_by_step}.png}
\caption{Computed solution}\label{\detokenize{python/examples:id1}}\label{\detokenize{python/examples:py-fig-sbs}}\end{figure}


\section{Another Laplacian with exact solution (source term)}
\label{\detokenize{python/examples:another-laplacian-with-exact-solution-source-term}}
This example shows the basic usage of getfem, on the canonical problem: solving
the Laplacian, \(-\Delta u = f\) on a square, with the Dirichlet condition
\(u = g(x)\) on the domain boundary \(\Gamma_D\) and the Neumann condition
\(\frac{\partial u}{\partial\eta} = h(x)\) on the domain boundary
\(\Gamma_N\). You can find the \sphinxstylestrong{py\sphinxhyphen{}file} of this example under the name
\sphinxstylestrong{demo\_laplacian.py} in the directory \sphinxcode{\sphinxupquote{interface/tests/python/}} of the \sphinxstyleemphasis{GetFEM}
distribution.

We create Mesh, MeshFem, MeshIm object and find the boundary of the domain in
the same way as the previous example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} import basic modules}
\PYG{k+kn}{import} \PYG{n+nn}{getfem} \PYG{k}{as} \PYG{n+nn}{gf}

\PYG{c+c1}{\PYGZsh{} boundary names}
\PYG{n}{top}   \PYG{o}{=} \PYG{l+m+mi}{101} \PYG{c+c1}{\PYGZsh{} Dirichlet boundary}
\PYG{n}{down}  \PYG{o}{=} \PYG{l+m+mi}{102} \PYG{c+c1}{\PYGZsh{} Neumann boundary}
\PYG{n}{left}  \PYG{o}{=} \PYG{l+m+mi}{103} \PYG{c+c1}{\PYGZsh{} Dirichlet boundary}
\PYG{n}{right} \PYG{o}{=} \PYG{l+m+mi}{104} \PYG{c+c1}{\PYGZsh{} Neumann boundary}

\PYG{c+c1}{\PYGZsh{} parameters}
\PYG{n}{NX} \PYG{o}{=} \PYG{l+m+mi}{40}                             \PYG{c+c1}{\PYGZsh{} Mesh parameter}
\PYG{n}{Dirichlet\PYGZus{}with\PYGZus{}multipliers} \PYG{o}{=} \PYG{k+kc}{True}\PYG{p}{;}  \PYG{c+c1}{\PYGZsh{} Dirichlet condition with multipliers or penalization}
\PYG{n}{dirichlet\PYGZus{}coefficient} \PYG{o}{=} \PYG{l+m+mf}{1e10}\PYG{p}{;}       \PYG{c+c1}{\PYGZsh{} Penalization coefficient}

\PYG{c+c1}{\PYGZsh{} mesh creation}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{regular\PYGZus{}simplices}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{NX}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{NX}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{NX}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{n}{NX}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a MeshFem for u and rhs fields of dimension 1 (i.e. a scalar field)}
\PYG{n}{mfu}   \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{mfrhs} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} assign the P2 fem to all convexes of the both MeshFem}
\PYG{n}{mfu}\PYG{o}{.}\PYG{n}{set\PYGZus{}fem}\PYG{p}{(}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEM\PYGZus{}PK(2,2)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{mfrhs}\PYG{o}{.}\PYG{n}{set\PYGZus{}fem}\PYG{p}{(}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEM\PYGZus{}PK(2,2)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} an exact integration will be used}
\PYG{n}{mim} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshIm}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Integ}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IM\PYGZus{}TRIANGLE(4)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} boundary selection}
\PYG{n}{flst}   \PYG{o}{=} \PYG{n}{m}\PYG{o}{.}\PYG{n}{outer\PYGZus{}faces}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fnor}   \PYG{o}{=} \PYG{n}{m}\PYG{o}{.}\PYG{n}{normal\PYGZus{}of\PYGZus{}faces}\PYG{p}{(}\PYG{n}{flst}\PYG{p}{)}
\PYG{n}{ttop}   \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{fnor}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}14}
\PYG{n}{tdown}  \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{fnor}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}14}
\PYG{n}{tleft}  \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{fnor}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}14}
\PYG{n}{tright} \PYG{o}{=} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{fnor}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}14}
\PYG{n}{ftop}   \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{ttop}\PYG{p}{,} \PYG{n}{flst}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{fdown}  \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{tdown}\PYG{p}{,} \PYG{n}{flst}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{fleft}  \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{tleft}\PYG{p}{,} \PYG{n}{flst}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{fright} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{tright}\PYG{p}{,} \PYG{n}{flst}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} mark it as boundary}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{set\PYGZus{}region}\PYG{p}{(}\PYG{n}{top}\PYG{p}{,} \PYG{n}{ftop}\PYG{p}{)}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{set\PYGZus{}region}\PYG{p}{(}\PYG{n}{down}\PYG{p}{,} \PYG{n}{fdown}\PYG{p}{)}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{set\PYGZus{}region}\PYG{p}{(}\PYG{n}{left}\PYG{p}{,} \PYG{n}{fleft}\PYG{p}{)}
\end{sphinxVerbatim}

then, we interpolate the exact solution and source terms

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} interpolate the exact solution (assuming mfu is a Lagrange fem)}
\PYG{n}{g} \PYG{o}{=} \PYG{n}{mfu}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y*(y\PYGZhy{}1)*x*(x\PYGZhy{}1)+x*x*x*x*x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} interpolate the source terms (assuming mfrhs is a Lagrange fem)}
\PYG{n}{f} \PYG{o}{=} \PYG{n}{mfrhs}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}(2*(x*x+y*y)\PYGZhy{}2*x\PYGZhy{}2*y+20*x*x*x)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

and we bricked the problem as in the previous example

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} model}
\PYG{n}{md} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{real}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} add variable and data to model}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}fem\PYGZus{}variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{)}              \PYG{c+c1}{\PYGZsh{} main unknown}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}fem\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfrhs}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} volumic source term}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}fem\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfrhs}\PYG{p}{,} \PYG{n}{g}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Dirichlet condition}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}fem\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfrhs}\PYG{p}{,} \PYG{n}{h}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Neumann condition}

\PYG{c+c1}{\PYGZsh{} bricked the problem}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}Laplacian\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}                             \PYG{c+c1}{\PYGZsh{} laplacian term on u}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}source\PYGZus{}term\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}                      \PYG{c+c1}{\PYGZsh{} volumic source term}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}normal\PYGZus{}source\PYGZus{}term\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{down}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} Neumann condition}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}normal\PYGZus{}source\PYGZus{}term\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{left}\PYG{p}{)}         \PYG{c+c1}{\PYGZsh{} Neumann condition}

\PYG{c+c1}{\PYGZsh{} Dirichlet condition on the top}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{Dirichlet\PYGZus{}with\PYGZus{}multipliers}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}Dirichlet\PYGZus{}condition\PYGZus{}with\PYGZus{}multipliers}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{top}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
  \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}Dirichlet\PYGZus{}condition\PYGZus{}with\PYGZus{}penalization}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{dirichlet\PYGZus{}coefficient}\PYG{p}{,} \PYG{n}{top}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Dirichlet condition on the right}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{Dirichlet\PYGZus{}with\PYGZus{}multipliers}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}Dirichlet\PYGZus{}condition\PYGZus{}with\PYGZus{}multipliers}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{right}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
\end{sphinxVerbatim}

the only change is the add of \sphinxtitleref{source term} bricks. Finally the solution of the
problem is extracted and exported

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]

\PYG{c+c1}{\PYGZsh{} assembly of the linear system and solve.}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} main unknown}
\PYG{n}{u}  \PYG{o}{=} \PYG{n}{md}\PYG{o}{.}\PYG{n}{variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{L2error} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{compute}\PYG{p}{(}\PYG{n}{mfu}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{g}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L2 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{)}
\PYG{n}{H1error} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{compute}\PYG{p}{(}\PYG{n}{mfu}\PYG{p}{,} \PYG{n}{u}\PYG{o}{\PYGZhy{}}\PYG{n}{g}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H1 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{)}

\PYG{k}{if} \PYG{p}{(}\PYG{n}{H1error} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{1e\PYGZhy{}3}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error in L2 norm : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{L2error}
    \PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error in H1 norm : }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{H1error}
    \PYG{n+nb}{print} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Error too large !}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} export data}
\PYG{n}{mfu}\PYG{o}{.}\PYG{n}{export\PYGZus{}to\PYGZus{}pos}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sol.pos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{g}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Exact solution}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\end{sphinxVerbatim}

view with \sphinxcode{\sphinxupquote{gmsh sol.pos}}:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=250bp]{{laplacian}.png}
\caption{Differences}\label{\detokenize{python/examples:id2}}\end{figure}


\section{Linear and non\sphinxhyphen{}linear elasticity}
\label{\detokenize{python/examples:linear-and-non-linear-elasticity}}
This example uses a mesh that was generated with \sphinxhref{http://gid.cimne.upc.es}{GiD}. The object is meshed
with quadratic tetrahedrons. You can find the \sphinxstylestrong{py\sphinxhyphen{}file} of this example under
the name \sphinxcode{\sphinxupquote{demo\_tripod.py}} in the directory \sphinxcode{\sphinxupquote{interface/tests/python/}}
of the \sphinxstyleemphasis{GetFEM} distribution.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{import} \PYG{n+nn}{getfem} \PYG{k}{as} \PYG{n+nn}{gf}

\PYG{n}{with\PYGZus{}graphics}\PYG{o}{=}\PYG{k+kc}{True}
\PYG{k}{try}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{getfem\PYGZus{}tvtk}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{** Could NOT import getfem\PYGZus{}tvtk \PYGZhy{}\PYGZhy{} graphical output disabled **}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k+kn}{import} \PYG{n+nn}{time}
    \PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{with\PYGZus{}graphics}\PYG{o}{=}\PYG{k+kc}{False}


\PYG{n}{m}\PYG{o}{=}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{import}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../meshes/tripod.GiD.msh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{done!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mfu}\PYG{o}{=}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} displacement}
\PYG{n}{mfp}\PYG{o}{=}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} pressure}
\PYG{n}{mfd}\PYG{o}{=}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} data}
\PYG{n}{mim}\PYG{o}{=}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshIm}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Integ}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{IM\PYGZus{}TETRAHEDRON(5)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{degree} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{linear} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{n}{incompressible} \PYG{o}{=} \PYG{k+kc}{False} \PYG{c+c1}{\PYGZsh{} ensure that degree \PYGZgt{} 1 when incompressible is on..}

\PYG{n}{mfu}\PYG{o}{.}\PYG{n}{set\PYGZus{}fem}\PYG{p}{(}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEM\PYGZus{}PK(3,}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{degree}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{mfd}\PYG{o}{.}\PYG{n}{set\PYGZus{}fem}\PYG{p}{(}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEM\PYGZus{}PK(3,0)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{mfp}\PYG{o}{.}\PYG{n}{set\PYGZus{}fem}\PYG{p}{(}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEM\PYGZus{}PK\PYGZus{}DISCONTINUOUS(3,0)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbcvs=}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{, nbpts=}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{, qdim=}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{, fem = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{, nbdof=}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYGZbs{}
      \PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{nbcvs}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{m}\PYG{o}{.}\PYG{n}{nbpts}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mfu}\PYG{o}{.}\PYG{n}{qdim}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mfu}\PYG{o}{.}\PYG{n}{fem}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{char}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mfu}\PYG{o}{.}\PYG{n}{nbdof}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{P}\PYG{o}{=}\PYG{n}{m}\PYG{o}{.}\PYG{n}{pts}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{P}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ctop}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{P}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{13}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}
\PYG{n}{cbot}\PYG{o}{=}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{P}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}
\PYG{n}{pidtop}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{ctop}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{m}\PYG{o}{.}\PYG{n}{nbpts}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{pidbot}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{compress}\PYG{p}{(}\PYG{n}{cbot}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{m}\PYG{o}{.}\PYG{n}{nbpts}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{ftop}\PYG{o}{=}\PYG{n}{m}\PYG{o}{.}\PYG{n}{faces\PYGZus{}from\PYGZus{}pid}\PYG{p}{(}\PYG{n}{pidtop}\PYG{p}{)}
\PYG{n}{fbot}\PYG{o}{=}\PYG{n}{m}\PYG{o}{.}\PYG{n}{faces\PYGZus{}from\PYGZus{}pid}\PYG{p}{(}\PYG{n}{pidbot}\PYG{p}{)}
\PYG{n}{NEUMANN\PYGZus{}BOUNDARY} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{DIRICHLET\PYGZus{}BOUNDARY} \PYG{o}{=} \PYG{l+m+mi}{2}

\PYG{n}{m}\PYG{o}{.}\PYG{n}{set\PYGZus{}region}\PYG{p}{(}\PYG{n}{NEUMANN\PYGZus{}BOUNDARY}\PYG{p}{,}\PYG{n}{ftop}\PYG{p}{)}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{set\PYGZus{}region}\PYG{p}{(}\PYG{n}{DIRICHLET\PYGZus{}BOUNDARY}\PYG{p}{,}\PYG{n}{fbot}\PYG{p}{)}

\PYG{n}{E}\PYG{o}{=}\PYG{l+m+mf}{1e3}
\PYG{n}{Nu}\PYG{o}{=}\PYG{l+m+mf}{0.3}
\PYG{n}{Lambda} \PYG{o}{=} \PYG{n}{E}\PYG{o}{*}\PYG{n}{Nu}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{Nu}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Nu}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Mu} \PYG{o}{=}\PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{Nu}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{md} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{real}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}fem\PYGZus{}variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{linear}\PYG{p}{:}
    \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cmu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Mu}\PYG{p}{)}
    \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clambda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Lambda}\PYG{p}{)}
    \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}isotropic\PYGZus{}linearized\PYGZus{}elasticity\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clambda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cmu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{incompressible}\PYG{p}{:}
        \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}fem\PYGZus{}variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfp}\PYG{p}{)}
        \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}linear\PYGZus{}incompressibility\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{params}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{n}{Lambda}\PYG{p}{,} \PYG{n}{Mu}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if} \PYG{n}{incompressible}\PYG{p}{:}
        \PYG{n}{lawname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Incompressible Mooney Rivlin}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}finite\PYGZus{}strain\PYGZus{}elasticity\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{n}{lawname}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{params}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}fem\PYGZus{}variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfp}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}finite\PYGZus{}strain\PYGZus{}incompressibility\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{lawname} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SaintVenant Kirchhoff}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
        \PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}finite\PYGZus{}strain\PYGZus{}elasticity\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{n}{lawname}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{params}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
  

\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}initialized\PYGZus{}data}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VolumicData}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}source\PYGZus{}term\PYGZus{}brick}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{VolumicData}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{} Attach the tripod to the ground}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{add\PYGZus{}Dirichlet\PYGZus{}condition\PYGZus{}with\PYGZus{}multipliers}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{running solve...}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{md}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{noisy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max iter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{md}\PYG{o}{.}\PYG{n}{variable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{solve done!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}


\PYG{n}{mfdu}\PYG{o}{=}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{mfdu}\PYG{o}{.}\PYG{n}{set\PYGZus{}fem}\PYG{p}{(}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEM\PYGZus{}PK\PYGZus{}DISCONTINUOUS(3,1)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{linear}\PYG{p}{:}
  \PYG{n}{VM} \PYG{o}{=} \PYG{n}{md}\PYG{o}{.}\PYG{n}{compute\PYGZus{}isotropic\PYGZus{}linearized\PYGZus{}Von\PYGZus{}Mises\PYGZus{}or\PYGZus{}Tresca}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clambda}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cmu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfdu}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{else}\PYG{p}{:}
  \PYG{n}{VM} \PYG{o}{=} \PYG{n}{md}\PYG{o}{.}\PYG{n}{compute\PYGZus{}finite\PYGZus{}strain\PYGZus{}elasticity\PYGZus{}Von\PYGZus{}Mises}\PYG{p}{(}\PYG{n}{lawname}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{params}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfdu}\PYG{p}{)}\PYG{p}{;}

\PYG{c+c1}{\PYGZsh{} post\PYGZhy{}processing}
\PYG{n}{sl}\PYG{o}{=}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Slice}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{degree}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Von Mises range: }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{VM}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{VM}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} export results to VTK}
\PYG{n}{sl}\PYG{o}{.}\PYG{n}{export\PYGZus{}to\PYGZus{}vtk}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tripod.vtk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ascii}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfdu}\PYG{p}{,}  \PYG{n}{VM}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Von Mises Stress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Displacement}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Here is the final figure, displaying the \index{Von Mises@\spxentry{Von Mises}}\index{environment variable@\spxentry{environment variable}!Von Mises@\spxentry{Von Mises}}\sphinxcode{\sphinxupquote{Von Mises}} stress and
displacements norms:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=400bp]{{tripod}.png}
\caption{(a) Tripod Von Mises, (b) Tripod displacements norms.}\label{\detokenize{python/examples:id3}}\end{figure}


\section{Avoiding the model framework}
\label{\detokenize{python/examples:avoiding-the-model-framework}}
The model bricks are very convenient, as they hide most of the details of the
assembly of the final linear systems. However it is also possible to stay at a
lower level, and handle the assembly of linear systems, and their resolution,
directly in \sphinxstyleemphasis{Python}. For example, the demonstration \sphinxcode{\sphinxupquote{demo\_tripod\_alt.py}} is
very similar to the \sphinxcode{\sphinxupquote{demo\_tripod.py}} except that the assembly is explicit

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{n}{mfu} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} displacement}
\PYG{n}{mfe} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{MeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} for plot von\PYGZhy{}mises}
\PYG{n}{mfu}\PYG{o}{.}\PYG{n}{set\PYGZus{}fem}\PYG{p}{(}\PYG{n}{gf}\PYG{o}{.}\PYG{n}{Fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FEM\PYGZus{}PK(3,}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{degree}\PYG{p}{,}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{set\PYGZus{}region}\PYG{p}{(}\PYG{n}{DIRICHLET\PYGZus{}BOUNDARY}\PYG{p}{,}\PYG{n}{fbot}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} assembly}
\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nbd: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{nbd}

\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{np.repeat([Mu], nbd).shape:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{repeat}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Mu}\PYG{p}{]}\PYG{p}{,} \PYG{n}{nbd}\PYG{p}{)}\PYG{o}{.}\PYG{n}{shape}

\PYG{c+c1}{\PYGZsh{} handle Dirichlet condition}

\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U0.shape: }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{U0}\PYG{o}{.}\PYG{n}{shape}

\PYG{n}{Nt} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{copy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}
\PYG{n}{Nt}\PYG{o}{.}\PYG{n}{transpose}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{KK} \PYG{o}{=} \PYG{n}{Nt}\PYG{o}{*}\PYG{n}{K}\PYG{o}{*}\PYG{n}{N}
\PYG{n}{FF} \PYG{o}{=} \PYG{n}{Nt}\PYG{o}{*}\PYG{n}{F} \PYG{c+c1}{\PYGZsh{} FF = Nt*(F\PYGZhy{}K*U0)}

\PYG{c+c1}{\PYGZsh{} solve ...}
\PYG{n}{P} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ildlt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{KK}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{UU.shape:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{UU}\PYG{o}{.}\PYG{n}{shape}
\PYG{n+nb}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{U.shape:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{U}\PYG{o}{.}\PYG{n}{shape}

\PYG{c+c1}{\PYGZsh{} post\PYGZhy{}processing}
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Slice}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{degree}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} compute the Von Mises Stress}
\PYG{n}{DU} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{compute\PYGZus{}gradient}\PYG{p}{(}\PYG{n}{mfu}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{n}{mfe}\PYG{p}{)}
\PYG{n}{VM} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{(}\PYG{n}{DU}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Sigma} \PYG{o}{=} \PYG{n}{DU}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{DU}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
  \PYG{n}{d} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{DU}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
  \PYG{n}{E} \PYG{o}{=} \PYG{p}{(}\PYG{n}{d}\PYG{o}{+}\PYG{n}{d}\PYG{o}{.}\PYG{n}{T}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mf}{0.5}
  \PYG{n}{Sigma}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{n}{E}
  \PYG{n}{VM}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{E}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mf}{1.}\PYG{o}{/}\PYG{l+m+mf}{3.}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{diagonal}\PYG{p}{(}\PYG{n}{E}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{c+c1}{\PYGZsh{} can be viewed with mayavi \PYGZhy{}d ./tripod\PYGZus{}ev.vtk \PYGZhy{}f WarpVector \PYGZhy{}m TensorGlyphs}
\PYG{c+c1}{\PYGZsh{}print \PYGZsq{}mayavi \PYGZhy{}d ./tripod.vtk \PYGZhy{}f WarpVector \PYGZhy{}m BandedSurfaceMap\PYGZsq{}}

\PYG{c+c1}{\PYGZsh{} export to Gmsh}
\PYG{n}{sl}\PYG{o}{.}\PYG{n}{export\PYGZus{}to\PYGZus{}pos}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tripod.pos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfe}\PYG{p}{,} \PYG{n}{VM}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Von Mises Stress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Displacement}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{sl}\PYG{o}{.}\PYG{n}{export\PYGZus{}to\PYGZus{}pos}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tripod\PYGZus{}ev.pos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Displacement}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{SigmaSL}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{stress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

In \sphinxstyleemphasis{getfem\sphinxhyphen{}interface}, the assembly of vectors, and matrices is done via the \sphinxcode{\sphinxupquote{gf.asm\_*}}
functions. The Dirichlet condition \(h(x)u(x) = r(x)\) is handled in the
weak form \(\int (h(x)u(x)).v(x) = \int r(x).v(x)\quad\forall v\) (where
\(h(x)\) is a \(3\times 3\) matrix field \textendash{} here it is constant and
equal to the identity). The reduced system \sphinxcode{\sphinxupquote{KK UU = FF}} is then built via the
elimination of Dirichlet constraints from the original system. Note that it
might be more efficient (and simpler) to deal with Dirichlet condition via a
penalization technique.


\section{Other examples}
\label{\detokenize{python/examples:other-examples}}\begin{itemize}
\item {} 
the \sphinxcode{\sphinxupquote{demo\_refine.py}} script shows a simple 2D or 3D bar whose extremity
is clamped. An adaptative refinement is used to obtain a better approximation
in the area where the stress is singular (the transition between the clamped
area and the neumann boundary).

\item {} 
the \sphinxcode{\sphinxupquote{demo\_nonlinear\_elasticity.py}} script shows a 3D bar which is is
bended and twisted. This is a quasi\sphinxhyphen{}static problem as the deformation is
applied in many steps. At each step, a non\sphinxhyphen{}linear (large deformations)
elasticity problem is solved.

\item {} 
the \sphinxcode{\sphinxupquote{demo\_stokes\_3D\_tank.py}} script shows a Stokes (viscous fluid)
problem in a tank. The \sphinxcode{\sphinxupquote{demo\_stokes\_3D\_tank\_draw.py}} shows how to draw
a nice plot of the solution, with mesh slices and stream lines. Note that the
\sphinxcode{\sphinxupquote{demo\_stokes\_3D\_tank\_alt.py}} is the old example, which uses the
deprecated \sphinxcode{\sphinxupquote{gf\_solve}} function.

\item {} 
the \sphinxcode{\sphinxupquote{demo\_bilaplacian.py}} script is just an adaption of the \sphinxstyleemphasis{GetFEM}
example \sphinxcode{\sphinxupquote{tests/bilaplacian.cc}}. Solve the bilaplacian (or a
Kirchhoff\sphinxhyphen{}Love plate model) on a square.

\item {} 
the \sphinxcode{\sphinxupquote{demo\_plasticity.py}} script is an adaptation of the \sphinxstyleemphasis{GetFEM} example
\sphinxcode{\sphinxupquote{tests/plasticity.cc}}: a 2D or 3D bar is bended in many steps, and the
plasticity of the material is taken into account (plastification occurs when
the material’s Von Mises exceeds a given threshold).

\item {} 
the \sphinxcode{\sphinxupquote{demo\_wave2D.py}} is a 2D scalar wave equation example (diffraction
of a plane wave by a cylinder), with high order geometric transformations and
high order FEMs.

\end{itemize}


\chapter{How\sphinxhyphen{}tos}
\label{\detokenize{python/howtos:how-tos}}\label{\detokenize{python/howtos:howtos}}\label{\detokenize{python/howtos::doc}}

\section{Import gmsh mesh}
\label{\detokenize{python/howtos:import-gmsh-mesh}}
If we have in the file \sphinxtitleref{quad.geo} a parameterized mesh, as this:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{n}{lc} \PYG{o}{=} \PYG{l+m+mf}{0.05} \PYG{p}{;}

\PYG{n}{Point}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{lc}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Point}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{lc}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Point}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{lc}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Point}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{lc}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{Line}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Line}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Line}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Line}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{Line} \PYG{n+nf}{Loop}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Plane} \PYG{n+nf}{Surface}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{Physical} \PYG{n+nf}{Line}\PYG{p}{(}\PYG{l+m+mi}{101}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Physical} \PYG{n+nf}{Line}\PYG{p}{(}\PYG{l+m+mi}{102}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Physical} \PYG{n+nf}{Line}\PYG{p}{(}\PYG{l+m+mi}{103}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{Physical} \PYG{n+nf}{Line}\PYG{p}{(}\PYG{l+m+mi}{104}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{Physical} \PYG{n+nf}{Surface}\PYG{p}{(}\PYG{l+m+mi}{201}\PYG{p}{)} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

then, when we run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} gmsh \PYGZhy{}2 quad.geo \PYGZhy{}format msh1
\end{sphinxVerbatim}

the file \sphinxtitleref{quad.msh} is created and contains the encoding of the mesh and its
regions. We can import that file (\sphinxstyleemphasis{quad.msh}) to getfem:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{getfem} \PYG{k}{as} \PYG{n+nn}{gf}

\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf}\PYG{o}{.}\PYG{n}{Mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{import}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gmsh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quad.msh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print} \PYG{n}{m}\PYG{o}{.}\PYG{n}{regions}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

with the second command we can see the \sphinxstyleemphasis{regions ids}. When we import the mesh,
we might be warned with the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Level 3 Warning in getfem\PYGZus{}import.cc, line 137:
  All regions must have different number!
\end{sphinxVerbatim}

this means that the parametrization of the mesh in \sphinxstyleemphasis{Gmsh} \sphinxstyleemphasis{.geo file} must
assign a \sphinxstylestrong{different} number to each region, the problem exists because in
\sphinxstyleemphasis{Gmsh} can coexist, for example, “Physical Surface (200)” and “Physical Line
(200)”, as they are different “types of regions” in \sphinxstyleemphasis{Gmsh}, that which does
not occur in \sphinxstyleemphasis{GetFEM} since there is only one “type of region”.


\chapter{API reference}
\label{\detokenize{python/cmdref:api-reference}}\label{\detokenize{python/cmdref:api}}\label{\detokenize{python/cmdref::doc}}
Please remember that this documentation is not self contained.
You should in particular refer to the \sphinxhref{http://getfem.org/userdoc/index.html}{user documentation}
to have a more extensive description of the structures algorithms
and concepts used.


\section{ContStruct}
\label{\detokenize{python/cmdref_ContStruct:contstruct}}\label{\detokenize{python/cmdref_ContStruct::doc}}\index{ContStruct (class in getfem)@\spxentry{ContStruct}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{ContStruct}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM ContStruct object

This object serves for storing parameters and data used in numerical
continuation of solution branches of models (for more details about
continuation see the GetFEM user documentation).

General constructor for ContStruct objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{S = ContStruct(Model md, string dataname\_parameter{[},string dataname\_init, string dataname\_final, string dataname\_current{]}, scalar sc\_fac{[}, ...{]})}}
The variable \sphinxtitleref{dataname\_parameter} should parametrise the model given by
\sphinxtitleref{md}. If the parameterization is done via a vector datum, \sphinxtitleref{dataname\_init}
and \sphinxtitleref{dataname\_final} should store two given values of this datum
determining the parameterization, and \sphinxtitleref{dataname\_current} serves for actual
values of this datum. \sphinxtitleref{sc\_fac} is a scale factor involved in the weighted
norm used in the continuation.

Additional options:
\begin{itemize}
\item {} \begin{description}
\item[{‘lsolver’, string SOLVER\_NAME}] \leavevmode
name of the solver to be used for the incorporated linear systems
(the default value is ‘auto’, which lets getfem choose itself);
possible values are ‘superlu’, ‘mumps’ (if supported), ‘cg/ildlt’,
‘gmres/ilu’ and ‘gmres/ilut’;

\end{description}

\item {} \begin{description}
\item[{‘h\_init’, scalar HIN}] \leavevmode
initial step size (the default value is 1e\sphinxhyphen{}2);

\end{description}

\item {} \begin{description}
\item[{‘h\_max’, scalar HMAX}] \leavevmode
maximum step size (the default value is 1e\sphinxhyphen{}1);

\end{description}

\item {} \begin{description}
\item[{‘h\_min’, scalar HMIN}] \leavevmode
minimum step size (the default value is 1e\sphinxhyphen{}5);

\end{description}

\item {} \begin{description}
\item[{‘h\_inc’, scalar HINC}] \leavevmode
factor for enlarging the step size (the default value is 1.3);

\end{description}

\item {} \begin{description}
\item[{‘h\_dec’, scalar HDEC}] \leavevmode
factor for diminishing the step size (the default value is 0.5);

\end{description}

\item {} \begin{description}
\item[{‘max\_iter’, int MIT}] \leavevmode
maximum number of iterations allowed in the correction (the default
value is 10);

\end{description}

\item {} \begin{description}
\item[{‘thr\_iter’, int TIT}] \leavevmode
threshold number of iterations of the correction for enlarging the
step size (the default value is 4);

\end{description}

\item {} \begin{description}
\item[{‘max\_res’, scalar RES}] \leavevmode
target residual value of a new point on the solution curve (the
default value is 1e\sphinxhyphen{}6);

\end{description}

\item {} \begin{description}
\item[{‘max\_diff’, scalar DIFF}] \leavevmode
determines a convergence criterion for two consecutive points (the
default value is 1e\sphinxhyphen{}6);

\end{description}

\item {} \begin{description}
\item[{‘min\_cos’, scalar MCOS}] \leavevmode
minimal value of the cosine of the angle between tangents to the
solution curve at an old point and a new one (the default value is
0.9);

\end{description}

\item {} \begin{description}
\item[{‘max\_res\_solve’, scalar RES\_SOLVE}] \leavevmode
target residual value for the linear systems to be solved (the
default value is 1e\sphinxhyphen{}8);

\end{description}

\item {} \begin{description}
\item[{‘singularities’, int SING}] \leavevmode
activates tools for detection and treatment of singular points (1 for
limit points, 2 for bifurcation points and points requiring special
branching techniques);

\end{description}

\item {} \begin{description}
\item[{‘non\sphinxhyphen{}smooth’}] \leavevmode
determines that some special methods for non\sphinxhyphen{}smooth problems can be
used;

\end{description}

\item {} \begin{description}
\item[{‘delta\_max’, scalar DMAX}] \leavevmode
maximum size of division for evaluating the test function on the
convex combination of two augmented Jacobians that belong to different
smooth pieces (the default value is 0.005);

\end{description}

\item {} \begin{description}
\item[{‘delta\_min’, scalar DMIN}] \leavevmode
minimum size of division for evaluating the test function on the
convex combination (the default value is 0.00012);

\end{description}

\item {} \begin{description}
\item[{‘thr\_var’, scalar TVAR}] \leavevmode
threshold variation for refining the division (the default value is
0.02);

\end{description}

\item {} \begin{description}
\item[{‘nb\_dir’, int NDIR}] \leavevmode
total number of the linear combinations of one couple of reference
vectors when searching for new tangent predictions during location of
new one\sphinxhyphen{}sided branches (the default value is 40);

\end{description}

\item {} \begin{description}
\item[{‘nb\_span’, int NSPAN}] \leavevmode
total number of the couples of the reference vectors forming the
linear combinations (the default value is 1);

\end{description}

\item {} \begin{description}
\item[{‘noisy’ or ‘very\_noisy’}] \leavevmode
determines how detailed information has to be displayed during the
continuation process (residual values etc.).

\end{description}

\end{itemize}

\end{itemize}
\index{Moore\_Penrose\_continuation() (ContStruct method)@\spxentry{Moore\_Penrose\_continuation()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.Moore_Penrose_continuation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Moore\_Penrose\_continuation}}}{\emph{\DUrole{n}{solution}}, \emph{\DUrole{n}{parameter}}, \emph{\DUrole{n}{tangent\_sol}}, \emph{\DUrole{n}{tangent\_par}}, \emph{\DUrole{n}{h}}}{}
Compute one step of the Moore\sphinxhyphen{}Penrose continuation: Take the point
given by \sphinxtitleref{solution} and \sphinxtitleref{parameter}, the tangent given by \sphinxtitleref{tangent\_sol}
and \sphinxtitleref{tangent\_par}, and the step size \sphinxtitleref{h}. Return a new point on the
solution curve, the corresponding tangent, a step size for the next
step and optionally the current step size. If the returned step
size equals zero, the continuation has failed. Optionally, return
the type of any detected singular point.
NOTE: The new point need not to be saved in the model in the end!

\end{fulllineitems}

\index{bifurcation\_test\_function() (ContStruct method)@\spxentry{bifurcation\_test\_function()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.bifurcation_test_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{bifurcation\_test\_function}}}{}{}
Return the last value of the bifurcation test function and eventually
the whole calculated graph when passing between different sub\sphinxhyphen{}domains
of differentiability.

\end{fulllineitems}

\index{char() (ContStruct method)@\spxentry{char()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the ContStruct.

This can be used for performing comparisons between two
different ContStruct objects.
This function is to be completed.

\end{fulllineitems}

\index{compute\_tangent() (ContStruct method)@\spxentry{compute\_tangent()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.compute_tangent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_tangent}}}{\emph{\DUrole{n}{solution}}, \emph{\DUrole{n}{parameter}}, \emph{\DUrole{n}{tangent\_sol}}, \emph{\DUrole{n}{tangent\_par}}}{}
Compute and return an updated tangent.

\end{fulllineitems}

\index{display() (ContStruct method)@\spxentry{display()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
Display a short summary for a ContStruct object.

\end{fulllineitems}

\index{init\_Moore\_Penrose\_continuation() (ContStruct method)@\spxentry{init\_Moore\_Penrose\_continuation()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.init_Moore_Penrose_continuation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_Moore\_Penrose\_continuation}}}{\emph{\DUrole{n}{solution}}, \emph{\DUrole{n}{parameter}}, \emph{\DUrole{n}{init\_dir}}}{}
Initialise the Moore\sphinxhyphen{}Penrose continuation: Return a unit tangent to
the solution curve at the point given by \sphinxtitleref{solution} and \sphinxtitleref{parameter},
and an initial step size for the continuation. Orientation of the
computed tangent with respect to the parameter is determined by the
sign of \sphinxtitleref{init\_dir}.

\end{fulllineitems}

\index{init\_step\_size() (ContStruct method)@\spxentry{init\_step\_size()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.init_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_step\_size}}}{}{}
Return an initial step size for continuation.

\end{fulllineitems}

\index{max\_step\_size() (ContStruct method)@\spxentry{max\_step\_size()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.max_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{max\_step\_size}}}{}{}
Return the maximum step size for continuation.

\end{fulllineitems}

\index{min\_step\_size() (ContStruct method)@\spxentry{min\_step\_size()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.min_step_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{min\_step\_size}}}{}{}
Return the minimum step size for continuation.

\end{fulllineitems}

\index{non\_smooth\_bifurcation\_test() (ContStruct method)@\spxentry{non\_smooth\_bifurcation\_test()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.non_smooth_bifurcation_test}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{non\_smooth\_bifurcation\_test}}}{\emph{\DUrole{n}{solution1}}, \emph{\DUrole{n}{parameter1}}, \emph{\DUrole{n}{tangent\_sol1}}, \emph{\DUrole{n}{tangent\_par1}}, \emph{\DUrole{n}{solution2}}, \emph{\DUrole{n}{parameter2}}, \emph{\DUrole{n}{tangent\_sol2}}, \emph{\DUrole{n}{tangent\_par2}}}{}
Test for a non\sphinxhyphen{}smooth bifurcation point between the point given by
\sphinxtitleref{solution1} and \sphinxtitleref{parameter1} with the tangent given by \sphinxtitleref{tangent\_sol1}
and \sphinxtitleref{tangent\_par1} and the point given by \sphinxtitleref{solution2} and \sphinxtitleref{parameter2}
with the tangent given by \sphinxtitleref{tangent\_sol2} and \sphinxtitleref{tangent\_par2}.

\end{fulllineitems}

\index{sing\_data() (ContStruct method)@\spxentry{sing\_data()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.sing_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sing\_data}}}{}{}
Return a singular point (\sphinxtitleref{X}, \sphinxtitleref{gamma}) stored in the ContStruct object and a
couple of arrays (\sphinxtitleref{T\_X}, \sphinxtitleref{T\_gamma}) of tangents to all located solution
branches that emanate from there.

\end{fulllineitems}

\index{step\_size\_decrement() (ContStruct method)@\spxentry{step\_size\_decrement()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.step_size_decrement}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step\_size\_decrement}}}{}{}
Return the decrement ratio of the step size for continuation.

\end{fulllineitems}

\index{step\_size\_increment() (ContStruct method)@\spxentry{step\_size\_increment()}\spxextra{ContStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_ContStruct:getfem.ContStruct.step_size_increment}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{step\_size\_increment}}}{}{}
Return the increment ratio of the step size for continuation.

\end{fulllineitems}


\end{fulllineitems}



\section{CvStruct}
\label{\detokenize{python/cmdref_CvStruct:cvstruct}}\label{\detokenize{python/cmdref_CvStruct::doc}}\index{CvStruct (class in getfem)@\spxentry{CvStruct}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CvStruct}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM CvStruct object

General constructor for CvStruct objects
\index{basic\_structure() (CvStruct method)@\spxentry{basic\_structure()}\spxextra{CvStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct.basic_structure}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{basic\_structure}}}{}{}
Get the simplest convex structure.

For example, the ‘basic structure’ of the 6\sphinxhyphen{}node triangle, is the
canonical 3\sphinxhyphen{}noded triangle.

\end{fulllineitems}

\index{char() (CvStruct method)@\spxentry{char()}\spxextra{CvStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a string description of the CvStruct.

\end{fulllineitems}

\index{dim() (CvStruct method)@\spxentry{dim()}\spxextra{CvStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct.dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dim}}}{}{}
Get the dimension of the convex structure.

\end{fulllineitems}

\index{display() (CvStruct method)@\spxentry{display()}\spxextra{CvStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a CvStruct object.

\end{fulllineitems}

\index{face() (CvStruct method)@\spxentry{face()}\spxextra{CvStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct.face}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{face}}}{\emph{\DUrole{n}{F}}}{}
Return the convex structure of the face \sphinxtitleref{F}.

\end{fulllineitems}

\index{facepts() (CvStruct method)@\spxentry{facepts()}\spxextra{CvStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct.facepts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{facepts}}}{\emph{\DUrole{n}{F}}}{}
Return the list of point indices for the face \sphinxtitleref{F}.

\end{fulllineitems}

\index{nbpts() (CvStruct method)@\spxentry{nbpts()}\spxextra{CvStruct method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_CvStruct:getfem.CvStruct.nbpts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbpts}}}{}{}
Get the number of points of the convex structure.

\end{fulllineitems}


\end{fulllineitems}



\section{Eltm}
\label{\detokenize{python/cmdref_Eltm:eltm}}\label{\detokenize{python/cmdref_Eltm::doc}}\index{Eltm (class in getfem)@\spxentry{Eltm}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Eltm:getfem.Eltm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Eltm}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Eltm object

This object represents a type of elementary matrix. In order to obtain a
numerical value of these matrices, see MeshIm.eltm().

If you have very particular assembling needs, or if you just want to check
the content of an elementary matrix, this function might be useful. But
the generic assembly abilities of gf\_asm(…) should suit most needs.

General constructor for Eltm objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{E = Eltm(\textquotesingle{}base\textquotesingle{}, Fem FEM)}}
return a descriptor for the integration of shape functions on
elements, using the Fem \sphinxtitleref{FEM}.

\item {} 
\sphinxcode{\sphinxupquote{E = Eltm(\textquotesingle{}grad\textquotesingle{}, Fem FEM)}}
return a descriptor for the integration of the gradient of shape
functions on elements, using the Fem \sphinxtitleref{FEM}.

\item {} 
\sphinxcode{\sphinxupquote{E = Eltm(\textquotesingle{}hessian\textquotesingle{}, Fem FEM)}}
return a descriptor for the integration of the hessian of shape
functions on elements, using the Fem \sphinxtitleref{FEM}.

\item {} 
\sphinxcode{\sphinxupquote{E = Eltm(\textquotesingle{}normal\textquotesingle{})}}
return a descriptor for the unit normal of convex faces.

\item {} 
\sphinxcode{\sphinxupquote{E = Eltm(\textquotesingle{}grad\_geotrans\textquotesingle{})}}
return a descriptor to the gradient matrix of the geometric
transformation.

\item {} 
\sphinxcode{\sphinxupquote{E = Eltm(\textquotesingle{}grad\_geotrans\_inv\textquotesingle{})}}
return a descriptor to the inverse of the gradient matrix of the
geometric transformation (this is rarely used).

\item {} 
\sphinxcode{\sphinxupquote{E = Eltm(\textquotesingle{}product\textquotesingle{}, Eltm A, Eltm B)}}
return a descriptor for the integration of the tensorial product of
elementary matrices \sphinxtitleref{A} and \sphinxtitleref{B}.

\end{itemize}

\end{fulllineitems}



\section{Fem}
\label{\detokenize{python/cmdref_Fem:fem}}\label{\detokenize{python/cmdref_Fem::doc}}\index{Fem (class in getfem)@\spxentry{Fem}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Fem}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Fem object

This object represents a finite element method on a reference element.

General constructor for Fem objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{F = Fem(\textquotesingle{}interpolated\_fem\textquotesingle{}, MeshFem mf\_source, MeshIm mim\_target, {[}ivec blocked\_dofs{[}, bool caching{]}{]})}}
Build a special Fem which is interpolated from another MeshFem.

Using this special finite element, it is possible to interpolate a given
MeshFem \sphinxtitleref{mf\_source} on another mesh, given the integration method \sphinxtitleref{mim\_target}
that will be used on this mesh.

Note that this finite element may be quite slow or consume much
memory depending if caching is used or not. By default \sphinxtitleref{caching} is
True

\item {} 
\sphinxcode{\sphinxupquote{F = Fem(\textquotesingle{}projected\_fem\textquotesingle{}, MeshFem mf\_source, MeshIm mim\_target, int rg\_source, int rg\_target{[}, ivec blocked\_dofs{[}, bool caching{]}{]})}}
Build a special Fem which is interpolated from another MeshFem.

Using this special finite element, it is possible to interpolate a given
MeshFem \sphinxtitleref{mf\_source} on another mesh, given the integration method \sphinxtitleref{mim\_target}
that will be used on this mesh.

Note that this finite element may be quite slow or consume much
memory depending if caching is used or not. By default \sphinxtitleref{caching} is
True

\item {} 
\sphinxcode{\sphinxupquote{F = Fem(string fem\_name)}}
The \sphinxtitleref{fem\_name} should contain a description of the finite element
method. Please refer to the GetFEM manual (especially the
description of finite element and integration methods) for a complete
reference. Here is a list of some of them:
\begin{itemize}
\item {} 
FEM\_PK(n,k) :
classical Lagrange element Pk on a simplex of dimension \sphinxtitleref{n}.

\item {} 
FEM\_PK\_DISCONTINUOUS(n,k{[},alpha{]}) :
discontinuous Lagrange element Pk on a simplex of dimension \sphinxtitleref{n}.

\item {} 
FEM\_QK(n,k) :
classical Lagrange element Qk on quadrangles, hexahedrons etc.

\item {} 
FEM\_QK\_DISCONTINUOUS(n,k{[},alpha{]}) :
discontinuous Lagrange element Qk on quadrangles, hexahedrons etc.

\item {} 
FEM\_Q2\_INCOMPLETE(n) :
incomplete Q2 elements with 8 and 20 dof (serendipity Quad 8 and
Hexa 20 elements).

\item {} 
FEM\_PK\_PRISM(n,k) :
classical Lagrange element Pk on a prism of dimension \sphinxtitleref{n}.

\item {} 
FEM\_PK\_PRISM\_DISCONTINUOUS(n,k{[},alpha{]}) :
classical discontinuous Lagrange element Pk on a prism.

\item {} 
FEM\_PK\_WITH\_CUBIC\_BUBBLE(n,k) :
classical Lagrange element Pk on a simplex with an additional
volumic bubble function.

\item {} 
FEM\_P1\_NONCONFORMING :
non\sphinxhyphen{}conforming P1 method on a triangle.

\item {} 
FEM\_P1\_BUBBLE\_FACE(n) :
P1 method on a simplex with an additional bubble function on face 0.

\item {} 
FEM\_P1\_BUBBLE\_FACE\_LAG :
P1 method on a simplex with an additional lagrange dof on face 0.

\item {} 
FEM\_PK\_HIERARCHICAL(n,k) :
PK element with a hierarchical basis.

\item {} 
FEM\_QK\_HIERARCHICAL(n,k) :
QK element with a hierarchical basis.

\item {} 
FEM\_PK\_PRISM\_HIERARCHICAL(n,k) :
PK element on a prism with a hierarchical basis.

\item {} 
FEM\_STRUCTURED\_COMPOSITE(Fem f,k) :
Composite Fem \sphinxtitleref{f} on a grid with \sphinxtitleref{k} divisions.

\item {} 
FEM\_PK\_HIERARCHICAL\_COMPOSITE(n,k,s) :
Pk composite element on a grid with \sphinxtitleref{s} subdivisions and with a
hierarchical basis.

\item {} 
FEM\_PK\_FULL\_HIERARCHICAL\_COMPOSITE(n,k,s) :
Pk composite element with \sphinxtitleref{s} subdivisions and a hierarchical basis
on both degree and subdivision.

\item {} 
FEM\_PRODUCT(A,B) :
tensorial product of two polynomial elements.

\item {} 
FEM\_HERMITE(n) :
Hermite element P3 on a simplex of dimension \sphinxtitleref{n = 1, 2, 3}.

\item {} 
FEM\_ARGYRIS :
Argyris element P5 on the triangle.

\item {} 
FEM\_HCT\_TRIANGLE :
Hsieh\sphinxhyphen{}Clough\sphinxhyphen{}Tocher element on the triangle (composite P3 element
which is C1), should be used with IM\_HCT\_COMPOSITE() integration
method.

\item {} 
FEM\_QUADC1\_COMPOSITE :
Quadrilateral element, composite P3 element and C1 (16 dof).

\item {} 
FEM\_REDUCED\_QUADC1\_COMPOSITE :
Quadrilateral element, composite P3 element and C1 (12 dof).

\item {} 
FEM\_RT0(n) :
Raviart\sphinxhyphen{}Thomas element of order 0 on a simplex of dimension \sphinxtitleref{n}.

\item {} 
FEM\_NEDELEC(n) :
Nedelec edge element of order 0 on a simplex of dimension \sphinxtitleref{n}.

\end{itemize}

Of course, you have to ensure that the selected fem is compatible with
the geometric transformation: a Pk fem has no meaning on a quadrangle.

\end{itemize}
\index{base\_value() (Fem method)@\spxentry{base\_value()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.base_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{base\_value}}}{\emph{\DUrole{n}{p}}}{}
Evaluate all basis functions of the FEM at point \sphinxtitleref{p}.

\sphinxtitleref{p} is supposed to be in the reference convex!

\end{fulllineitems}

\index{char() (Fem method)@\spxentry{char()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Ouput a (unique) string representation of the Fem.

This can be used to perform comparisons between two different Fem
objects.

\end{fulllineitems}

\index{dim() (Fem method)@\spxentry{dim()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dim}}}{}{}
Return the dimension (dimension of the reference convex) of the Fem.

\end{fulllineitems}

\index{display() (Fem method)@\spxentry{display()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a Fem object.

\end{fulllineitems}

\index{estimated\_degree() (Fem method)@\spxentry{estimated\_degree()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.estimated_degree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{estimated\_degree}}}{}{}
Return an estimation of the polynomial degree of the Fem.

This is an estimation for fem which are not polynomials.

\end{fulllineitems}

\index{grad\_base\_value() (Fem method)@\spxentry{grad\_base\_value()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.grad_base_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad\_base\_value}}}{\emph{\DUrole{n}{p}}}{}
Evaluate the gradient of all base functions of the Fem at point \sphinxtitleref{p}.

\sphinxtitleref{p} is supposed to be in the reference convex!

\end{fulllineitems}

\index{hess\_base\_value() (Fem method)@\spxentry{hess\_base\_value()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.hess_base_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hess\_base\_value}}}{\emph{\DUrole{n}{p}}}{}
Evaluate the Hessian of all base functions of the Fem at point \sphinxtitleref{p}.

\sphinxtitleref{p} is supposed to be in the reference convex!

\end{fulllineitems}

\index{index\_of\_global\_dof() (Fem method)@\spxentry{index\_of\_global\_dof()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.index_of_global_dof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{index\_of\_global\_dof}}}{\emph{\DUrole{n}{cv}}}{}
Return the index of global dof for special fems such as interpolated fem.

\end{fulllineitems}

\index{is\_equivalent() (Fem method)@\spxentry{is\_equivalent()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.is_equivalent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_equivalent}}}{}{}
Return 0 if the Fem is not equivalent.

Equivalent Fem are evaluated on the reference convex. This is
the case of most classical Fem’s.

\end{fulllineitems}

\index{is\_lagrange() (Fem method)@\spxentry{is\_lagrange()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.is_lagrange}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_lagrange}}}{}{}
Return 0 if the Fem is not of Lagrange type.

\end{fulllineitems}

\index{is\_polynomial() (Fem method)@\spxentry{is\_polynomial()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.is_polynomial}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_polynomial}}}{}{}
Return 0 if the basis functions are not polynomials.

\end{fulllineitems}

\index{nbdof() (Fem method)@\spxentry{nbdof()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.nbdof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbdof}}}{\emph{\DUrole{n}{cv}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the number of dof for the Fem.

Some specific Fem (for example ‘interpolated\_fem’) may require a
convex number \sphinxtitleref{cv} to give their result. In most of the case, you
can omit this convex number.

\end{fulllineitems}

\index{poly\_str() (Fem method)@\spxentry{poly\_str()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.poly_str}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{poly\_str}}}{}{}
Return the polynomial expressions of its basis functions in
the reference convex.

The result is expressed as a tuple of
strings. Of course this will fail on non\sphinxhyphen{}polynomial Fem’s.

\end{fulllineitems}

\index{pts() (Fem method)@\spxentry{pts()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pts}}}{\emph{\DUrole{n}{cv}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get the location of the dof on the reference element.

Some specific Fem may require a convex number \sphinxtitleref{cv} to give their
result (for example ‘interpolated\_fem’). In most of the case, you
can omit this convex number.

\end{fulllineitems}

\index{target\_dim() (Fem method)@\spxentry{target\_dim()}\spxextra{Fem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Fem:getfem.Fem.target_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{target\_dim}}}{}{}
Return the dimension of the target space.

The target space dimension is usually 1, except for vector Fem.

\end{fulllineitems}


\end{fulllineitems}



\section{GeoTrans}
\label{\detokenize{python/cmdref_GeoTrans:geotrans}}\label{\detokenize{python/cmdref_GeoTrans::doc}}\index{GeoTrans (class in getfem)@\spxentry{GeoTrans}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{GeoTrans}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM GeoTrans object

The geometric transformation must be used when you are building a custom
mesh convex by convex (see the add\_convex() function of Mesh): it also
defines the kind of convex (triangle, hexahedron, prism, etc..)

General constructor for GeoTrans objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{GT = GeoTrans(string name)}}
The name argument contains the specification of the geometric transformation
as a string, which may be:
\begin{itemize}
\item {} 
GT\_PK(n,k) :
Transformation on simplexes, dim \sphinxtitleref{n}, degree \sphinxtitleref{k}.

\item {} 
GT\_QK(n,k) :
Transformation on parallelepipeds, dim \sphinxtitleref{n}, degree \sphinxtitleref{k}.

\item {} 
GT\_PRISM(n,k) :
Transformation on prisms, dim \sphinxtitleref{n}, degree \sphinxtitleref{k}.

\item {} 
GT\_PRODUCT(A,B) :
Tensorial product of two transformations.

\item {} 
GT\_LINEAR\_PRODUCT(GeoTrans gt1,GeoTrans gt2) :
Linear tensorial product of two transformations

\end{itemize}

\end{itemize}
\index{char() (GeoTrans method)@\spxentry{char()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the GeoTrans.

This can be used to perform comparisons between two
different GeoTrans objects.

\end{fulllineitems}

\index{dim() (GeoTrans method)@\spxentry{dim()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dim}}}{}{}
Get the dimension of the GeoTrans.

This is the dimension of the source space, i.e. the dimension of
the reference convex.

\end{fulllineitems}

\index{display() (GeoTrans method)@\spxentry{display()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a GeoTrans object.

\end{fulllineitems}

\index{is\_linear() (GeoTrans method)@\spxentry{is\_linear()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.is_linear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_linear}}}{}{}
Return 0 if the GeoTrans is not linear.

\end{fulllineitems}

\index{nbpts() (GeoTrans method)@\spxentry{nbpts()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.nbpts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbpts}}}{}{}
Return the number of points of the GeoTrans.

\end{fulllineitems}

\index{normals() (GeoTrans method)@\spxentry{normals()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.normals}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{normals}}}{}{}
Get the normals for each face of the reference convex of the GeoTrans.

The normals are stored in the columns of the output matrix.

\end{fulllineitems}

\index{pts() (GeoTrans method)@\spxentry{pts()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pts}}}{}{}
Return the reference convex points of the GeoTrans.

The points are stored in the columns of the output matrix.

\end{fulllineitems}

\index{transform() (GeoTrans method)@\spxentry{transform()}\spxextra{GeoTrans method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GeoTrans:getfem.GeoTrans.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{G}}, \emph{\DUrole{n}{Pr}}}{}
Apply the GeoTrans to a set of points.

\sphinxtitleref{G} is the set of vertices of the real convex, \sphinxtitleref{Pr} is the set
of points (in the reference convex) that are to be transformed.
The corresponding set of points in the real convex is returned.

\end{fulllineitems}


\end{fulllineitems}



\section{GlobalFunction}
\label{\detokenize{python/cmdref_GlobalFunction:globalfunction}}\label{\detokenize{python/cmdref_GlobalFunction::doc}}\index{GlobalFunction (class in getfem)@\spxentry{GlobalFunction}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GlobalFunction:getfem.GlobalFunction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{GlobalFunction}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM GlobalFunction object

Global function object is represented by three functions:
\begin{itemize}
\item {} 
The function \sphinxtitleref{val}.

\item {} 
The function gradient \sphinxtitleref{grad}.

\item {} 
The function Hessian \sphinxtitleref{hess}.

\end{itemize}

this type of function is used as local and global enrichment function. The
global function Hessian is an optional parameter (only for fourth order
derivative problems).

General constructor for GlobalFunction objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{GF = GlobalFunction(\textquotesingle{}cutoff\textquotesingle{}, int fn, scalar r, scalar r1, scalar r0)}}
Create a cutoff global function.

\item {} 
\sphinxcode{\sphinxupquote{GF = GlobalFunction(\textquotesingle{}crack\textquotesingle{}, int fn)}}
Create a near\sphinxhyphen{}tip asymptotic global function for modelling cracks.

\item {} 
\sphinxcode{\sphinxupquote{GF = GlobalFunction(\textquotesingle{}parser\textquotesingle{}, string val{[}, string grad{[}, string hess{]}{]})}}
Create a global function from strings \sphinxtitleref{val}, \sphinxtitleref{grad} and \sphinxtitleref{hess}.
This function could be improved by using the derivation of the generic
assembly language … to be done.

\item {} 
\sphinxcode{\sphinxupquote{GF = GlobalFunction(\textquotesingle{}product\textquotesingle{}, GlobalFunction F, GlobalFunction G)}}
Create a product of two global functions.

\item {} 
\sphinxcode{\sphinxupquote{GF = GlobalFunction(\textquotesingle{}add\textquotesingle{}, GlobalFunction gf1, GlobalFunction gf2)}}
Create a add of two global functions.

\end{itemize}
\index{char() (GlobalFunction method)@\spxentry{char()}\spxextra{GlobalFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GlobalFunction:getfem.GlobalFunction.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the GlobalFunction.

This can be used to perform comparisons between two
different GlobalFunction objects.
This function is to be completed.

\end{fulllineitems}

\index{display() (GlobalFunction method)@\spxentry{display()}\spxextra{GlobalFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GlobalFunction:getfem.GlobalFunction.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a GlobalFunction object.

\end{fulllineitems}

\index{grad() (GlobalFunction method)@\spxentry{grad()}\spxextra{GlobalFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GlobalFunction:getfem.GlobalFunction.grad}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grad}}}{\emph{\DUrole{n}{PTs}}}{}
Return \sphinxtitleref{grad} function evaluation in \sphinxtitleref{PTs} (column points).

On return, each column of \sphinxtitleref{GRADs} is of the
form {[}Gx,Gy{]}.

\end{fulllineitems}

\index{hess() (GlobalFunction method)@\spxentry{hess()}\spxextra{GlobalFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GlobalFunction:getfem.GlobalFunction.hess}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hess}}}{\emph{\DUrole{n}{PTs}}}{}
Return \sphinxtitleref{hess} function evaluation in \sphinxtitleref{PTs} (column points).

On return, each column of \sphinxtitleref{HESSs} is of the
form {[}Hxx,Hxy,Hyx,Hyy{]}.

\end{fulllineitems}

\index{val() (GlobalFunction method)@\spxentry{val()}\spxextra{GlobalFunction method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_GlobalFunction:getfem.GlobalFunction.val}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{val}}}{\emph{\DUrole{n}{PTs}}}{}
Return \sphinxtitleref{val} function evaluation in \sphinxtitleref{PTs} (column points).

\end{fulllineitems}


\end{fulllineitems}



\section{Integ}
\label{\detokenize{python/cmdref_Integ:integ}}\label{\detokenize{python/cmdref_Integ::doc}}\index{Integ (class in getfem)@\spxentry{Integ}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Integ}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Integ object

General object for obtaining handles to various integrations methods on
convexes (used when the elementary matrices are built).

General constructor for Integ objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{I = Integ(string method)}}
Here is a list of some integration methods defined in GetFEM (see the
description of finite element and integration methods for a complete
reference):
\begin{itemize}
\item {} 
IM\_EXACT\_SIMPLEX(n) :
Exact integration on simplices (works only with linear geometric
transformations and PK Fem’s).

\item {} 
IM\_PRODUCT(A,B) :
Product of two integration methods.

\item {} 
IM\_EXACT\_PARALLELEPIPED(n) :
Exact integration on parallelepipeds.

\item {} 
IM\_EXACT\_PRISM(n) :
Exact integration on prisms.

\item {} 
IM\_GAUSS1D(k) :
Gauss method on the segment, order \sphinxtitleref{k=1,3,…,99}.

\item {} 
IM\_NC(n,k) :
Newton\sphinxhyphen{}Cotes approximative integration on simplexes, order \sphinxtitleref{k}.

\item {} 
IM\_NC\_PARALLELEPIPED(n,k) :
Product of Newton\sphinxhyphen{}Cotes integration on parallelepipeds.

\item {} 
IM\_NC\_PRISM(n,k) :
Product of Newton\sphinxhyphen{}Cotes integration on prisms.

\item {} 
IM\_GAUSS\_PARALLELEPIPED(n,k) :
Product of Gauss1D integration on parallelepipeds.

\item {} 
IM\_TRIANGLE(k) :
Gauss methods on triangles \sphinxtitleref{k=1,3,5,6,7,8,9,10,13,17,19}.

\item {} 
IM\_QUAD(k) :
Gauss methods on quadrilaterons \sphinxtitleref{k=2,3,5, …,17}. Note that
IM\_GAUSS\_PARALLELEPIPED should be prefered for QK Fem’s.

\item {} 
IM\_TETRAHEDRON(k) :
Gauss methods on tetrahedrons \sphinxtitleref{k=1,2,3,5,6 or 8}.

\item {} 
IM\_SIMPLEX4D(3) :
Gauss method on a 4\sphinxhyphen{}dimensional simplex.

\item {} 
IM\_STRUCTURED\_COMPOSITE(im,k) :
Composite method on a grid with \sphinxtitleref{k} divisions.

\item {} 
IM\_HCT\_COMPOSITE(im) :
Composite integration suited to the HCT composite finite element.

\end{itemize}

Example:
\begin{itemize}
\item {} 
I = Integ(‘IM\_PRODUCT(IM\_GAUSS1D(5),IM\_GAUSS1D(5))’)

\end{itemize}

is the same as:
\begin{itemize}
\item {} 
I = Integ(‘IM\_GAUSS\_PARALLELEPIPED(2,5)’)

\end{itemize}

Note that ‘exact integration’ should be avoided in general, since they
only apply to linear geometric transformations, are quite slow, and
subject to numerical stability problems for high degree Fem’s.

\end{itemize}
\index{char() (Integ method)@\spxentry{char()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Ouput a (unique) string representation of the integration method.

This can be used to  comparisons between two different Integ
objects.

\end{fulllineitems}

\index{coeffs() (Integ method)@\spxentry{coeffs()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.coeffs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coeffs}}}{}{}
Returns the coefficients associated to each integration point.

Only for approximate methods, this has no meaning for exact
integration methods!

\end{fulllineitems}

\index{dim() (Integ method)@\spxentry{dim()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dim}}}{}{}
Return the dimension of the reference convex of
the method.

\end{fulllineitems}

\index{display() (Integ method)@\spxentry{display()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a Integ object.

\end{fulllineitems}

\index{face\_coeffs() (Integ method)@\spxentry{face\_coeffs()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.face_coeffs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{face\_coeffs}}}{\emph{\DUrole{n}{F}}}{}
Returns the coefficients associated to each integration of a face.

Only for approximate methods, this has no meaning for exact
integration methods!

\end{fulllineitems}

\index{face\_pts() (Integ method)@\spxentry{face\_pts()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.face_pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{face\_pts}}}{\emph{\DUrole{n}{F}}}{}
Return the list of integration points for a face.

Only for approximate methods, this has no meaning for exact
integration methods!

\end{fulllineitems}

\index{is\_exact() (Integ method)@\spxentry{is\_exact()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.is_exact}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_exact}}}{}{}
Return 0 if the integration is an approximate one.

\end{fulllineitems}

\index{nbpts() (Integ method)@\spxentry{nbpts()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.nbpts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbpts}}}{}{}
Return the total number of integration points.

Count the points for the volume integration, and points for
surface integration on each face of the reference convex.

Only for approximate methods, this has no meaning for exact
integration methods!

\end{fulllineitems}

\index{pts() (Integ method)@\spxentry{pts()}\spxextra{Integ method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Integ:getfem.Integ.pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pts}}}{}{}
Return the list of integration points

Only for approximate methods, this has no meaning for exact
integration methods!

\end{fulllineitems}


\end{fulllineitems}



\section{LevelSet}
\label{\detokenize{python/cmdref_LevelSet:levelset}}\label{\detokenize{python/cmdref_LevelSet::doc}}\index{LevelSet (class in getfem)@\spxentry{LevelSet}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{LevelSet}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM LevelSet object

The level\sphinxhyphen{}set object is represented by a primary level\sphinxhyphen{}set and optionally
a secondary level\sphinxhyphen{}set used to represent fractures (if p(x) is the primary
level\sphinxhyphen{}set function and s(x) is the secondary level\sphinxhyphen{}set, the crack is
defined by \(p(x)=0\) and \(s(x)\leq0\) : the role of the secondary is to determine
the crack front/tip).

note:
\begin{quote}

All tools listed below need the package qhull installed on your
system. This package is widely available. It computes convex hull and
delaunay triangulations in arbitrary dimension.
\end{quote}

General constructor for LevelSet objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{LS = LevelSet(Mesh m, int d{[}, string \textquotesingle{}ws\textquotesingle{}| string f1{[}, string f2 | string \textquotesingle{}ws\textquotesingle{}{]}{]})}}
Create a LevelSet object on a Mesh represented by a primary function
(and optional secondary function, both) defined on a lagrange MeshFem of
degree \sphinxtitleref{d}.

If \sphinxtitleref{ws} (with secondary) is set; this levelset is represented by a
primary function and a secondary function. If \sphinxtitleref{f1} is set; the primary
function is defined by that expression (with the syntax of the high
generic assembly language). If \sphinxtitleref{f2} is set; this levelset
is represented by a primary function and a secondary function defined
by these expressions.

\end{itemize}
\index{char() (LevelSet method)@\spxentry{char()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the LevelSet.

This can be used to perform comparisons between two
different LevelSet objects.
This function is to be completed.

\end{fulllineitems}

\index{degree() (LevelSet method)@\spxentry{degree()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.degree}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{degree}}}{}{}
Return the degree of lagrange representation.

\end{fulllineitems}

\index{display() (LevelSet method)@\spxentry{display()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a LevelSet.

\end{fulllineitems}

\index{memsize() (LevelSet method)@\spxentry{memsize()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.memsize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{memsize}}}{}{}
Return the amount of memory (in bytes) used by the level\sphinxhyphen{}set.

\end{fulllineitems}

\index{mf() (LevelSet method)@\spxentry{mf()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.mf}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mf}}}{}{}
Return a reference on the MeshFem object.

\end{fulllineitems}

\index{set\_values() (LevelSet method)@\spxentry{set\_values()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.set_values}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_values}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: LevelSet.set\_values(self, \{mat v1|string func\_1\}{[}, mat v2|string func\_2{]})

Set values of the vector of dof for the level\sphinxhyphen{}set functions.

Set the primary function with the vector of dof \sphinxtitleref{v1} (or the expression
\sphinxtitleref{func\_1}) and the secondary function (if any) with  the vector of dof
\sphinxtitleref{v2} (or the expression \sphinxtitleref{func\_2})

\end{fulllineitems}

\index{simplify() (LevelSet method)@\spxentry{simplify()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.simplify}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simplify}}}{\emph{\DUrole{n}{eps}\DUrole{o}{=}\DUrole{default_value}{0.01}}}{}
Simplify dof of level\sphinxhyphen{}set optionally with the parameter \sphinxtitleref{eps}.

\end{fulllineitems}

\index{values() (LevelSet method)@\spxentry{values()}\spxextra{LevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_LevelSet:getfem.LevelSet.values}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{values}}}{\emph{\DUrole{n}{nls}}}{}
Return the vector of dof for \sphinxtitleref{nls} function.

If \sphinxtitleref{nls} is 0, the method return the vector of dof for the primary
level\sphinxhyphen{}set function. If \sphinxtitleref{nls} is 1, the method return the vector of
dof for the secondary level\sphinxhyphen{}set function (if any).

\end{fulllineitems}


\end{fulllineitems}



\section{Mesh}
\label{\detokenize{python/cmdref_Mesh:mesh}}\label{\detokenize{python/cmdref_Mesh::doc}}\index{Mesh (class in getfem)@\spxentry{Mesh}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Mesh}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Mesh object

This object is able to store any element in any dimension even if you mix
elements with different dimensions.

General constructor for Mesh objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}empty\textquotesingle{}, int dim)}}
Create a new empty mesh.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}cartesian\textquotesingle{}, vec X{[}, vec Y{[}, vec Z,..{]}{]})}}
Build quickly a regular mesh of quadrangles, cubes, etc.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}pyramidal\textquotesingle{}, vec X{[}, vec Y{[}, vec Z,..{]}{]})}}
Build quickly a regular mesh of pyramids, etc.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}cartesian Q1\textquotesingle{}, vec X, vec Y{[}, vec Z,..{]})}}
Build quickly a regular mesh of quadrangles, cubes, etc. with
Q1 elements.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}triangles grid\textquotesingle{}, vec X, vec Y)}}
Build quickly a regular mesh of triangles.

This is a very limited and somehow deprecated function (See also
\sphinxcode{\sphinxupquote{Mesh(\textquotesingle{}ptND\textquotesingle{})}}, \sphinxcode{\sphinxupquote{Mesh(\textquotesingle{}regular simplices\textquotesingle{})}} and
\sphinxcode{\sphinxupquote{Mesh(\textquotesingle{}cartesian\textquotesingle{})}}).

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}regular simplices\textquotesingle{}, vec X{[}, vec Y{[}, vec Z,...{]}{]}{[}\textquotesingle{}degree\textquotesingle{}, int k{]}{[}\textquotesingle{}noised\textquotesingle{}{]})}}
Mesh a n\sphinxhyphen{}dimensional parallelepiped with simplices (triangles,
tetrahedrons etc) .

The optional degree may be used to build meshes with non linear
geometric transformations.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}curved\textquotesingle{}, Mesh m, vec F)}}
Build a curved (n+1)\sphinxhyphen{}dimensions mesh from a n\sphinxhyphen{}dimensions mesh \sphinxtitleref{m}.

The points of the new mesh have one additional coordinate, given by
the vector \sphinxtitleref{F}. This can be used to obtain meshes for shells. \sphinxtitleref{m} may
be a MeshFem object, in that case its linked mesh will be used.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}prismatic\textquotesingle{}, Mesh m, int nl{[}, int degree{]})}}
Extrude a prismatic Mesh \sphinxtitleref{M} from a Mesh \sphinxtitleref{m}.

In the additional dimension there are \sphinxtitleref{nl} layers of elements
distributed from \sphinxcode{\sphinxupquote{0}} to \sphinxcode{\sphinxupquote{1}}.
If the optional parameter \sphinxtitleref{degree} is provided with a value greater
than the default value of \sphinxcode{\sphinxupquote{1}}, a non\sphinxhyphen{}linear transformation of
corresponding degree is considered in the extrusion direction.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}pt2D\textquotesingle{}, mat P, imat T{[}, int n{]})}}
Build a mesh from a 2D triangulation.

Each column of \sphinxtitleref{P} contains a point coordinate, and each column of \sphinxtitleref{T}
contains the point indices of a triangle. \sphinxtitleref{n} is optional and is a
zone number. If \sphinxtitleref{n} is specified then only the zone number \sphinxtitleref{n} is
converted (in that case, \sphinxtitleref{T} is expected to have 4 rows, the fourth
containing these zone numbers).

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}ptND\textquotesingle{}, mat P, imat T)}}
Build a mesh from a n\sphinxhyphen{}dimensional “triangulation”.

Similar function to ‘pt2D’, for building simplexes meshes from a
triangulation given in \sphinxtitleref{T}, and a list of points given in \sphinxtitleref{P}. The
dimension of the mesh will be the number of rows of \sphinxtitleref{P}, and the
dimension of the simplexes will be the number of rows of \sphinxtitleref{T}.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}load\textquotesingle{}, string filename)}}
Load a mesh from a GetFEM ascii mesh file.

See also \sphinxcode{\sphinxupquote{Mesh.save(string filename)}}.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}from string\textquotesingle{}, string s)}}
Load a mesh from a string description.

For example, a string returned by \sphinxcode{\sphinxupquote{Mesh.char()}}.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}import\textquotesingle{}, string format, string filename)}}
Import a mesh.

\sphinxtitleref{format} may be:
\begin{itemize}
\item {} 
‘gmsh’ for a mesh created with \sphinxtitleref{Gmsh}

\item {} 
‘gid’ for a mesh created with \sphinxtitleref{GiD}

\item {} 
‘cdb’ for a mesh created with \sphinxtitleref{ANSYS}

\item {} 
‘am\_fmt’ for a mesh created with \sphinxtitleref{EMC2}

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}clone\textquotesingle{}, Mesh m2)}}
Create a copy of a mesh.

\item {} 
\sphinxcode{\sphinxupquote{M = Mesh(\textquotesingle{}generate\textquotesingle{}, MesherObject mo, scalar h{[}, int K = 1{[}, mat vertices{]}{]})}}
Call the experimental mesher of Getfem on the geometry
represented by \sphinxtitleref{mo}. please control the conformity of the produced mesh.
You can help the mesher by adding a priori vertices in the array
\sphinxtitleref{vertices} which should be of size \sphinxcode{\sphinxupquote{n x m}} where \sphinxcode{\sphinxupquote{n}} n is the
dimension of the mesh and \sphinxcode{\sphinxupquote{m}} the number of points. \sphinxtitleref{h} is
approximate diameter of the elements. \sphinxtitleref{K} is the degree of the
mesh ( \textgreater{} 1 for curved boundaries).  The mesher try to optimize the
quality of the elements. This operation may be time consuming.
Note that if the mesh generation fails, because of some random
procedure used, it can be run again since it will not give necessarily
the same result due to random procedures used.
The messages send to the console by the mesh generation can be
deactivated using \sphinxtitleref{gf\_util(‘trace level’, 2)}. More information
can be obtained by \sphinxtitleref{gf\_util(‘trace level’, 4)}. See \sphinxcode{\sphinxupquote{MesherObject}}
to manipulate geometric primitives in order to describe the geometry.

\end{itemize}
\index{add\_convex() (Mesh method)@\spxentry{add\_convex()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.add_convex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_convex}}}{\emph{\DUrole{n}{GT}}, \emph{\DUrole{n}{PTS}}}{}
Add a new convex into the mesh.

The convex structure (triangle, prism,…) is given by \sphinxtitleref{GT}
(obtained with GeoTrans(‘…’)), and its points are given by
the columns of \sphinxtitleref{PTS}. On return, \sphinxtitleref{CVIDs} contains the convex \#ids.
\sphinxtitleref{PTS} might be a 3\sphinxhyphen{}dimensional array in order to insert more than
one convex (or a two dimensional array correctly shaped according
to Fortran ordering).

\end{fulllineitems}

\index{add\_point() (Mesh method)@\spxentry{add\_point()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.add_point}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_point}}}{\emph{\DUrole{n}{PTS}}}{}
Insert new points in the mesh and return their \#ids.

\sphinxtitleref{PTS} should be an \sphinxcode{\sphinxupquote{nxm}} matrix , where \sphinxcode{\sphinxupquote{n}} is the mesh
dimension, and \sphinxcode{\sphinxupquote{m}} is the number of points that will be
added to the mesh. On output, \sphinxtitleref{PIDs} contains the point \#ids
of these new points.

Remark: if some points are already part of the mesh (with a small
tolerance of approximately \sphinxcode{\sphinxupquote{1e\sphinxhyphen{}8}}), they won’t be inserted again,
and \sphinxtitleref{PIDs} will contain the previously assigned \#ids of these
points.

\end{fulllineitems}

\index{adjacent\_face() (Mesh method)@\spxentry{adjacent\_face()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.adjacent_face}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{adjacent\_face}}}{\emph{\DUrole{n}{cvid}}, \emph{\DUrole{n}{fid}}}{}
Return convex face of the neighbor element if it exists.
If the convex have more than one neighbor
relatively to the face \sphinxcode{\sphinxupquote{f}} (think to bar elements in 3D for instance),
return the first face found.

\end{fulllineitems}

\index{all\_faces() (Mesh method)@\spxentry{all\_faces()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.all_faces}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{all\_faces}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the set of faces of the in CVIDs (in all the mesh if CVIDs is
omitted). Note that the face shared by two neighbor elements will be
represented twice.

\end{fulllineitems}

\index{boundaries() (Mesh method)@\spxentry{boundaries()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.boundaries}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{boundaries}}}{}{}
DEPRECATED FUNCTION. Use ‘regions’ instead.

\end{fulllineitems}

\index{boundary() (Mesh method)@\spxentry{boundary()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.boundary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{boundary}}}{}{}
DEPRECATED FUNCTION. Use ‘region’ instead.

\end{fulllineitems}

\index{char() (Mesh method)@\spxentry{char()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a string description of the mesh.

\end{fulllineitems}

\index{convex\_area() (Mesh method)@\spxentry{convex\_area()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.convex_area}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convex\_area}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return an estimate of the area of each convex.

\end{fulllineitems}

\index{convex\_radius() (Mesh method)@\spxentry{convex\_radius()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.convex_radius}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convex\_radius}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return an estimate of the radius of each convex.

\end{fulllineitems}

\index{convexes\_in\_box() (Mesh method)@\spxentry{convexes\_in\_box()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.convexes_in_box}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convexes\_in\_box}}}{\emph{\DUrole{n}{pmin}}, \emph{\DUrole{n}{pmax}}}{}
Return the set of convexes lying entirely within the box defined by the corner points \sphinxtitleref{pmin} and \sphinxtitleref{pmax}.

The output \sphinxtitleref{CVIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.

\end{fulllineitems}

\index{curved\_edges() (Mesh method)@\spxentry{curved\_edges()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.curved_edges}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{curved\_edges}}}{\emph{\DUrole{n}{N}}, \emph{\DUrole{n}{CVLST}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
{[}OBSOLETE FUNCTION! will be removed in a future release{]}

Return E and C.
More sophisticated version of Mesh.edges() designed for
curved elements. This one will return N (N\textgreater{}=2) points of the
(curved) edges. With N==2, this is equivalent to
Mesh.edges(). Since the points are no more always part of
the mesh, their coordinates are returned instead of points
number, in the array E which is a {[} mesh\_dim x 2 x nb\_edges {]}
array.  If the optional output argument C is specified, it will
contain the convex number associated with each edge.

\end{fulllineitems}

\index{cvid() (Mesh method)@\spxentry{cvid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.cvid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cvid}}}{}{}
Return the list of all convex \#id.

Note that their numbering is not supposed to be contiguous from
0 to Mesh.nbcvs()\sphinxhyphen{}1,
especially if some points have been removed from the mesh. You
can use Mesh.optimize\_structure() to enforce a contiguous
numbering.

\end{fulllineitems}

\index{cvid\_from\_pid() (Mesh method)@\spxentry{cvid\_from\_pid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.cvid_from_pid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cvid\_from\_pid}}}{\emph{\DUrole{n}{PIDs}}, \emph{\DUrole{n}{share}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Return convex \#ids related with the point \#ids given in \sphinxtitleref{PIDs}.

If \sphinxtitleref{share=False}, search convex whose vertex \#ids are in \sphinxtitleref{PIDs}.
If \sphinxtitleref{share=True}, search convex \#ids that share the point \#ids
given in \sphinxtitleref{PIDs}. \sphinxtitleref{CVIDs} is a  vector (possibly
empty).

\end{fulllineitems}

\index{cvstruct() (Mesh method)@\spxentry{cvstruct()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.cvstruct}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cvstruct}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return an array of the convex structures.

If \sphinxtitleref{CVIDs} is not given, all convexes are considered. Each convex
structure is listed once in \sphinxtitleref{S}, and \sphinxtitleref{CV2S} maps the convexes
indice in \sphinxtitleref{CVIDs} to the indice of its structure in \sphinxtitleref{S}.

\end{fulllineitems}

\index{del\_convex() (Mesh method)@\spxentry{del\_convex()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.del_convex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{del\_convex}}}{\emph{\DUrole{n}{CVIDs}}}{}
Remove one or more convexes from the mesh.

\sphinxtitleref{CVIDs} should contain the convexes \#ids, such as the ones
returned by the ‘add convex’ command.

\end{fulllineitems}

\index{del\_convex\_of\_dim() (Mesh method)@\spxentry{del\_convex\_of\_dim()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.del_convex_of_dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{del\_convex\_of\_dim}}}{\emph{\DUrole{n}{DIMs}}}{}
Remove all convexes of dimension listed in \sphinxtitleref{DIMs}.

For example; \sphinxcode{\sphinxupquote{Mesh.del\_convex\_of\_dim({[}1,2{]})}} remove
all line segments, triangles and quadrangles.

\end{fulllineitems}

\index{del\_point() (Mesh method)@\spxentry{del\_point()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.del_point}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{del\_point}}}{\emph{\DUrole{n}{PIDs}}}{}
Removes one or more points from the mesh.

\sphinxtitleref{PIDs} should contain the point \#ids, such as the one returned by
the ‘add point’ command.

\end{fulllineitems}

\index{delete\_boundary() (Mesh method)@\spxentry{delete\_boundary()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.delete_boundary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete\_boundary}}}{\emph{\DUrole{n}{rnum}}, \emph{\DUrole{n}{CVFIDs}}}{}
DEPRECATED FUNCTION. Use ‘delete region’ instead.

\end{fulllineitems}

\index{delete\_region() (Mesh method)@\spxentry{delete\_region()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.delete_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete\_region}}}{\emph{\DUrole{n}{RIDs}}}{}
Remove the regions whose \#ids are listed in \sphinxtitleref{RIDs}

\end{fulllineitems}

\index{dim() (Mesh method)@\spxentry{dim()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dim}}}{}{}
Get the dimension of the mesh (2 for a 2D mesh, etc).

\end{fulllineitems}

\index{display() (Mesh method)@\spxentry{display()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a Mesh object.

\end{fulllineitems}

\index{edges() (Mesh method)@\spxentry{edges()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.edges}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{edges}}}{\emph{\DUrole{n}{CVLST}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: {[}E,C{]} = Mesh.edges(self {[}, CVLST{]}{[}, ‘merge’{]})

{[}OBSOLETE FUNCTION! will be removed in a future release{]}

Return the list of edges of mesh M for the convexes listed in the
row vector CVLST. E is a 2 x nb\_edges matrix containing point
indices. If CVLST is omitted, then the edges of all convexes are
returned. If CVLST has two rows then the first row is supposed to
contain convex numbers, and the second face numbers, of which the
edges will be returned.  If ‘merge’ is indicated, all common
edges of convexes are merged in a single edge.  If the optional
output argument C is specified, it will contain the convex number
associated with each edge.

\end{fulllineitems}

\index{export\_to\_dx() (Mesh method)@\spxentry{export\_to\_dx()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.export_to_dx}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_dx}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Mesh.export\_to\_dx(self, string filename, … {[},’ascii’{]}{[},’append’{]}{[},’as’,string name,{[},’serie’,string serie\_name{]}{]}{[},’edges’{]})

Exports a mesh to an OpenDX file.

See also MeshFem.export\_to\_dx(), Slice.export\_to\_dx().

\end{fulllineitems}

\index{export\_to\_pos() (Mesh method)@\spxentry{export\_to\_pos()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.export_to_pos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_pos}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Exports a mesh to a POS file .

See also MeshFem.export\_to\_pos(), Slice.export\_to\_pos().

\end{fulllineitems}

\index{export\_to\_vtk() (Mesh method)@\spxentry{export\_to\_vtk()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.export_to_vtk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_vtk}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Mesh.export\_to\_vtk(self, string filename, … {[},’ascii’{]}{[},’quality’{]})

Exports a mesh to a VTK file .

If ‘quality’ is specified, an estimation of the quality of each
convex will be written to the file.

See also MeshFem.export\_to\_vtk(), Slice.export\_to\_vtk().

\end{fulllineitems}

\index{export\_to\_vtu() (Mesh method)@\spxentry{export\_to\_vtu()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.export_to_vtu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_vtu}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Mesh.export\_to\_vtu(self, string filename, … {[},’ascii’{]}{[},’quality’{]})

Exports a mesh to a VTK(XML) file .

If ‘quality’ is specified, an estimation of the quality of each
convex will be written to the file.

See also MeshFem.export\_to\_vtu(), Slice.export\_to\_vtu().

\end{fulllineitems}

\index{extend\_region() (Mesh method)@\spxentry{extend\_region()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.extend_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend\_region}}}{\emph{\DUrole{n}{rnum}}, \emph{\DUrole{n}{CVFIDs}}}{}
Extends the region identified by the region number \sphinxtitleref{rnum} to include
the set of convexes or/and convex faces provided in the matrix
\sphinxtitleref{CVFIDs}, see also \sphinxcode{\sphinxupquote{Mesh.(set region)}}.

\end{fulllineitems}

\index{faces\_from\_cvid() (Mesh method)@\spxentry{faces\_from\_cvid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.faces_from_cvid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{faces\_from\_cvid}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: CVFIDs = Mesh.faces\_from\_cvid(self{[}, ivec CVIDs{]}{[}, ‘merge’{]})

Return a list of convex faces from a list of convex \#id.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers (local number in the convex).
If \sphinxtitleref{CVIDs} is not given, all convexes are considered. The optional
argument ‘merge’ merges faces shared by the convex of \sphinxtitleref{CVIDs}.

\end{fulllineitems}

\index{faces\_from\_pid() (Mesh method)@\spxentry{faces\_from\_pid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.faces_from_pid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{faces\_from\_pid}}}{\emph{\DUrole{n}{PIDs}}}{}
Return the convex faces whose vertex \#ids are in \sphinxtitleref{PIDs}.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers (local number in the convex).
For a convex face to be returned, EACH of its points have to be
listed in \sphinxtitleref{PIDs}.

\end{fulllineitems}

\index{geotrans() (Mesh method)@\spxentry{geotrans()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.geotrans}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{geotrans}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Returns an array of the geometric transformations.

See also Mesh.cvstruct().

\end{fulllineitems}

\index{inner\_faces() (Mesh method)@\spxentry{inner\_faces()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.inner_faces}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inner\_faces}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the set of faces shared at least by two elements in CVIDs.
Each face is represented only once and is arbitrarily chosen
between the two neighbor elements.

\end{fulllineitems}

\index{max\_cvid() (Mesh method)@\spxentry{max\_cvid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.max_cvid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{max\_cvid}}}{}{}
Return the maximum \#id of all convexes in the mesh (see ‘max pid’).

\end{fulllineitems}

\index{max\_pid() (Mesh method)@\spxentry{max\_pid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.max_pid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{max\_pid}}}{}{}
Return the maximum \#id of all points in the mesh (see ‘max cvid’).

\end{fulllineitems}

\index{memsize() (Mesh method)@\spxentry{memsize()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.memsize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{memsize}}}{}{}
Return the amount of memory (in bytes) used by the mesh.

\end{fulllineitems}

\index{merge() (Mesh method)@\spxentry{merge()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.merge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{merge}}}{\emph{\DUrole{n}{m2}}, \emph{\DUrole{n}{tol}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Merge with the Mesh \sphinxtitleref{m2}.

Overlapping points, within a tolerance radius \sphinxtitleref{tol}, will not be
duplicated. If \sphinxtitleref{m2} is a MeshFem object, its linked mesh will be used.

\end{fulllineitems}

\index{nbcvs() (Mesh method)@\spxentry{nbcvs()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.nbcvs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbcvs}}}{}{}
Get the number of convexes of the mesh.

\end{fulllineitems}

\index{nbpts() (Mesh method)@\spxentry{nbpts()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.nbpts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbpts}}}{}{}
Get the number of points of the mesh.

\end{fulllineitems}

\index{normal\_of\_face() (Mesh method)@\spxentry{normal\_of\_face()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.normal_of_face}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{normal\_of\_face}}}{\emph{\DUrole{n}{cv}}, \emph{\DUrole{n}{f}}, \emph{\DUrole{n}{nfpt}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the normal vector of convex \sphinxtitleref{cv}, face \sphinxtitleref{f} at the \sphinxtitleref{nfpt} point of the face.

If \sphinxtitleref{nfpt} is not specified, then the normal is evaluated at each
geometrical node of the face.

\end{fulllineitems}

\index{normal\_of\_faces() (Mesh method)@\spxentry{normal\_of\_faces()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.normal_of_faces}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{normal\_of\_faces}}}{\emph{\DUrole{n}{CVFIDs}}}{}
Return matrix of (at face centers) the normal vectors of convexes.

\sphinxtitleref{CVFIDs} is supposed a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second lists face numbers (local number in the convex).

\end{fulllineitems}

\index{optimize\_structure() (Mesh method)@\spxentry{optimize\_structure()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.optimize_structure}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{optimize\_structure}}}{\emph{\DUrole{n}{with\_renumbering}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Reset point and convex numbering.

After optimisation, the points (resp. convexes) will
be consecutively numbered from \sphinxcode{\sphinxupquote{0}} to
\sphinxcode{\sphinxupquote{Mesh.max\_pid()\sphinxhyphen{}1}} (resp. \sphinxcode{\sphinxupquote{Mesh.max\_cvid()\sphinxhyphen{}1}}).

\end{fulllineitems}

\index{orphaned\_pid() (Mesh method)@\spxentry{orphaned\_pid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.orphaned_pid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{orphaned\_pid}}}{}{}
Return point \#id which are not linked to a convex.

\end{fulllineitems}

\index{outer\_faces() (Mesh method)@\spxentry{outer\_faces()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.outer_faces}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{outer\_faces}}}{\emph{\DUrole{n}{dim}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: CVFIDs = Mesh.outer\_faces(self{[}, dim{]}{[}, CVIDs{]})

Return the set of faces not shared by two elements.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists
convex \#ids, and the second one lists face numbers (local number
in the convex). If \sphinxtitleref{dim} is provided, the function is forced to
detect faces of elements that have dimension \sphinxtitleref{dim}, e.g. \sphinxtitleref{dim\textasciigrave{}=2 will
detect edges of surface elements, even if these belong to a 3D mesh.
If \textasciigrave{}CVIDs} is not given, all convexes are considered, and the
function basically returns the mesh boundary. If \sphinxtitleref{CVIDs}
is given, it returns the boundary of the convex set whose \#ids are
listed in \sphinxtitleref{CVIDs}.

\end{fulllineitems}

\index{outer\_faces\_in\_ball() (Mesh method)@\spxentry{outer\_faces\_in\_ball()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.outer_faces_in_ball}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{outer\_faces\_in\_ball}}}{\emph{\DUrole{n}{center}}, \emph{\DUrole{n}{radius}}, \emph{\DUrole{n}{dim}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: CVFIDs = Mesh.outer\_faces\_in\_ball(self, vec center, scalar radius{[}, dim{]}{[}, CVIDs{]})

Return the set of faces not shared by two convexes and lying within the ball of corresponding \sphinxtitleref{center} and \sphinxtitleref{radius}.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). The argument \sphinxtitleref{dim} works as in outer\_faces().
If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.

\end{fulllineitems}

\index{outer\_faces\_in\_box() (Mesh method)@\spxentry{outer\_faces\_in\_box()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.outer_faces_in_box}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{outer\_faces\_in\_box}}}{\emph{\DUrole{n}{pmin}}, \emph{\DUrole{n}{pmax}}, \emph{\DUrole{n}{dim}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: CVFIDs = Mesh.outer\_faces\_in\_box(self, vec pmin, vec pmax{[}, dim{]}{[}, CVIDs{]})

Return the set of faces not shared by two convexes and lying within the box defined by the corner points \sphinxtitleref{pmin} and \sphinxtitleref{pmax}.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). The argument \sphinxtitleref{dim} works as in outer\_faces().
If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.

\end{fulllineitems}

\index{outer\_faces\_with\_direction() (Mesh method)@\spxentry{outer\_faces\_with\_direction()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.outer_faces_with_direction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{outer\_faces\_with\_direction}}}{\emph{\DUrole{n}{v}}, \emph{\DUrole{n}{angle}}, \emph{\DUrole{n}{dim}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: CVFIDs = Mesh.outer\_faces\_with\_direction(self, vec v, scalar angle{[}, dim{]}{[}, CVIDs{]})

Return the set of faces not shared by two convexes and with a mean outward vector lying within an angle \sphinxtitleref{angle} (in radians) from vector \sphinxtitleref{v}.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). The argument \sphinxtitleref{dim} works as in outer\_faces().
If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.

\end{fulllineitems}

\index{pid() (Mesh method)@\spxentry{pid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pid}}}{}{}
Return the list of points \#id of the mesh.

Note that their numbering is not supposed to be contiguous from
0 to Mesh.nbpts()\sphinxhyphen{}1,
especially if some points have been removed from the mesh. You
can use Mesh.optimize\_structure() to enforce a contiguous
numbering.

\end{fulllineitems}

\index{pid\_from\_coords() (Mesh method)@\spxentry{pid\_from\_coords()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pid_from_coords}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pid\_from\_coords}}}{\emph{\DUrole{n}{PTS}}, \emph{\DUrole{n}{radius}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
Return point \#id whose coordinates are listed in \sphinxtitleref{PTS}.

\sphinxtitleref{PTS} is an array containing a list of point coordinates. On
return, \sphinxtitleref{PIDs} is a vector containing points
\#id for each point found in \sphinxtitleref{eps} range, and \sphinxhyphen{}1 for those
which where not found in the mesh.

\end{fulllineitems}

\index{pid\_from\_cvid() (Mesh method)@\spxentry{pid\_from\_cvid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pid_from_cvid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pid\_from\_cvid}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the points attached to each convex of the mesh.

If \sphinxtitleref{CVIDs} is omitted, all the convexes will be considered
(equivalent to \sphinxtitleref{CVIDs = Mesh.max\_cvid()}). \sphinxtitleref{IDx} is a
vector, length(IDx) = length(CVIDs)+1. \sphinxtitleref{Pid} is a
vector containing the concatenated list of \#id of
points of each convex in \sphinxtitleref{CVIDs}. Each entry of \sphinxtitleref{IDx} is the
position of the corresponding convex point list in \sphinxtitleref{Pid}. Hence,
for example, the list of \#id of points of the second convex is
Pid{[}IDx(2):IDx(3){]}.

If \sphinxtitleref{CVIDs} contains convex \#id which do not exist in the mesh,
their point list will be empty.

\end{fulllineitems}

\index{pid\_in\_cvids() (Mesh method)@\spxentry{pid\_in\_cvids()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pid_in_cvids}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pid\_in\_cvids}}}{\emph{\DUrole{n}{CVIDs}}}{}
Return point \#id listed in \sphinxtitleref{CVIDs}.

\sphinxtitleref{PIDs} is a vector containing points \#id.

\end{fulllineitems}

\index{pid\_in\_faces() (Mesh method)@\spxentry{pid\_in\_faces()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pid_in_faces}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pid\_in\_faces}}}{\emph{\DUrole{n}{CVFIDs}}}{}
Return point \#id listed in \sphinxtitleref{CVFIDs}.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers. On return, \sphinxtitleref{PIDs} is a
vector containing points \#id.

\end{fulllineitems}

\index{pid\_in\_regions() (Mesh method)@\spxentry{pid\_in\_regions()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pid_in_regions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pid\_in\_regions}}}{\emph{\DUrole{n}{RIDs}}}{}
Return point \#id listed in \sphinxtitleref{RIDs}.

\sphinxtitleref{PIDs} is a vector containing points \#id.

\end{fulllineitems}

\index{pts() (Mesh method)@\spxentry{pts()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pts}}}{\emph{\DUrole{n}{PIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the list of point coordinates of the mesh.

Each column of the returned matrix contains the coordinates of one
point. If the optional argument \sphinxtitleref{PIDs} was given, only the points
whose \#id is listed in this vector are returned. Otherwise, the
returned matrix will have Mesh.max\_pid() columns, which might
be greater than Mesh.nbpts() (if some points of the mesh have
been destroyed and no call to Mesh.optimize\_structure() have
been issued). The columns corresponding to deleted points will be
filled with NaN. You can use Mesh.pid() to filter such invalid
points.

\end{fulllineitems}

\index{pts\_from\_cvid() (Mesh method)@\spxentry{pts\_from\_cvid()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.pts_from_cvid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pts\_from\_cvid}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Search point listed in \sphinxtitleref{CVID}.

Return \sphinxtitleref{Pts} and \sphinxtitleref{IDx}.
If \sphinxtitleref{CVIDs} is omitted, all the convexes will be considered
(equivalent to \sphinxtitleref{CVIDs = Mesh.max\_cvid()}). \sphinxtitleref{IDx} is a
vector, length(IDx) = length(CVIDs)+1. \sphinxtitleref{Pts} is a
vector containing the concatenated list of points
of each convex in \sphinxtitleref{CVIDs}. Each entry of \sphinxtitleref{IDx} is the position
of the corresponding convex point list in \sphinxtitleref{Pts}. Hence, for
example, the list of points of the second convex is
Pts{[}:,IDx{[}2{]}:IDx{[}3{]}{]}.

If \sphinxtitleref{CVIDs} contains convex \#id which do not exist in the mesh,
their point list will be empty.

\end{fulllineitems}

\index{quality() (Mesh method)@\spxentry{quality()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.quality}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{quality}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return an estimation of the quality of each convex (\(0 \leq Q \leq 1\)).

\end{fulllineitems}

\index{refine() (Mesh method)@\spxentry{refine()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.refine}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{refine}}}{\emph{\DUrole{n}{CVIDs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Use a Bank strategy for mesh refinement.

If \sphinxtitleref{CVIDs} is not given, the whole mesh is refined. Note
that the regions, and the finite element methods and
integration methods of the MeshFem and MeshIm objects linked
to this mesh will be automagically refined.

\end{fulllineitems}

\index{region() (Mesh method)@\spxentry{region()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{region}}}{\emph{\DUrole{n}{RIDs}}}{}
Return the list of convexes/faces on the regions \sphinxtitleref{RIDs}.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers (local number in the convex).
(and \sphinxhyphen{}1 when the whole convex is in the
regions).

\end{fulllineitems}

\index{region\_intersect() (Mesh method)@\spxentry{region\_intersect()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.region_intersect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{region\_intersect}}}{\emph{\DUrole{n}{r1}}, \emph{\DUrole{n}{r2}}}{}
Replace the region number \sphinxtitleref{r1} with its intersection with region number \sphinxtitleref{r2}.

\end{fulllineitems}

\index{region\_merge() (Mesh method)@\spxentry{region\_merge()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.region_merge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{region\_merge}}}{\emph{\DUrole{n}{r1}}, \emph{\DUrole{n}{r2}}}{}
Merge region number \sphinxtitleref{r2} into region number \sphinxtitleref{r1}.

\end{fulllineitems}

\index{region\_subtract() (Mesh method)@\spxentry{region\_subtract()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.region_subtract}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{region\_subtract}}}{\emph{\DUrole{n}{r1}}, \emph{\DUrole{n}{r2}}}{}
Replace the region number \sphinxtitleref{r1} with its difference with region
number \sphinxtitleref{r2}.

\end{fulllineitems}

\index{regions() (Mesh method)@\spxentry{regions()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.regions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{regions}}}{}{}
Return the list of valid regions stored in the mesh.

\end{fulllineitems}

\index{save() (Mesh method)@\spxentry{save()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{filename}}}{}
Save the mesh object to an ascii file.

This mesh can be restored with Mesh(‘load’, filename).

\end{fulllineitems}

\index{set\_boundary() (Mesh method)@\spxentry{set\_boundary()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.set_boundary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_boundary}}}{\emph{\DUrole{n}{rnum}}, \emph{\DUrole{n}{CVFIDs}}}{}
DEPRECATED FUNCTION. Use ‘region’ instead.

\end{fulllineitems}

\index{set\_pts() (Mesh method)@\spxentry{set\_pts()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.set_pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_pts}}}{\emph{\DUrole{n}{PTS}}}{}
Replace the coordinates of the mesh points with those given in \sphinxtitleref{PTS}.

\end{fulllineitems}

\index{set\_region() (Mesh method)@\spxentry{set\_region()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.set_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_region}}}{\emph{\DUrole{n}{rnum}}, \emph{\DUrole{n}{CVFIDs}}}{}
Assigns the region number \sphinxtitleref{rnum} to the set of convexes or/and convex
faces provided in the matrix \sphinxtitleref{CVFIDs}.

The first row of \sphinxtitleref{CVFIDs} contains convex \#ids, and the second row
contains a face number in the convex (or \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}
for the whole convex (regions are usually used to store a list of
convex faces, but you may also use them to store a list of convexes).

If a vector is provided (or a one row matrix) the region will represent
the corresponding set of convex.

\end{fulllineitems}

\index{transform() (Mesh method)@\spxentry{transform()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.transform}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{T}}}{}
Applies the matrix \sphinxtitleref{T} to each point of the mesh.

Note that \sphinxtitleref{T} is not required to be a \sphinxcode{\sphinxupquote{NxN}} matrix (with
\sphinxcode{\sphinxupquote{N = Mesh.dim()}}). Hence it is possible to transform
a 2D mesh into a 3D one (and reciprocally).

\end{fulllineitems}

\index{translate() (Mesh method)@\spxentry{translate()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.translate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{translate}}}{\emph{\DUrole{n}{V}}}{}
Translates each point of the mesh from \sphinxtitleref{V}.

\end{fulllineitems}

\index{triangulated\_surface() (Mesh method)@\spxentry{triangulated\_surface()}\spxextra{Mesh method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Mesh:getfem.Mesh.triangulated_surface}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{triangulated\_surface}}}{\emph{\DUrole{n}{Nrefine}}, \emph{\DUrole{n}{CVLIST}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
{[}DEPRECATED FUNCTION! will be removed in a future release{]}

Similar function to Mesh.curved\_edges() : split (if
necessary, i.e. if the geometric transformation if non\sphinxhyphen{}linear)
each face into sub\sphinxhyphen{}triangles and return their coordinates in T
(see also gf\_compute(‘eval on P1 tri mesh’))

\end{fulllineitems}


\end{fulllineitems}



\section{MeshFem}
\label{\detokenize{python/cmdref_MeshFem:meshfem}}\label{\detokenize{python/cmdref_MeshFem::doc}}\index{MeshFem (class in getfem)@\spxentry{MeshFem}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MeshFem}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM MeshFem object

This object represents a finite element method defined on a whole mesh.

General constructor for MeshFem objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(Mesh m{[}, int Qdim1=1{[}, int Qdim2=1, ...{]}{]})}}
Build a new MeshFem object.

The \sphinxtitleref{Qdim} parameters specifies the dimension of the field represented
by the finite element method. Qdim1 = 1 for a scalar field,
Qdim1 = n for a vector field off size n, Qdim1=m, Qdim2=n for
a matrix field of size mxn …
Returns the handle of the created object.

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}load\textquotesingle{}, string fname{[}, Mesh m{]})}}
Load a MeshFem from a file.

If the mesh \sphinxtitleref{m} is not supplied (this kind of file does not store the
mesh), then it is read from the file \sphinxtitleref{fname} and its descriptor is
returned as the second output argument.

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}from string\textquotesingle{}, string s{[}, Mesh m{]})}}
Create a MeshFem object from its string description.

See also \sphinxcode{\sphinxupquote{MeshFem.char()}}

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}clone\textquotesingle{}, MeshFem mf)}}
Create a copy of a MeshFem.

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}sum\textquotesingle{}, MeshFem mf1, MeshFem mf2{[}, MeshFem mf3{[}, ...{]}{]})}}
Create a MeshFem that spans two (or more) MeshFem’s.

All MeshFem must share the same mesh.

After that, you should not modify the FEM of \sphinxtitleref{mf1}, \sphinxtitleref{mf2} etc.

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}product\textquotesingle{}, MeshFem mf1, MeshFem mf2)}}
Create a MeshFem that spans all the product of a selection of shape
functions of \sphinxtitleref{mf1} by all shape functions of \sphinxtitleref{mf2}.
Designed for Xfem enrichment.

\sphinxtitleref{mf1} and \sphinxtitleref{mf2} must share the same mesh.

After that, you should not modify the FEM of \sphinxtitleref{mf1}, \sphinxtitleref{mf2}.

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}levelset\textquotesingle{}, MeshLevelSet mls, MeshFem mf)}}
Create a MeshFem that is conformal to implicit surfaces defined in
MeshLevelSet.

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}global function\textquotesingle{}, Mesh m, LevelSet ls, (GlobalFunction GF1,...){[}, int Qdim\_m{]})}}
Create a MeshFem whose base functions are global function given by the
user in the system of coordinate defined by the iso\sphinxhyphen{}values of the two
level\sphinxhyphen{}set function of \sphinxtitleref{ls}.

\item {} 
\sphinxcode{\sphinxupquote{MF = MeshFem(\textquotesingle{}partial\textquotesingle{}, MeshFem mf, ivec DOFs{[}, ivec RCVs{]})}}
Build a restricted MeshFem by keeping only a subset of the degrees of
freedom of \sphinxtitleref{mf}.

If \sphinxtitleref{RCVs} is given, no FEM will be put on the convexes listed in
\sphinxtitleref{RCVs}.

\end{itemize}
\index{adapt() (MeshFem method)@\spxentry{adapt()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.adapt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{adapt}}}{}{}
For a MeshFem levelset object only. Adapt the mesh\_fem object to a
change of the levelset function.

\end{fulllineitems}

\index{basic\_dof\_from\_cv() (MeshFem method)@\spxentry{basic\_dof\_from\_cv()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.basic_dof_from_cv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{basic\_dof\_from\_cv}}}{\emph{\DUrole{n}{CVids}}}{}
Return the dof of the convexes listed in \sphinxtitleref{CVids}.

WARNING: the Degree of Freedom might be returned in ANY order, do
not use this function in your assembly routines. Use ‘basic dof from cvid’
instead, if you want to be able to map a convex number with its
associated degrees of freedom.

One can also get the list of basic dof on a set on convex faces, by
indicating on the second row of \sphinxtitleref{CVids} the faces numbers (with
respect to the convex number on the first row).

\end{fulllineitems}

\index{basic\_dof\_from\_cvid() (MeshFem method)@\spxentry{basic\_dof\_from\_cvid()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.basic_dof_from_cvid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{basic\_dof\_from\_cvid}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the degrees of freedom attached to each convex of the mesh.

If \sphinxtitleref{CVids} is omitted, all the convexes will be considered (equivalent
to \sphinxtitleref{CVids = 1 … Mesh.max\_cvid()}).

\sphinxtitleref{IDx} is a vector, \sphinxtitleref{length(IDx) = length(CVids)+1}.
\sphinxtitleref{DOFs} is a vector containing the concatenated list
of dof of each convex in \sphinxtitleref{CVids}. Each entry of \sphinxtitleref{IDx} is the position
of the corresponding convex point list in \sphinxtitleref{DOFs}. Hence, for example,
the list of points of the second convex is DOFs{[}IDx(2):IDx(3){]}.

If \sphinxtitleref{CVids} contains convex \#id which do not exist in the mesh, their
point list will be empty.

\end{fulllineitems}

\index{basic\_dof\_nodes() (MeshFem method)@\spxentry{basic\_dof\_nodes()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.basic_dof_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{basic\_dof\_nodes}}}{\emph{\DUrole{n}{DOFids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Get location of basic degrees of freedom.

Return the list of interpolation points for the specified
dof \#IDs in \sphinxtitleref{DOFids} (if \sphinxtitleref{DOFids} is omitted, all basic dof are
considered).

\end{fulllineitems}

\index{basic\_dof\_on\_region() (MeshFem method)@\spxentry{basic\_dof\_on\_region()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.basic_dof_on_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{basic\_dof\_on\_region}}}{\emph{\DUrole{n}{Rs}}}{}
Return the list of basic dof (before the optional reduction) lying on one
of the mesh regions listed in \sphinxtitleref{Rs}.

More precisely, this function returns the basic dof whose support is
non\sphinxhyphen{}null on one of regions whose \#ids are listed in \sphinxtitleref{Rs} (note
that for boundary regions, some dof nodes may not lie exactly
on the boundary, for example the dof of Pk(n,0) lies on the center
of the convex, but the base function in not null on the convex
border).

\end{fulllineitems}

\index{char() (MeshFem method)@\spxentry{char()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{\emph{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Output a string description of the MeshFem.

By default, it does not include the description of the linked mesh
object, except if \sphinxtitleref{opt} is ‘with\_mesh’.

\end{fulllineitems}

\index{convex\_index() (MeshFem method)@\spxentry{convex\_index()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.convex_index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convex\_index}}}{}{}
Return the list of convexes who have an FEM.

\end{fulllineitems}

\index{display() (MeshFem method)@\spxentry{display()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a MeshFem object.

\end{fulllineitems}

\index{dof\_from\_cv() (MeshFem method)@\spxentry{dof\_from\_cv()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.dof_from_cv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dof\_from\_cv}}}{\emph{\DUrole{n}{CVids}}}{}
Deprecated function. Use MeshFem.basic\_dof\_from\_cv() instead.

\end{fulllineitems}

\index{dof\_from\_cvid() (MeshFem method)@\spxentry{dof\_from\_cvid()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.dof_from_cvid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dof\_from\_cvid}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Deprecated function. Use MeshFem.basic\_dof\_from\_cvid() instead.

\end{fulllineitems}

\index{dof\_from\_im() (MeshFem method)@\spxentry{dof\_from\_im()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.dof_from_im}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dof\_from\_im}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{p}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return a selection of dof who contribute significantly to the
mass\sphinxhyphen{}matrix that would be computed with \sphinxtitleref{mf} and the integration
method \sphinxtitleref{mim}.

\sphinxtitleref{p} represents the dimension on what the integration method
operates (default \sphinxtitleref{p = mesh dimension}).

IMPORTANT: you still have to set a valid integration method on
the convexes which are not crosses by the levelset!

\end{fulllineitems}

\index{dof\_nodes() (MeshFem method)@\spxentry{dof\_nodes()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.dof_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dof\_nodes}}}{\emph{\DUrole{n}{DOFids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Deprecated function. Use MeshFem.basic\_dof\_nodes() instead.

\end{fulllineitems}

\index{dof\_on\_region() (MeshFem method)@\spxentry{dof\_on\_region()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.dof_on_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dof\_on\_region}}}{\emph{\DUrole{n}{Rs}}}{}
Return the list of dof (after the optional reduction) lying on one
of the mesh regions listed in \sphinxtitleref{Rs}.

More precisely, this function returns the basic dof whose support is
non\sphinxhyphen{}null on one of regions whose \#ids are listed in \sphinxtitleref{Rs} (note
that for boundary regions, some dof nodes may not lie exactly
on the boundary, for example the dof of Pk(n,0) lies on the center
of the convex, but the base function in not null on the convex
border).

For a reduced mesh\_fem
a dof is lying on a region if its potential corresponding shape
function is nonzero on this region. The extension matrix is used
to make the correspondence between basic and reduced dofs.

\end{fulllineitems}

\index{dof\_partition() (MeshFem method)@\spxentry{dof\_partition()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.dof_partition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dof\_partition}}}{}{}
Get the ‘dof\_partition’ array.

Return the array which associates an integer (the partition number)
to each convex of the MeshFem. By default, it is an all\sphinxhyphen{}zero array.
The degrees of freedom of each convex of the MeshFem are connected
only to the dof of neighboring convexes which have the same
partition number, hence it is possible to create partially
discontinuous MeshFem very easily.

\end{fulllineitems}

\index{eval() (MeshFem method)@\spxentry{eval()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.eval}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eval}}}{\emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{gl}\DUrole{o}{=}\DUrole{default_value}{\{\}}}, \emph{\DUrole{n}{lo}\DUrole{o}{=}\DUrole{default_value}{\{\}}}}{}
interpolate an expression on the (lagrangian) MeshFem.

Examples:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mf}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x*y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} interpolates the function \PYGZsq{}x*y\PYGZsq{}}
\PYG{n}{mf}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{[x,y]}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} interpolates the vector field \PYGZsq{}[x,y]\PYGZsq{}}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{n}{mf}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{np.sin(x)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{globals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{locals}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} interpolates the function sin(x)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{export\_to\_dx() (MeshFem method)@\spxentry{export\_to\_dx()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.export_to_dx}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_dx}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: MeshFem.export\_to\_dx(self,string filename, …{[}‘as’, string mesh\_name{]}{[},’edges’{]}{[}‘serie’,string serie\_name{]}{[},’ascii’{]}{[},’append’{]}, U, ‘name’…)

Export a MeshFem and some fields to an OpenDX file.

This function will fail if the MeshFem mixes different convex types
(i.e. quads and triangles), or if OpenDX does not handle a specific
element type (i.e. prism connections are not known by OpenDX).

The FEM will be mapped to order 1 Pk (or Qk) FEMs. If you need to
represent high\sphinxhyphen{}order FEMs or high\sphinxhyphen{}order geometric transformations,
you should consider Slice.export\_to\_dx().

\end{fulllineitems}

\index{export\_to\_pos() (MeshFem method)@\spxentry{export\_to\_pos()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.export_to_pos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_pos}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: MeshFem.export\_to\_pos(self,string filename{[}, string name{]}{[}{[},MeshFem mf1{]}, mat U1, string nameU1{[}{[},MeshFem mf2{]}, mat U2, string nameU2,…{]}{]})

Export a MeshFem and some fields to a pos file.

The FEM and geometric transformations will be mapped to order 1
isoparametric Pk (or Qk) FEMs (as GMSH does not handle higher
order elements).

\end{fulllineitems}

\index{export\_to\_vtk() (MeshFem method)@\spxentry{export\_to\_vtk()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.export_to_vtk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_vtk}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: MeshFem.export\_to\_vtk(self,string filename, … {[}‘ascii’{]}, U, ‘name’…)

Export a MeshFem and some fields to a vtk file.

The FEM and geometric transformations will be mapped to order 1
or 2 isoparametric Pk (or Qk) FEMs (as VTK does not handle higher
order elements). If you need to represent high\sphinxhyphen{}order FEMs or
high\sphinxhyphen{}order geometric transformations, you should consider
Slice.export\_to\_vtk().

\end{fulllineitems}

\index{export\_to\_vtu() (MeshFem method)@\spxentry{export\_to\_vtu()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.export_to_vtu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_vtu}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: MeshFem.export\_to\_vtu(self,string filename, … {[}‘ascii’{]}, U, ‘name’…)

Export a MeshFem and some fields to a vtu file.

The FEM and geometric transformations will be mapped to order 1
or 2 isoparametric Pk (or Qk) FEMs (as VTK(XML) does not handle higher
order elements). If you need to represent high\sphinxhyphen{}order FEMs or
high\sphinxhyphen{}order geometric transformations, you should consider
Slice.export\_to\_vtu().

\end{fulllineitems}

\index{extend\_vector() (MeshFem method)@\spxentry{extend\_vector()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.extend_vector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extend\_vector}}}{\emph{\DUrole{n}{V}}}{}
Multiply the provided vector V with the reduction matrix of the MeshFem.

\end{fulllineitems}

\index{extension\_matrix() (MeshFem method)@\spxentry{extension\_matrix()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.extension_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extension\_matrix}}}{}{}
Return the optional extension matrix.

\end{fulllineitems}

\index{fem() (MeshFem method)@\spxentry{fem()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.fem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fem}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return a list of FEM used by the MeshFem.

\sphinxtitleref{FEMs} is an array of all Fem objects found in the convexes
given in \sphinxtitleref{CVids}. If \sphinxtitleref{CV2F} was supplied as an output argument,
it contains, for each convex listed in \sphinxtitleref{CVids}, the index of its
correspounding FEM in \sphinxtitleref{FEMs}.

Convexes which are not part of the mesh, or convexes which do not
have any FEM have their correspounding entry in \sphinxtitleref{CV2F} set to \sphinxhyphen{}1.

\end{fulllineitems}

\index{has\_linked\_mesh\_levelset() (MeshFem method)@\spxentry{has\_linked\_mesh\_levelset()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.has_linked_mesh_levelset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{has\_linked\_mesh\_levelset}}}{}{}
Is a mesh\_fem\_level\_set or not.

\end{fulllineitems}

\index{interpolate\_convex\_data() (MeshFem method)@\spxentry{interpolate\_convex\_data()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.interpolate_convex_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpolate\_convex\_data}}}{\emph{\DUrole{n}{Ucv}}}{}
Interpolate data given on each convex of the mesh to the MeshFem dof.
The MeshFem has to be lagrangian, and should be discontinuous (typically
an FEM\_PK(N,0) or FEM\_QK(N,0) should be used).

The last dimension of the input vector Ucv should have
Mesh.max\_cvid() elements.

Example of use: MeshFem.interpolate\_convex\_data(Mesh.quality())

\end{fulllineitems}

\index{is\_equivalent() (MeshFem method)@\spxentry{is\_equivalent()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.is_equivalent}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_equivalent}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Test if the MeshFem is equivalent.

See MeshFem.is\_lagrangian()

\end{fulllineitems}

\index{is\_lagrangian() (MeshFem method)@\spxentry{is\_lagrangian()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.is_lagrangian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_lagrangian}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Test if the MeshFem is Lagrangian.

Lagrangian means that each base function Phi{[}i{]} is such that
Phi{[}i{]}(P{[}j{]}) = delta(i,j), where P{[}j{]} is the dof location of
the jth base function, and delta(i,j) = 1 if i==j, else 0.

If \sphinxtitleref{CVids} is omitted, it returns 1 if all convexes in the mesh
are Lagrangian. If \sphinxtitleref{CVids} is used, it returns the convex indices
(with respect to \sphinxtitleref{CVids}) which are Lagrangian.

\end{fulllineitems}

\index{is\_polynomial() (MeshFem method)@\spxentry{is\_polynomial()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.is_polynomial}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_polynomial}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Test if all base functions are polynomials.

See MeshFem.is\_lagrangian()

\end{fulllineitems}

\index{is\_reduced() (MeshFem method)@\spxentry{is\_reduced()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.is_reduced}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_reduced}}}{}{}
Return 1 if the optional reduction matrix is applied to the dofs.

\end{fulllineitems}

\index{linked\_mesh() (MeshFem method)@\spxentry{linked\_mesh()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.linked_mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linked\_mesh}}}{}{}
Return a reference to the Mesh object linked to \sphinxtitleref{mf}.

\end{fulllineitems}

\index{linked\_mesh\_levelset() (MeshFem method)@\spxentry{linked\_mesh\_levelset()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.linked_mesh_levelset}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linked\_mesh\_levelset}}}{}{}
if it is a mesh\_fem\_level\_set gives the linked mesh\_level\_set.

\end{fulllineitems}

\index{memsize() (MeshFem method)@\spxentry{memsize()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.memsize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{memsize}}}{}{}
Return the amount of memory (in bytes) used by the mesh\_fem object.

The result does not take into account the linked mesh object.

\end{fulllineitems}

\index{mesh() (MeshFem method)@\spxentry{mesh()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh}}}{}{}
Return a reference to the Mesh object linked to \sphinxtitleref{mf}.
(identical to Mesh.linked\_mesh())

\end{fulllineitems}

\index{nb\_basic\_dof() (MeshFem method)@\spxentry{nb\_basic\_dof()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.nb_basic_dof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nb\_basic\_dof}}}{}{}
Return the number of basic degrees of freedom (dof) of the MeshFem.

\end{fulllineitems}

\index{nbdof() (MeshFem method)@\spxentry{nbdof()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.nbdof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbdof}}}{}{}
Return the number of degrees of freedom (dof) of the MeshFem.

\end{fulllineitems}

\index{non\_conformal\_basic\_dof() (MeshFem method)@\spxentry{non\_conformal\_basic\_dof()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.non_conformal_basic_dof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{non\_conformal\_basic\_dof}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return partially linked degrees of freedom.

Return the basic dof located on the border of a convex and which belong
to only one convex, except the ones which are located on the border
of the mesh.  For example, if the convex ‘a’ and ‘b’ share a common
face, ‘a’ has a P1 FEM, and ‘b’ has a P2 FEM, then the basic dof on the
middle of the face will be returned by this function (this can be
useful when searching the interfaces between classical FEM and
hierarchical FEM).

\end{fulllineitems}

\index{non\_conformal\_dof() (MeshFem method)@\spxentry{non\_conformal\_dof()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.non_conformal_dof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{non\_conformal\_dof}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Deprecated function. Use MeshFem.non\_conformal\_basic\_dof() instead.

\end{fulllineitems}

\index{qdim() (MeshFem method)@\spxentry{qdim()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.qdim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{qdim}}}{}{}
Return the dimension Q of the field interpolated by the MeshFem.

By default, Q=1 (scalar field). This has an impact on the dof numbering.

\end{fulllineitems}

\index{reduce\_meshfem() (MeshFem method)@\spxentry{reduce\_meshfem()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.reduce_meshfem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce\_meshfem}}}{\emph{\DUrole{n}{RM}}}{}
Set reduction mesh fem
This function selects the degrees of freedom of the finite element
method by selecting a set of independent vectors of the matrix RM.
The numer of columns of RM should corresponds to the number of degrees
of freedom of the finite element method.

\end{fulllineitems}

\index{reduce\_vector() (MeshFem method)@\spxentry{reduce\_vector()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.reduce_vector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduce\_vector}}}{\emph{\DUrole{n}{V}}}{}
Multiply the provided vector V with the extension matrix of the MeshFem.

\end{fulllineitems}

\index{reduction() (MeshFem method)@\spxentry{reduction()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.reduction}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduction}}}{\emph{\DUrole{n}{s}}}{}
Set or unset the use of the reduction/extension matrices.

\end{fulllineitems}

\index{reduction\_matrices() (MeshFem method)@\spxentry{reduction\_matrices()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.reduction_matrices}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduction\_matrices}}}{\emph{\DUrole{n}{R}}, \emph{\DUrole{n}{E}}}{}
Set the reduction and extension matrices and valid their use.

\end{fulllineitems}

\index{reduction\_matrix() (MeshFem method)@\spxentry{reduction\_matrix()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.reduction_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reduction\_matrix}}}{}{}
Return the optional reduction matrix.

\end{fulllineitems}

\index{save() (MeshFem method)@\spxentry{save()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{opt}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Save a MeshFem in a text file (and optionally its linked mesh object
if \sphinxtitleref{opt} is the string ‘with\_mesh’).

\end{fulllineitems}

\index{set\_classical\_discontinuous\_fem() (MeshFem method)@\spxentry{set\_classical\_discontinuous\_fem()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.set_classical_discontinuous_fem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_classical\_discontinuous\_fem}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: MeshFem.set\_classical\_discontinuous\_fem(self, int k{[}{[}, ‘complete’{]}, @tscalar alpha{[}, ivec CVIDX{]}{]})

Assigns a classical (Lagrange polynomial) discontinuous fem of order k.

Similar to MeshFem.set\_classical\_fem() except that
FEM\_PK\_DISCONTINUOUS is used. Param \sphinxtitleref{alpha} the node inset,
\(0 \leq alpha < 1\), where 0 implies usual dof nodes, greater values
move the nodes toward the center of gravity, and 1 means that all
degrees of freedom collapse on the center of gravity.
The option ‘complete’ requests complete Langrange polynomial elements,
even if the element geometric transformation is an incomplete one
(e.g. 8\sphinxhyphen{}node quadrilateral or 20\sphinxhyphen{}node hexahedral).

\end{fulllineitems}

\index{set\_classical\_fem() (MeshFem method)@\spxentry{set\_classical\_fem()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.set_classical_fem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_classical\_fem}}}{\emph{\DUrole{n}{k}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: MeshFem.set\_classical\_fem(self, int k{[}{[}, ‘complete’{]}, ivec CVids{]})

Assign a classical (Lagrange polynomial) fem of order \sphinxtitleref{k} to the MeshFem.
The option ‘complete’ requests complete Langrange polynomial elements,
even if the element geometric transformation is an incomplete one
(e.g. 8\sphinxhyphen{}node quadrilateral or 20\sphinxhyphen{}node hexahedral).

Uses FEM\_PK for simplexes, FEM\_QK for parallelepipeds etc.

\end{fulllineitems}

\index{set\_dof\_partition() (MeshFem method)@\spxentry{set\_dof\_partition()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.set_dof_partition}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_dof\_partition}}}{\emph{\DUrole{n}{DOFP}}}{}
Change the ‘dof\_partition’ array.

\sphinxtitleref{DOFP} is a vector holding a integer value for each convex of the MeshFem.
See MeshFem.dof\_partition() for a description of “dof partition”.

\end{fulllineitems}

\index{set\_enriched\_dofs() (MeshFem method)@\spxentry{set\_enriched\_dofs()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.set_enriched_dofs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_enriched\_dofs}}}{\emph{\DUrole{n}{DOFs}}}{}
For a MeshFem product object only. Set te enriched dofs and adapt the MeshFem product.

\end{fulllineitems}

\index{set\_fem() (MeshFem method)@\spxentry{set\_fem()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.set_fem}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_fem}}}{\emph{\DUrole{n}{f}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Set the Finite Element Method.

Assign an FEM \sphinxtitleref{f} to all convexes whose \#ids are listed in \sphinxtitleref{CVids}.
If \sphinxtitleref{CVids} is not given, the integration is assigned to all convexes.

See the help of Fem to obtain a list of available FEM methods.

\end{fulllineitems}

\index{set\_partial() (MeshFem method)@\spxentry{set\_partial()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.set_partial}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_partial}}}{\emph{\DUrole{n}{DOFs}}, \emph{\DUrole{n}{RCVs}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Can only be applied to a partial MeshFem. Change the subset of the
degrees of freedom of \sphinxtitleref{mf}.

If \sphinxtitleref{RCVs} is given, no FEM will be put on the convexes listed
in \sphinxtitleref{RCVs}.

\end{fulllineitems}

\index{set\_qdim() (MeshFem method)@\spxentry{set\_qdim()}\spxextra{MeshFem method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshFem:getfem.MeshFem.set_qdim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_qdim}}}{\emph{\DUrole{n}{Q}}}{}
Change the \sphinxtitleref{Q} dimension of the field that is interpolated by the MeshFem.

\sphinxtitleref{Q = 1} means that the MeshFem describes a scalar field, \sphinxtitleref{Q = N} means
that the MeshFem describes a vector field of dimension N.

\end{fulllineitems}


\end{fulllineitems}



\section{MeshIm}
\label{\detokenize{python/cmdref_MeshIm:meshim}}\label{\detokenize{python/cmdref_MeshIm::doc}}\index{MeshIm (class in getfem)@\spxentry{MeshIm}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MeshIm}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM MeshIm object

This object represents an integration method defined on a whole mesh (an 
potentially on its boundaries).

General constructor for MeshIm objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MIM = MeshIm(\textquotesingle{}load\textquotesingle{}, string fname{[}, Mesh m{]})}}
Load a MeshIm from a file.

If the mesh \sphinxtitleref{m} is not supplied (this kind of file does not store the
mesh), then it is read from the file and its descriptor is returned as
the second output argument.

\item {} 
\sphinxcode{\sphinxupquote{MIM = MeshIm(\textquotesingle{}from string\textquotesingle{}, string s{[}, Mesh m{]})}}
Create a MeshIm object from its string description.

See also \sphinxcode{\sphinxupquote{MeshIm.char()}}

\item {} 
\sphinxcode{\sphinxupquote{MIM = MeshIm(\textquotesingle{}clone\textquotesingle{}, MeshIm mim)}}
Create a copy of a MeshIm.

\item {} 
\sphinxcode{\sphinxupquote{MIM = MeshIm(\textquotesingle{}levelset\textquotesingle{}, MeshLevelSet mls, string where, Integ im{[}, Integ im\_tip{[}, Integ im\_set{]}{]})}}
Build an integration method conformal to a partition defined
implicitly by a levelset.

The \sphinxtitleref{where} argument define the domain of integration with respect to
the levelset, it has to be chosen among ‘ALL’, ‘INSIDE’, ‘OUTSIDE’ and
‘BOUNDARY’.

it can be completed by a string defining the boolean operation
to define the integration domain when there is more than one levelset.

the syntax is very simple, for example if there are 3 different
levelset,
\begin{quote}

“a*b*c” is the intersection of the domains defined by each
levelset (this is the default behaviour if this function is not
called).

“a+b+c” is the union of their domains.

“c\sphinxhyphen{}(a+b)” is the domain of the third levelset minus the union of
the domains of the two others.

“!a” is the complementary of the domain of a (i.e. it is the
domain where a(x)\textgreater{}0)

The first levelset is always referred to with “a”, the second
with “b”, and so on.
\end{quote}

for intance INSIDE(a*b*c)

CAUTION: this integration method will be defined only on the element
cut by the level\sphinxhyphen{}set. For the ‘ALL’, ‘INSIDE’ and ‘OUTSIDE’ options
it is mandatory to use the method \sphinxcode{\sphinxupquote{MeshIm.set\_integ()}} to define
the integration method on the remaining elements.

\item {} 
\sphinxcode{\sphinxupquote{MIM = MeshIm(Mesh m, {[}\{Integ im|int im\_degree\}{]})}}
Build a new MeshIm object.

For convenience, optional arguments (\sphinxtitleref{im} or \sphinxtitleref{im\_degree}) can be
provided, in that case a call to \sphinxcode{\sphinxupquote{MeshIm.integ()}} is issued
with these arguments.

\end{itemize}
\index{adapt() (MeshIm method)@\spxentry{adapt()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.adapt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{adapt}}}{}{}
For a MeshIm levelset object only. Adapt the integration methods to a
change of the levelset function.

\end{fulllineitems}

\index{char() (MeshIm method)@\spxentry{char()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a string description of the MeshIm.

By default, it does not include the description of the linked
Mesh object.

\end{fulllineitems}

\index{convex\_index() (MeshIm method)@\spxentry{convex\_index()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.convex_index}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convex\_index}}}{}{}
Return the list of convexes who have a integration method.

Convexes who have the dummy IM\_NONE method are not listed.

\end{fulllineitems}

\index{display() (MeshIm method)@\spxentry{display()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a MeshIm object.

\end{fulllineitems}

\index{eltm() (MeshIm method)@\spxentry{eltm()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.eltm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{eltm}}}{\emph{\DUrole{n}{em}}, \emph{\DUrole{n}{cv}}, \emph{\DUrole{n}{f}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the elementary matrix (or tensor) integrated on the convex \sphinxtitleref{cv}.

\sphinxstylestrong{WARNING}

Be sure that the fem used for the construction of \sphinxtitleref{em} is compatible
with the fem assigned to element \sphinxtitleref{cv} ! This is not checked by the
function ! If the argument \sphinxtitleref{f} is given, then the elementary tensor
is integrated on the face \sphinxtitleref{f} of \sphinxtitleref{cv} instead of the whole convex.

\end{fulllineitems}

\index{im\_nodes() (MeshIm method)@\spxentry{im\_nodes()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.im_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{im\_nodes}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the coordinates of the integration points, with their weights.

\sphinxtitleref{CVids} may be a list of convexes, or a list of convex faces, such
as returned by Mesh.region()

\sphinxstylestrong{WARNING}

Convexes which are not part of the mesh, or convexes which
do not have an approximate integration method do not have
their corresponding entry (this has no meaning for exact
integration methods!).

\end{fulllineitems}

\index{integ() (MeshIm method)@\spxentry{integ()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.integ}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{integ}}}{\emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return a list of integration methods used by the MeshIm.

\sphinxtitleref{I} is an array of all Integ objects found in the convexes
given in \sphinxtitleref{CVids}. If \sphinxtitleref{CV2I} was supplied as an output argument, it
contains, for each convex listed in \sphinxtitleref{CVids}, the index of its
correspounding integration method in \sphinxtitleref{I}.

Convexes which are not part of the mesh, or convexes which do
not have any integration method have their correspounding entry
in \sphinxtitleref{CV2I} set to \sphinxhyphen{}1.

\end{fulllineitems}

\index{linked\_mesh() (MeshIm method)@\spxentry{linked\_mesh()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.linked_mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linked\_mesh}}}{}{}
Returns a reference to the Mesh object linked to \sphinxtitleref{mim}.

\end{fulllineitems}

\index{memsize() (MeshIm method)@\spxentry{memsize()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.memsize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{memsize}}}{}{}
Return the amount of memory (in bytes) used by the MeshIm object.

The result does not take into account the linked Mesh object.

\end{fulllineitems}

\index{save() (MeshIm method)@\spxentry{save()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{filename}}}{}
Saves a MeshIm in a text file (and optionally its linked mesh object).

\end{fulllineitems}

\index{set\_integ() (MeshIm method)@\spxentry{set\_integ()}\spxextra{MeshIm method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshIm:getfem.MeshIm.set_integ}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_integ}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: MeshIm.set\_integ(self,\{Integ im|int im\_degree\}{[}, ivec CVids{]})

Set the integration method.

Assign an integration method to all convexes whose \#ids are
listed in \sphinxtitleref{CVids}. If \sphinxtitleref{CVids} is not given, the integration is
assigned to all convexes. It is possible to assign a specific
integration method with an integration method handle \sphinxtitleref{im} obtained
via Integ(‘IM\_SOMETHING’), or to let getfem choose a suitable
integration method with \sphinxtitleref{im\_degree} (choosen such that polynomials
of \(\text{degree} \leq \text{im\_degree}\) are exactly integrated.
If \sphinxtitleref{im\_degree=\sphinxhyphen{}1}, then the dummy integration method IM\_NONE will 
be used.)

\end{fulllineitems}


\end{fulllineitems}



\section{MeshImData}
\label{\detokenize{python/cmdref_MeshImData:meshimdata}}\label{\detokenize{python/cmdref_MeshImData::doc}}\index{MeshImData (class in getfem)@\spxentry{MeshImData}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MeshImData}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM MeshImData object

This object represents data defined on a mesh\_im object.

General constructor for MeshImData objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MIMD = MeshImData(MeshIm mim, int region, ivec size)}}
Build a new MeshImd object linked to a MeshIm object. If \sphinxtitleref{region} is
provided, considered integration points are filtered in this region.
\sphinxtitleref{size} is a vector of integers that specifies the dimensions of the
stored data per integration point. If not given, the scalar stored
data are considered.

\end{itemize}
\index{display() (MeshImData method)@\spxentry{display()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a MeshImd object.

\end{fulllineitems}

\index{linked\_mesh() (MeshImData method)@\spxentry{linked\_mesh()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.linked_mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linked\_mesh}}}{}{}
Returns a reference to the Mesh object linked to \sphinxtitleref{mim}.

\end{fulllineitems}

\index{nb\_tensor\_elements() (MeshImData method)@\spxentry{nb\_tensor\_elements()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.nb_tensor_elements}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nb\_tensor\_elements}}}{}{}
Output the size of the stored data (per integration point).

\end{fulllineitems}

\index{nbpts() (MeshImData method)@\spxentry{nbpts()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.nbpts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbpts}}}{}{}
Output the number of integration points (filtered in the considered region).

\end{fulllineitems}

\index{region() (MeshImData method)@\spxentry{region()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{region}}}{}{}
Output the region that the MeshImd is restricted to.

\end{fulllineitems}

\index{set\_region() (MeshImData method)@\spxentry{set\_region()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.set_region}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_region}}}{\emph{\DUrole{n}{rnum}}}{}
Set the considered region to \sphinxtitleref{rnum}.

\end{fulllineitems}

\index{set\_tensor\_size() (MeshImData method)@\spxentry{set\_tensor\_size()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.set_tensor_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_tensor\_size}}}{}{}
Set the size of the data per integration point.

\end{fulllineitems}

\index{tensor\_size() (MeshImData method)@\spxentry{tensor\_size()}\spxextra{MeshImData method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshImData:getfem.MeshImData.tensor_size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tensor\_size}}}{}{}
Output the dimensions of the stored data (per integration point).

\end{fulllineitems}


\end{fulllineitems}



\section{MeshLevelSet}
\label{\detokenize{python/cmdref_MeshLevelSet:meshlevelset}}\label{\detokenize{python/cmdref_MeshLevelSet::doc}}\index{MeshLevelSet (class in getfem)@\spxentry{MeshLevelSet}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MeshLevelSet}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM MeshLevelSet object

General constructor for mesh\_levelset objects. The role of this object is
to provide a mesh cut by a certain number of level\_set. This object is
used to build conformal integration method (object mim and enriched finite
element methods (Xfem)).

General constructor for MeshLevelSet objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MLS = MeshLevelSet(Mesh m)}}
Build a new MeshLevelSet object from a Mesh and returns its handle.

\end{itemize}
\index{adapt() (MeshLevelSet method)@\spxentry{adapt()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.adapt}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{adapt}}}{}{}
Do all the work (cut the convexes with the levelsets).

To initialice the MeshLevelSet object or to actualize it when the
value of any levelset function is modified, one has to call
this method.

\end{fulllineitems}

\index{add() (MeshLevelSet method)@\spxentry{add()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.add}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\emph{\DUrole{n}{ls}}}{}
Add a link to the LevelSet \sphinxtitleref{ls}.

Only a reference is kept, no copy is done. In order to indicate
that the linked Mesh is cut by a LevelSet one has to call this
method, where \sphinxtitleref{ls} is an LevelSet object. An arbitrary number of
LevelSet can be added.

\sphinxstylestrong{WARNING}

The Mesh of \sphinxtitleref{ls} and the linked Mesh must be the same.

\end{fulllineitems}

\index{char() (MeshLevelSet method)@\spxentry{char()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the MeshLevelSetn.

This can be used to perform comparisons between two
different MeshLevelSet objects.
This function is to be completed.

\end{fulllineitems}

\index{crack\_tip\_convexes() (MeshLevelSet method)@\spxentry{crack\_tip\_convexes()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.crack_tip_convexes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crack\_tip\_convexes}}}{}{}
Return the list of convex \#id’s of the linked Mesh on
which have a tip of any linked LevelSet’s.

\end{fulllineitems}

\index{cut\_mesh() (MeshLevelSet method)@\spxentry{cut\_mesh()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.cut_mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cut\_mesh}}}{}{}
Return a Mesh cut by the linked LevelSet’s.

\end{fulllineitems}

\index{display() (MeshLevelSet method)@\spxentry{display()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a MeshLevelSet object.

\end{fulllineitems}

\index{levelsets() (MeshLevelSet method)@\spxentry{levelsets()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.levelsets}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{levelsets}}}{}{}
Return a list of references to the linked LevelSet’s.

\end{fulllineitems}

\index{linked\_mesh() (MeshLevelSet method)@\spxentry{linked\_mesh()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.linked_mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linked\_mesh}}}{}{}
Return a reference to the linked Mesh.

\end{fulllineitems}

\index{memsize() (MeshLevelSet method)@\spxentry{memsize()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.memsize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{memsize}}}{}{}
Return the amount of memory (in bytes) used by the MeshLevelSet.

\end{fulllineitems}

\index{nb\_ls() (MeshLevelSet method)@\spxentry{nb\_ls()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.nb_ls}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nb\_ls}}}{}{}
Return the number of linked LevelSet’s.

\end{fulllineitems}

\index{sup() (MeshLevelSet method)@\spxentry{sup()}\spxextra{MeshLevelSet method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MeshLevelSet:getfem.MeshLevelSet.sup}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sup}}}{\emph{\DUrole{n}{ls}}}{}
Remove a link to the LevelSet \sphinxtitleref{ls}.

\end{fulllineitems}


\end{fulllineitems}



\section{MesherObject}
\label{\detokenize{python/cmdref_MesherObject:mesherobject}}\label{\detokenize{python/cmdref_MesherObject::doc}}\index{MesherObject (class in getfem)@\spxentry{MesherObject}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MesherObject:getfem.MesherObject}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{MesherObject}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM MesherObject object

This object represents a geometric object to be meshed by the
experimental meshing procedure of Getfem.

General constructor for MesherObject objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}ball\textquotesingle{}, vec center, scalar radius)}}
Represents a ball of corresponding center and radius.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}half space\textquotesingle{}, vec origin, vec normal\_vector)}}
Represents an half space delimited by the plane which contains the
origin and normal to \sphinxtitleref{normal\_vector}. The selected part is the part
in the direction of the normal vector. This allows to cut a geometry
with a plane for instance to build a polygon or a polyhedron.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}cylinder\textquotesingle{}, vec origin, vec n, scalar length, scalar radius)}}
Represents a cylinder (in any dimension) of a certain radius whose axis
is determined by the origin, a vector \sphinxtitleref{n} and a certain length.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}cone\textquotesingle{}, vec origin, vec n, scalar length, scalar half\_angle)}}
Represents a cone (in any dimension) of a certain half\sphinxhyphen{}angle (in radians)
whose axis is determined by the origin, a vector \sphinxtitleref{n} and a certain length.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}torus\textquotesingle{}, scalar R, scalar r)}}
Represents a torus in 3d of axis along the z axis with a great radius
equal to \sphinxtitleref{R} and small radius equal to \sphinxtitleref{r}. For the moment, the
possibility to change the axis is not given.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}rectangle\textquotesingle{}, vec rmin, vec rmax)}}
Represents a rectangle (or parallelepiped in 3D) parallel to the axes.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}intersect\textquotesingle{}, MesherObject object1 , MesherObject object2, ...)}}
Intersection of several objects.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}union\textquotesingle{}, MesherObject object1 , MesherObject object2, ...)}}
Union of several objects.

\item {} 
\sphinxcode{\sphinxupquote{MF = MesherObject(\textquotesingle{}set minus\textquotesingle{}, MesherObject object1 , MesherObject object2)}}
Geometric object being object1 minus object2.

\end{itemize}
\index{char() (MesherObject method)@\spxentry{char()}\spxextra{MesherObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MesherObject:getfem.MesherObject.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the MesherObject.

This can be used to perform comparisons between two
different MesherObject objects.
This function is to be completed.

\end{fulllineitems}

\index{display() (MesherObject method)@\spxentry{display()}\spxextra{MesherObject method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_MesherObject:getfem.MesherObject.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a MesherObject object.

\end{fulllineitems}


\end{fulllineitems}



\section{Model}
\label{\detokenize{python/cmdref_Model:model}}\label{\detokenize{python/cmdref_Model::doc}}\index{Model (class in getfem)@\spxentry{Model}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Model}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Model object

Model variables store the variables and the state data and the
description of a model. This includes the global tangent matrix, the right
hand side and the constraints. There are two kinds of models, the \sphinxtitleref{real}
and the \sphinxtitleref{complex} models.

General constructor for Model objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{MD = Model(\textquotesingle{}real\textquotesingle{})}}
Build a model for real unknowns.

\item {} 
\sphinxcode{\sphinxupquote{MD = Model(\textquotesingle{}complex\textquotesingle{})}}
Build a model for complex unknowns.

\end{itemize}
\index{Neumann\_term() (Model method)@\spxentry{Neumann\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.Neumann_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Neumann\_term}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{region}}}{}
Gives the assembly string corresponding to the Neumann term of
the fem variable \sphinxtitleref{varname} on \sphinxtitleref{region}. It is deduced from the
assembly string declared by the model bricks.
\sphinxtitleref{region} should be the index of a boundary region
on the mesh where \sphinxtitleref{varname} is defined. Care to call this function
only after all the volumic bricks have been declared.
Complains, if a brick
omit to declare an assembly string.

\end{fulllineitems}

\index{add\_Dirichlet\_condition\_with\_Nitsche\_method() (Model method)@\spxentry{add\_Dirichlet\_condition\_with\_Nitsche\_method()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Dirichlet_condition_with_Nitsche_method}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Dirichlet\_condition\_with\_Nitsche\_method}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{Neumannterm}}, \emph{\DUrole{n}{datagamma0}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{theta}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_Dirichlet\_condition\_with\_Nitsche\_method(self, MeshIm mim, string varname, string Neumannterm, string datagamma0, int region{[}, scalar theta{]}{[}, string dataname{]})

Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. \sphinxtitleref{Neumannterm}
is the expression of the Neumann term (obtained by the Green formula)
described as an expression of the high\sphinxhyphen{}level
generic assembly language. This term can be obtained by 
Model.Neumann\_term(varname, region) once all volumic bricks have
been added to the model. The Dirichlet
condition is prescribed with Nitsche’s method. \sphinxtitleref{datag} is the optional
right hand side of the Dirichlet condition. \sphinxtitleref{datagamma0} is the
Nitsche’s method parameter. \sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} (default) is the simplest method
for which the second derivative of the Neumann term is not necessary
even for nonlinear problems. Return the brick index in the model.

\end{fulllineitems}

\index{add\_Dirichlet\_condition\_with\_multipliers() (Model method)@\spxentry{add\_Dirichlet\_condition\_with\_multipliers()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Dirichlet_condition_with_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Dirichlet\_condition\_with\_multipliers}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{mult\_description}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with a multiplier variable described by
\sphinxtitleref{mult\_description}. If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is the optional right hand side of  the
Dirichlet condition. It could be constant or described on a fem; scalar
or vector valued, depending on the variable on which the Dirichlet
condition is prescribed. Return the brick index in the model.

\end{fulllineitems}

\index{add\_Dirichlet\_condition\_with\_penalization() (Model method)@\spxentry{add\_Dirichlet\_condition\_with\_penalization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Dirichlet_condition_with_penalization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Dirichlet\_condition\_with\_penalization}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{coeff}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mf\_mult}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with penalization. The penalization coefficient
is initially \sphinxtitleref{coeff} and will be added to the data of the model.
\sphinxtitleref{dataname} is the optional right hand side of the Dirichlet condition.
It could be constant or described on a fem; scalar or vector valued,
depending on the variable on which the Dirichlet condition is prescribed.
\sphinxtitleref{mf\_mult} is an optional parameter which allows to weaken the
Dirichlet condition specifying a multiplier space.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_Dirichlet\_condition\_with\_simplification() (Model method)@\spxentry{add\_Dirichlet\_condition\_with\_simplification()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Dirichlet_condition_with_simplification}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Dirichlet\_condition\_with\_simplification}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a (simple) Dirichlet condition on the variable \sphinxtitleref{varname} and
the mesh region \sphinxtitleref{region}. The Dirichlet condition is prescribed by
a simple post\sphinxhyphen{}treatment of the final linear system (tangent system
for nonlinear problems) consisting of modifying the lines corresponding
to the degree of freedom of the variable on \sphinxtitleref{region} (0 outside the
diagonal, 1 on the diagonal of the matrix and the expected value on
the right hand side).
The symmetry of the linear system is kept if all other bricks are
symmetric.
This brick is to be reserved for simple Dirichlet conditions (only dof
declared on the corresponding boundary are prescribed). The application
of this brick on reduced dof may be problematic. Intrinsic vectorial
finite element method are not supported. 
\sphinxtitleref{dataname} is the optional right hand side of  the Dirichlet condition.
It could be constant (but in that case, it can only be applied to
Lagrange f.e.m.) or (important) described on the same finite
element method as \sphinxtitleref{varname}.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_Fourier\_Robin\_brick() (Model method)@\spxentry{add\_Fourier\_Robin\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Fourier_Robin_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Fourier\_Robin\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataexpr}}, \emph{\DUrole{n}{region}}}{}
Add a Fourier\sphinxhyphen{}Robin term to the model relatively to the variable
\sphinxtitleref{varname}. This corresponds to a weak term of the form
\(\int (qu).v\). \sphinxtitleref{dataexpr} is the parameter \(q\) of
the Fourier\sphinxhyphen{}Robin condition.  It can be an arbitrary valid expression
of the high\sphinxhyphen{}level generic assembly language (except for the complex version
for which it should be a data of the model). \sphinxtitleref{region} is the mesh region
on which the term is added. Return the brick index in the model.

\end{fulllineitems}

\index{add\_HHO\_reconstructed\_gradient() (Model method)@\spxentry{add\_HHO\_reconstructed\_gradient()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_HHO_reconstructed_gradient}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_HHO\_reconstructed\_gradient}}}{\emph{\DUrole{n}{transname}}}{}
Add to the model the elementary transformation corresponding to the
reconstruction of a gradient for HHO methods.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_HHO\_reconstructed\_symmetrized\_gradient() (Model method)@\spxentry{add\_HHO\_reconstructed\_symmetrized\_gradient()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_HHO_reconstructed_symmetrized_gradient}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_HHO\_reconstructed\_symmetrized\_gradient}}}{\emph{\DUrole{n}{transname}}}{}
Add to the model the elementary transformation corresponding to the
reconstruction of a symmetrized gradient for HHO methods.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_HHO\_reconstructed\_symmetrized\_value() (Model method)@\spxentry{add\_HHO\_reconstructed\_symmetrized\_value()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_HHO_reconstructed_symmetrized_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_HHO\_reconstructed\_symmetrized\_value}}}{\emph{\DUrole{n}{transname}}}{}
Add to the model the elementary transformation corresponding to the
reconstruction of the variable for HHO methods using a symmetrized
gradient.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_HHO\_reconstructed\_value() (Model method)@\spxentry{add\_HHO\_reconstructed\_value()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_HHO_reconstructed_value}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_HHO\_reconstructed\_value}}}{\emph{\DUrole{n}{transname}}}{}
Add to the model the elementary transformation corresponding to the
reconstruction of the variable for HHO methods.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_HHO\_stabilization() (Model method)@\spxentry{add\_HHO\_stabilization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_HHO_stabilization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_HHO\_stabilization}}}{\emph{\DUrole{n}{transname}}}{}
Add to the model the elementary transformation corresponding to the
HHO stabilization operator.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_HHO\_symmetrized\_stabilization() (Model method)@\spxentry{add\_HHO\_symmetrized\_stabilization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_HHO_symmetrized_stabilization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_HHO\_symmetrized\_stabilization}}}{\emph{\DUrole{n}{transname}}}{}
Add to the model the elementary transformation corresponding to the
HHO stabilization operator using a symmetrized gradient.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_Helmholtz\_brick() (Model method)@\spxentry{add\_Helmholtz\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Helmholtz_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Helmholtz\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataexpr}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Helmholtz term to the model relatively to the variable \sphinxtitleref{varname}.
\sphinxtitleref{dataexpr} is the wave number. \sphinxtitleref{region} is an optional mesh
region on which the term is added. If it is not specified, it is added
on the whole mesh. Return the brick index in the model.

\end{fulllineitems}

\index{add\_Houbolt\_scheme() (Model method)@\spxentry{add\_Houbolt\_scheme()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Houbolt_scheme}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Houbolt\_scheme}}}{\emph{\DUrole{n}{varname}}}{}
Attach a Houbolt method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most second order time derivative
of the variable

\end{fulllineitems}

\index{add\_Kirchhoff\_Love\_Neumann\_term\_brick() (Model method)@\spxentry{add\_Kirchhoff\_Love\_Neumann\_term\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Kirchhoff_Love_Neumann_term_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Kirchhoff\_Love\_Neumann\_term\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname\_M}}, \emph{\DUrole{n}{dataname\_divM}}, \emph{\DUrole{n}{region}}}{}
Add a Neumann term brick for Kirchhoff\sphinxhyphen{}Love model
on the variable \sphinxtitleref{varname} and the mesh region \sphinxtitleref{region}.
\sphinxtitleref{dataname\_M} represents the bending moment tensor and  \sphinxtitleref{dataname\_divM}
its divergence.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_Kirchhoff\_Love\_plate\_brick() (Model method)@\spxentry{add\_Kirchhoff\_Love\_plate\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Kirchhoff_Love_plate_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Kirchhoff\_Love\_plate\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname\_D}}, \emph{\DUrole{n}{dataname\_nu}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a bilaplacian brick on the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region}.
This represent a term \(\Delta(D \Delta u)\) where \(D(x)\)
is a the flexion modulus determined by \sphinxtitleref{dataname\_D}. The term is
integrated by part following a Kirchhoff\sphinxhyphen{}Love plate model
with \sphinxtitleref{dataname\_nu} the poisson ratio.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_Laplacian\_brick() (Model method)@\spxentry{add\_Laplacian\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Laplacian_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Laplacian\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Laplacian term to the model relatively to the variable \sphinxtitleref{varname}
(in fact with a minus : \(-\text{div}(\nabla u)\)).
If this is a vector valued variable, the Laplacian term is added
componentwise. \sphinxtitleref{region} is an optional mesh region on which the term
is added. If it is not specified, it is added on the whole mesh. Return
the brick index in the model.

\end{fulllineitems}

\index{add\_Mindlin\_Reissner\_plate\_brick() (Model method)@\spxentry{add\_Mindlin\_Reissner\_plate\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Mindlin_Reissner_plate_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Mindlin\_Reissner\_plate\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mim\_reduced}}, \emph{\DUrole{n}{varname\_u3}}, \emph{\DUrole{n}{varname\_theta}}, \emph{\DUrole{n}{param\_E}}, \emph{\DUrole{n}{param\_nu}}, \emph{\DUrole{n}{param\_epsilon}}, \emph{\DUrole{n}{param\_kappa}}, \emph{\DUrole{n}{variant}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_Mindlin\_Reissner\_plate\_brick(self, MeshIm mim, MeshIm mim\_reduced, string varname\_u3, string varname\_theta , string param\_E, string param\_nu, string param\_epsilon, string param\_kappa {[},int variant {[}, int region{]}{]})

Add a term corresponding to the classical Reissner\sphinxhyphen{}Mindlin plate
model for which \sphinxtitleref{varname\_u3} is the transverse displacement,
\sphinxtitleref{varname\_theta} the rotation of
fibers normal to the midplane, ‘param\_E’ the Young Modulus,
\sphinxtitleref{param\_nu} the poisson ratio,
\sphinxtitleref{param\_epsilon} the plate thickness,
\sphinxtitleref{param\_kappa} the shear correction factor. Note that since this brick
uses the high level generic assembly language, the parameter can
be regular expression of this language.
There are three variants.
\sphinxtitleref{variant = 0} corresponds to the an
unreduced formulation and in that case only the integration
method \sphinxtitleref{mim} is used. Practically this variant is not usable since
it is subject to a strong locking phenomenon.
\sphinxtitleref{variant = 1} corresponds to a reduced integration where \sphinxtitleref{mim} is
used for the rotation term and \sphinxtitleref{mim\_reduced} for the transverse
shear term. \sphinxtitleref{variant = 2} (default) corresponds to the projection onto
a rotated RT0 element of the transverse shear term. For the moment, this
is adapted to quadrilateral only (because it is not sufficient to
remove the locking phenomenon on triangle elements). Note also that if
you use high order elements, the projection on RT0 will reduce the order
of the approximation.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_Newmark\_scheme() (Model method)@\spxentry{add\_Newmark\_scheme()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Newmark_scheme}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Newmark\_scheme}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{gamma}}}{}
Attach a theta method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most second order time derivative
of the variable.

\end{fulllineitems}

\index{add\_Nitsche\_contact\_with\_rigid\_obstacle\_brick() (Model method)@\spxentry{add\_Nitsche\_contact\_with\_rigid\_obstacle\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Nitsche_contact_with_rigid_obstacle_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Nitsche\_contact\_with\_rigid\_obstacle\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{Neumannterm}}, \emph{\DUrole{n}{dataname\_obstacle}}, \emph{\DUrole{n}{gamma0name}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{theta}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_Nitsche\_contact\_with\_rigid\_obstacle\_brick(self, MeshIm mim, string varname, string Neumannterm, string dataname\_obstacle, string gamma0name,  int region{[}, scalar theta{[}, string dataname\_friction\_coeff{[}, string dataname\_alpha, string dataname\_wt{]}{]}{]})

Adds a contact condition with or without Coulomb friction on the variable
\sphinxtitleref{varname} and the mesh boundary \sphinxtitleref{region}. The contact condition
is prescribed with Nitsche’s method. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
\sphinxtitleref{gamma0name} is the Nitsche’s method parameter.
\sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method.
CAUTION: This brick has to be added in the model after all the bricks
corresponding to partial differential terms having a Neumann term.
Moreover, This brick can only be applied to bricks declaring their
Neumann terms. Returns the brick index in the model.

\end{fulllineitems}

\index{add\_Nitsche\_fictitious\_domain\_contact\_brick() (Model method)@\spxentry{add\_Nitsche\_fictitious\_domain\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Nitsche_fictitious_domain_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Nitsche\_fictitious\_domain\_contact\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname1}}, \emph{\DUrole{n}{varname2}}, \emph{\DUrole{n}{dataname\_d1}}, \emph{\DUrole{n}{dataname\_d2}}, \emph{\DUrole{n}{gamma0name}}, \emph{\DUrole{n}{theta}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_Nitsche\_fictitious\_domain\_contact\_brick(self, MeshIm mim, string varname1, string varname2, string dataname\_d1, string dataname\_d2, string gamma0name {[}, scalar theta{[}, string dataname\_friction\_coeff{[}, string dataname\_alpha, string dataname\_wt1,string dataname\_wt2{]}{]}{]})

Adds a contact condition with or without Coulomb friction between
two bodies in a fictitious domain. The contact condition is applied on 
the variable \sphinxtitleref{varname\_u1} corresponds with the first and slave body 
with Nitsche’s method and on the variable \sphinxtitleref{varname\_u2} corresponds 
with the second and master body with Nitsche’s method. 
The contact condition is evaluated on the fictitious slave boundary.
The first body should be described by the level\sphinxhyphen{}set \sphinxtitleref{dataname\_d1} 
and the second body should be described by the level\sphinxhyphen{}set \sphinxtitleref{dataname\_d2}.
\sphinxtitleref{gamma0name} is the Nitsche’s method parameter. 
\sphinxtitleref{theta} is a scalar value which can be positive or negative. 
\sphinxtitleref{theta = 1} corresponds to the standard symmetric method which is
conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is inconditionally coercive.
\sphinxtitleref{theta = 0} is the simplest method for which the second derivative of
the Neumann term is not necessary. The optional parameter \sphinxtitleref{dataname\_friction\_coeff}
is the friction coefficient which could be constant or defined on a finite element method. 
CAUTION: This brick has to be added in the model after all the bricks
corresponding to partial differential terms having a Neumann term.
Moreover, This brick can only be applied to bricks declaring their
Neumann terms. Returns the brick index in the model.

\end{fulllineitems}

\index{add\_Nitsche\_large\_sliding\_contact\_brick\_raytracing() (Model method)@\spxentry{add\_Nitsche\_large\_sliding\_contact\_brick\_raytracing()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Nitsche_large_sliding_contact_brick_raytracing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Nitsche\_large\_sliding\_contact\_brick\_raytracing}}}{\emph{\DUrole{n}{unbiased\_version}}, \emph{\DUrole{n}{dataname\_r}}, \emph{\DUrole{n}{release\_distance}}, \emph{\DUrole{n}{dataname\_fr}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_Nitsche\_large\_sliding\_contact\_brick\_raytracing(self, bool unbiased\_version, string dataname\_r, scalar release\_distance{[}, string dataname\_fr{[}, string dataname\_alpha{[}, int version{]}{]}{]})

Adds a large sliding contact with friction brick to the model based on the Nitsche’s method.
This brick is able to deal with self\sphinxhyphen{}contact, contact between
several deformable bodies and contact with rigid obstacles.
It uses the high\sphinxhyphen{}level generic assembly. It adds to the model
a raytracing\_interpolate\_transformation object. “unbiased\_version” refers to the version of Nische’s method to be used.
(unbiased or biased one).
For each slave boundary a  material law should be defined as a function of the dispacement variable on this boundary.
The release distance should be determined with care
(generally a few times a mean element size, and less than the
thickness of the body). Initially, the brick is added with no contact
boundaries. The contact boundaries and rigid bodies are added with
special functions. \sphinxtitleref{version} is 0 (the default value) for the
non\sphinxhyphen{}symmetric version and 1 for the more symmetric one
(not fully symmetric even without friction).

\end{fulllineitems}

\index{add\_Nitsche\_midpoint\_contact\_with\_rigid\_obstacle\_brick() (Model method)@\spxentry{add\_Nitsche\_midpoint\_contact\_with\_rigid\_obstacle\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_Nitsche_midpoint_contact_with_rigid_obstacle_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_Nitsche\_midpoint\_contact\_with\_rigid\_obstacle\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{Neumannterm}}, \emph{\DUrole{n}{Neumannterm\_wt}}, \emph{\DUrole{n}{dataname\_obstacle}}, \emph{\DUrole{n}{gamma0name}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{theta}}, \emph{\DUrole{n}{dataname\_friction\_coeff}}, \emph{\DUrole{n}{dataname\_alpha}}, \emph{\DUrole{n}{dataname\_wt}}}{}
EXPERIMENTAL BRICK: for midpoint scheme only !!
Adds a contact condition with or without Coulomb friction on the variable
\sphinxtitleref{varname} and the mesh boundary \sphinxtitleref{region}. The contact condition
is prescribed with Nitsche’s method. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
\sphinxtitleref{gamma0name} is the Nitsche’s method parameter.
\sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_assembly\_assignment() (Model method)@\spxentry{add\_assembly\_assignment()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_assembly_assignment}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_assembly\_assignment}}}{\emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Model.add\_assembly\_assignment(self, string dataname, string expression{[}, int region{[}, int order{[}, int before{]}{]}{]})

Adds expression \sphinxtitleref{expr} to be evaluated at assembly time and being
assigned to the data \sphinxtitleref{dataname} which has to be of im\_data type.
This allows for instance to store a sub\sphinxhyphen{}expression of an assembly
computation to be used on an other assembly. It can be used for instance
to store the plastic strain in plasticity models.
\sphinxtitleref{order} represents the order of assembly where this assignement has to be
done (potential(0), weak form(1) or tangent system(2) or at each
order(\sphinxhyphen{}1)). The default value is 1.
If before = 1, the the assignement is perfromed before the computation
of the other assembly terms, such that the data can be used in the
remaining of the assembly as an intermediary result (be careful that it is
still considered as a data, no derivation of the expression is performed
for the tangent system).     
If before = 0 (default), the assignement is done after the assembly terms.

\end{fulllineitems}

\index{add\_basic\_contact\_brick() (Model method)@\spxentry{add\_basic\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_basic_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_basic\_contact\_brick}}}{\emph{\DUrole{n}{varname\_u}}, \emph{\DUrole{n}{multname\_n}}, \emph{\DUrole{n}{multname\_t}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_basic\_contact\_brick(self, string varname\_u, string multname\_n{[}, string multname\_t{]}, string dataname\_r, Spmat BN{[}, Spmat BT, string dataname\_friction\_coeff{]}{[}, string dataname\_gap{[}, string dataname\_alpha{[}, int augmented\_version{[}, string dataname\_gamma, string dataname\_wt{]}{]}{]})

Add a contact with or without friction brick to the model.
If U is the vector
of degrees of freedom on which the unilateral constraint is applied,
the matrix \sphinxtitleref{BN} have to be such that this constraint is defined by
\(B_N U \le 0\). A friction condition can be considered by adding
the three parameters \sphinxtitleref{multname\_t}, \sphinxtitleref{BT} and \sphinxtitleref{dataname\_friction\_coeff}.
In this case, the tangential displacement is \(B_T U\) and
the matrix \sphinxtitleref{BT} should have as many rows as \sphinxtitleref{BN} multiplied by
\(d-1\) where \(d\) is the domain dimension.
In this case also, \sphinxtitleref{dataname\_friction\_coeff} is a data which represents
the coefficient of friction. It can be a scalar or a vector representing a
value on each contact condition.  The unilateral constraint is prescribed
thank to a multiplier
\sphinxtitleref{multname\_n} whose dimension should be equal to the number of rows of
\sphinxtitleref{BN}. If a friction condition is added, it is prescribed with a
multiplier \sphinxtitleref{multname\_t} whose dimension should be equal to the number
of rows of \sphinxtitleref{BT}. The augmentation parameter \sphinxtitleref{r} should be chosen in
a range of
acceptabe values (see Getfem user documentation). \sphinxtitleref{dataname\_gap} is an
optional parameter representing the initial gap. It can be a single value
or a vector of value. \sphinxtitleref{dataname\_alpha} is an optional homogenization
parameter for the augmentation parameter
(see Getfem user documentation).  The parameter \sphinxtitleref{augmented\_version}
indicates the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric
Alart\sphinxhyphen{}Curnier augmented Lagrangian, 2 for the symmetric one (except for
the coupling between contact and Coulomb friction), 3 for the
unsymmetric method with augmented multipliers, 4 for the unsymmetric
method with augmented multipliers and De Saxce projection.

\end{fulllineitems}

\index{add\_basic\_contact\_brick\_two\_deformable\_bodies() (Model method)@\spxentry{add\_basic\_contact\_brick\_two\_deformable\_bodies()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_basic_contact_brick_two_deformable_bodies}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_basic\_contact\_brick\_two\_deformable\_bodies}}}{\emph{\DUrole{n}{varname\_u1}}, \emph{\DUrole{n}{varname\_u2}}, \emph{\DUrole{n}{multname\_n}}, \emph{\DUrole{n}{dataname\_r}}, \emph{\DUrole{n}{BN1}}, \emph{\DUrole{n}{BN2}}, \emph{\DUrole{n}{dataname\_gap}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_basic\_contact\_brick\_two\_deformable\_bodies(self, string varname\_u1, string varname\_u2, string multname\_n, string dataname\_r, Spmat BN1, Spmat BN2{[}, string dataname\_gap{[}, string dataname\_alpha{[}, int augmented\_version{]}{]}{]})
\begin{description}
\item[{Add a frictionless contact condition to the model between two deformable}] \leavevmode
bodies. If U1, U2 are the vector
of degrees of freedom on which the unilateral constraint is applied,
the matrices \sphinxtitleref{BN1} and \sphinxtitleref{BN2} have to be such that this condition
is defined by
\$B\_\{N1\} U\_1 B\_\{N2\} U\_2 + le gap\$. The constraint is prescribed thank
to a multiplier
\sphinxtitleref{multname\_n} whose dimension should be equal to the number of lines of
\sphinxtitleref{BN}. The augmentation parameter \sphinxtitleref{r} should be chosen in a range of
acceptabe values (see Getfem user documentation). \sphinxtitleref{dataname\_gap} is an
optional parameter representing the initial gap. It can be a single value
or a vector of value. \sphinxtitleref{dataname\_alpha} is an optional homogenization
parameter for the augmentation parameter
(see Getfem user documentation). The parameter \sphinxtitleref{aug\_version} indicates
the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier
augmented Lagrangian, 2 for the symmetric one, 3 for the unsymmetric
method with augmented multiplier.

\end{description}

\end{fulllineitems}

\index{add\_bilaplacian\_brick() (Model method)@\spxentry{add\_bilaplacian\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_bilaplacian_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_bilaplacian\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a bilaplacian brick on the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region}.
This represent a term \(\Delta(D \Delta u)\).
where \(D(x)\) is a coefficient determined by \sphinxtitleref{dataname} which
could be constant or described on a f.e.m. The corresponding weak form
is \(\int D(x)\Delta u(x) \Delta v(x) dx\).
Return the brick index in the model.

\end{fulllineitems}

\index{add\_constraint\_with\_multipliers() (Model method)@\spxentry{add\_constraint\_with\_multipliers()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_constraint_with_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_constraint\_with\_multipliers}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{multname}}, \emph{\DUrole{n}{B}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_constraint\_with\_multipliers(self, string varname, string multname, Spmat B, \{vec L | string dataname\})

Add an additional explicit constraint on the variable \sphinxtitleref{varname} thank to
a multiplier \sphinxtitleref{multname} peviously added to the model (should be a fixed
size variable). The constraint is \(BU=L\)
with \sphinxtitleref{B} being a rectangular sparse matrix. It is possible to change
the constraint at any time with the methods Model.set\_private\_matrix()
and Model.set\_private\_rhs(). If \sphinxtitleref{dataname} is specified instead of \sphinxtitleref{L},
the vector \sphinxtitleref{L} is defined in the model as data with the given name.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_constraint\_with\_penalization() (Model method)@\spxentry{add\_constraint\_with\_penalization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_constraint_with_penalization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_constraint\_with\_penalization}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{coeff}}, \emph{\DUrole{n}{B}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_constraint\_with\_penalization(self, string varname, scalar coeff, Spmat B, \{vec L | string dataname\})

Add an additional explicit penalized constraint on the variable \sphinxtitleref{varname}.
The constraint is :math\textasciigrave{}BU=L\textasciigrave{} with \sphinxtitleref{B} being a rectangular sparse matrix.
Be aware that \sphinxtitleref{B} should not contain a plain row, otherwise the whole
tangent matrix will be plain. It is possible to change the constraint
at any time with the methods Model.set\_private\_matrix()
and Model.set\_private\_rhs(). The method
Model.change\_penalization\_coeff() can be used.
If \sphinxtitleref{dataname} is specified instead of \sphinxtitleref{L}, the vector \sphinxtitleref{L} is defined
in the model as data with the given name.
Return the brick
index in the model.

\end{fulllineitems}

\index{add\_contact\_boundary\_to\_unbiased\_Nitsche\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_contact\_boundary\_to\_unbiased\_Nitsche\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_contact_boundary_to_unbiased_Nitsche_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_contact\_boundary\_to\_unbiased\_Nitsche\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{lambdaname}}, \emph{\DUrole{n}{wname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a contact boundary to an existing unbiased Nitschelarge sliding contact
with friction brick which is both master and slave.

\end{fulllineitems}

\index{add\_contact\_with\_rigid\_obstacle\_brick() (Model method)@\spxentry{add\_contact\_with\_rigid\_obstacle\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_contact_with_rigid_obstacle_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_contact\_with\_rigid\_obstacle\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname\_u}}, \emph{\DUrole{n}{multname\_n}}, \emph{\DUrole{n}{multname\_t}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_contact\_with\_rigid\_obstacle\_brick(self,  MeshIm mim, string varname\_u, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_friction\_coeff{]}, int region, string obstacle{[},  int augmented\_version{]})

DEPRECATED FUNCTION. Use ‘add nodal contact with rigid obstacle brick’ instead.

\end{fulllineitems}

\index{add\_data() (Model method)@\spxentry{add\_data()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_data}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{size}}}{}
Add a fixed size data to the model.  \sphinxtitleref{sizes} is either a
integer (for a scalar or vector data) or a vector of dimensions
for a tensor data. \sphinxtitleref{name} is the data name.

\end{fulllineitems}

\index{add\_elastoplasticity\_brick() (Model method)@\spxentry{add\_elastoplasticity\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_elastoplasticity_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_elastoplasticity\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{projname}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{previous\_dep\_name}}, \emph{\DUrole{n}{datalambda}}, \emph{\DUrole{n}{datamu}}, \emph{\DUrole{n}{datathreshold}}, \emph{\DUrole{n}{datasigma}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Old (obsolete) brick which do not use the high level generic
assembly. Add a nonlinear elastoplastic term to the model relatively
to the variable \sphinxtitleref{varname}, in small deformations, for an isotropic
material and for a quasistatic model. \sphinxtitleref{projname} is the type of
projection that used: only the Von Mises projection is
available with ‘VM’ or ‘Von Mises’.
\sphinxtitleref{datasigma} is the variable representing the constraints on the material.
\sphinxtitleref{previous\_dep\_name} represents the displacement at the previous time step.
Moreover, the finite element method on which \sphinxtitleref{varname} is described
is an K ordered mesh\_fem, the \sphinxtitleref{datasigma} one have to be at least
an K\sphinxhyphen{}1 ordered mesh\_fem.
\sphinxtitleref{datalambda} and \sphinxtitleref{datamu} are the Lame coefficients of the studied
material.
\sphinxtitleref{datathreshold} is the plasticity threshold of the material.
The three last variables could be constants or described on the
same finite element method.
\sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added on the whole mesh.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_element\_extrapolation\_transformation() (Model method)@\spxentry{add\_element\_extrapolation\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_element_extrapolation_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_element\_extrapolation\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{source\_mesh}}, \emph{\DUrole{n}{elt\_corr}}}{}
Add a special interpolation transformation which represents the identity
transformation but allows to evaluate the expression on another element
than the current element by polynomial extrapolation. It is used for
stabilization term in fictitious domain applications. the array elt\_cor
should be a two entry array whose first line contains the elements
concerned by the transformation and the second line the respective
elements on which the extrapolation has to be made. If an element
is not listed in elt\_cor the evaluation is just made on the current
element.

\end{fulllineitems}

\index{add\_elementary\_P0\_projection() (Model method)@\spxentry{add\_elementary\_P0\_projection()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_elementary_P0_projection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_elementary\_P0\_projection}}}{\emph{\DUrole{n}{transname}}}{}
Add the elementary transformation corresponding to the projection
P0 element.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_elementary\_rotated\_RT0\_projection() (Model method)@\spxentry{add\_elementary\_rotated\_RT0\_projection()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_elementary_rotated_RT0_projection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_elementary\_rotated\_RT0\_projection}}}{\emph{\DUrole{n}{transname}}}{}
Add the elementary transformation corresponding to the projection
on rotated RT0 element for two\sphinxhyphen{}dimensional elements to the model.
The name is the name given to the elementary transformation.

\end{fulllineitems}

\index{add\_enriched\_Mindlin\_Reissner\_plate\_brick() (Model method)@\spxentry{add\_enriched\_Mindlin\_Reissner\_plate\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_enriched_Mindlin_Reissner_plate_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_enriched\_Mindlin\_Reissner\_plate\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mim\_reduced1}}, \emph{\DUrole{n}{mim\_reduced2}}, \emph{\DUrole{n}{varname\_ua}}, \emph{\DUrole{n}{varname\_theta}}, \emph{\DUrole{n}{varname\_u3}}, \emph{\DUrole{n}{varname\_theta3}}, \emph{\DUrole{n}{param\_E}}, \emph{\DUrole{n}{param\_nu}}, \emph{\DUrole{n}{param\_epsilon}}, \emph{\DUrole{n}{variant}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_enriched\_Mindlin\_Reissner\_plate\_brick(self, MeshIm mim, MeshIm mim\_reduced1, MeshIm mim\_reduced2, string varname\_ua, string varname\_theta,string varname\_u3, string varname\_theta3 , string param\_E, string param\_nu, string param\_epsilon {[},int variant {[}, int region{]}{]})

Add a term corresponding to the enriched Reissner\sphinxhyphen{}Mindlin plate
model for which \sphinxtitleref{varname\_ua} is the membrane displacements,
\sphinxtitleref{varname\_u3} is the transverse displacement,
\sphinxtitleref{varname\_theta} the rotation of
fibers normal to the midplane, 
\sphinxtitleref{varname\_theta3} the pinching,     
‘param\_E’ the Young Modulus,
\sphinxtitleref{param\_nu} the poisson ratio,
\sphinxtitleref{param\_epsilon} the plate thickness. Note that since this brick
uses the high level generic assembly language, the parameter can
be regular expression of this language.
There are four variants.
\sphinxtitleref{variant = 0} corresponds to the an
unreduced formulation and in that case only the integration
method \sphinxtitleref{mim} is used. Practically this variant is not usable since
it is subject to a strong locking phenomenon.
\sphinxtitleref{variant = 1} corresponds to a reduced integration where \sphinxtitleref{mim} is
used for the rotation term and \sphinxtitleref{mim\_reduced1} for the transverse
shear term and \sphinxtitleref{mim\_reduced2} for the pinching term.
\sphinxtitleref{variant = 2} (default) corresponds to the projection onto
a rotated RT0 element of the transverse shear term and a reduced integration for the pinching term.
For the moment, this is adapted to quadrilateral only (because it is not sufficient to
remove the locking phenomenon on triangle elements). Note also that if
you use high order elements, the projection on RT0 will reduce the order
of the approximation.
\sphinxtitleref{variant = 3} corresponds to the projection onto
a rotated RT0 element of the transverse shear term and the projection onto P0 element of the pinching term.
For the moment, this is adapted to quadrilateral only (because it is not sufficient to
remove the locking phenomenon on triangle elements). Note also that if
you use high order elements, the projection on RT0 will reduce the order
of the approximation.   
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_explicit\_matrix() (Model method)@\spxentry{add\_explicit\_matrix()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_explicit_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_explicit\_matrix}}}{\emph{\DUrole{n}{varname1}}, \emph{\DUrole{n}{varname2}}, \emph{\DUrole{n}{B}}, \emph{\DUrole{n}{issymmetric}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_explicit\_matrix(self, string varname1, string varname2, Spmat B{[}, int issymmetric{[}, int iscoercive{]}{]})

Add a brick representing an explicit matrix to be added to the tangent
linear system relatively to the variables \sphinxtitleref{varname1} and \sphinxtitleref{varname2}.
The given matrix should have has many rows as the dimension of
\sphinxtitleref{varname1} and as many columns as the dimension of \sphinxtitleref{varname2}.
If the two variables are different and if \sphinxtitleref{issymmetric} is set to 1
then the transpose of the matrix is also added to the tangent system
(default is 0). Set \sphinxtitleref{iscoercive} to 1 if the term does not affect the
coercivity of the tangent system (default is 0). The matrix can be
changed by the command Model.set\_private\_matrix(). Return the
brick index in the model.

\end{fulllineitems}

\index{add\_explicit\_rhs() (Model method)@\spxentry{add\_explicit\_rhs()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_explicit_rhs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_explicit\_rhs}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{L}}}{}
Add a brick representing an explicit right hand side to be added to
the right hand side of the tangent linear system relatively to the
variable \sphinxtitleref{varname}. The given rhs should have the same size than the
dimension of \sphinxtitleref{varname}. The rhs can be changed by the command
Model.set\_private\_rhs(). If \sphinxtitleref{dataname} is specified instead of
\sphinxtitleref{L}, the vector \sphinxtitleref{L} is defined in the model as data with the given name.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_fem\_data() (Model method)@\spxentry{add\_fem\_data()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_fem_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_fem\_data}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mf}}, \emph{\DUrole{n}{sizes}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a data to the model linked to a MeshFem. \sphinxtitleref{name} is the data name,
\sphinxtitleref{sizes} an optional parameter which is either an 
integer  or a vector of suplementary dimensions with respect to \sphinxtitleref{mf}.

\end{fulllineitems}

\index{add\_fem\_variable() (Model method)@\spxentry{add\_fem\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_fem_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_fem\_variable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mf}}}{}
Add a variable to the model linked to a MeshFem. \sphinxtitleref{name} is the variable
name.

\end{fulllineitems}

\index{add\_filtered\_fem\_variable() (Model method)@\spxentry{add\_filtered\_fem\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_filtered_fem_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_filtered\_fem\_variable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mf}}, \emph{\DUrole{n}{region}}}{}
Add a variable to the model linked to a MeshFem. The variable is filtered
in the sense that only the dof on the region are considered.
\sphinxtitleref{name} is the variable name.

\end{fulllineitems}

\index{add\_finite\_strain\_elasticity\_brick() (Model method)@\spxentry{add\_finite\_strain\_elasticity\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_finite_strain_elasticity_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_finite\_strain\_elasticity\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{constitutive\_law}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{params}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a nonlinear elasticity term to the model relatively to the
variable \sphinxtitleref{varname}. \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘Neo Hookean’,
‘Ciarlet Geymonat’ or ‘Generalized Blatz Ko’.
‘Mooney Rivlin’ and ‘Neo Hookean’ law names have to be preceeded with
the word ‘Compressible’ or ‘Incompressible’ to force using the
corresponding version.
The compressible version of these laws requires one additional material
coefficient.

IMPORTANT : if the variable is defined on a 2D mesh, the plane strain
approximation is automatically used.
\sphinxtitleref{params} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable
coefficients. \sphinxtitleref{region} is an optional mesh region on which the term
is added. If it is not specified, it is added on the whole mesh.
This brick use the high\sphinxhyphen{}level generic assembly.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_finite\_strain\_elastoplasticity\_brick() (Model method)@\spxentry{add\_finite\_strain\_elastoplasticity\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_finite_strain_elastoplasticity_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_finite\_strain\_elastoplasticity\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{unknowns\_type}}, \emph{\DUrole{n}{varnames}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_finite\_strain\_elastoplasticity\_brick(self, MeshIm mim , string lawname, string unknowns\_type {[}, string varnames, …{]} {[}, string params, …{]} {[}, int region = \sphinxhyphen{}1{]})

Add a finite strain elastoplasticity brick to the model.
For the moment there is only one supported law defined through 
\sphinxtitleref{lawname} as “Simo\_Miehe”.
This law supports to possibilities of unknown variables to solve for
defined by means of \sphinxtitleref{unknowns\_type} set to either
‘DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER’ (integer value 1) or
‘DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER\_AND\_PRESSURE’ (integer value 3).
The  “Simo\_Miehe” law expects as \sphinxtitleref{varnames} a set of the
following names that have to be defined as variables in the model:
\begin{itemize}
\item {} 
the displacement variable which has to be defined as an unknown,

\item {} 
the plastic multiplier which has also defined as an unknown,

\item {} 
optionally the pressure variable for a mixed displacement\sphinxhyphen{}pressure
formulation for ‘DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER\_AND\_PRESSURE’
as \sphinxtitleref{unknowns\_type},

\item {} 
the name of a (scalar) fem\_data or im\_data field that holds the
plastic strain at the previous time step, and

\item {} 
the name of a fem\_data or im\_data field that holds all
non\sphinxhyphen{}repeated components of the inverse of the plastic right
Cauchy\sphinxhyphen{}Green tensor at the previous time step
(it has to be a 4 element vector for plane strain 2D problems
and a 6 element vector for 3D problems).

\end{itemize}

The  “Simo\_Miehe” law also expects as \sphinxtitleref{params} a set of the
following three parameters:
\begin{itemize}
\item {} 
an expression for the initial bulk modulus K,

\item {} 
an expression for the initial shear modulus G,

\item {} 
the name of a user predefined function that decribes
the yield limit as a function of the hardening variable
(both the yield limit and the hardening variable values are
assumed to be Frobenius norms of appropriate stress and strain
tensors, respectively).

\end{itemize}

As usual, \sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added on the whole mesh.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_finite\_strain\_incompressibility\_brick() (Model method)@\spxentry{add\_finite\_strain\_incompressibility\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_finite_strain_incompressibility_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_finite\_strain\_incompressibility\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{multname\_pressure}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a finite strain incompressibility condition on \sphinxtitleref{variable} (for large
strain elasticity). \sphinxtitleref{multname\_pressure}
is a variable which represent the pressure. Be aware that an inf\sphinxhyphen{}sup
condition between the finite element method describing the pressure and the
primal variable has to be satisfied. \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it is added on the
whole mesh. Return the brick index in the model.
This brick is equivalent to the \sphinxcode{\sphinxupquote{nonlinear incompressibility brick}} but
uses the high\sphinxhyphen{}level generic assembly adding the term
\sphinxcode{\sphinxupquote{p*(1\sphinxhyphen{}Det(Id(meshdim)+Grad\_u))}} if \sphinxcode{\sphinxupquote{p}} is the multiplier and
\sphinxcode{\sphinxupquote{u}} the variable which represent the displacement.

\end{fulllineitems}

\index{add\_generalized\_Dirichlet\_condition\_with\_Nitsche\_method() (Model method)@\spxentry{add\_generalized\_Dirichlet\_condition\_with\_Nitsche\_method()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_generalized_Dirichlet_condition_with_Nitsche_method}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_generalized\_Dirichlet\_condition\_with\_Nitsche\_method}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{Neumannterm}}, \emph{\DUrole{n}{gamma0name}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{theta}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}.
This version is for vector field. It prescribes a condition
@f\$ Hu = r @f\$ where \sphinxtitleref{H} is a matrix field.
CAUTION : the matrix H should have all eigenvalues equal to 1 or 0.
The region should be a boundary.   \sphinxtitleref{Neumannterm}
is the expression of the Neumann term (obtained by the Green formula)
described as an expression of the high\sphinxhyphen{}level
generic assembly language. This term can be obtained by 
Model.Neumann\_term(varname, region) once all volumic bricks have
been added to the model.  The Dirichlet
condition is prescribed with Nitsche’s method. \sphinxtitleref{dataname} is the optional
right hand side of the Dirichlet condition. It could be constant or
described on a fem. \sphinxtitleref{gamma0name} is the
Nitsche’s method parameter. \sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary
even for nonlinear problems. \sphinxtitleref{Hname} is the data
corresponding to the matrix field \sphinxtitleref{H}. It has to be a constant matrix
or described on a scalar fem. Returns the brick index in the model.
(This brick is not fully tested)

\end{fulllineitems}

\index{add\_generalized\_Dirichlet\_condition\_with\_multipliers() (Model method)@\spxentry{add\_generalized\_Dirichlet\_condition\_with\_multipliers()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_generalized_Dirichlet_condition_with_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_generalized\_Dirichlet\_condition\_with\_multipliers}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{mult\_description}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{Hname}}}{}
Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}.  This version is for vector field.
It prescribes a condition \(Hu = r\)
where \sphinxtitleref{H} is a matrix field. The region should be a boundary. The Dirichlet
condition is prescribed with a multiplier variable described by
\sphinxtitleref{mult\_description}. If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is the right hand side of  the
Dirichlet condition. It could be constant or described on a fem; scalar
or vector valued, depending on the variable on which the Dirichlet
condition is prescribed. \sphinxtitleref{Hname} is the data
corresponding to the matrix field \sphinxtitleref{H}.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_generalized\_Dirichlet\_condition\_with\_penalization() (Model method)@\spxentry{add\_generalized\_Dirichlet\_condition\_with\_penalization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_generalized_Dirichlet_condition_with_penalization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_generalized\_Dirichlet\_condition\_with\_penalization}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{coeff}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{Hname}}, \emph{\DUrole{n}{mf\_mult}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This version is for vector field.
It prescribes a condition \(Hu = r\)
where \sphinxtitleref{H} is a matrix field.
The region should be a boundary. The Dirichlet
condition is prescribed with penalization. The penalization coefficient
is intially \sphinxtitleref{coeff} and will be added to the data of the model.
\sphinxtitleref{dataname} is the right hand side of the Dirichlet condition.
It could be constant or described on a fem; scalar or vector valued,
depending on the variable on which the Dirichlet condition is prescribed.
\sphinxtitleref{Hname} is the data
corresponding to the matrix field \sphinxtitleref{H}. It has to be a constant matrix
or described on a scalar fem.
\sphinxtitleref{mf\_mult} is an optional parameter which allows to weaken the
Dirichlet condition specifying a multiplier space.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_generic\_elliptic\_brick() (Model method)@\spxentry{add\_generic\_elliptic\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_generic_elliptic_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_generic\_elliptic\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a generic elliptic term to the model relatively to the variable \sphinxtitleref{varname}.
The shape of the elliptic term depends both on the variable and the data.
This corresponds to a term
\(-\text{div}(a\nabla u)\)
where \(a\) is the data and \(u\) the variable. The data can be
a scalar,
a matrix or an order four tensor. The variable can be vector valued or
not. If the data is a scalar or a matrix and the variable is vector
valued then the term is added componentwise. An order four tensor data
is allowed for vector valued variable only. The data can be constant or
describbed on a fem. Of course, when the data is a tensor describe on a
finite element method (a tensor field) the data can be a huge vector.
The components of the matrix/tensor have to be stored with the fortran
order (columnwise) in the data vector (compatibility with blas). The
symmetry of the given matrix/tensor is not verified (but assumed). If
this is a vector valued variable, the elliptic term is added
componentwise. \sphinxtitleref{region} is an optional mesh region on which the term is
added. If it is not specified, it is added on the whole mesh. Note that
for the real
version which uses the high\sphinxhyphen{}level generic assembly language, \sphinxtitleref{dataname}
can be any regular expression of the high\sphinxhyphen{}level generic assembly
language (like “1”, “sin(X(1))” or “Norm(u)” for instance) even
depending on model variables. Return the
brick index in the model.

\end{fulllineitems}

\index{add\_im\_data() (Model method)@\spxentry{add\_im\_data()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_im_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_im\_data}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mimd}}}{}
Add a data set to the model linked to a MeshImd. \sphinxtitleref{name} is the data
name.

\end{fulllineitems}

\index{add\_im\_variable() (Model method)@\spxentry{add\_im\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_im_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_im\_variable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mimd}}}{}
Add a variable to the model linked to a MeshImd. \sphinxtitleref{name} is the variable
name.

\end{fulllineitems}

\index{add\_initialized\_data() (Model method)@\spxentry{add\_initialized\_data()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_initialized_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_initialized\_data}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{V}}, \emph{\DUrole{n}{sizes}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add an initialized fixed size data to the model. \sphinxtitleref{sizes} an
optional parameter which is either an 
integer  or a vector dimensions that describes the format of the
data. By default, the data is considered to b a vector field.
\sphinxtitleref{name} is the data name and \sphinxtitleref{V} is the value of the data.

\end{fulllineitems}

\index{add\_initialized\_fem\_data() (Model method)@\spxentry{add\_initialized\_fem\_data()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_initialized_fem_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_initialized\_fem\_data}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mf}}, \emph{\DUrole{n}{V}}, \emph{\DUrole{n}{sizes}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a data to the model linked to a MeshFem. \sphinxtitleref{name} is the data name.
The data is initiakized with \sphinxtitleref{V}. The data can be a scalar or vector
field. \sphinxtitleref{sizes} an optional parameter which is either an 
integer or a vector of suplementary dimensions with respect to \sphinxtitleref{mf}.

\end{fulllineitems}

\index{add\_integral\_contact\_between\_nonmatching\_meshes\_brick() (Model method)@\spxentry{add\_integral\_contact\_between\_nonmatching\_meshes\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_integral_contact_between_nonmatching_meshes_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_integral\_contact\_between\_nonmatching\_meshes\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname\_u1}}, \emph{\DUrole{n}{varname\_u2}}, \emph{\DUrole{n}{multname}}, \emph{\DUrole{n}{dataname\_r}}, \emph{\DUrole{n}{dataname\_friction\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_integral\_contact\_between\_nonmatching\_meshes\_brick(self,  MeshIm mim, string varname\_u1, string varname\_u2, string multname, string dataname\_r {[}, string dataname\_friction\_coeff{]}, int region1, int region2 {[}, int option {[}, string dataname\_alpha {[}, string dataname\_wt1 , string dataname\_wt2{]}{]}{]})

Add a contact with or without friction condition between nonmatching
meshes to the model. This brick adds a contact which is defined
in an integral way. It is the direct approximation of an augmented
agrangian formulation (see Getfem user documentation) defined at the
continuous level. The advantage should be a better scalability:
the number of Newton iterations should be more or less independent
of the mesh size.
The condition is applied on the variables \sphinxtitleref{varname\_u1} and \sphinxtitleref{varname\_u2}
on the boundaries corresponding to \sphinxtitleref{region1} and \sphinxtitleref{region2}.
\sphinxtitleref{multname} should be a fem variable representing the contact stress
for the frictionless case and the contact and friction stress for the
case with friction. An inf\sphinxhyphen{}sup condition between \sphinxtitleref{multname} and
\sphinxtitleref{varname\_u1} and \sphinxtitleref{varname\_u2} is required.
The augmentation parameter \sphinxtitleref{dataname\_r} should be chosen in a
range of acceptable values.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method on the same mesh as \sphinxtitleref{varname\_u1}.
Possible values for \sphinxtitleref{option} is 1 for the non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier
augmented Lagrangian method, 2 for the symmetric one, 3 for the
non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier method with an additional augmentation
and 4 for a new unsymmetric method. The default value is 1.
In case of contact with friction, \sphinxtitleref{dataname\_alpha}, \sphinxtitleref{dataname\_wt1} and
\sphinxtitleref{dataname\_wt2} are optional parameters to solve evolutionary friction
problems.

\end{fulllineitems}

\index{add\_integral\_contact\_with\_rigid\_obstacle\_brick() (Model method)@\spxentry{add\_integral\_contact\_with\_rigid\_obstacle\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_integral_contact_with_rigid_obstacle_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_integral\_contact\_with\_rigid\_obstacle\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname\_u}}, \emph{\DUrole{n}{multname}}, \emph{\DUrole{n}{dataname\_obstacle}}, \emph{\DUrole{n}{dataname\_r}}, \emph{\DUrole{n}{dataname\_friction\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_integral\_contact\_with\_rigid\_obstacle\_brick(self,  MeshIm mim, string varname\_u, string multname, string dataname\_obstacle, string dataname\_r {[}, string dataname\_friction\_coeff{]}, int region {[}, int option {[}, string dataname\_alpha {[}, string dataname\_wt {[}, string dataname\_gamma {[}, string dataname\_vt{]}{]}{]}{]}{]})

Add a contact with or without friction condition with a rigid obstacle
to the model. This brick adds a contact which is defined
in an integral way. It is the direct approximation of an augmented
Lagrangian formulation (see Getfem user documentation) defined at the
continuous level. The advantage is a better scalability: the number of
Newton iterations should be more or less independent of the mesh size.
The contact condition is applied on the variable \sphinxtitleref{varname\_u}
on the boundary corresponding to \sphinxtitleref{region}. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
\sphinxtitleref{multname} should be a fem variable representing the contact stress.
An inf\sphinxhyphen{}sup condition beetween \sphinxtitleref{multname} and \sphinxtitleref{varname\_u} is required.
The augmentation parameter \sphinxtitleref{dataname\_r} should be chosen in a
range of acceptabe values.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element method.
Possible values for \sphinxtitleref{option} is 1 for the non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier
augmented Lagrangian method, 2 for the symmetric one, 3 for the
non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier method with an additional augmentation
and 4 for a new unsymmetric method. The default value is 1.
In case of contact with friction, \sphinxtitleref{dataname\_alpha} and \sphinxtitleref{dataname\_wt}
are optional parameters to solve evolutionary friction problems.
\sphinxtitleref{dataname\_gamma} and \sphinxtitleref{dataname\_vt} represent optional data for adding
a parameter\sphinxhyphen{}dependent sliding velocity to the friction condition.

\end{fulllineitems}

\index{add\_integral\_large\_sliding\_contact\_brick\_raytracing() (Model method)@\spxentry{add\_integral\_large\_sliding\_contact\_brick\_raytracing()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_integral_large_sliding_contact_brick_raytracing}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_integral\_large\_sliding\_contact\_brick\_raytracing}}}{\emph{\DUrole{n}{dataname\_r}}, \emph{\DUrole{n}{release\_distance}}, \emph{\DUrole{n}{dataname\_fr}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_integral\_large\_sliding\_contact\_brick\_raytracing(self, string dataname\_r, scalar release\_distance, {[}, string dataname\_fr{[}, string dataname\_alpha{[}, int version{]}{]}{]})

Adds a large sliding contact with friction brick to the model.
This brick is able to deal with self\sphinxhyphen{}contact, contact between
several deformable bodies and contact with rigid obstacles.
It uses the high\sphinxhyphen{}level generic assembly. It adds to the model
a raytracing\_interpolate\_transformation object.
For each slave boundary a multiplier variable should be defined.
The release distance should be determined with care
(generally a few times a mean element size, and less than the
thickness of the body). Initially, the brick is added with no contact
boundaries. The contact boundaries and rigid bodies are added with
special functions. \sphinxtitleref{version} is 0 (the default value) for the
non\sphinxhyphen{}symmetric version and 1 for the more symmetric one
(not fully symmetric even without friction).

\end{fulllineitems}

\index{add\_internal\_im\_variable() (Model method)@\spxentry{add\_internal\_im\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_internal_im_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_internal\_im\_variable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mimd}}}{}
Add a variable to the model, which is linked to a MeshImd and will be
condensed out during the assemblage of the tangent matrix. \sphinxtitleref{name} is
the variable name.

\end{fulllineitems}

\index{add\_interpolate\_transformation\_from\_expression() (Model method)@\spxentry{add\_interpolate\_transformation\_from\_expression()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_interpolate_transformation_from_expression}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_interpolate\_transformation\_from\_expression}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{source\_mesh}}, \emph{\DUrole{n}{target\_mesh}}, \emph{\DUrole{n}{expr}}}{}
Add a transformation to the model from mesh \sphinxtitleref{source\_mesh} to mesh
\sphinxtitleref{target\_mesh} given by the expression \sphinxtitleref{expr} which corresponds to a
high\sphinxhyphen{}level generic assembly expression which may contains some
variable of the model. CAUTION: the derivative of the
transformation with used variable is taken into account in the
computation of the tangen system. However, order two derivative is not
implemented, so such tranformation is not allowed in the definition
of a potential.

\end{fulllineitems}

\index{add\_isotropic\_linearized\_elasticity\_brick() (Model method)@\spxentry{add\_isotropic\_linearized\_elasticity\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_isotropic_linearized_elasticity_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_isotropic\_linearized\_elasticity\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname\_lambda}}, \emph{\DUrole{n}{dataname\_mu}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add an isotropic linearized elasticity term to the model relatively to
the variable \sphinxtitleref{varname}. \sphinxtitleref{dataname\_lambda} and \sphinxtitleref{dataname\_mu} should
contain the Lame coefficients. \sphinxtitleref{region} is an optional mesh region
on which the term is added. If it is not specified, it is added
on the whole mesh. Return the brick index in the model.

\end{fulllineitems}

\index{add\_isotropic\_linearized\_elasticity\_brick\_pstrain() (Model method)@\spxentry{add\_isotropic\_linearized\_elasticity\_brick\_pstrain()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_isotropic_linearized_elasticity_brick_pstrain}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_isotropic\_linearized\_elasticity\_brick\_pstrain}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{data\_E}}, \emph{\DUrole{n}{data\_nu}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add an isotropic linearized elasticity term to the model relatively to
the variable \sphinxtitleref{varname}. \sphinxtitleref{data\_E} and \sphinxtitleref{data\_nu} should
contain the Young modulus and Poisson ratio, respectively.
\sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added
on the whole mesh.
On two\sphinxhyphen{}dimensional meshes, the term will correpsond to a plain strain
approximation. On three\sphinxhyphen{}dimensional meshes, it will correspond to the
standard model. 
Return the brick index in the model.

\end{fulllineitems}

\index{add\_isotropic\_linearized\_elasticity\_brick\_pstress() (Model method)@\spxentry{add\_isotropic\_linearized\_elasticity\_brick\_pstress()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_isotropic_linearized_elasticity_brick_pstress}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_isotropic\_linearized\_elasticity\_brick\_pstress}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{data\_E}}, \emph{\DUrole{n}{data\_nu}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add an isotropic linearized elasticity term to the model relatively to
the variable \sphinxtitleref{varname}. \sphinxtitleref{data\_E} and \sphinxtitleref{data\_nu} should
contain the Young modulus and Poisson ratio, respectively.
\sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added
on the whole mesh.
On two\sphinxhyphen{}dimensional meshes, the term will correpsond to a plain stress
approximation. On three\sphinxhyphen{}dimensional meshes, it will correspond to the
standard model. 
Return the brick index in the model.

\end{fulllineitems}

\index{add\_linear\_generic\_assembly\_brick() (Model method)@\spxentry{add\_linear\_generic\_assembly\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_linear_generic_assembly_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_linear\_generic\_assembly\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_linear\_generic\_assembly\_brick(self, MeshIm mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})

Deprecated. Use Model.add\_linear\_term() instead.

\end{fulllineitems}

\index{add\_linear\_incompressibility\_brick() (Model method)@\spxentry{add\_linear\_incompressibility\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_linear_incompressibility_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_linear\_incompressibility\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{multname\_pressure}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_linear\_incompressibility\_brick(self, MeshIm mim, string varname, string multname\_pressure{[}, int region{[}, string dataexpr\_coeff{]}{]})

Add a linear incompressibility condition on \sphinxtitleref{variable}. \sphinxtitleref{multname\_pressure}
is a variable which represent the pressure. Be aware that an inf\sphinxhyphen{}sup
condition between the finite element method describing the pressure and the
primal variable has to be satisfied. \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it is added on the whole
mesh. \sphinxtitleref{dataexpr\_coeff} is an optional penalization coefficient for nearly
incompressible elasticity for instance. In this case, it is the inverse
of the Lame coefficient \(\lambda\). Return the brick index in the
model.

\end{fulllineitems}

\index{add\_linear\_term() (Model method)@\spxentry{add\_linear\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_linear_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_linear\_term}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_linear\_term(self, MeshIm mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})

Adds a matrix term given by the assembly string \sphinxtitleref{expr} which will
be assembled in region \sphinxtitleref{region} and with the integration method \sphinxtitleref{mim}.
Only the matrix term will be taken into account, assuming that it is
linear.
The advantage of declaring a term linear instead of nonlinear is that
it will be assembled only once and no assembly is necessary for the
residual.
Take care that if the expression contains some variables and if the
expression is a potential or of first order (i.e. describe the weak
form, not the derivative of the weak form), the expression will be
derivated with respect to all variables.
You can specify if the term is symmetric, coercive or not.
If you are not sure, the better is to declare the term not symmetric
and not coercive. But some solvers (conjugate gradient for instance)
are not allowed for non\sphinxhyphen{}coercive problems.
\sphinxtitleref{brickname} is an optional name for the brick.

\end{fulllineitems}

\index{add\_linear\_twodomain\_term() (Model method)@\spxentry{add\_linear\_twodomain\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_linear_twodomain_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_linear\_twodomain\_term}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{secondary\_domain}}, \emph{\DUrole{n}{is\_symmetric}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_linear\_twodomain\_term(self, MeshIm mim, string expression, int region, string secondary\_domain{[}, int is\_symmetric{[}, int is\_coercive{]}{]})

Adds a linear term given by a weak form language expression like
Model.add\_linear\_term() but for an integration on a direct
product of two domains, a first specfied by \sphinxcode{\sphinxupquote{mim}} and \sphinxcode{\sphinxupquote{region}}
and a second one by \sphinxcode{\sphinxupquote{secondary\_domain}} which has to be declared
first into the model.

\end{fulllineitems}

\index{add\_macro() (Model method)@\spxentry{add\_macro()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_macro}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_macro}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{expr}}}{}
Define a new macro for the high generic assembly language.
The name include the parameters. For instance name=’sp(a,b)’, expr=’a.b’
is a valid definition. Macro without parameter can also be defined.
For instance name=’x1’, expr=’X{[}1{]}’ is valid. The form name=’grad(u)’,
expr=’Grad\_u’ is also allowed but in that case, the parameter ‘u’ will
only be allowed to be a variable name when using the macro. Note that
macros can be directly defined inside the assembly strings with the
keyword ‘Def’.

\end{fulllineitems}

\index{add\_mass\_brick() (Model method)@\spxentry{add\_mass\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_mass_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_mass\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataexpr\_rho}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_mass\_brick(self, MeshIm mim, string varname{[}, string dataexpr\_rho{[}, int region{]}{]})

Add mass term to the model relatively to the variable \sphinxtitleref{varname}.
If specified, the data \sphinxtitleref{dataexpr\_rho} is the
density (1 if omitted). \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it
is added on the whole mesh. Return the brick index in the model.

\end{fulllineitems}

\index{add\_master\_contact\_boundary\_to\_biased\_Nitsche\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_master\_contact\_boundary\_to\_biased\_Nitsche\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_master_contact_boundary_to_biased_Nitsche_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_master\_contact\_boundary\_to\_biased\_Nitsche\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{wname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a master contact boundary to an existing biased Nitsche’s large sliding contact
with friction brick.

\end{fulllineitems}

\index{add\_master\_contact\_boundary\_to\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_master\_contact\_boundary\_to\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_master_contact_boundary_to_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_master\_contact\_boundary\_to\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{wname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a master contact boundary to an existing large sliding contact
with friction brick.

\end{fulllineitems}

\index{add\_master\_contact\_boundary\_to\_projection\_transformation() (Model method)@\spxentry{add\_master\_contact\_boundary\_to\_projection\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_master_contact_boundary_to_projection_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_master\_contact\_boundary\_to\_projection\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{m}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{region}}}{}
Add a master contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing projection
interpolate transformation called \sphinxtitleref{transname}.

\end{fulllineitems}

\index{add\_master\_contact\_boundary\_to\_raytracing\_transformation() (Model method)@\spxentry{add\_master\_contact\_boundary\_to\_raytracing\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_master_contact_boundary_to_raytracing_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_master\_contact\_boundary\_to\_raytracing\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{m}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{region}}}{}
Add a master contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing raytracing
interpolate transformation called \sphinxtitleref{transname}.

\end{fulllineitems}

\index{add\_master\_slave\_contact\_boundary\_to\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_master\_slave\_contact\_boundary\_to\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_master_slave_contact_boundary_to_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_master\_slave\_contact\_boundary\_to\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{lambdaname}}, \emph{\DUrole{n}{wname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a contact boundary to an existing large sliding contact
with friction brick which is both master and slave
(allowing the self\sphinxhyphen{}contact).

\end{fulllineitems}

\index{add\_multiplier() (Model method)@\spxentry{add\_multiplier()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_multiplier}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_multiplier}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mf}}, \emph{\DUrole{n}{primalname}}, \emph{\DUrole{n}{mim}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a particular variable linked to a fem being a multiplier with
respect to a primal variable. The dof will be filtered with the
\sphinxcode{\sphinxupquote{gmm::range\_basis}} function applied on the terms of the model
which link the multiplier and the primal variable. This in order to
retain only linearly independent constraints on the primal variable.
Optimized for boundary multipliers.

\end{fulllineitems}

\index{add\_nodal\_contact\_between\_nonmatching\_meshes\_brick() (Model method)@\spxentry{add\_nodal\_contact\_between\_nonmatching\_meshes\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nodal_contact_between_nonmatching_meshes_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodal\_contact\_between\_nonmatching\_meshes\_brick}}}{\emph{\DUrole{n}{mim1}}, \emph{\DUrole{n}{mim2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_nodal\_contact\_between\_nonmatching\_meshes\_brick(self,  MeshIm mim1{[}, MeshIm mim2{]}, string varname\_u1{[}, string varname\_u2{]}, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_fr{]}, int rg1, int rg2{[}, int slave1, int slave2,  int augmented\_version{]})

Add a contact with or without friction condition between two faces of
one or two elastic bodies. The condition is applied on the variable
\sphinxtitleref{varname\_u1} or the variables \sphinxtitleref{varname\_u1} and \sphinxtitleref{varname\_u2} depending
if a single or two distinct displacement fields are given. Integers
\sphinxtitleref{rg1} and \sphinxtitleref{rg2} represent the regions expected to come in contact with
each other. In the single displacement variable case the regions defined
in both \sphinxtitleref{rg1} and \sphinxtitleref{rg2} refer to the variable \sphinxtitleref{varname\_u1}. In the case
of two displacement variables, \sphinxtitleref{rg1} refers to \sphinxtitleref{varname\_u1} and \sphinxtitleref{rg2}
refers to \sphinxtitleref{varname\_u2}. \sphinxtitleref{multname\_n} should be a fixed size variable
whose size is the number of degrees of freedom on those regions among
the ones defined in \sphinxtitleref{rg1} and \sphinxtitleref{rg2} which are characterized as “slaves”.
It represents the contact equivalent nodal normal forces. \sphinxtitleref{multname\_t}
should be a fixed size variable whose size corresponds to the size of
\sphinxtitleref{multname\_n} multiplied by qdim \sphinxhyphen{} 1 . It represents the contact
equivalent nodal tangent (frictional) forces. The augmentation parameter
\sphinxtitleref{r} should be chosen in a range of acceptabe values (close to the Young
modulus of the elastic body, see Getfem user documentation). The
friction coefficient stored in the parameter \sphinxtitleref{fr} is either a single
value or a vector of the same size as \sphinxtitleref{multname\_n}. The optional
parameters \sphinxtitleref{slave1} and \sphinxtitleref{slave2} declare if the regions defined in \sphinxtitleref{rg1}
and \sphinxtitleref{rg2} are correspondingly considered as “slaves”. By default
\sphinxtitleref{slave1} is true and \sphinxtitleref{slave2} is false, i.e. \sphinxtitleref{rg1} contains the slave
surfaces, while ‘rg2’ the master surfaces. Preferrably only one of
\sphinxtitleref{slave1} and \sphinxtitleref{slave2} is set to true.  The parameter \sphinxtitleref{augmented\_version}
indicates the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric
Alart\sphinxhyphen{}Curnier augmented Lagrangian, 2 for the symmetric one (except for
the coupling between contact and Coulomb friction),
3 for the new unsymmetric method.
Basically, this brick computes the matrices BN and BT and the vectors
gap and alpha and calls the basic contact brick.

\end{fulllineitems}

\index{add\_nodal\_contact\_with\_rigid\_obstacle\_brick() (Model method)@\spxentry{add\_nodal\_contact\_with\_rigid\_obstacle\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nodal_contact_with_rigid_obstacle_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodal\_contact\_with\_rigid\_obstacle\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname\_u}}, \emph{\DUrole{n}{multname\_n}}, \emph{\DUrole{n}{multname\_t}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_nodal\_contact\_with\_rigid\_obstacle\_brick(self,  MeshIm mim, string varname\_u, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_friction\_coeff{]}, int region, string obstacle{[},  int augmented\_version{]})

Add a contact with or without friction condition with a rigid obstacle
to the model. The condition is applied on the variable \sphinxtitleref{varname\_u}
on the boundary corresponding to \sphinxtitleref{region}. The rigid obstacle should
be described with the string \sphinxtitleref{obstacle} being a signed distance to
the obstacle. This string should be an expression where the coordinates
are ‘x’, ‘y’ in 2D and ‘x’, ‘y’, ‘z’ in 3D. For instance, if the rigid
obstacle correspond to \(z \le 0\), the corresponding signed distance
will be simply “z”. \sphinxtitleref{multname\_n} should be a fixed size variable whose size
is the number of degrees of freedom on boundary \sphinxtitleref{region}. It represents the
contact equivalent nodal forces. In order to add a friction condition
one has to add the \sphinxtitleref{multname\_t} and \sphinxtitleref{dataname\_friction\_coeff} parameters.
\sphinxtitleref{multname\_t} should be a fixed size variable whose size is
the number of degrees of freedom on boundary \sphinxtitleref{region} multiplied by
\(d-1\) where \(d\) is the domain dimension. It represents
the friction equivalent nodal forces.
The augmentation parameter \sphinxtitleref{r} should be chosen in a
range of acceptabe values (close to the Young modulus of the elastic
body, see Getfem user documentation).  \sphinxtitleref{dataname\_friction\_coeff} is
the friction coefficient. It could be a scalar or a vector of values
representing the friction coefficient on each contact node. 
The parameter \sphinxtitleref{augmented\_version}
indicates the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric
Alart\sphinxhyphen{}Curnier augmented Lagrangian, 2 for the symmetric one (except for
the coupling between contact and Coulomb friction),
3 for the new unsymmetric method.
Basically, this brick compute the matrix BN
and the vectors gap and alpha and calls the basic contact brick.

\end{fulllineitems}

\index{add\_nonlinear\_elasticity\_brick() (Model method)@\spxentry{add\_nonlinear\_elasticity\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nonlinear_elasticity_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nonlinear\_elasticity\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{constitutive\_law}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a nonlinear elasticity term to the model relatively to the
variable \sphinxtitleref{varname} (deprecated brick, use add\_finite\_strain\_elaticity
instead). \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘neo Hookean’,
‘Ciarlet Geymonat’ or ‘generalized Blatz Ko’.
‘Mooney Rivlin’ and ‘neo Hookean’ law names can be preceded with the word
‘compressible’ or ‘incompressible’ to force using the corresponding version.
The compressible version of these laws requires one additional material
coefficient. By default, the incompressible version of ‘Mooney Rivlin’ law
and the compressible one of the ‘neo Hookean’ law are considered. In
general, ‘neo Hookean’ is a special case of the ‘Mooney Rivlin’ law that
requires one coefficient less.
IMPORTANT : if the variable is defined on a 2D mesh, the plane strain
approximation is automatically used.
\sphinxtitleref{dataname} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable
coefficients. \sphinxtitleref{region} is an optional mesh region on which the term
is added. If it is not specified, it is added on the whole mesh.
This brick use the low\sphinxhyphen{}level generic assembly.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_nonlinear\_generic\_assembly\_brick() (Model method)@\spxentry{add\_nonlinear\_generic\_assembly\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nonlinear_generic_assembly_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nonlinear\_generic\_assembly\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_nonlinear\_generic\_assembly\_brick(self, MeshIm mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})

Deprecated. Use Model.add\_nonlinear\_term() instead.

\end{fulllineitems}

\index{add\_nonlinear\_incompressibility\_brick() (Model method)@\spxentry{add\_nonlinear\_incompressibility\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nonlinear_incompressibility_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nonlinear\_incompressibility\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{multname\_pressure}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a nonlinear incompressibility condition on \sphinxtitleref{variable} (for large
strain elasticity). \sphinxtitleref{multname\_pressure}
is a variable which represent the pressure. Be aware that an inf\sphinxhyphen{}sup
condition between the finite element method describing the pressure and the
primal variable has to be satisfied. \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it is added on the
whole mesh. Return the brick index in the model.

\end{fulllineitems}

\index{add\_nonlinear\_term() (Model method)@\spxentry{add\_nonlinear\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nonlinear_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nonlinear\_term}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_nonlinear\_term(self, MeshIm mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})

Adds a nonlinear term given by the assembly string \sphinxtitleref{expr} which will
be assembled in region \sphinxtitleref{region} and with the integration method \sphinxtitleref{mim}.
The expression can describe a potential or a weak form. Second order
terms (i.e. containing second order test functions, Test2) are not
allowed.
You can specify if the term is symmetric, coercive or not.
If you are not sure, the better is to declare the term not symmetric
and not coercive. But some solvers (conjugate gradient for instance)
are not allowed for non\sphinxhyphen{}coercive problems.
\sphinxtitleref{brickname} is an optional name for the brick.

\end{fulllineitems}

\index{add\_nonlinear\_twodomain\_term() (Model method)@\spxentry{add\_nonlinear\_twodomain\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nonlinear_twodomain_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nonlinear\_twodomain\_term}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{secondary\_domain}}, \emph{\DUrole{n}{is\_symmetric}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_nonlinear\_twodomain\_term(self, MeshIm mim, string expression, int region, string secondary\_domain{[}, int is\_symmetric{[}, int is\_coercive{]}{]})

Adds a nonlinear term given by a weak form language expression like
Model.add\_nonlinear\_term() but for an integration on a direct
product of two domains, a first specfied by \sphinxcode{\sphinxupquote{mim}} and \sphinxcode{\sphinxupquote{region}}
and a second one by \sphinxcode{\sphinxupquote{secondary\_domain}} which has to be declared
first into the model.

\end{fulllineitems}

\index{add\_nonmatching\_meshes\_contact\_brick() (Model method)@\spxentry{add\_nonmatching\_meshes\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_nonmatching_meshes_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nonmatching\_meshes\_contact\_brick}}}{\emph{\DUrole{n}{mim1}}, \emph{\DUrole{n}{mim2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_nonmatching\_meshes\_contact\_brick(self,  MeshIm mim1{[}, MeshIm mim2{]}, string varname\_u1{[}, string varname\_u2{]}, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_fr{]}, int rg1, int rg2{[}, int slave1, int slave2,  int augmented\_version{]})

DEPRECATED FUNCTION. Use ‘add nodal contact between nonmatching meshes brick’ instead.

\end{fulllineitems}

\index{add\_normal\_Dirichlet\_condition\_with\_Nitsche\_method() (Model method)@\spxentry{add\_normal\_Dirichlet\_condition\_with\_Nitsche\_method()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_normal_Dirichlet_condition_with_Nitsche_method}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_normal\_Dirichlet\_condition\_with\_Nitsche\_method}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{Neumannterm}}, \emph{\DUrole{n}{gamma0name}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{theta}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_normal\_Dirichlet\_condition\_with\_Nitsche\_method(self, MeshIm mim, string varname, string Neumannterm, string gamma0name, int region{[}, scalar theta{]}{[}, string dataname{]})

Add a Dirichlet condition to the normal component of the vector
(or tensor) valued variable \sphinxtitleref{varname} and the mesh region \sphinxtitleref{region}.
This region should be a boundary. \sphinxtitleref{Neumannterm}
is the expression of the Neumann term (obtained by the Green formula)
described as an expression of the high\sphinxhyphen{}level
generic assembly language. This term can be obtained by 
Model.Neumann\_term(varname, region) once all volumic bricks have
been added to the model. The Dirichlet
condition is prescribed with Nitsche’s method. \sphinxtitleref{dataname} is the optional
right hand side of the Dirichlet condition. It could be constant or
described on a fem. \sphinxtitleref{gamma0name} is the
Nitsche’s method parameter. \sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary
even for nonlinear problems. 
Returns the brick index in the model.
(This brick is not fully tested)

\end{fulllineitems}

\index{add\_normal\_Dirichlet\_condition\_with\_multipliers() (Model method)@\spxentry{add\_normal\_Dirichlet\_condition\_with\_multipliers()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_normal_Dirichlet_condition_with_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_normal\_Dirichlet\_condition\_with\_multipliers}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{mult\_description}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition to the normal component of the vector
(or tensor) valued variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with a multiplier variable described by
\sphinxtitleref{mult\_description}. If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is the optional right hand side of  the
Dirichlet condition. It could be constant or described on a fem; scalar
or vector valued, depending on the variable on which the Dirichlet
condition is prescribed (scalar if the variable
is vector valued, vector if the variable is tensor valued).
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_normal\_Dirichlet\_condition\_with\_penalization() (Model method)@\spxentry{add\_normal\_Dirichlet\_condition\_with\_penalization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_normal_Dirichlet_condition_with_penalization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_normal\_Dirichlet\_condition\_with\_penalization}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{coeff}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mf\_mult}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition to the normal component of the vector
(or tensor) valued variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with penalization. The penalization coefficient
is initially \sphinxtitleref{coeff} and will be added to the data of the model.
\sphinxtitleref{dataname} is the optional right hand side of the Dirichlet condition.
It could be constant or described on a fem; scalar or vector valued,
depending on the variable on which the Dirichlet condition is prescribed
(scalar if the variable
is vector valued, vector if the variable is tensor valued).
\sphinxtitleref{mf\_mult} is an optional parameter which allows to weaken the
Dirichlet condition specifying a multiplier space.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_normal\_derivative\_Dirichlet\_condition\_with\_multipliers() (Model method)@\spxentry{add\_normal\_derivative\_Dirichlet\_condition\_with\_multipliers()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_normal_derivative_Dirichlet_condition_with_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_normal\_derivative\_Dirichlet\_condition\_with\_multipliers}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{mult\_description}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{R\_must\_be\_derivated}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition on the normal derivative of the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region} (which should be a boundary).
The general form is
\(\int \partial_n u(x)v(x) = \int r(x)v(x) \forall v\)
where \(r(x)\) is
the right hand side for the Dirichlet condition (0 for
homogeneous conditions) and \(v\) is in a space of multipliers
defined by \sphinxtitleref{mult\_description}.
If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is an optional parameter which represents
the right hand side of the Dirichlet condition.
If \sphinxtitleref{R\_must\_be\_derivated} is set to \sphinxtitleref{true} then the normal
derivative of \sphinxtitleref{dataname} is considered.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_normal\_derivative\_Dirichlet\_condition\_with\_penalization() (Model method)@\spxentry{add\_normal\_derivative\_Dirichlet\_condition\_with\_penalization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_normal_derivative_Dirichlet_condition_with_penalization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_normal\_derivative\_Dirichlet\_condition\_with\_penalization}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{coeff}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dataname}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{R\_must\_be\_derivated}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Add a Dirichlet condition on the normal derivative of the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region} (which should be a boundary).
The general form is
\(\int \partial_n u(x)v(x) = \int r(x)v(x) \forall v\)
where \(r(x)\) is
the right hand side for the Dirichlet condition (0 for
homogeneous conditions).
The penalization coefficient
is initially \sphinxtitleref{coeff} and will be added to the data of the model.
It can be changed with the command Model.change\_penalization\_coeff().
\sphinxtitleref{dataname} is an optional parameter which represents
the right hand side of the Dirichlet condition.
If \sphinxtitleref{R\_must\_be\_derivated} is set to \sphinxtitleref{true} then the normal
derivative of \sphinxtitleref{dataname} is considered.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_normal\_derivative\_source\_term\_brick() (Model method)@\spxentry{add\_normal\_derivative\_source\_term\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_normal_derivative_source_term_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_normal\_derivative\_source\_term\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{region}}}{}
Add a normal derivative source term brick
\(F = \int b.\partial_n v\) on the variable \sphinxtitleref{varname} and the
mesh region \sphinxtitleref{region}.

Update the right hand side of the linear system.
\sphinxtitleref{dataname} represents \sphinxtitleref{b} and \sphinxtitleref{varname} represents \sphinxtitleref{v}.
Return the brick index in the model.

\end{fulllineitems}

\index{add\_normal\_source\_term\_brick() (Model method)@\spxentry{add\_normal\_source\_term\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_normal_source_term_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_normal\_source\_term\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{region}}}{}
Add a source term on the variable \sphinxtitleref{varname} on a boundary \sphinxtitleref{region}.
This region should be a boundary. The source term is
represented by the data \sphinxtitleref{dataepxpr} which could be any regular
expression of the high\sphinxhyphen{}level generic assembly language (except
for the complex version where it has to be a declared data of
the model). A scalar
product with the outward normal unit vector to the boundary is performed.
The main aim of this brick is to represent a Neumann condition with a
vector data without performing the scalar product with the normal as a
pre\sphinxhyphen{}processing. Return the brick index in the model.

\end{fulllineitems}

\index{add\_penalized\_contact\_between\_nonmatching\_meshes\_brick() (Model method)@\spxentry{add\_penalized\_contact\_between\_nonmatching\_meshes\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_penalized_contact_between_nonmatching_meshes_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_penalized\_contact\_between\_nonmatching\_meshes\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname\_u1}}, \emph{\DUrole{n}{varname\_u2}}, \emph{\DUrole{n}{dataname\_r}}, \emph{\DUrole{n}{dataname\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_penalized\_contact\_between\_nonmatching\_meshes\_brick(self,  MeshIm mim, string varname\_u1, string varname\_u2, string dataname\_r {[}, string dataname\_coeff{]}, int region1, int region2 {[}, int option {[}, string dataname\_lambda, {[}, string dataname\_alpha {[}, string dataname\_wt1, string dataname\_wt2{]}{]}{]}{]})

Add a penalized contact condition with or without friction between
nonmatching meshes to the model.
The condition is applied on the variables \sphinxtitleref{varname\_u1} and  \sphinxtitleref{varname\_u2}
on the boundaries corresponding to \sphinxtitleref{region1} and \sphinxtitleref{region2}.
The penalization parameter \sphinxtitleref{dataname\_r} should be chosen
large enough to prescribe approximate non\sphinxhyphen{}penetration and friction
conditions but not too large not to deteriorate too much the
conditionning of the tangent system.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method on the same mesh as \sphinxtitleref{varname\_u1}.
\sphinxtitleref{dataname\_lambda} is an optional parameter used if option
is 2. In that case, the penalization term is shifted by lambda (this
allows the use of an Uzawa algorithm on the corresponding augmented
Lagrangian formulation)
In case of contact with friction, \sphinxtitleref{dataname\_alpha}, \sphinxtitleref{dataname\_wt1} and
\sphinxtitleref{dataname\_wt2} are optional parameters to solve evolutionary friction
problems.

\end{fulllineitems}

\index{add\_penalized\_contact\_with\_rigid\_obstacle\_brick() (Model method)@\spxentry{add\_penalized\_contact\_with\_rigid\_obstacle\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_penalized_contact_with_rigid_obstacle_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_penalized\_contact\_with\_rigid\_obstacle\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname\_u}}, \emph{\DUrole{n}{dataname\_obstacle}}, \emph{\DUrole{n}{dataname\_r}}, \emph{\DUrole{n}{dataname\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_penalized\_contact\_with\_rigid\_obstacle\_brick(self,  MeshIm mim, string varname\_u, string dataname\_obstacle, string dataname\_r {[}, string dataname\_coeff{]}, int region {[}, int option, string dataname\_lambda, {[}, string dataname\_alpha {[}, string dataname\_wt{]}{]}{]})

Add a penalized contact with or without friction condition with a
rigid obstacle to the model.
The condition is applied on the variable \sphinxtitleref{varname\_u}
on the boundary corresponding to \sphinxtitleref{region}. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
The penalization parameter \sphinxtitleref{dataname\_r} should be chosen
large enough to prescribe approximate non\sphinxhyphen{}penetration and friction
conditions but not too large not to deteriorate too much the
conditionning of the tangent system.
\sphinxtitleref{dataname\_lambda} is an optional parameter used if option
is 2. In that case, the penalization term is shifted by lambda (this
allows the use of an Uzawa algorithm on the corresponding augmented
Lagrangian formulation)

\end{fulllineitems}

\index{add\_pointwise\_constraints\_with\_given\_multipliers() (Model method)@\spxentry{add\_pointwise\_constraints\_with\_given\_multipliers()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_pointwise_constraints_with_given_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_pointwise\_constraints\_with\_given\_multipliers}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{multname}}, \emph{\DUrole{n}{dataname\_pt}}, \emph{\DUrole{n}{dataname\_unitv}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_pointwise\_constraints\_with\_given\_multipliers(self, string varname, string multname, string dataname\_pt{[}, string dataname\_unitv{]} {[}, string dataname\_val{]})

Add some pointwise constraints on the variable \sphinxtitleref{varname} using a given
multiplier \sphinxtitleref{multname}.
The conditions are prescribed on a set of points given in the data
\sphinxtitleref{dataname\_pt} whose dimension is the number of points times the dimension
of the mesh.
The multiplier variable should be a fixed size variable of size the
number of points.
If the variable represents a vector field, one has to give the data
\sphinxtitleref{dataname\_unitv} which represents a vector of dimension the number of
points times the dimension of the vector field which should store some
unit vectors. In that case the prescribed constraint is the scalar
product of the variable at the corresponding point with the corresponding
unit vector.
The optional data \sphinxtitleref{dataname\_val} is the vector of values to be prescribed
at the different points.
This brick is specifically designed to kill rigid displacement
in a Neumann problem.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_pointwise\_constraints\_with\_multipliers() (Model method)@\spxentry{add\_pointwise\_constraints\_with\_multipliers()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_pointwise_constraints_with_multipliers}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_pointwise\_constraints\_with\_multipliers}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname\_pt}}, \emph{\DUrole{n}{dataname\_unitv}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_pointwise\_constraints\_with\_multipliers(self, string varname, string dataname\_pt{[}, string dataname\_unitv{]} {[}, string dataname\_val{]})

Add some pointwise constraints on the variable \sphinxtitleref{varname} using
multiplier. The multiplier variable is automatically added to the model.
The conditions are prescribed on a set of points given in the data
\sphinxtitleref{dataname\_pt} whose dimension is the number of points times the dimension
of the mesh.
If the variable represents a vector field, one has to give the data
\sphinxtitleref{dataname\_unitv} which represents a vector of dimension the number of
points times the dimension of the vector field which should store some
unit vectors. In that case the prescribed constraint is the scalar
product of the variable at the corresponding point with the corresponding
unit vector.
The optional data \sphinxtitleref{dataname\_val} is the vector of values to be prescribed
at the different points.
This brick is specifically designed to kill rigid displacement
in a Neumann problem.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_pointwise\_constraints\_with\_penalization() (Model method)@\spxentry{add\_pointwise\_constraints\_with\_penalization()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_pointwise_constraints_with_penalization}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_pointwise\_constraints\_with\_penalization}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{coeff}}, \emph{\DUrole{n}{dataname\_pt}}, \emph{\DUrole{n}{dataname\_unitv}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_pointwise\_constraints\_with\_penalization(self, string varname, scalar coeff, string dataname\_pt{[}, string dataname\_unitv{]} {[}, string dataname\_val{]})

Add some pointwise constraints on the variable \sphinxtitleref{varname} thanks to
a penalization. The penalization coefficient is initially
\sphinxtitleref{penalization\_coeff} and will be added to the data of the model.
The conditions are prescribed on a set of points given in the data
\sphinxtitleref{dataname\_pt} whose dimension is the number of points times the dimension
of the mesh.
If the variable represents a vector field, one has to give the data
\sphinxtitleref{dataname\_unitv} which represents a vector of dimension the number of
points times the dimension of the vector field which should store some
unit vectors. In that case the prescribed constraint is the scalar
product of the variable at the corresponding point with the corresponding
unit vector.
The optional data \sphinxtitleref{dataname\_val} is the vector of values to be prescribed
at the different points.
This brick is specifically designed to kill rigid displacement
in a Neumann problem.
Returns the brick index in the model.

\end{fulllineitems}

\index{add\_projection\_transformation() (Model method)@\spxentry{add\_projection\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_projection_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_projection\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{release\_distance}}}{}
Add a projection interpolate transformation called \sphinxtitleref{transname} to a model
to be used by the generic assembly bricks.
CAUTION: For the moment, the derivative of the
transformation is not taken into account in the model solve.

\end{fulllineitems}

\index{add\_raytracing\_transformation() (Model method)@\spxentry{add\_raytracing\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_raytracing_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_raytracing\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{release\_distance}}}{}
Add a raytracing interpolate transformation called \sphinxtitleref{transname} to a model
to be used by the generic assembly bricks.
CAUTION: For the moment, the derivative of the
transformation is not taken into account in the model solve.

\end{fulllineitems}

\index{add\_rigid\_obstacle\_to\_Nitsche\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_rigid\_obstacle\_to\_Nitsche\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_rigid_obstacle_to_Nitsche_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_rigid\_obstacle\_to\_Nitsche\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{expr}}, \emph{\DUrole{n}{N}}}{}
Adds a rigid obstacle to an existing large sliding contact
with friction brick. \sphinxtitleref{expr} is an expression using the high\sphinxhyphen{}level
generic assembly language (where \sphinxtitleref{x} is the current point n the mesh)
which should be a signed distance to the obstacle.
\sphinxtitleref{N} is the mesh dimension.

\end{fulllineitems}

\index{add\_rigid\_obstacle\_to\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_rigid\_obstacle\_to\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_rigid_obstacle_to_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_rigid\_obstacle\_to\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{expr}}, \emph{\DUrole{n}{N}}}{}
Adds a rigid obstacle to an existing large sliding contact
with friction brick. \sphinxtitleref{expr} is an expression using the high\sphinxhyphen{}level
generic assembly language (where \sphinxtitleref{x} is the current point n the mesh)
which should be a signed distance to the obstacle.
\sphinxtitleref{N} is the mesh dimension.

\end{fulllineitems}

\index{add\_rigid\_obstacle\_to\_projection\_transformation() (Model method)@\spxentry{add\_rigid\_obstacle\_to\_projection\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_rigid_obstacle_to_projection_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_rigid\_obstacle\_to\_projection\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{expr}}, \emph{\DUrole{n}{N}}}{}
Add a rigid obstacle whose geometry corresponds to the zero level\sphinxhyphen{}set
of the high\sphinxhyphen{}level generic assembly expression \sphinxtitleref{expr}
to an existing projection interpolate transformation called \sphinxtitleref{transname}.

\end{fulllineitems}

\index{add\_rigid\_obstacle\_to\_raytracing\_transformation() (Model method)@\spxentry{add\_rigid\_obstacle\_to\_raytracing\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_rigid_obstacle_to_raytracing_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_rigid\_obstacle\_to\_raytracing\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{expr}}, \emph{\DUrole{n}{N}}}{}
Add a rigid obstacle whose geometry corresponds to the zero level\sphinxhyphen{}set
of the high\sphinxhyphen{}level generic assembly expression \sphinxtitleref{expr}
to an existing raytracing interpolate transformation called \sphinxtitleref{transname}.

\end{fulllineitems}

\index{add\_slave\_contact\_boundary\_to\_biased\_Nitsche\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_slave\_contact\_boundary\_to\_biased\_Nitsche\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_slave_contact_boundary_to_biased_Nitsche_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_slave\_contact\_boundary\_to\_biased\_Nitsche\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{lambdaname}}, \emph{\DUrole{n}{wname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a slave contact boundary to an existing biased Nitsche’s large sliding contact
with friction brick.

\end{fulllineitems}

\index{add\_slave\_contact\_boundary\_to\_large\_sliding\_contact\_brick() (Model method)@\spxentry{add\_slave\_contact\_boundary\_to\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_slave_contact_boundary_to_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_slave\_contact\_boundary\_to\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{lambdaname}}, \emph{\DUrole{n}{wname}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a slave contact boundary to an existing large sliding contact
with friction brick.

\end{fulllineitems}

\index{add\_slave\_contact\_boundary\_to\_projection\_transformation() (Model method)@\spxentry{add\_slave\_contact\_boundary\_to\_projection\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_slave_contact_boundary_to_projection_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_slave\_contact\_boundary\_to\_projection\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{m}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{region}}}{}
Add a slave contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing projection
interpolate transformation called \sphinxtitleref{transname}.

\end{fulllineitems}

\index{add\_slave\_contact\_boundary\_to\_raytracing\_transformation() (Model method)@\spxentry{add\_slave\_contact\_boundary\_to\_raytracing\_transformation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_slave_contact_boundary_to_raytracing_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_slave\_contact\_boundary\_to\_raytracing\_transformation}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{m}}, \emph{\DUrole{n}{dispname}}, \emph{\DUrole{n}{region}}}{}
Add a slave contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing raytracing
interpolate transformation called \sphinxtitleref{transname}.

\end{fulllineitems}

\index{add\_small\_strain\_elastoplasticity\_brick() (Model method)@\spxentry{add\_small\_strain\_elastoplasticity\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_small_strain_elastoplasticity_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_small\_strain\_elastoplasticity\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{unknowns\_type}}, \emph{\DUrole{n}{varnames}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_small\_strain\_elastoplasticity\_brick(self, MeshIm mim,  string lawname, string unknowns\_type {[}, string varnames, …{]} {[}, string params, …{]} {[}, string theta = ‘1’ {[}, string dt = ‘timestep’{]}{]} {[}, int region = \sphinxhyphen{}1{]})

Adds a small strain plasticity term to the model \sphinxtitleref{M}. This is the
main GetFEM brick for small strain plasticity. \sphinxtitleref{lawname} is the name
of an implemented plastic law, \sphinxtitleref{unknowns\_type} indicates the choice
between a discretization where the plastic multiplier is an unknown of
the problem or (return mapping approach) just a data of the model
stored for the next iteration. Remember that in both cases, a multiplier
is stored anyway. \sphinxtitleref{varnames} is a set of variable and data names with
length which may depend on the plastic law (at least the displacement,
the plastic multiplier and the plastic strain). \sphinxtitleref{params} is a list of
expressions for the parameters (at least elastic coefficients and the
yield stress). These expressions can be some data names (or even
variable names) of the model but can also be any scalar valid expression
of the high level assembly language (such as ‘1/2’, ‘2+sin(X{[}0{]})’,
‘1+Norm(v)’ …). The last two parameters optionally provided in
\sphinxtitleref{params} are the \sphinxtitleref{theta} parameter of the \sphinxtitleref{theta}\sphinxhyphen{}scheme (generalized
trapezoidal rule) used for the plastic strain integration and the
time\sphinxhyphen{}step\textasciigrave{}dt\textasciigrave{}. The default value for \sphinxtitleref{theta} if omitted is 1, which
corresponds to the classical Backward Euler scheme which is first order
consistent. \sphinxtitleref{theta=1/2} corresponds to the Crank\sphinxhyphen{}Nicolson scheme
(trapezoidal rule) which is second order consistent. Any value
between 1/2 and 1 should be a valid value. The default value of \sphinxtitleref{dt} is
‘timestep’ which simply indicates the time step defined in the model
(by md.set\_time\_step(dt)). Alternatively it can be any expression
(data name, constant value …). The time step can be altered from one
iteration to the next one. \sphinxtitleref{region} is a mesh region.

The available plasticity laws are:
\begin{itemize}
\item {} 
‘Prandtl Reuss’ (or ‘isotropic perfect plasticity’).
Isotropic elasto\sphinxhyphen{}plasticity with no hardening. The variables are the
displacement, the plastic multiplier and the plastic strain.
The displacement should be a variable and have a corresponding data
having the same name preceded by ‘Previous\_’ corresponding to the
displacement at the previous time step (typically ‘u’ and ‘Previous\_u’).
The plastic multiplier should also have two versions (typically ‘xi’
and ‘Previous\_xi’) the first one being defined as data if
\sphinxtitleref{unknowns\_type \textasciigrave{} is ‘DISPLACEMENT\_ONLY’ or the integer value 0, or as
a variable if \textasciigrave{}unknowns\_type} is DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER
or the integer value 1.
The plastic strain should represent a n x n data tensor field stored
on mesh\_fem or (preferably) on an im\_data (corresponding to \sphinxtitleref{mim}).
The data are the first Lame coefficient, the second one (shear modulus)
and the uniaxial yield stress. A typical call is
Model.add\_small\_strain\_elastoplasticity\_brick(mim, ‘Prandtl Reuss’, 0, ‘u’, ‘xi’, ‘Previous\_Ep’, ‘lambda’, ‘mu’, ‘sigma\_y’, ‘1’, ‘timestep’);
IMPORTANT: Note that this law implements
the 3D expressions. If it is used in 2D, the expressions are just
transposed to the 2D. For the plane strain approximation, see below.

\item {} 
“plane strain Prandtl Reuss”
(or “plane strain isotropic perfect plasticity”)
The same law as the previous one but adapted to the plane strain
approximation. Can only be used in 2D.

\item {} 
“Prandtl Reuss linear hardening”
(or “isotropic plasticity linear hardening”).
Isotropic elasto\sphinxhyphen{}plasticity with linear isotropic and kinematic
hardening. An additional variable compared to “Prandtl Reuss” law:
the accumulated plastic strain. Similarly to the plastic strain, it
is only stored at the end of the time step, so a simple data is
required (preferably on an im\_data).
Two additional parameters: the kinematic hardening modulus and the
isotropic one. 3D expressions only. A typical call is
Model.add\_small\_strain\_elastoplasticity\_brick(mim, ‘Prandtl Reuss linear hardening’, 0, ‘u’, ‘xi’, ‘Previous\_Ep’, ‘Previous\_alpha’, ‘lambda’, ‘mu’, ‘sigma\_y’, ‘H\_k’, H\_i’, ‘1’, ‘timestep’);

\item {} 
“plane strain Prandtl Reuss linear hardening”
(or “plane strain isotropic plasticity linear hardening”).
The same law as the previous one but adapted to the plane strain
approximation. Can only be used in 2D.

\end{itemize}

See GetFEM user documentation for further explanations on the
discretization of the plastic flow and on the implemented plastic laws.
See also GetFEM user documentation on time integration strategy
(integration of transient problems).

IMPORTANT : remember that \sphinxtitleref{small\_strain\_elastoplasticity\_next\_iter} has
to be called at the end of each time step, before the next one
(and before any post\sphinxhyphen{}treatment : this sets the value of the plastic
strain and plastic multiplier).

\end{fulllineitems}

\index{add\_source\_term() (Model method)@\spxentry{add\_source\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_source_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_source\_term}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Adds a source term given by the assembly string \sphinxtitleref{expr} which will
be assembled in region \sphinxtitleref{region} and with the integration method \sphinxtitleref{mim}.
Only the residual term will be taken into account.
Take care that if the expression contains some variables and if the
expression is a potential, the expression will be
derivated with respect to all variables.
\sphinxtitleref{brickname} is an optional name for the brick.

\end{fulllineitems}

\index{add\_source\_term\_brick() (Model method)@\spxentry{add\_source\_term\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_source_term_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_source\_term\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataexpr}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: ind = Model.add\_source\_term\_brick(self, MeshIm mim, string varname, string dataexpr{[}, int region{[}, string directdataname{]}{]})

Add a source term to the model relatively to the variable \sphinxtitleref{varname}.
The source term is
represented by \sphinxtitleref{dataexpr} which could be any regular expression of the
high\sphinxhyphen{}level generic assembly language (except for the complex version
where it has to be a declared data of the model).
\sphinxtitleref{region} is an optional mesh region
on which the term is added. An additional optional data \sphinxtitleref{directdataname}
can be provided. The corresponding data vector will be directly added
to the right hand side without assembly. Note that when region is a
boundary, this brick allows to prescribe a nonzero Neumann boundary
condition. Return the brick index in the model.

\end{fulllineitems}

\index{add\_source\_term\_generic\_assembly\_brick() (Model method)@\spxentry{add\_source\_term\_generic\_assembly\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_source_term_generic_assembly_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_source\_term\_generic\_assembly\_brick}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Deprecated. Use Model.add\_source\_term() instead.

\end{fulllineitems}

\index{add\_standard\_secondary\_domain() (Model method)@\spxentry{add\_standard\_secondary\_domain()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_standard_secondary_domain}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_standard\_secondary\_domain}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{} 1}}}{}
Add a secondary domain to the model which can be used in a weak\sphinxhyphen{}form language expression for integration on the product of two domains. \sphinxtitleref{name} is the name
of the secondary domain, \sphinxtitleref{mim} is an integration method on this domain
and \sphinxtitleref{region} the region on which the integration is to be performed.

\end{fulllineitems}

\index{add\_theta\_method\_for\_first\_order() (Model method)@\spxentry{add\_theta\_method\_for\_first\_order()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_theta_method_for_first_order}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_theta\_method\_for\_first\_order}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{theta}}}{}
Attach a theta method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most first order time derivative
of the variable.

\end{fulllineitems}

\index{add\_theta\_method\_for\_second\_order() (Model method)@\spxentry{add\_theta\_method\_for\_second\_order()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_theta_method_for_second_order}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_theta\_method\_for\_second\_order}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{theta}}}{}
Attach a theta method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most second order time derivative
of the variable.

\end{fulllineitems}

\index{add\_twodomain\_source\_term() (Model method)@\spxentry{add\_twodomain\_source\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_twodomain_source_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_twodomain\_source\_term}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{secondary\_domain}}}{}
Adds a source term given by a weak form language expression like
Model.add\_source\_term() but for an integration on a direct
product of two domains, a first specfied by \sphinxcode{\sphinxupquote{mim}} and \sphinxcode{\sphinxupquote{region}}
and a second one by \sphinxcode{\sphinxupquote{secondary\_domain}} which has to be declared
first into the model.

\end{fulllineitems}

\index{add\_variable() (Model method)@\spxentry{add\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.add_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_variable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{sizes}}}{}
Add a variable to the model of constant sizes. \sphinxtitleref{sizes} is either a
integer (for a scalar or vector variable) or a vector of dimensions
for a tensor variable. \sphinxtitleref{name} is the variable name.

\end{fulllineitems}

\index{assembly() (Model method)@\spxentry{assembly()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.assembly}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{assembly}}}{\emph{\DUrole{n}{option}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of the tangent system taking into account the terms
from all bricks. \sphinxtitleref{option}, if specified, should be ‘build\_all’,
‘build\_rhs’, ‘build\_matrix’.
The default is to build the whole
tangent linear system (matrix and rhs). This function is useful
to solve your problem with you own solver.

\end{fulllineitems}

\index{brick\_list() (Model method)@\spxentry{brick\_list()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.brick_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brick\_list}}}{}{}
print to the output the list of bricks of the model.

\end{fulllineitems}

\index{brick\_term\_rhs() (Model method)@\spxentry{brick\_term\_rhs()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.brick_term_rhs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{brick\_term\_rhs}}}{\emph{\DUrole{n}{ind\_brick}}, \emph{\DUrole{n}{ind\_term}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{sym}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{ind\_iter}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Gives the access to the part of the right hand side of a term
of a particular nonlinear brick. Does not account of the eventual
time dispatcher. An assembly of the rhs has to be done first.
\sphinxtitleref{ind\_brick} is the brick index. \sphinxtitleref{ind\_term} is the index of the
term inside the brick (default value : 0).
\sphinxtitleref{sym} is to access to the second right hand side of for symmetric
terms acting on two different variables (default is 0).
\sphinxtitleref{ind\_iter} is the iteration number when time dispatchers are
used (default is 0).

\end{fulllineitems}

\index{change\_penalization\_coeff() (Model method)@\spxentry{change\_penalization\_coeff()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.change_penalization_coeff}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{change\_penalization\_coeff}}}{\emph{\DUrole{n}{ind\_brick}}, \emph{\DUrole{n}{coeff}}}{}
Change the penalization coefficient of a Dirichlet condition with
penalization brick. If the brick is not of this kind, this
function has an undefined behavior.

\end{fulllineitems}

\index{char() (Model method)@\spxentry{char()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the Model.

This can be used to perform comparisons between two
different Model objects.
This function is to be completed.

\end{fulllineitems}

\index{clear() (Model method)@\spxentry{clear()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{}{}
Clear the model.

\end{fulllineitems}

\index{clear\_assembly\_assignment() (Model method)@\spxentry{clear\_assembly\_assignment()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.clear_assembly_assignment}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear\_assembly\_assignment}}}{}{}
Delete all added assembly assignments

\end{fulllineitems}

\index{compute\_Von\_Mises\_or\_Tresca() (Model method)@\spxentry{compute\_Von\_Mises\_or\_Tresca()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_Von_Mises_or_Tresca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_Von\_Mises\_or\_Tresca}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{mf\_vm}}, \emph{\DUrole{n}{version}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises stress or the Tresca stress of a field
for nonlinear elasticity in 3D. \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘neo Hookean’ or
‘Ciarlet Geymonat’.
\sphinxtitleref{dataname} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable coefficients.
\sphinxtitleref{version} should be  ‘Von\_Mises’ or ‘Tresca’ (‘Von\_Mises’ is the default).

\end{fulllineitems}

\index{compute\_elastoplasticity\_Von\_Mises\_or\_Tresca() (Model method)@\spxentry{compute\_elastoplasticity\_Von\_Mises\_or\_Tresca()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_elastoplasticity_Von_Mises_or_Tresca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_elastoplasticity\_Von\_Mises\_or\_Tresca}}}{\emph{\DUrole{n}{datasigma}}, \emph{\DUrole{n}{mf\_vm}}, \emph{\DUrole{n}{version}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises or the Tresca stress of a field for plasticity and return it into the vector V.
\sphinxtitleref{datasigma} is a vector which contains the stress constraints values supported by the mesh.
\sphinxtitleref{version} should be  ‘Von\_Mises’ or ‘Tresca’ (‘Von\_Mises’ is the default).

\end{fulllineitems}

\index{compute\_finite\_strain\_elasticity\_Von\_Mises() (Model method)@\spxentry{compute\_finite\_strain\_elasticity\_Von\_Mises()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_finite_strain_elasticity_Von_Mises}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_finite\_strain\_elasticity\_Von\_Mises}}}{\emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{params}}, \emph{\DUrole{n}{mf\_vm}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises stress of a field \sphinxtitleref{varname}
for nonlinear elasticity in 3D. \sphinxtitleref{lawname} is the constitutive law which
should be a valid name. \sphinxtitleref{params} are the parameters law. It could be
a short vector of constant values or may depend on data or variables
of the model.
Uses the high\sphinxhyphen{}level generic assembly.

\end{fulllineitems}

\index{compute\_finite\_strain\_elastoplasticity\_Von\_Mises() (Model method)@\spxentry{compute\_finite\_strain\_elastoplasticity\_Von\_Mises()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_finite_strain_elastoplasticity_Von_Mises}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_finite\_strain\_elastoplasticity\_Von\_Mises}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_vm}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{unknowns\_type}}, \emph{\DUrole{n}{varnames}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: V = Model.compute\_finite\_strain\_elastoplasticity\_Von\_Mises(self, MeshIm mim, MeshFem mf\_vm, string lawname, string unknowns\_type, {[}, string varnames, …{]} {[}, string params, …{]} {[}, int region = \sphinxhyphen{}1{]})

Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises or the Tresca stress of a field for plasticity and return it into the vector V.
The first input parameters ar as in the function ‘finite strain elastoplasticity next iter’.

\end{fulllineitems}

\index{compute\_isotropic\_linearized\_Von\_Mises\_or\_Tresca() (Model method)@\spxentry{compute\_isotropic\_linearized\_Von\_Mises\_or\_Tresca()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_isotropic_linearized_Von_Mises_or_Tresca}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_isotropic\_linearized\_Von\_Mises\_or\_Tresca}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{dataname\_lambda}}, \emph{\DUrole{n}{dataname\_mu}}, \emph{\DUrole{n}{mf\_vm}}, \emph{\DUrole{n}{version}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the Von\sphinxhyphen{}Mises stress or the Tresca stress of a field (only
valid for isotropic linearized elasticity in 3D). \sphinxtitleref{version} should
be  ‘Von\_Mises’ or ‘Tresca’ (‘Von\_Mises’ is the default).
Parametrized by Lame coefficients.

\end{fulllineitems}

\index{compute\_isotropic\_linearized\_Von\_Mises\_pstrain() (Model method)@\spxentry{compute\_isotropic\_linearized\_Von\_Mises\_pstrain()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_isotropic_linearized_Von_Mises_pstrain}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_isotropic\_linearized\_Von\_Mises\_pstrain}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{data\_E}}, \emph{\DUrole{n}{data\_nu}}, \emph{\DUrole{n}{mf\_vm}}}{}
Compute the Von\sphinxhyphen{}Mises stress  of a displacement field for isotropic
linearized elasticity in 3D or in 2D with plane strain assumption.
Parametrized by Young modulus and Poisson ratio.

\end{fulllineitems}

\index{compute\_isotropic\_linearized\_Von\_Mises\_pstress() (Model method)@\spxentry{compute\_isotropic\_linearized\_Von\_Mises\_pstress()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_isotropic_linearized_Von_Mises_pstress}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_isotropic\_linearized\_Von\_Mises\_pstress}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{data\_E}}, \emph{\DUrole{n}{data\_nu}}, \emph{\DUrole{n}{mf\_vm}}}{}
Compute the Von\sphinxhyphen{}Mises stress  of a displacement field for isotropic
linearized elasticity in 3D or in 2D with plane stress assumption.
Parametrized by Young modulus and Poisson ratio.

\end{fulllineitems}

\index{compute\_plastic\_part() (Model method)@\spxentry{compute\_plastic\_part()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_plastic_part}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_plastic\_part}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_pl}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{previous\_dep\_name}}, \emph{\DUrole{n}{projname}}, \emph{\DUrole{n}{datalambda}}, \emph{\DUrole{n}{datamu}}, \emph{\DUrole{n}{datathreshold}}, \emph{\DUrole{n}{datasigma}}}{}
Compute on \sphinxtitleref{mf\_pl} the plastic part and return it into the vector V.
\sphinxtitleref{datasigma} is a vector which contains the stress constraints values supported by the mesh.

\end{fulllineitems}

\index{compute\_second\_Piola\_Kirchhoff\_tensor() (Model method)@\spxentry{compute\_second\_Piola\_Kirchhoff\_tensor()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.compute_second_Piola_Kirchhoff_tensor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_second\_Piola\_Kirchhoff\_tensor}}}{\emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{dataname}}, \emph{\DUrole{n}{mf\_sigma}}}{}
Compute on \sphinxtitleref{mf\_sigma} the second Piola Kirchhoff stress tensor of a field
for nonlinear elasticity in 3D. \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘neo Hookean’ or
‘Ciarlet Geymonat’.
\sphinxtitleref{dataname} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable
coefficients.

\end{fulllineitems}

\index{contact\_brick\_set\_BN() (Model method)@\spxentry{contact\_brick\_set\_BN()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.contact_brick_set_BN}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{contact\_brick\_set\_BN}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{BN}}}{}
Can be used to set the BN matrix of a basic contact/friction brick.

\end{fulllineitems}

\index{contact\_brick\_set\_BT() (Model method)@\spxentry{contact\_brick\_set\_BT()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.contact_brick_set_BT}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{contact\_brick\_set\_BT}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{BT}}}{}
Can be used to set the BT matrix of a basic contact with
friction brick.

\end{fulllineitems}

\index{define\_variable\_group() (Model method)@\spxentry{define\_variable\_group()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.define_variable_group}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{define\_variable\_group}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{varname}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Model.define\_variable\_group(self, string name{[}, string varname, …{]})

Defines a group of variables for the interpolation (mainly for the
raytracing interpolation transformation.

\end{fulllineitems}

\index{del\_macro() (Model method)@\spxentry{del\_macro()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.del_macro}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{del\_macro}}}{\emph{\DUrole{n}{name}}}{}
Delete a previously defined macro for the high generic assembly language.

\end{fulllineitems}

\index{delete\_brick() (Model method)@\spxentry{delete\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.delete_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete\_brick}}}{\emph{\DUrole{n}{ind\_brick}}}{}
Delete a variable or a data from the model.

\end{fulllineitems}

\index{delete\_variable() (Model method)@\spxentry{delete\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.delete_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete\_variable}}}{\emph{\DUrole{n}{name}}}{}
Delete a variable or a data from the model.

\end{fulllineitems}

\index{disable\_bricks() (Model method)@\spxentry{disable\_bricks()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.disable_bricks}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{disable\_bricks}}}{\emph{\DUrole{n}{bricks\_indices}}}{}
Disable a brick (the brick will no longer participate to the
building of the tangent linear system).

\end{fulllineitems}

\index{disable\_variable() (Model method)@\spxentry{disable\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.disable_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{disable\_variable}}}{\emph{\DUrole{n}{varname}}}{}
Disable a variable for a solve (and its attached multipliers).
The next solve will operate only on
the remaining variables. This allows to solve separately different
parts of a model. If there is a strong coupling of the variables,
a fixed point strategy can the be used.

\end{fulllineitems}

\index{displacement\_group\_name\_of\_Nitsche\_large\_sliding\_contact\_brick() (Model method)@\spxentry{displacement\_group\_name\_of\_Nitsche\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.displacement_group_name_of_Nitsche_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{displacement\_group\_name\_of\_Nitsche\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}}{}
Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.

\end{fulllineitems}

\index{displacement\_group\_name\_of\_large\_sliding\_contact\_brick() (Model method)@\spxentry{displacement\_group\_name\_of\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.displacement_group_name_of_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{displacement\_group\_name\_of\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}}{}
Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.

\end{fulllineitems}

\index{display() (Model method)@\spxentry{display()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a Model object.

\end{fulllineitems}

\index{elastoplasticity\_next\_iter() (Model method)@\spxentry{elastoplasticity\_next\_iter()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.elastoplasticity_next_iter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{elastoplasticity\_next\_iter}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{varname}}, \emph{\DUrole{n}{previous\_dep\_name}}, \emph{\DUrole{n}{projname}}, \emph{\DUrole{n}{datalambda}}, \emph{\DUrole{n}{datamu}}, \emph{\DUrole{n}{datathreshold}}, \emph{\DUrole{n}{datasigma}}}{}
Used with the old (obsolete) elastoplasticity brick to pass from an
iteration to the next one.
Compute and save the stress constraints sigma for the next iterations.
‘mim’ is the integration method to use for the computation.
‘varname’ is the main variable of the problem.
‘previous\_dep\_name’ represents the displacement at the previous time step.
‘projname’ is the type of projection to use. For the moment it could only be ‘Von Mises’ or ‘VM’.
‘datalambda’ and ‘datamu’ are the Lame coefficients of the material.
‘datasigma’ is a vector which will contain the new stress constraints values.

\end{fulllineitems}

\index{enable\_bricks() (Model method)@\spxentry{enable\_bricks()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.enable_bricks}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{enable\_bricks}}}{\emph{\DUrole{n}{bricks\_indices}}}{}
Enable a disabled brick.

\end{fulllineitems}

\index{enable\_variable() (Model method)@\spxentry{enable\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.enable_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{enable\_variable}}}{\emph{\DUrole{n}{varname}}}{}
Enable a disabled variable (and its attached multipliers).

\end{fulllineitems}

\index{finite\_strain\_elastoplasticity\_next\_iter() (Model method)@\spxentry{finite\_strain\_elastoplasticity\_next\_iter()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.finite_strain_elastoplasticity_next_iter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{finite\_strain\_elastoplasticity\_next\_iter}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{unknowns\_type}}, \emph{\DUrole{n}{varnames}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Model.finite\_strain\_elastoplasticity\_next\_iter(self, MeshIm mim, string lawname, string unknowns\_type, {[}, string varnames, …{]} {[}, string params, …{]} {[}, int region = \sphinxhyphen{}1{]})

Function that allows to pass from a time step to another for the
finite strain plastic brick. The parameters have to be exactly the
same than the one of \sphinxtitleref{add\_finite\_strain\_elastoplasticity\_brick},
so see the documentation of this function for the explanations.
Basically, this brick computes the plastic strain
and the plastic multiplier and stores them for the next step.
For the Simo\sphinxhyphen{}Miehe law which is currently the only one implemented,
this function updates the state variables defined in the last two
entries of \sphinxtitleref{varnames}, and resets the plastic multiplier field given
as the second entry of \sphinxtitleref{varnames}.

\end{fulllineitems}

\index{first\_iter() (Model method)@\spxentry{first\_iter()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.first_iter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{first\_iter}}}{}{}
To be executed before the first iteration of a time integration
scheme.

\end{fulllineitems}

\index{from\_variables() (Model method)@\spxentry{from\_variables()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.from_variables}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_variables}}}{}{}
Return the vector of all the degrees of freedom of the model consisting
of the concatenation of the variables of the model (useful
to solve your problem with you own solver).

\end{fulllineitems}

\index{get\_time() (Model method)@\spxentry{get\_time()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.get_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_time}}}{}{}
Give the value of the data \sphinxtitleref{t} corresponding to the current time.

\end{fulllineitems}

\index{get\_time\_step() (Model method)@\spxentry{get\_time\_step()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.get_time_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_time\_step}}}{}{}
Gives the value of the time step.

\end{fulllineitems}

\index{interpolation() (Model method)@\spxentry{interpolation()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.interpolation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpolation}}}{\emph{\DUrole{n}{expr}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: V = Model.interpolation(self, string expr, \{MeshFem mf | MeshImd mimd | vec pts,  Mesh m\}{[}, int region{[}, int extrapolation{[}, int rg\_source{]}{]}{]})

Interpolate a certain expression with respect to the mesh\_fem \sphinxtitleref{mf}
or the mesh\_im\_data \sphinxtitleref{mimd} or the set of points \sphinxtitleref{pts} on mesh \sphinxtitleref{m}.
The expression has to be valid according to the high\sphinxhyphen{}level generic
assembly language possibly including references to the variables
and data of the model.

The options \sphinxtitleref{extrapolation} and \sphinxtitleref{rg\_source} are specific to
interpolations with respect to a set of points \sphinxtitleref{pts}.

\end{fulllineitems}

\index{interval\_of\_variable() (Model method)@\spxentry{interval\_of\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.interval_of_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interval\_of\_variable}}}{\emph{\DUrole{n}{varname}}}{}
Gives the interval of the variable \sphinxtitleref{varname} in the linear system of
the model.

\end{fulllineitems}

\index{is\_complex() (Model method)@\spxentry{is\_complex()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.is_complex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_complex}}}{}{}
Return 0 is the model is real, 1 if it is complex.

\end{fulllineitems}

\index{list\_residuals() (Model method)@\spxentry{list\_residuals()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.list_residuals}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{list\_residuals}}}{}{}
print to the output the residuals corresponding to all terms
included in the model.

\end{fulllineitems}

\index{local\_projection() (Model method)@\spxentry{local\_projection()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.local_projection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{local\_projection}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{expr}}, \emph{\DUrole{n}{mf}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Make an elementwise L2 projection of an expression with respect
to the mesh\_fem \sphinxtitleref{mf}. This mesh\_fem has to be
a discontinuous one.
The expression has to be valid according to the high\sphinxhyphen{}level generic
assembly language possibly including references to the variables
and data of the model.

\end{fulllineitems}

\index{matrix\_term() (Model method)@\spxentry{matrix\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.matrix_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{matrix\_term}}}{\emph{\DUrole{n}{ind\_brick}}, \emph{\DUrole{n}{ind\_term}}}{}
Gives the matrix term ind\_term of the brick ind\_brick if it exists

\end{fulllineitems}

\index{memsize() (Model method)@\spxentry{memsize()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.memsize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{memsize}}}{}{}
Return a rough approximation of the amount of memory (in bytes) used by
the model.

\end{fulllineitems}

\index{mesh\_fem\_of\_variable() (Model method)@\spxentry{mesh\_fem\_of\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.mesh_fem_of_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh\_fem\_of\_variable}}}{\emph{\DUrole{n}{name}}}{}
Gives access to the \sphinxtitleref{mesh\_fem} of a variable or data.

\end{fulllineitems}

\index{mult\_varname\_Dirichlet() (Model method)@\spxentry{mult\_varname\_Dirichlet()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.mult_varname_Dirichlet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mult\_varname\_Dirichlet}}}{\emph{\DUrole{n}{ind\_brick}}}{}
Gives the name of the multiplier variable for a Dirichlet brick.
If the brick is not a Dirichlet condition with multiplier brick,
this function has an undefined behavior

\end{fulllineitems}

\index{nbdof() (Model method)@\spxentry{nbdof()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.nbdof}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbdof}}}{}{}
Return the total number of degrees of freedom of the model.

\end{fulllineitems}

\index{next\_iter() (Model method)@\spxentry{next\_iter()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.next_iter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{next\_iter}}}{}{}
To be executed at the end of each iteration of a time
integration scheme.

\end{fulllineitems}

\index{perform\_init\_time\_derivative() (Model method)@\spxentry{perform\_init\_time\_derivative()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.perform_init_time_derivative}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{perform\_init\_time\_derivative}}}{\emph{\DUrole{n}{ddt}}}{}
By calling this function, indicates that the next solve will compute
the solution for a (very) small time step \sphinxtitleref{ddt} in order to initalize
the data corresponding to the derivatives needed by time integration
schemes (mainly the initial time derivative for order one in time
problems  and the second order time derivative for second order in time
problems). The next solve will not change the value of the variables.

\end{fulllineitems}

\index{resize\_variable() (Model method)@\spxentry{resize\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.resize_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{resize\_variable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{sizes}}}{}
Resize a  constant size variable of the model.  \sphinxtitleref{sizes} is either a
integer (for a scalar or vector variable) or a vector of dimensions
for a tensor variable. \sphinxtitleref{name} is the variable name.

\end{fulllineitems}

\index{rhs() (Model method)@\spxentry{rhs()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.rhs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rhs}}}{}{}
Return the right hand side of the tangent problem.

\end{fulllineitems}

\index{set\_element\_extrapolation\_correspondence() (Model method)@\spxentry{set\_element\_extrapolation\_correspondence()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.set_element_extrapolation_correspondence}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_element\_extrapolation\_correspondence}}}{\emph{\DUrole{n}{transname}}, \emph{\DUrole{n}{elt\_corr}}}{}
Change the correspondence map of an element extrapolation interpolate
transformation.

\end{fulllineitems}

\index{set\_private\_matrix() (Model method)@\spxentry{set\_private\_matrix()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.set_private_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_private\_matrix}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{B}}}{}
For some specific bricks having an internal sparse matrix
(explicit bricks: ‘constraint brick’ and ‘explicit matrix brick’),
set this matrix.

\end{fulllineitems}

\index{set\_private\_rhs() (Model method)@\spxentry{set\_private\_rhs()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.set_private_rhs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_private\_rhs}}}{\emph{\DUrole{n}{indbrick}}, \emph{\DUrole{n}{B}}}{}
For some specific bricks having an internal right hand side vector
(explicit bricks: ‘constraint brick’ and ‘explicit rhs brick’),
set this rhs.

\end{fulllineitems}

\index{set\_time() (Model method)@\spxentry{set\_time()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.set_time}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_time}}}{\emph{\DUrole{n}{t}}}{}
Set the value of the data \sphinxtitleref{t} corresponding to the current time to \sphinxtitleref{t}.

\end{fulllineitems}

\index{set\_time\_step() (Model method)@\spxentry{set\_time\_step()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.set_time_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_time\_step}}}{\emph{\DUrole{n}{dt}}}{}
Set the value of the time step to \sphinxtitleref{dt}. This value can be change
from a step to another for all one\sphinxhyphen{}step schemes (i.e. for the moment
to all proposed time integration schemes).

\end{fulllineitems}

\index{set\_variable() (Model method)@\spxentry{set\_variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.set_variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_variable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{V}}}{}
Set the value of a variable or data. \sphinxtitleref{name} is the data name.

\end{fulllineitems}

\index{shift\_variables\_for\_time\_integration() (Model method)@\spxentry{shift\_variables\_for\_time\_integration()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.shift_variables_for_time_integration}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{shift\_variables\_for\_time\_integration}}}{}{}
Function used to shift the variables of a model to the data
corresponding of ther value on the previous time step for time
integration schemes. For each variable for which a time integration
scheme has been declared, the scheme is called to perform the shift.
This function has to be called between two time steps.

\end{fulllineitems}

\index{sliding\_data\_group\_name\_of\_Nitsche\_large\_sliding\_contact\_brick() (Model method)@\spxentry{sliding\_data\_group\_name\_of\_Nitsche\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.sliding_data_group_name_of_Nitsche_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sliding\_data\_group\_name\_of\_Nitsche\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}}{}
Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.

\end{fulllineitems}

\index{sliding\_data\_group\_name\_of\_large\_sliding\_contact\_brick() (Model method)@\spxentry{sliding\_data\_group\_name\_of\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.sliding_data_group_name_of_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sliding\_data\_group\_name\_of\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}}{}
Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.

\end{fulllineitems}

\index{small\_strain\_elastoplasticity\_Von\_Mises() (Model method)@\spxentry{small\_strain\_elastoplasticity\_Von\_Mises()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.small_strain_elastoplasticity_Von_Mises}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{small\_strain\_elastoplasticity\_Von\_Mises}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_vm}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{unknowns\_type}}, \emph{\DUrole{n}{varnames}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: V = Model.small\_strain\_elastoplasticity\_Von\_Mises(self, MeshIm mim, MeshFem mf\_vm, string lawname, string unknowns\_type {[}, string varnames, …{]} {[}, string params, …{]} {[}, string theta = ‘1’ {[}, string dt = ‘timestep’{]}{]} {[}, int region{]})

This function computes the Von Mises stress field with respect to
a small strain elastoplasticity term, approximated on \sphinxtitleref{mf\_vm},
and stores the result into \sphinxtitleref{VM}.  All other parameters have to be
exactly the same as for \sphinxtitleref{add\_small\_strain\_elastoplasticity\_brick}.
Remember that \sphinxtitleref{small\_strain\_elastoplasticity\_next\_iter} has to be called
before any call of this function.

\end{fulllineitems}

\index{small\_strain\_elastoplasticity\_next\_iter() (Model method)@\spxentry{small\_strain\_elastoplasticity\_next\_iter()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.small_strain_elastoplasticity_next_iter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{small\_strain\_elastoplasticity\_next\_iter}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{lawname}}, \emph{\DUrole{n}{unknowns\_type}}, \emph{\DUrole{n}{varnames}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Model.small\_strain\_elastoplasticity\_next\_iter(self, MeshIm mim,  string lawname, string unknowns\_type {[}, string varnames, …{]} {[}, string params, …{]} {[}, string theta = ‘1’ {[}, string dt = ‘timestep’{]}{]} {[}, int region = \sphinxhyphen{}1{]})

Function that allows to pass from a time step to another for the
small strain plastic brick. The parameters have to be exactly the
same than the one of \sphinxtitleref{add\_small\_strain\_elastoplasticity\_brick},
so see the documentation of this function for the explanations.
Basically, this brick computes the plastic strain
and the plastic multiplier and stores them for the next step.
Additionaly, it copies the computed displacement to the data
that stores the displacement of the previous time step (typically
‘u’ to ‘Previous\_u’). It has to be called before any use of
\sphinxtitleref{compute\_small\_strain\_elastoplasticity\_Von\_Mises}.

\end{fulllineitems}

\index{solve() (Model method)@\spxentry{solve()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.solve}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{solve}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: (nbit, converged) = Model.solve(self{[}, …{]})

Run the standard getfem solver.

Note that you should be able to use your own solver if you want
(it is possible to obtain the tangent matrix and its right hand
side with the Model.tangent\_matrix() etc.).

Various options can be specified:
\begin{itemize}
\item {} \begin{description}
\item[{‘noisy’ or ‘very\_noisy’}] \leavevmode
the solver will display some information showing the progress
(residual values etc.).

\end{description}

\item {} \begin{description}
\item[{‘max\_iter’, int NIT}] \leavevmode
set the maximum iterations numbers.

\end{description}

\item {} \begin{description}
\item[{‘max\_res’, @float RES}] \leavevmode
set the target residual value.

\end{description}

\item {} \begin{description}
\item[{‘diverged\_res’, @float RES}] \leavevmode
set the threshold value of the residual beyond which the iterative
method is considered to diverge (default is 1e200).

\end{description}

\item {} \begin{description}
\item[{‘lsolver’, string SOLVER\_NAME}] \leavevmode
select explicitely the solver used for the linear systems (the
default value is ‘auto’, which lets getfem choose itself).
Possible values are ‘superlu’, ‘mumps’ (if supported),
‘cg/ildlt’, ‘gmres/ilu’ and ‘gmres/ilut’.

\end{description}

\item {} \begin{description}
\item[{‘lsearch’, string LINE\_SEARCH\_NAME}] \leavevmode
select explicitely the line search method used for the linear systems (the
default value is ‘default’).
Possible values are ‘simplest’, ‘systematic’, ‘quadratic’ or ‘basic’.

\end{description}

Return the number of iterations, if an iterative method is used.

Note that it is possible to disable some variables
(see Model.disable\_variable() ) in order to
solve the problem only with respect to a subset of variables (the
disabled variables are then considered as data) for instance to
replace the global Newton strategy with a fixed point one.

\end{itemize}

\end{fulllineitems}

\index{tangent\_matrix() (Model method)@\spxentry{tangent\_matrix()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.tangent_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tangent\_matrix}}}{}{}
Return the tangent matrix stored in the model .

\end{fulllineitems}

\index{test\_tangent\_matrix() (Model method)@\spxentry{test\_tangent\_matrix()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.test_tangent_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{test\_tangent\_matrix}}}{\emph{\DUrole{n}{EPS}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Model.test\_tangent\_matrix(self{[}, scalar EPS{[}, int NB{[}, scalar scale{]}{]}{]})

Test the consistency of the tangent matrix in some random positions
and random directions (useful to test newly created bricks).
\sphinxtitleref{EPS} is the value of the small parameter for the finite difference
computation of the derivative is the random direction (default is 1E\sphinxhyphen{}6).
\sphinxtitleref{NN} is the number of tests (default is 100). \sphinxtitleref{scale} is a parameter
for the random position (default is 1, 0 is an acceptable value) around
the current position.
Each dof of the random position is chosen in the range
{[}current\sphinxhyphen{}scale, current+scale{]}.

\end{fulllineitems}

\index{test\_tangent\_matrix\_term() (Model method)@\spxentry{test\_tangent\_matrix\_term()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.test_tangent_matrix_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{test\_tangent\_matrix\_term}}}{\emph{\DUrole{n}{varname1}}, \emph{\DUrole{n}{varname2}}, \emph{\DUrole{n}{EPS}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Model.test\_tangent\_matrix\_term(self, string varname1, string varname2{[}, scalar EPS{[}, int NB{[}, scalar scale{]}{]}{]})

Test the consistency of a part of the tangent matrix in some
random positions and random directions
(useful to test newly created bricks).
The increment is only made on variable \sphinxtitleref{varname2} and tested on the
part of the residual corresponding to \sphinxtitleref{varname1}. This means that
only the term (\sphinxtitleref{varname1}, \sphinxtitleref{varname2}) of the tangent matrix is tested.
\sphinxtitleref{EPS} is the value of the small parameter for the finite difference
computation of the derivative is the random direction (default is 1E\sphinxhyphen{}6).
\sphinxtitleref{NN} is the number of tests (default is 100). \sphinxtitleref{scale} is a parameter
for the random position (default is 1, 0 is an acceptable value)
around the current position.
Each dof of the random position is chosen in the range
{[}current\sphinxhyphen{}scale, current+scale{]}.

\end{fulllineitems}

\index{to\_variables() (Model method)@\spxentry{to\_variables()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.to_variables}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_variables}}}{\emph{\DUrole{n}{V}}}{}
Set the value of the variables of the model with the vector \sphinxtitleref{V}.
Typically, the vector \sphinxtitleref{V} results of the solve of the tangent
linear system (useful to solve your problem with you own solver).

\end{fulllineitems}

\index{transformation\_name\_of\_Nitsche\_large\_sliding\_contact\_brick() (Model method)@\spxentry{transformation\_name\_of\_Nitsche\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.transformation_name_of_Nitsche_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transformation\_name\_of\_Nitsche\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}}{}
Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.

\end{fulllineitems}

\index{transformation\_name\_of\_large\_sliding\_contact\_brick() (Model method)@\spxentry{transformation\_name\_of\_large\_sliding\_contact\_brick()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.transformation_name_of_large_sliding_contact_brick}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transformation\_name\_of\_large\_sliding\_contact\_brick}}}{\emph{\DUrole{n}{indbrick}}}{}
Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.

\end{fulllineitems}

\index{variable() (Model method)@\spxentry{variable()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.variable}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{variable}}}{\emph{\DUrole{n}{name}}}{}
Gives the value of a variable or data.

\end{fulllineitems}

\index{variable\_list() (Model method)@\spxentry{variable\_list()}\spxextra{Model method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Model:getfem.Model.variable_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{variable\_list}}}{}{}
print to the output the list of variables and constants of the model.

\end{fulllineitems}


\end{fulllineitems}



\section{Precond}
\label{\detokenize{python/cmdref_Precond:precond}}\label{\detokenize{python/cmdref_Precond::doc}}\index{Precond (class in getfem)@\spxentry{Precond}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Precond}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Precond object

The preconditioners may store REAL or COMPLEX values. They accept getfem
sparse matrices and Matlab sparse matrices.

General constructor for Precond objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}identity\textquotesingle{})}}
Create a REAL identity precondioner.

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}cidentity\textquotesingle{})}}
Create a COMPLEX identity precondioner.

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}diagonal\textquotesingle{}, vec D)}}
Create a diagonal precondioner.

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}ildlt\textquotesingle{}, SpMat m)}}
Create an ILDLT (Cholesky) preconditioner for the (symmetric) sparse
matrix \sphinxtitleref{m}. This preconditioner has the same sparsity pattern than \sphinxtitleref{m}
(no fill\sphinxhyphen{}in).

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}ilu\textquotesingle{}, SpMat m)}}
Create an ILU (Incomplete LU) preconditioner for the sparse
matrix \sphinxtitleref{m}. This preconditioner has the same sparsity pattern
than \sphinxtitleref{m} (no fill\sphinxhyphen{}in).

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}ildltt\textquotesingle{}, SpMat m{[}, int fillin{[}, scalar threshold{]}{]})}}
Create an ILDLTT (Cholesky with filling) preconditioner for the
(symmetric) sparse matrix \sphinxtitleref{m}. The preconditioner may add at most
\sphinxtitleref{fillin} additional non\sphinxhyphen{}zero entries on each line. The default value
for \sphinxtitleref{fillin} is 10, and the default threshold is1e\sphinxhyphen{}7.

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}ilut\textquotesingle{}, SpMat m{[}, int fillin{[}, scalar threshold{]}{]})}}
Create an ILUT (Incomplete LU with filling) preconditioner for the
sparse matrix \sphinxtitleref{m}. The preconditioner may add at most \sphinxtitleref{fillin}
additional non\sphinxhyphen{}zero entries on each line. The default value for
\sphinxtitleref{fillin} is 10, and the default threshold is 1e\sphinxhyphen{}7.

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}superlu\textquotesingle{}, SpMat m)}}
Uses SuperLU to build an exact factorization of the sparse matrix \sphinxtitleref{m}.
This preconditioner is only available if the getfem\sphinxhyphen{}interface was
built with SuperLU support. Note that LU factorization is likely to
eat all your memory for 3D problems.

\item {} 
\sphinxcode{\sphinxupquote{PC = Precond(\textquotesingle{}spmat\textquotesingle{}, SpMat m)}}
Preconditioner given explicitely by a sparse matrix.

\end{itemize}
\index{char() (Precond method)@\spxentry{char()}\spxextra{Precond method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the Precond.

This can be used to perform comparisons between two
different Precond objects.
This function is to be completed.

\end{fulllineitems}

\index{display() (Precond method)@\spxentry{display()}\spxextra{Precond method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a Precond object.

\end{fulllineitems}

\index{is\_complex() (Precond method)@\spxentry{is\_complex()}\spxextra{Precond method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond.is_complex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_complex}}}{}{}
Return 1 if the preconditioner stores complex values.

\end{fulllineitems}

\index{mult() (Precond method)@\spxentry{mult()}\spxextra{Precond method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond.mult}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mult}}}{\emph{\DUrole{n}{V}}}{}
Apply the preconditioner to the supplied vector.

\end{fulllineitems}

\index{size() (Precond method)@\spxentry{size()}\spxextra{Precond method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond.size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{size}}}{}{}
Return the dimensions of the preconditioner.

\end{fulllineitems}

\index{tmult() (Precond method)@\spxentry{tmult()}\spxextra{Precond method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond.tmult}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tmult}}}{\emph{\DUrole{n}{V}}}{}
Apply the transposed preconditioner to the supplied vector.

\end{fulllineitems}

\index{type() (Precond method)@\spxentry{type()}\spxextra{Precond method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Precond:getfem.Precond.type}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{type}}}{}{}
Return a string describing the type of the preconditioner (‘ilu’, ‘ildlt’,..).

\end{fulllineitems}


\end{fulllineitems}



\section{Slice}
\label{\detokenize{python/cmdref_Slice:slice}}\label{\detokenize{python/cmdref_Slice::doc}}\index{Slice (class in getfem)@\spxentry{Slice}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Slice}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Slice object

Creation of a mesh slice. Mesh slices are very similar to a
P1\sphinxhyphen{}discontinuous MeshFem on which interpolation is very fast. The slice is
built from a mesh object, and a description of the slicing operation, for
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{Slice}\PYG{p}{(}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{planar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

cuts the original mesh with the half space \{y\textgreater{}0\}. Each convex of the
original Mesh \sphinxtitleref{m} is simplexified (for example a quadrangle is splitted
into 2 triangles), and each simplex is refined 5 times.

Slicing operations can be:
\begin{itemize}
\item {} 
cutting with a plane, a sphere or a cylinder

\item {} 
intersection or union of slices

\item {} 
isovalues surfaces/volumes

\item {} 
“points”, “streamlines” (see below)

\end{itemize}

If the first argument is a MeshFem \sphinxtitleref{mf} instead of a Mesh, and if it is
followed by a \sphinxtitleref{mf}\sphinxhyphen{}field \sphinxtitleref{u}, then the deformation \sphinxtitleref{u} will be applied to the
mesh before the slicing operation.

The first argument can also be a slice.

General constructor for Slice objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{sl = Slice(sliceop, \{Slice sl|\{Mesh m| MeshFem mf, vec U\}, int refine\}{[}, mat CVfids{]})}}
Create a Slice using \sphinxtitleref{sliceop} operation.

\sphinxtitleref{sliceop} operation is specified with  Tuple
or List, do not forget the extra parentheses!. The first element is the
name of the operation, followed the slicing options:
\begin{itemize}
\item {} 
(‘none’) :
Does not cut the mesh.

\item {} 
(‘planar’, int orient, vec p, vec n) :
Planar cut. \sphinxtitleref{p} and \sphinxtitleref{n} define a half\sphinxhyphen{}space, \sphinxtitleref{p} being a point belong to
the boundary of the half\sphinxhyphen{}space, and \sphinxtitleref{n} being its normal. If \sphinxtitleref{orient} is
equal to \sphinxhyphen{}1 (resp. 0, +1), then the slicing operation will cut the mesh
with the “interior” (resp. “boundary”, “exterior”) of the half\sphinxhyphen{}space.
\sphinxtitleref{orient} may also be set to +2 which means that the mesh will be sliced,
but both the outer and inner parts will be kept.

\item {} 
(‘ball’, int orient, vec c, scalar r) :
Cut with a ball of center \sphinxtitleref{c} and radius \sphinxtitleref{r}.

\item {} 
(‘cylinder’, int orient, vec p1, vec p2, scalar r) :
Cut with a cylinder whose axis is the line \sphinxtitleref{(p1, p2)} and whose radius
is \sphinxtitleref{r}.

\item {} 
(‘isovalues’, int orient, MeshFem mf, vec U, scalar s) :
Cut using the isosurface of the field \sphinxtitleref{U} (defined on the MeshFem \sphinxtitleref{mf}).
The result is the set \sphinxtitleref{\{x such that :math:\textasciigrave{}U(x) leq s}\}\textasciigrave{} or \sphinxtitleref{\{x such that
\textasciigrave{}U\textasciigrave{}(x)=\textasciigrave{}s}\}\textasciigrave{} or \sphinxtitleref{\{x such that \textasciigrave{}U\textasciigrave{}(x) \textgreater{}= \textasciigrave{}s}\}\textasciigrave{} depending on the value of
\sphinxtitleref{orient}.

\item {} 
(‘boundary’{[}, SLICEOP{]}) :
Return the boundary of the result of SLICEOP, where SLICEOP is any
slicing operation. If SLICEOP is not specified, then the whole mesh is
considered (i.e. it is equivalent to (‘boundary’,\{‘none’\})).

\item {} 
(‘explode’, mat Coef) :
Build an ‘exploded’ view of the mesh: each convex is shrinked (\(0 <
\text{Coef} \leq 1\)). In the case of 3D convexes, only their faces are kept.

\item {} 
(‘union’, SLICEOP1, SLICEOP2) :
Returns the union of slicing operations.

\item {} 
(‘intersection’, SLICEOP1, SLICEOP2) :
Returns the intersection of slicing operations, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{Slice}\PYG{p}{(}\PYG{p}{(}\PYG{n}{intersection}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{planar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,+1,[[0],[0],[0]],[[0],[0],[1]]),}
                           \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isovalues}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{mf2}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
(‘comp’, SLICEOP) :
Returns the complementary of slicing operations.

\item {} 
(‘diff’, SLICEOP1, SLICEOP2) :
Returns the difference of slicing operations.

\item {} 
(‘mesh’, Mesh m) :
Build a slice which is the intersection of the sliced mesh with another
mesh. The slice is such that all of its simplexes are stricly contained
into a convex of each mesh.

\end{itemize}

\item {} 
\sphinxcode{\sphinxupquote{sl = Slice(\textquotesingle{}streamlines\textquotesingle{}, MeshFem mf, mat U, mat S)}}
Compute streamlines of the (vector) field \sphinxtitleref{U}, with seed points given
by the columns of \sphinxtitleref{S}.

\item {} 
\sphinxcode{\sphinxupquote{sl = Slice(\textquotesingle{}points\textquotesingle{}, Mesh m, mat Pts)}}
Return the “slice” composed of points given by the columns of \sphinxtitleref{Pts}
(useful for interpolation on a given set of sparse points, see
\sphinxcode{\sphinxupquote{gf\_compute(\textquotesingle{}interpolate on\textquotesingle{},sl)}}).

\item {} 
\sphinxcode{\sphinxupquote{sl = Slice(\textquotesingle{}load\textquotesingle{}, string filename{[}, Mesh m{]})}}
Load the slice (and its linked mesh if it is not given as an argument)
from a text file.

\end{itemize}
\index{area() (Slice method)@\spxentry{area()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.area}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{area}}}{}{}
Return the area of the slice.

\end{fulllineitems}

\index{char() (Slice method)@\spxentry{char()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the Slice.

This can be used to perform comparisons between two
different Slice objects.
This function is to be completed.

\end{fulllineitems}

\index{cvs() (Slice method)@\spxentry{cvs()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.cvs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cvs}}}{}{}
Return the list of convexes of the original mesh contained in the slice.

\end{fulllineitems}

\index{dim() (Slice method)@\spxentry{dim()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.dim}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dim}}}{}{}
Return the dimension of the slice (2 for a 2D mesh, etc..).

\end{fulllineitems}

\index{display() (Slice method)@\spxentry{display()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a Slice object.

\end{fulllineitems}

\index{edges() (Slice method)@\spxentry{edges()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.edges}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{edges}}}{}{}
Return the edges of the linked mesh contained in the slice.

\sphinxtitleref{P} contains the list of all edge vertices, \sphinxtitleref{E1} contains
the indices of each mesh edge in \sphinxtitleref{P}, and \sphinxtitleref{E2} contains the
indices of each “edges” which is on the border of the slice.
This function is useless except for post\sphinxhyphen{}processing purposes.

\end{fulllineitems}

\index{export\_to\_dx() (Slice method)@\spxentry{export\_to\_dx()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.export_to_dx}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_dx}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Slice.export\_to\_dx(self, string filename, …)

Export a slice to OpenDX.

Following the \sphinxtitleref{filename}, you may use any of the following
options:
\begin{itemize}
\item {} 
if ‘ascii’ is not used, the file will contain binary data
(non portable, but fast).

\item {} 
if ‘edges’ is used, the edges of the original mesh will be
written instead of the slice content.

\item {} 
if ‘append’ is used, the opendx file will not be overwritten,
and the new data will be added at the end of the file.

\end{itemize}

More than one dataset may be written, just list them. Each dataset
consists of either:
\begin{itemize}
\item {} 
a field interpolated on the slice (scalar, vector or tensor),
followed by an optional name.

\item {} 
a mesh\_fem and a field, followed by an optional name.

\end{itemize}

\end{fulllineitems}

\index{export\_to\_pos() (Slice method)@\spxentry{export\_to\_pos()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.export_to_pos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_pos}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Slice.export\_to\_pos(self, string filename{[}, string name{]}{[}{[},MeshFem mf1{]}, mat U1, string nameU1{[}{[},MeshFem mf1{]}, mat U2, string nameU2,…{]})

Export a slice to Gmsh.

More than one dataset may be written, just list them.
Each dataset consists of either:
\begin{itemize}
\item {} 
a field interpolated on the slice (scalar, vector or tensor).

\item {} 
a mesh\_fem and a field.

\end{itemize}

\end{fulllineitems}

\index{export\_to\_pov() (Slice method)@\spxentry{export\_to\_pov()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.export_to_pov}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_pov}}}{\emph{\DUrole{n}{filename}}}{}
Export a the triangles of the slice to POV\sphinxhyphen{}RAY.

\end{fulllineitems}

\index{export\_to\_vtk() (Slice method)@\spxentry{export\_to\_vtk()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.export_to_vtk}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_vtk}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Slice.export\_to\_vtk(self, string filename, …)

Export a slice to VTK.

Following the \sphinxtitleref{filename}, you may use any of the following options:
\begin{itemize}
\item {} 
if ‘ascii’ is not used, the file will contain binary data
(non portable, but fast).

\item {} 
if ‘edges’ is used, the edges of the original mesh will be
written instead of the slice content.

\end{itemize}

More than one dataset may be written, just list them. Each dataset
consists of either:
\begin{itemize}
\item {} 
a field interpolated on the slice (scalar, vector or tensor),
followed by an optional name.

\item {} 
a mesh\_fem and a field, followed by an optional name.

\end{itemize}

Examples:
\begin{itemize}
\item {} 
Slice.export\_to\_vtk(‘test.vtk’, Usl, ‘first\_dataset’, mf,
U2, ‘second\_dataset’)

\item {} 
Slice.export\_to\_vtk(‘test.vtk’, ‘ascii’, mf,U2)

\item {} 
Slice.export\_to\_vtk(‘test.vtk’, ‘edges’, ‘ascii’, Uslice)

\end{itemize}

\end{fulllineitems}

\index{export\_to\_vtu() (Slice method)@\spxentry{export\_to\_vtu()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.export_to_vtu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{export\_to\_vtu}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Slice.export\_to\_vtu(self, string filename, …)

Export a slice to VTK(XML).

Following the \sphinxtitleref{filename}, you may use any of the following options:
\begin{itemize}
\item {} 
if ‘ascii’ is not used, the file will contain binary data
(non portable, but fast).

\item {} 
if ‘edges’ is used, the edges of the original mesh will be
written instead of the slice content.

\end{itemize}

More than one dataset may be written, just list them. Each dataset
consists of either:
\begin{itemize}
\item {} 
a field interpolated on the slice (scalar, vector or tensor),
followed by an optional name.

\item {} 
a mesh\_fem and a field, followed by an optional name.

\end{itemize}

Examples:
\begin{itemize}
\item {} 
Slice.export\_to\_vtu(‘test.vtu’, Usl, ‘first\_dataset’, mf,
U2, ‘second\_dataset’)

\item {} 
Slice.export\_to\_vtu(‘test.vtu’, ‘ascii’, mf,U2)

\item {} 
Slice.export\_to\_vtu(‘test.vtu’, ‘edges’, ‘ascii’, Uslice)

\end{itemize}

\end{fulllineitems}

\index{interpolate\_convex\_data() (Slice method)@\spxentry{interpolate\_convex\_data()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.interpolate_convex_data}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{interpolate\_convex\_data}}}{\emph{\DUrole{n}{Ucv}}}{}
Interpolate data given on each convex of the mesh to the slice nodes.

The input array \sphinxtitleref{Ucv} may have any number of dimensions, but its
last dimension should be equal to Mesh.max\_cvid().

Example of use: Slice.interpolate\_convex\_data(Mesh.quality()).

\end{fulllineitems}

\index{linked\_mesh() (Slice method)@\spxentry{linked\_mesh()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.linked_mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linked\_mesh}}}{}{}
Return the mesh on which the slice was taken.

\end{fulllineitems}

\index{memsize() (Slice method)@\spxentry{memsize()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.memsize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{memsize}}}{}{}
Return the amount of memory (in bytes) used by the slice object.

\end{fulllineitems}

\index{mesh() (Slice method)@\spxentry{mesh()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.mesh}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh}}}{}{}
Return the mesh on which the slice was taken
(identical to ‘linked mesh’)

\end{fulllineitems}

\index{nbpts() (Slice method)@\spxentry{nbpts()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.nbpts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbpts}}}{}{}
Return the number of points in the slice.

\end{fulllineitems}

\index{nbsplxs() (Slice method)@\spxentry{nbsplxs()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.nbsplxs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nbsplxs}}}{\emph{\DUrole{n}{dim}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the number of simplexes in the slice.

Since the slice may contain points (simplexes of dim 0), segments
(simplexes of dimension 1), triangles etc., the result is a vector
of size Slice.dim()+1, except if the optional argument \sphinxtitleref{dim}
is used.

\end{fulllineitems}

\index{pts() (Slice method)@\spxentry{pts()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{pts}}}{}{}
Return the list of point coordinates.

\end{fulllineitems}

\index{set\_pts() (Slice method)@\spxentry{set\_pts()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.set_pts}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_pts}}}{\emph{\DUrole{n}{P}}}{}
Replace the points of the slice.

The new points \sphinxtitleref{P} are stored in the columns the matrix. Note that
you can use the function to apply a deformation to a slice, or to
change the dimension of the slice (the number of rows of \sphinxtitleref{P} is not
required to be equal to Slice.dim()).

\end{fulllineitems}

\index{splxs() (Slice method)@\spxentry{splxs()}\spxextra{Slice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Slice:getfem.Slice.splxs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{splxs}}}{\emph{\DUrole{n}{dim}}}{}
Return the list of simplexes of dimension \sphinxtitleref{dim}.

On output, S has ‘dim+1’ rows, each column contains the point
numbers of a simplex.  The vector \sphinxtitleref{CV2S} can be used to find the
list of simplexes for any convex stored in the slice. For example
‘S{[}:,CV2S{[}4{]}:CV2S{[}5{]}{]}’
gives the list of simplexes for the fourth convex.

\end{fulllineitems}


\end{fulllineitems}



\section{Spmat}
\label{\detokenize{python/cmdref_Spmat:spmat}}\label{\detokenize{python/cmdref_Spmat::doc}}\index{Spmat (class in getfem)@\spxentry{Spmat}\spxextra{class in getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Spmat}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
GetFEM Spmat object

Create a new sparse matrix in GetFEM format. These sparse matrix can be stored as CSC (compressed column
sparse), which is the format used by Matlab, or they can be stored as WSC
(internal format to getfem). The CSC matrices are not writable (it would
be very inefficient), but they are optimized for multiplication with
vectors, and memory usage. The WSC are writable, they are very fast with
respect to random read/write operation. However their memory overhead is
higher than CSC matrices, and they are a little bit slower for
matrix\sphinxhyphen{}vector multiplications.

By default, all newly created matrices are build as WSC matrices. This can
be changed later with \sphinxcode{\sphinxupquote{Spmat.to\_csc(...)}}, or may be changed
automatically by getfem (for example \sphinxcode{\sphinxupquote{gf\_linsolve()}} converts the
matrices to CSC).

The matrices may store REAL or COMPLEX values.

General constructor for Spmat objects
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{SM = Spmat(\textquotesingle{}empty\textquotesingle{}, int m {[}, int n{]})}}
Create a new empty (i.e. full of zeros) sparse matrix, of dimensions
\sphinxtitleref{m x n}. If \sphinxtitleref{n} is omitted, the matrix dimension is \sphinxtitleref{m x m}.

\item {} 
\sphinxcode{\sphinxupquote{SM = Spmat(\textquotesingle{}copy\textquotesingle{}, mat K {[}, list I {[}, list J{]}{]})}}
Duplicate a matrix \sphinxtitleref{K} (which might be a SpMat). If index \sphinxtitleref{I} and/or \sphinxtitleref{J} are given, the matrix will
be a submatrix of \sphinxtitleref{K}. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{Spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{copy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{empty}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{40}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

will return a 40x5 matrix.

\item {} 
\sphinxcode{\sphinxupquote{SM = Spmat(\textquotesingle{}identity\textquotesingle{}, int n)}}
Create a \sphinxtitleref{n x n} identity matrix.

\item {} 
\sphinxcode{\sphinxupquote{SM = Spmat(\textquotesingle{}mult\textquotesingle{}, Spmat A, Spmat B)}}
Create a sparse matrix as the product of the sparse matrices \sphinxtitleref{A} and
\sphinxtitleref{B}. It requires that \sphinxtitleref{A} and \sphinxtitleref{B} be both real or both complex, you
may have to use \sphinxcode{\sphinxupquote{Spmat.to\_complex()}}

\item {} 
\sphinxcode{\sphinxupquote{SM = Spmat(\textquotesingle{}add\textquotesingle{}, Spmat A, Spmat B)}}
Create a sparse matrix as the sum of the sparse matrices \sphinxtitleref{A} and \sphinxtitleref{B}.
Adding a real matrix with a complex matrix is possible.

\item {} 
\sphinxcode{\sphinxupquote{SM = Spmat(\textquotesingle{}diag\textquotesingle{}, mat D {[}, ivec E {[}, int n {[},int m{]}{]}{]})}}
Create a diagonal matrix. If \sphinxtitleref{E} is given, \sphinxtitleref{D} might be a matrix and
each column of \sphinxtitleref{E} will contain the sub\sphinxhyphen{}diagonal number that will be
filled with the corresponding column of \sphinxtitleref{D}.

\item {} 
\sphinxcode{\sphinxupquote{SM = Spmat(\textquotesingle{}load\textquotesingle{},\textquotesingle{}hb\textquotesingle{}|\textquotesingle{}harwell\sphinxhyphen{}boeing\textquotesingle{}|\textquotesingle{}mm\textquotesingle{}|\textquotesingle{}matrix\sphinxhyphen{}market\textquotesingle{}, string filename)}}
Read a sparse matrix from an Harwell\sphinxhyphen{}Boeing or a Matrix\sphinxhyphen{}Market file
.

\end{itemize}
\index{add() (Spmat method)@\spxentry{add()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.add}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add}}}{\emph{\DUrole{n}{I}}, \emph{\DUrole{n}{J}}, \emph{\DUrole{n}{V}}}{}
Add \sphinxtitleref{V} to the sub\sphinxhyphen{}matrix ‘M(I,J)’.

\sphinxtitleref{V} might be a sparse matrix or a full matrix.

\end{fulllineitems}

\index{assign() (Spmat method)@\spxentry{assign()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.assign}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{assign}}}{\emph{\DUrole{n}{I}}, \emph{\DUrole{n}{J}}, \emph{\DUrole{n}{V}}}{}
Copy V into the sub\sphinxhyphen{}matrix ‘M(I,J)’.

\sphinxtitleref{V} might be a sparse matrix or a full matrix.

\end{fulllineitems}

\index{char() (Spmat method)@\spxentry{char()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.char}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{char}}}{}{}
Output a (unique) string representation of the Spmat.

This can be used to perform comparisons between two
different Spmat objects.
This function is to be completed.

\end{fulllineitems}

\index{clear() (Spmat method)@\spxentry{clear()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.clear}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear}}}{\emph{\DUrole{n}{I}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Spmat.clear(self{[}, list I{[}, list J{]}{]})

Erase the non\sphinxhyphen{}zero entries of the matrix.

The optional arguments \sphinxtitleref{I} and \sphinxtitleref{J} may be specified to clear a
sub\sphinxhyphen{}matrix instead of the entire matrix.

\end{fulllineitems}

\index{conjugate() (Spmat method)@\spxentry{conjugate()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.conjugate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{conjugate}}}{}{}
Conjugate each element of the matrix.

\end{fulllineitems}

\index{csc\_ind() (Spmat method)@\spxentry{csc\_ind()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.csc_ind}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{csc\_ind}}}{}{}
Return the two usual index arrays of CSC storage.

If \sphinxtitleref{M} is not stored as a CSC matrix, it is converted into CSC.

\end{fulllineitems}

\index{csc\_val() (Spmat method)@\spxentry{csc\_val()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.csc_val}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{csc\_val}}}{}{}
Return the array of values of all non\sphinxhyphen{}zero entries of \sphinxtitleref{M}.

If \sphinxtitleref{M} is not stored as a CSC matrix, it is converted into CSC.

\end{fulllineitems}

\index{determinant() (Spmat method)@\spxentry{determinant()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.determinant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{determinant}}}{}{}
returns the matrix determinant calculated using MUMPS.

\end{fulllineitems}

\index{diag() (Spmat method)@\spxentry{diag()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.diag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{diag}}}{\emph{\DUrole{n}{E}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Return the diagonal of \sphinxtitleref{M} as a vector.

If \sphinxtitleref{E} is used, return the sub\sphinxhyphen{}diagonals whose ranks are given in E.

\end{fulllineitems}

\index{dirichlet\_nullspace() (Spmat method)@\spxentry{dirichlet\_nullspace()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.dirichlet_nullspace}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dirichlet\_nullspace}}}{\emph{\DUrole{n}{R}}}{}
Solve the dirichlet conditions \sphinxtitleref{M.U=R}.

A solution \sphinxtitleref{U0} which has a minimum L2\sphinxhyphen{}norm is returned, with a
sparse matrix \sphinxtitleref{N} containing an orthogonal basis of the kernel of
the (assembled) constraints matrix \sphinxtitleref{M} (hence, the PDE linear system
should be solved on this subspace): the initial problem

\sphinxtitleref{K.U = B} with constraints \sphinxtitleref{M.U = R}

is replaced by

\sphinxtitleref{(N’.K.N).UU = N’.B} with \sphinxtitleref{U = N.UU + U0}

\end{fulllineitems}

\index{display() (Spmat method)@\spxentry{display()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
displays a short summary for a Spmat object.

\end{fulllineitems}

\index{full() (Spmat method)@\spxentry{full()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.full}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{full}}}{\emph{\DUrole{n}{I}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Sm = Spmat.full(self{[}, list I{[}, list J{]}{]})

Return a full (sub\sphinxhyphen{})matrix.

The optional arguments \sphinxtitleref{I} and \sphinxtitleref{J}, are the sub\sphinxhyphen{}intervals for the
rows and columns that are to be extracted.

\end{fulllineitems}

\index{is\_complex() (Spmat method)@\spxentry{is\_complex()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.is_complex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_complex}}}{}{}
Return 1 if the matrix contains complex values.

\end{fulllineitems}

\index{mult() (Spmat method)@\spxentry{mult()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.mult}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mult}}}{\emph{\DUrole{n}{V}}}{}
Product of the sparse matrix \sphinxtitleref{M} with a vector \sphinxtitleref{V}.

For matrix\sphinxhyphen{}matrix multiplications, see Spmat(‘mult’).

\end{fulllineitems}

\index{nnz() (Spmat method)@\spxentry{nnz()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.nnz}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nnz}}}{}{}
Return the number of non\sphinxhyphen{}null values stored in the sparse matrix.

\end{fulllineitems}

\index{save() (Spmat method)@\spxentry{save()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{format}}, \emph{\DUrole{n}{filename}}}{}
Export the sparse matrix.

the format of the file may be ‘hb’ for Harwell\sphinxhyphen{}Boeing, or ‘mm’
for Matrix\sphinxhyphen{}Market.

\end{fulllineitems}

\index{scale() (Spmat method)@\spxentry{scale()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.scale}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{scale}}}{\emph{\DUrole{n}{v}}}{}
Multiplies the matrix by a scalar value \sphinxtitleref{v}.

\end{fulllineitems}

\index{set\_diag() (Spmat method)@\spxentry{set\_diag()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.set_diag}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_diag}}}{\emph{\DUrole{n}{D}}, \emph{\DUrole{n}{E}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Change the diagonal (or sub\sphinxhyphen{}diagonals) of the matrix.

If \sphinxtitleref{E} is given, \sphinxtitleref{D} might be a matrix and each column of \sphinxtitleref{E} will
contain the sub\sphinxhyphen{}diagonal number that will be filled with the
corresponding column of \sphinxtitleref{D}.

\end{fulllineitems}

\index{size() (Spmat method)@\spxentry{size()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.size}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{size}}}{}{}
Return a vector where \sphinxtitleref{ni} and \sphinxtitleref{nj} are the dimensions of the matrix.

\end{fulllineitems}

\index{storage() (Spmat method)@\spxentry{storage()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.storage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{storage}}}{}{}
Return the storage type currently used for the matrix.

The storage is returned as a string, either ‘CSC’ or ‘WSC’.

\end{fulllineitems}

\index{tmult() (Spmat method)@\spxentry{tmult()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.tmult}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{tmult}}}{\emph{\DUrole{n}{V}}}{}
Product of \sphinxtitleref{M} transposed (conjugated if \sphinxtitleref{M} is complex) with the
vector \sphinxtitleref{V}.

\end{fulllineitems}

\index{to\_complex() (Spmat method)@\spxentry{to\_complex()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.to_complex}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_complex}}}{}{}
Store complex numbers.

\end{fulllineitems}

\index{to\_csc() (Spmat method)@\spxentry{to\_csc()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.to_csc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_csc}}}{}{}
Convert the matrix to CSC storage.

CSC storage is recommended for matrix\sphinxhyphen{}vector multiplications.

\end{fulllineitems}

\index{to\_wsc() (Spmat method)@\spxentry{to\_wsc()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.to_wsc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{to\_wsc}}}{}{}
Convert the matrix to WSC storage.

Read and write operation are quite fast with WSC storage.

\end{fulllineitems}

\index{transconj() (Spmat method)@\spxentry{transconj()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.transconj}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transconj}}}{}{}
Transpose and conjugate the matrix.

\end{fulllineitems}

\index{transpose() (Spmat method)@\spxentry{transpose()}\spxextra{Spmat method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Spmat:getfem.Spmat.transpose}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{transpose}}}{}{}
Transpose the matrix.

\end{fulllineitems}


\end{fulllineitems}



\section{Module asm}
\label{\detokenize{python/cmdref_Module asm:module-asm}}\label{\detokenize{python/cmdref_Module asm::doc}}\index{asm\_generic() (in module getfem)@\spxentry{asm\_generic()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_generic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_generic}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{order}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{region}}, \emph{\DUrole{n}{model}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: (…) = asm\_generic(MeshIm mim, int order, string expression, int region, {[}Model model, {[}‘Secondary\_domain’, ‘name’,{]}{]} {[}string varname, int is\_variable{[}, \{MeshFem mf, MeshImd mimd\}{]}, value{]}, {[}‘select\_output’, ‘varname1’{[}, ‘varname2{]}{]}, …)

High\sphinxhyphen{}level generic assembly procedure for volumic or boundary assembly.

Performs the generic assembly of \sphinxtitleref{expression} with the integration
method \sphinxtitleref{mim} on the mesh region of index \sphinxtitleref{region} (\sphinxhyphen{}1 means all
elements of the mesh). The same mesh should be shared by
the integration method and all the finite element methods or
mesh\_im\_data corresponding to the variables.

\sphinxtitleref{order} indicates either that the (scalar) potential
(order = 0) or the (vector) residual (order = 1) or the
tangent (matrix) (order = 2) is to be computed.

\sphinxtitleref{model} is an optional parameter allowing to take into account
all variables and data of a model. Note that all enabled variables
of the model will occupy space in the returned vector/matrix
corresponding to their degrees of freedom in the global system, even
if they are not present in \sphinxtitleref{expression}.

The variables and constants (data) are listed after the region number
(or optionally the model).
For each variable/constant, a name must be given first (as it is
referred in the assembly string), then an integer equal to 1 or 0
is expected respectively for declaring a variable or a constant,
then the finite element method if it is a fem variable/constant or
the mesh\_im\_data if it is data defined on integration points, and
the vector representing the value of the variable/constant.
It is possible to give an arbitrary number of variable/constant.
The difference between a variable and a constant is that test
functions are only available for variables, not for constants.

\sphinxtitleref{select\_output} is an optional parameter which allows to reduce the
output vector (for \sphinxtitleref{order} equal to 1) or the matrix (for \sphinxtitleref{order}
equal to 2) to the degrees of freedom of the specified variables.
One variable has to be specified for a vector output and two for a
matrix output.

Note that if several variables are given, the assembly of the
tangent matrix/residual vector will be done considering the order
in the call of the function (the degrees of freedom of the first
variable, then of the second one, and so on). If a model is provided,
all degrees of freedom of the model will be counted first, even if
some of the model variables do not appear in \sphinxtitleref{expression}.

For example, the L2 norm of a vector field “u” can be computed with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L2 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o+ow}{or} \PYG{k}{with} \PYG{n}{the} \PYG{n}{square} \PYG{n}{root} \PYG{n}{of}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u.u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The nonhomogeneous Laplacian stiffness matrix of a scalar field can be evaluated with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{laplacian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{mf\PYGZus{}data}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{equivalently} \PYG{k}{with}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A*Grad\PYGZus{}Test2\PYGZus{}u.Grad\PYGZus{}Test\PYGZus{}u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{mf\PYGZus{}data}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{asm\_mass\_matrix() (in module getfem)@\spxentry{asm\_mass\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_mass_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_mass\_matrix}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf1}}, \emph{\DUrole{n}{mf2}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: M = asm\_mass\_matrix(MeshIm mim, MeshFem mf1{[}, MeshFem mf2{[}, int region{]}{]})

Assembly of a mass matrix.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_laplacian() (in module getfem)@\spxentry{asm\_laplacian()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_laplacian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_laplacian}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of the matrix for the Laplacian problem.

\(\nabla\cdot(a(x)\nabla u)\)  with \sphinxtitleref{a} a scalar.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_linear\_elasticity() (in module getfem)@\spxentry{asm\_linear\_elasticity()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_linear_elasticity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_linear\_elasticity}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{lambda\_d}}, \emph{\DUrole{n}{mu\_d}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembles of the matrix for the linear (isotropic) elasticity problem.

\(\nabla\cdot(C(x):\nabla u)\)
with \(C\) defined via \sphinxtitleref{lambda\_d} and \sphinxtitleref{mu\_d}.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_nonlinear\_elasticity() (in module getfem)@\spxentry{asm\_nonlinear\_elasticity()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_nonlinear_elasticity}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_nonlinear\_elasticity}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{law}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{params}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: TRHS = asm\_nonlinear\_elasticity(MeshIm mim, MeshFem mf\_u, vec U, string law, MeshFem mf\_d, mat params, \{‘tangent matrix’|’rhs’|’incompressible tangent matrix’, MeshFem mf\_p, vec P|’incompressible rhs’, MeshFem mf\_p, vec P\})

Assembles terms (tangent matrix and right hand side) for nonlinear elasticity.

The solution \sphinxtitleref{U} is required at the current time\sphinxhyphen{}step. The \sphinxtitleref{law}
may be choosen among:
\begin{itemize}
\item {} 
‘SaintVenant Kirchhoff’:
Linearized law, should be avoided. This law has the two usual
Lame coefficients as parameters, called lambda and mu.

\item {} 
‘Mooney Rivlin’:
This law has three parameters, called C1, C2 and D1.
Can be preceded with the words ‘compressible’ or ‘incompressible’ to force
a specific version. By default, the incompressible version is considered
which requires only the first two material coefficients.

\item {} 
‘neo Hookean’:
A special case of the ‘Mooney Rivlin’ law that requires one material
coefficient less (C2 = 0). By default, its compressible version is used.

\item {} 
‘Ciarlet Geymonat’:
This law has 3 parameters, called lambda, mu and gamma, with
gamma chosen such that gamma is in {]}\sphinxhyphen{}lambda/2\sphinxhyphen{}mu, \sphinxhyphen{}mu{[}.

\end{itemize}

The parameters of the material law are described on the MeshFem \sphinxtitleref{mf\_d}.
The matrix \sphinxtitleref{params} should have \sphinxtitleref{nbdof(mf\_d)} columns, each row
correspounds to a parameter.

The last argument selects what is to be built: either the tangent
matrix, or the right hand side. If the incompressibility is
considered, it should be followed by a MeshFem \sphinxtitleref{mf\_p}, for the
pression.

Return a SpMat object (tangent matrix), vec object (right hand
side), tuple of SpMat objects (incompressible tangent matrix), or
tuple of vec objects (incompressible right hand side).

\end{fulllineitems}

\index{asm\_helmholtz() (in module getfem)@\spxentry{asm\_helmholtz()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_helmholtz}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_helmholtz}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{k}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of the matrix for the Helmholtz problem.

\(\Delta u + k^2 u\) = 0,  with \sphinxtitleref{k} complex scalar.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_bilaplacian() (in module getfem)@\spxentry{asm\_bilaplacian()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_bilaplacian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_bilaplacian}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of the matrix for the Bilaplacian problem.

\(\Delta(a(x)\Delta u) = 0\)   with \sphinxtitleref{a} scalar.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_bilaplacian\_KL() (in module getfem)@\spxentry{asm\_bilaplacian\_KL()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_bilaplacian_KL}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_bilaplacian\_KL}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{nu}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of the matrix for the Bilaplacian problem with Kirchhoff\sphinxhyphen{}Love formulation.

\(\Delta(a(x)\Delta u) = 0\)   with \sphinxtitleref{a} scalar.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_volumic\_source() (in module getfem)@\spxentry{asm\_volumic\_source()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_volumic_source}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_volumic\_source}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{fd}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of a volumic source term.

Output a vector \sphinxtitleref{V}, assembled on the MeshFem \sphinxtitleref{mf\_u}, using the data
vector \sphinxtitleref{fd} defined on the data MeshFem \sphinxtitleref{mf\_d}. \sphinxtitleref{fd} may be real or
complex\sphinxhyphen{}valued.

Return a vec object.

\end{fulllineitems}

\index{asm\_boundary\_source() (in module getfem)@\spxentry{asm\_boundary\_source()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_boundary_source}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_boundary\_source}}}{\emph{\DUrole{n}{bnum}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{G}}}{}
Assembly of a boundary source term.

\sphinxtitleref{G} should be a {[}Qdim x N{]} matrix, where N is the number of dof
of \sphinxtitleref{mf\_d}, and Qdim is the dimension of the unkown u (that is set
when creating the MeshFem).

Return a vec object.

\end{fulllineitems}

\index{asm\_dirichlet() (in module getfem)@\spxentry{asm\_dirichlet()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_dirichlet}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_dirichlet}}}{\emph{\DUrole{n}{bnum}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{H}}, \emph{\DUrole{n}{R}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of Dirichlet conditions of type \sphinxtitleref{h.u = r}.

Handle \sphinxtitleref{h.u = r} where h is a square matrix (of any rank) whose
size is equal to the dimension of the unkown u. This matrix is
stored in \sphinxtitleref{H}, one column per dof in \sphinxtitleref{mf\_d}, each column containing
the values of the matrix h stored in fortran order:
\begin{equation*}
\begin{split}`H(:,j) = [h11(x_j) h21(x_j) h12(x_j) h22(x_j)]`\end{split}
\end{equation*}
if u is a 2D vector field.

Of course, if the unknown is a scalar field, you just have to set
\sphinxtitleref{H = ones(1, N)}, where N is the number of dof of \sphinxtitleref{mf\_d}.

This is basically the same than calling gf\_asm(‘boundary qu term’)
for \sphinxtitleref{H} and calling gf\_asm(‘neumann’) for \sphinxtitleref{R}, except that this
function tries to produce a ‘better’ (more diagonal) constraints
matrix (when possible).

See also Spmat.Dirichlet\_nullspace().

\end{fulllineitems}

\index{asm\_boundary\_qu\_term() (in module getfem)@\spxentry{asm\_boundary\_qu\_term()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_boundary_qu_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_boundary\_qu\_term}}}{\emph{\DUrole{n}{boundary\_num}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_d}}, \emph{\DUrole{n}{q}}}{}
Assembly of a boundary qu term.

\sphinxtitleref{q} should be be a {[}Qdim x Qdim x N{]} array, where N is the number
of dof of \sphinxtitleref{mf\_d}, and Qdim is the dimension of the unkown u (that
is set when creating the MeshFem).

Return a SpMat object.

\end{fulllineitems}

\index{asm\_define\_function() (in module getfem)@\spxentry{asm\_define\_function()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_define_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_define\_function}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{nb\_args}}, \emph{\DUrole{n}{expression}}, \emph{\DUrole{n}{expression\_derivative\_t}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: asm\_define\_function(string name, int nb\_args, string expression{[}, string expression\_derivative\_t{[}, string expression\_derivative\_u{]}{]})

Define a new function \sphinxtitleref{name} which can be used in high level
generic assembly. The function can have one or two parameters.
In \sphinxtitleref{expression} all available predefined function or operation
of the generic assembly can be used. However, no reference to
some variables or data can be specified. The argument of the
function is \sphinxtitleref{t} for a one parameter function and \sphinxtitleref{t} and \sphinxtitleref{u}
for a two parameter function. For instance ‘sin(pi*t)+2*t*t’
is a valid expression for a one parameter function and
‘sin(max(t,u)*pi)’ is a valid expression for a two parameters
function. \sphinxtitleref{expression\_derivative\_t} and \sphinxtitleref{expression\_derivative\_u}
are optional expressions for the derivatives with respect
to \sphinxtitleref{t} and \sphinxtitleref{u}. If they are not furnished, a symbolic derivation
is used.

\end{fulllineitems}

\index{asm\_undefine\_function() (in module getfem)@\spxentry{asm\_undefine\_function()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_undefine_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_undefine\_function}}}{\emph{\DUrole{n}{name}}}{}
Cancel the definition of a previously defined function \sphinxtitleref{name}
for the high level generic assembly.

\end{fulllineitems}

\index{asm\_define\_linear\_hardening\_function() (in module getfem)@\spxentry{asm\_define\_linear\_hardening\_function()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_define_linear_hardening_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_define\_linear\_hardening\_function}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{sigma\_y0}}, \emph{\DUrole{n}{H}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: asm\_define\_linear\_hardening\_function(string name, scalar sigma\_y0, scalar H, … {[}string ‘Frobenius’{]})

Define a new linear hardening function under the name \sphinxtitleref{name}, with
initial yield stress \sphinxtitleref{sigma\_y0} and hardening modulus H.
If an extra string argument with the value ‘Frobenius’ is provided,
the hardening function is expressed in terms of Frobenius norms of its
input strain and output stress, instead of their Von\sphinxhyphen{}Mises equivalents.

\end{fulllineitems}

\index{asm\_define\_Ramberg\_Osgood\_hardening\_function() (in module getfem)@\spxentry{asm\_define\_Ramberg\_Osgood\_hardening\_function()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_define_Ramberg_Osgood_hardening_function}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_define\_Ramberg\_Osgood\_hardening\_function}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{sigma\_ref}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: asm\_define\_Ramberg\_Osgood\_hardening\_function(string name, scalar sigma\_ref, \{scalar eps\_ref | scalar E, scalar alpha\}, scalar n{[}, string ‘Frobenius’{]})

Define a new Ramberg Osgood hardening function under the name \sphinxtitleref{name},
with initial yield stress \sphinxtitleref{sigma\_y0} and hardening modulus H.
If an extra string argument with the value ‘Frobenius’ is provided,
the hardening function is expressed in terms of Frobenius norms of its
input strain and output stress, instead of their Von\sphinxhyphen{}Mises equivalents.

\end{fulllineitems}

\index{asm\_expression\_analysis() (in module getfem)@\spxentry{asm\_expression\_analysis()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_expression_analysis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_expression\_analysis}}}{\emph{\DUrole{n}{expression}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: asm\_expression\_analysis(string expression {[}, \{Mesh mesh | MeshIm mim\}{]} {[}, der\_order{]} {[}, Model model{]} {[}, string varname, int is\_variable{[}, \{MeshFem mf | MeshImd mimd\}{]}, …{]})

Analyse a high\sphinxhyphen{}level generic assembly expression and print
information about the provided expression.

\end{fulllineitems}

\index{asm\_volumic() (in module getfem)@\spxentry{asm\_volumic()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_volumic}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_volumic}}}{\emph{\DUrole{n}{CVLST}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: (…) = asm\_volumic(,CVLST{]}, expr {[}, mesh\_ims, mesh\_fems, data…{]})

Low\sphinxhyphen{}level generic assembly procedure for volumic assembly.

The expression \sphinxtitleref{expr} is evaluated over the MeshFem’s listed in the
arguments (with optional data) and assigned to the output arguments.
For details about the syntax of assembly expressions, please refer
to the getfem user manual (or look at the file getfem\_assembling.h
in the GetFEM sources).

For example, the L2 norm of a field can be computed with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L2 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o+ow}{or} \PYG{k}{with} \PYG{n}{the} \PYG{n}{square} \PYG{n}{root} \PYG{n}{of}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volumic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u=data(\PYGZsh{}1); V()+=u(i).u(j).comp(Base(\PYGZsh{}1).Base(\PYGZsh{}1))(i,j)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)}
\end{sphinxVerbatim}

The Laplacian stiffness matrix can be evaluated with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{laplacian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{mf\PYGZus{}data}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{equivalently} \PYG{k}{with}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volumic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a=data(\PYGZsh{}2);M(\PYGZsh{}1,\PYGZsh{}1)+=sym(comp(Grad(\PYGZsh{}1).Grad(\PYGZsh{}1).Base(\PYGZsh{}2))(:,i,:,i,j).a(j))}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{mf\PYGZus{}data}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{asm\_boundary() (in module getfem)@\spxentry{asm\_boundary()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_boundary}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_boundary}}}{\emph{\DUrole{n}{bnum}}, \emph{\DUrole{n}{expr}}, \emph{\DUrole{n}{mim}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mf}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{data}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: (…) = asm\_boundary(int bnum, string expr {[}, MeshIm mim, MeshFem mf, data…{]})

Low\sphinxhyphen{}level generic boundary assembly.

See the help for gf\_asm(‘volumic’).

\end{fulllineitems}

\index{asm\_interpolation\_matrix() (in module getfem)@\spxentry{asm\_interpolation\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_interpolation_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_interpolation\_matrix}}}{\emph{\DUrole{n}{mf}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Mi = asm\_interpolation\_matrix(MeshFem mf, \{MeshFem mfi | vec pts\})

Build the interpolation matrix from a MeshFem onto another MeshFem or a set of points.

Return a matrix \sphinxtitleref{Mi}, such that \sphinxtitleref{V = Mi.U} is equal to
gf\_compute(‘interpolate\_on’,mfi). Useful for repeated interpolations.
Note that this is just interpolation, no elementary integrations
are involved here, and \sphinxtitleref{mfi} has to be lagrangian. In the more
general case, you would have to do a L2 projection via the mass
matrix.

\sphinxtitleref{Mi} is a SpMat object.

\end{fulllineitems}

\index{asm\_extrapolation\_matrix() (in module getfem)@\spxentry{asm\_extrapolation\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_extrapolation_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_extrapolation\_matrix}}}{\emph{\DUrole{n}{mf}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Me = asm\_extrapolation\_matrix(MeshFem mf,  \{MeshFem mfe | vec pts\})

Build the extrapolation matrix from a MeshFem onto another MeshFem or a set of points.

Return a matrix \sphinxtitleref{Me}, such that \sphinxtitleref{V = Me.U} is equal to
gf\_compute(‘extrapolate\_on’,mfe). Useful for repeated
extrapolations.

\sphinxtitleref{Me} is a SpMat object.

\end{fulllineitems}

\index{asm\_integral\_contact\_Uzawa\_projection() (in module getfem)@\spxentry{asm\_integral\_contact\_Uzawa\_projection()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_integral_contact_Uzawa_projection}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_integral\_contact\_Uzawa\_projection}}}{\emph{\DUrole{n}{bnum}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mf\_lambda}}, \emph{\DUrole{n}{vec\_lambda}}, \emph{\DUrole{n}{mf\_obstacle}}, \emph{\DUrole{n}{obstacle}}, \emph{\DUrole{n}{r}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: B = asm\_integral\_contact\_Uzawa\_projection(int bnum, MeshIm mim, MeshFem mf\_u, vec U, MeshFem mf\_lambda, vec vec\_lambda, MeshFem mf\_obstacle, vec obstacle, scalar r {[}, \{scalar coeff | MeshFem mf\_coeff, vec coeff\} {[}, int option{[}, scalar alpha, vec W{]}{]}{]})
\begin{description}
\item[{Specific assembly procedure for the use of an Uzawa algorithm to solve}] \leavevmode
contact problems. Projects the term \$\sphinxhyphen{}(lambda \sphinxhyphen{} r (u\_N\sphinxhyphen{}g))\_\sphinxhyphen{}\$ on the
finite element space of \$lambda\$.

\end{description}

Return a vec object.

\end{fulllineitems}

\index{asm\_level\_set\_normal\_source\_term() (in module getfem)@\spxentry{asm\_level\_set\_normal\_source\_term()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_level_set_normal_source_term}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_level\_set\_normal\_source\_term}}}{\emph{\DUrole{n}{bnum}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf\_u}}, \emph{\DUrole{n}{mf\_lambda}}, \emph{\DUrole{n}{vec\_lambda}}, \emph{\DUrole{n}{mf\_levelset}}, \emph{\DUrole{n}{levelset}}}{}
Performs an assembly of the source term represented by \sphinxtitleref{vec\_lambda}
on \sphinxtitleref{mf\_lambda} considered to be a component in the direction of the
gradient of a levelset function (normal to the levelset) of a vector
field defined on \sphinxtitleref{mf\_u} on the boundary \sphinxtitleref{bnum}.

Return a vec object.

\end{fulllineitems}

\index{asm\_lsneuman\_matrix() (in module getfem)@\spxentry{asm\_lsneuman\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_lsneuman_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_lsneuman\_matrix}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf1}}, \emph{\DUrole{n}{mf2}}, \emph{\DUrole{n}{ls}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of a level set Neuman  matrix.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_nlsgrad\_matrix() (in module getfem)@\spxentry{asm\_nlsgrad\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_nlsgrad_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_nlsgrad\_matrix}}}{\emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf1}}, \emph{\DUrole{n}{mf2}}, \emph{\DUrole{n}{ls}}, \emph{\DUrole{n}{region}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Assembly of a nlsgrad matrix.

Return a SpMat object.

\end{fulllineitems}

\index{asm\_stabilization\_patch\_matrix() (in module getfem)@\spxentry{asm\_stabilization\_patch\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module asm:getfem.asm_stabilization_patch_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asm\_stabilization\_patch\_matrix}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{mf}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{ratio}}, \emph{\DUrole{n}{h}}}{}
Assembly of stabilization patch matrix .

Return a SpMat object.

\end{fulllineitems}



\section{Module compute}
\label{\detokenize{python/cmdref_Module compute:module-compute}}\label{\detokenize{python/cmdref_Module compute::doc}}\index{compute\_L2\_norm() (in module getfem)@\spxentry{compute\_L2\_norm()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_L2_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_L2\_norm}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the L2 norm of the (real or complex) field \sphinxtitleref{U}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.

\end{fulllineitems}

\index{compute\_L2\_dist() (in module getfem)@\spxentry{compute\_L2\_dist()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_L2_dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_L2\_dist}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf2}}, \emph{\DUrole{n}{U2}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the L2 distance between \sphinxtitleref{U} and \sphinxtitleref{U2}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.

\end{fulllineitems}

\index{compute\_H1\_semi\_norm() (in module getfem)@\spxentry{compute\_H1\_semi\_norm()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_H1_semi_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_H1\_semi\_norm}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the L2 norm of grad(\sphinxtitleref{U}).

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.

\end{fulllineitems}

\index{compute\_H1\_semi\_dist() (in module getfem)@\spxentry{compute\_H1\_semi\_dist()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_H1_semi_dist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_H1\_semi\_dist}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{mf2}}, \emph{\DUrole{n}{U2}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the semi H1 distance between \sphinxtitleref{U} and \sphinxtitleref{U2}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.

\end{fulllineitems}

\index{compute\_H1\_norm() (in module getfem)@\spxentry{compute\_H1\_norm()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_H1_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_H1\_norm}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the H1 norm of \sphinxtitleref{U}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.

\end{fulllineitems}

\index{compute\_H2\_semi\_norm() (in module getfem)@\spxentry{compute\_H2\_semi\_norm()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_H2_semi_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_H2\_semi\_norm}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the L2 norm of D\textasciicircum{}2(\sphinxtitleref{U}).

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.

\end{fulllineitems}

\index{compute\_H2\_norm() (in module getfem)@\spxentry{compute\_H2\_norm()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_H2_norm}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_H2\_norm}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{CVids}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Compute the H2 norm of \sphinxtitleref{U}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.

\end{fulllineitems}

\index{compute\_gradient() (in module getfem)@\spxentry{compute\_gradient()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_gradient}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_gradient}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mf\_du}}}{}
Compute the gradient of the field \sphinxtitleref{U} defined on MeshFem \sphinxtitleref{mf\_du}.

The gradient is interpolated on the MeshFem \sphinxtitleref{mf\_du}, and returned in
\sphinxtitleref{DU}. For example, if \sphinxtitleref{U} is defined on a P2 MeshFem, \sphinxtitleref{DU} should be
evaluated on a P1\sphinxhyphen{}discontinuous MeshFem. \sphinxtitleref{mf} and \sphinxtitleref{mf\_du} should
share the same mesh.

\sphinxtitleref{U} may have any number of dimensions (i.e. this function is not
restricted to the gradient of scalar fields, but may also be used
for tensor fields). However the last dimension of \sphinxtitleref{U} has to be
equal to the number of dof of \sphinxtitleref{mf}. For example, if \sphinxtitleref{U} is a
{[}3x3xNmf{]} array (where Nmf is the number of dof of \sphinxtitleref{mf}), \sphinxtitleref{DU} will
be a {[}Nx3x3{[}xQ{]}xNmf\_du{]} array, where N is the dimension of the mesh,
Nmf\_du is the number of dof of \sphinxtitleref{mf\_du}, and the optional Q dimension
is inserted if \sphinxtitleref{Qdim\_mf != Qdim\_mf\_du}, where Qdim\_mf is the Qdim of
\sphinxtitleref{mf} and Qdim\_mf\_du is the Qdim of \sphinxtitleref{mf\_du}.

\end{fulllineitems}

\index{compute\_hessian() (in module getfem)@\spxentry{compute\_hessian()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_hessian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_hessian}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mf\_h}}}{}
Compute the hessian of the field \sphinxtitleref{U} defined on MeshFem \sphinxtitleref{mf\_h}.

See also gf\_compute(‘gradient’, MeshFem mf\_du).

\end{fulllineitems}

\index{compute\_eval\_on\_triangulated\_surface() (in module getfem)@\spxentry{compute\_eval\_on\_triangulated\_surface()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_eval_on_triangulated_surface}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_eval\_on\_triangulated\_surface}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{Nrefine}}, \emph{\DUrole{n}{CVLIST}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
{[}OBSOLETE FUNCTION! will be removed in a future release{]}
Utility function designed for 2D triangular meshes : returns a list
of triangles coordinates with interpolated U values. This can be
used for the accurate visualization of data defined on a
discontinous high order element. On output, the six first rows of UP
contains the triangle coordinates, and the others rows contain the
interpolated values of U (one for each triangle vertex) CVLIST may
indicate the list of convex number that should be consider, if not
used then all the mesh convexes will be used. U should be a row
vector.

\end{fulllineitems}

\index{compute\_interpolate\_on() (in module getfem)@\spxentry{compute\_interpolate\_on()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_interpolate_on}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_interpolate\_on}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: Ui = compute\_interpolate\_on(MeshFem MF, vec U, \{MeshFem mfi | Slice sli | vec pts\})

Interpolate a field on another MeshFem or a Slice or a list of points.
\begin{itemize}
\item {} \begin{description}
\item[{Interpolation on another MeshFem \sphinxtitleref{mfi}:}] \leavevmode
\sphinxtitleref{mfi} has to be Lagrangian. If \sphinxtitleref{mf} and \sphinxtitleref{mfi} share the same
mesh object, the interpolation will be much faster.

\end{description}

\item {} \begin{description}
\item[{Interpolation on a Slice \sphinxtitleref{sli}:}] \leavevmode
this is similar to interpolation on a refined P1\sphinxhyphen{}discontinuous
mesh, but it is much faster. This can also be used with
Slice(‘points’) to obtain field values at a given set of
points.

\end{description}

\item {} 
Interpolation on a set of points \sphinxtitleref{pts}

\end{itemize}

See also gf\_asm(‘interpolation matrix’)

\end{fulllineitems}

\index{compute\_extrapolate\_on() (in module getfem)@\spxentry{compute\_extrapolate\_on()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_extrapolate_on}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_extrapolate\_on}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mfe}}}{}
Extrapolate a field on another MeshFem.

If the mesh of \sphinxtitleref{mfe} is stricly included in the mesh of \sphinxtitleref{mf}, this
function does stricly the same job as gf\_compute(‘interpolate\_on’).
However, if the mesh of \sphinxtitleref{mfe} is not exactly included in \sphinxtitleref{mf}
(imagine interpolation between a curved refined mesh and a coarse
mesh), then values which are outside \sphinxtitleref{mf} will be
extrapolated.

See also gf\_asm(‘extrapolation matrix’)

\end{fulllineitems}

\index{compute\_error\_estimate() (in module getfem)@\spxentry{compute\_error\_estimate()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_error_estimate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_error\_estimate}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}}{}
Compute an a posteriori error estimate.

Currently there is only one which is available: for each convex,
the jump of the normal derivative is integrated on its faces.

\end{fulllineitems}

\index{compute\_error\_estimate\_nitsche() (in module getfem)@\spxentry{compute\_error\_estimate\_nitsche()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_error_estimate_nitsche}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_error\_estimate\_nitsche}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mim}}, \emph{\DUrole{n}{GAMMAC}}, \emph{\DUrole{n}{GAMMAN}}, \emph{\DUrole{n}{lambda\_}}, \emph{\DUrole{n}{mu\_}}, \emph{\DUrole{n}{gamma0}}, \emph{\DUrole{n}{f\_coeff}}, \emph{\DUrole{n}{vertical\_force}}}{}
Compute an a posteriori error estimate in the case of Nitsche method.

Currently there is only one which is available: for each convex,
the jump of the normal derivative is integrated on its faces.

\end{fulllineitems}

\index{compute\_convect() (in module getfem)@\spxentry{compute\_convect()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module compute:getfem.compute_convect}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_convect}}}{\emph{\DUrole{n}{MF}}, \emph{\DUrole{n}{U}}, \emph{\DUrole{n}{mf\_v}}, \emph{\DUrole{n}{V}}, \emph{\DUrole{n}{dt}}, \emph{\DUrole{n}{nt}}, \emph{\DUrole{n}{option}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: compute\_convect(MeshFem MF, vec U, MeshFem mf\_v, vec V, scalar dt, int nt{[}, string option{[}, vec per\_min, vec per\_max{]}{]})

Compute a convection of \sphinxtitleref{U} with regards to a steady state velocity
field \sphinxtitleref{V} with a Characteristic\sphinxhyphen{}Galerkin method. The result is returned
in\sphinxhyphen{}place in \sphinxtitleref{U}.
This method is restricted to pure Lagrange fems for U. \sphinxtitleref{mf\_v} should
represent a continuous finite element method. \sphinxtitleref{dt} is the integration time
and \sphinxtitleref{nt} is the number of integration step on the caracteristics. \sphinxtitleref{option}
is an option for the part of the boundary where there is a re\sphinxhyphen{}entrant
convection.
\sphinxtitleref{option = ‘extrapolation’} for an extrapolation on the nearest element,
\sphinxtitleref{option = ‘unchanged’} for a constant value on that boundary or
\sphinxtitleref{option = ‘periodicity’} for a peridiodic boundary. For this latter option
the two vectors per\_min, per\_max has to be given and represent the limits
of the periodic domain (on components where per\_max{[}k{]} \textless{} per\_min{[}k{]}
no operation is done).
This method is rather dissipative, but stable.

\end{fulllineitems}



\section{Module delete}
\label{\detokenize{python/cmdref_Module delete:module-delete}}\label{\detokenize{python/cmdref_Module delete::doc}}\index{delete() (in module getfem)@\spxentry{delete()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module delete:getfem.delete}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{delete}}}{\emph{\DUrole{n}{I}}, \emph{\DUrole{n}{J}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{K}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: delete(I{[}, J, K,…{]})

I should be a descriptor given by gf\_mesh(),
gf\_mesh\_im(), gf\_slice() etc.

Note that if another object uses I, then object I will be deleted only
when both have been asked for deletion.

Only objects listed in the output of gf\_workspace(‘stats’) can be
deleted (for example gf\_fem objects cannot be destroyed).

You may also use gf\_workspace(‘clear all’) to erase everything at
once.

\end{fulllineitems}



\section{Module linsolve}
\label{\detokenize{python/cmdref_Module linsolve:module-linsolve}}\label{\detokenize{python/cmdref_Module linsolve::doc}}\index{linsolve\_gmres() (in module getfem)@\spxentry{linsolve\_gmres()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module linsolve:getfem.linsolve_gmres}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linsolve\_gmres}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{restart}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: X = linsolve\_gmres(SpMat M, vec b{[}, int restart{]}{[}, Mrecond P{]}{[},’noisy’{]}{[},’res’, r{]}{[},’maxiter’, n{]})

Solve \sphinxtitleref{M.X = b} with the generalized minimum residuals method.

Optionally using \sphinxtitleref{P} as preconditioner. The default value of the
restart parameter is 50.

\end{fulllineitems}

\index{linsolve\_cg() (in module getfem)@\spxentry{linsolve\_cg()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module linsolve:getfem.linsolve_cg}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linsolve\_cg}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{P}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: X = linsolve\_cg(SpMat M, vec b {[}, Mrecond P{]}{[},’noisy’{]}{[},’res’, r{]}{[},’maxiter’, n{]})

Solve \sphinxtitleref{M.X = b} with the conjugated gradient method.

Optionally using \sphinxtitleref{P} as preconditioner.

\end{fulllineitems}

\index{linsolve\_bicgstab() (in module getfem)@\spxentry{linsolve\_bicgstab()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module linsolve:getfem.linsolve_bicgstab}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linsolve\_bicgstab}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{b}}, \emph{\DUrole{n}{P}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{*}\DUrole{n}{args}}}{}
Synopsis: X = linsolve\_bicgstab(SpMat M, vec b {[}, Mrecond P{]}{[},’noisy’{]}{[},’res’, r{]}{[},’maxiter’, n{]})

Solve \sphinxtitleref{M.X = b} with the bi\sphinxhyphen{}conjugated gradient stabilized method.

Optionally using \sphinxtitleref{P} as a preconditioner.

\end{fulllineitems}

\index{linsolve\_lu() (in module getfem)@\spxentry{linsolve\_lu()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module linsolve:getfem.linsolve_lu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linsolve\_lu}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{b}}}{}
Alias for gf\_linsolve(‘superlu’,…)

\end{fulllineitems}

\index{linsolve\_superlu() (in module getfem)@\spxentry{linsolve\_superlu()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module linsolve:getfem.linsolve_superlu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linsolve\_superlu}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{b}}}{}
Solve \sphinxtitleref{M.U = b} apply the SuperLU solver (sparse LU factorization).

The condition number estimate \sphinxtitleref{cond} is returned with the solution \sphinxtitleref{U}.

\end{fulllineitems}

\index{linsolve\_mumps() (in module getfem)@\spxentry{linsolve\_mumps()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module linsolve:getfem.linsolve_mumps}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{linsolve\_mumps}}}{\emph{\DUrole{n}{M}}, \emph{\DUrole{n}{b}}}{}
Solve \sphinxtitleref{M.U = b} using the MUMPS solver.

\end{fulllineitems}



\section{Module poly}
\label{\detokenize{python/cmdref_Module poly:module-poly}}\label{\detokenize{python/cmdref_Module poly::doc}}\index{poly\_print() (in module getfem)@\spxentry{poly\_print()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module poly:getfem.poly_print}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{poly\_print}}}{\emph{\DUrole{n}{P}}}{}
Prints the content of P.

\end{fulllineitems}

\index{poly\_product() (in module getfem)@\spxentry{poly\_product()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module poly:getfem.poly_product}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{poly\_product}}}{\emph{\DUrole{n}{P}}}{}
To be done … !

\end{fulllineitems}



\section{Module util}
\label{\detokenize{python/cmdref_Module util:module-util}}\label{\detokenize{python/cmdref_Module util::doc}}\index{util\_save\_matrix() (in module getfem)@\spxentry{util\_save\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module util:getfem.util_save_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{util\_save\_matrix}}}{\emph{\DUrole{n}{FMT}}, \emph{\DUrole{n}{FILENAME}}, \emph{\DUrole{n}{A}}}{}
Exports a sparse matrix into the file named FILENAME, using
Harwell\sphinxhyphen{}Boeing (FMT=’hb’) or Matrix\sphinxhyphen{}Market (FMT=’mm’) formatting.

\end{fulllineitems}

\index{util\_load\_matrix() (in module getfem)@\spxentry{util\_load\_matrix()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module util:getfem.util_load_matrix}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{util\_load\_matrix}}}{\emph{\DUrole{n}{FMT}}, \emph{\DUrole{n}{FILENAME}}}{}
Imports a sparse matrix from a file.

\end{fulllineitems}

\index{util\_trace\_level() (in module getfem)@\spxentry{util\_trace\_level()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module util:getfem.util_trace_level}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{util\_trace\_level}}}{\emph{\DUrole{n}{level}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Set the verbosity of some GetFEM routines.

Typically the messages printed by the model bricks, 0 means no
trace message (default is 3). if no level is given,
the current trace level is returned.

\end{fulllineitems}

\index{util\_warning\_level() (in module getfem)@\spxentry{util\_warning\_level()}\spxextra{in module getfem}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{python/cmdref_Module util:getfem.util_warning_level}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{util\_warning\_level}}}{\emph{\DUrole{n}{level}}}{}
Filter the less important warnings displayed by getfem.

0 means no warnings, default level is 3. if no level is given,
the current warning level is returned.

\end{fulllineitems}




\renewcommand{\indexname}{Index}
\printindex
\end{document}