%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



% begin user_preamble:
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amssymb}
% end user_preamble


\title{Matlab-Octave Interface}
\date{Aug 30, 2020}
\release{5.4.1}
\author{Yves Renard, Julien Pommier, Konstantinos Poulios}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{logogetfem.png}\par}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{matlab_octave/index::doc}}



\chapter{Introduction}
\label{\detokenize{matlab_octave/intro:introduction}}\label{\detokenize{matlab_octave/intro:mlab-intro}}\label{\detokenize{matlab_octave/intro::doc}}
This guide provides a reference about the \sphinxstyleemphasis{Octave}/\sphinxstyleemphasis{MatLab} interface of \sphinxstyleemphasis{GetFEM}.
For a complete  reference of \sphinxstyleemphasis{GetFEM}, please report to the \sphinxhref{http://getfem.org/index.html}{specific guides},
but you should be able to use the \sphinxstyleemphasis{getfem\sphinxhyphen{}interface}’s without any particular knowledge
of the \sphinxstyleemphasis{GetFEM} internals, although a basic knowledge about Finite Elements
is required. This documentation is however not self contained. You should in
particular refer to the \sphinxhref{http://getfem.org/userdoc/index.html}{user documentation} to have a more extensive
description of the structures algorithms and concepts used.

Copyright © 2004\sphinxhyphen{}2020 \sphinxstyleemphasis{GetFEM} project.

The text of the \sphinxstyleemphasis{GetFEM} website and the documentations are available for modification and reuse under the terms of the \sphinxhref{http://www.gnu.org/licenses/fdl.html}{GNU Free Documentation License}

GetFEM  is  free software;  you  can  redistribute  it  and/or modify it
under  the  terms  of the  GNU  Lesser General Public License as published
by  the  Free Software Foundation;  either version 3 of the License,  or
(at your option) any later version along with the GCC Runtime Library
Exception either version 3.1 or (at your option) any later version.
This program  is  distributed  in  the  hope  that it will be useful,  but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or  FITNESS  FOR  A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License and GCC Runtime Library Exception for more details.
You  should  have received a copy of the GNU Lesser General Public License
along  with  this program;  if not, write to the Free Software Foundation,
Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110\sphinxhyphen{}1301, USA.


\chapter{Installation}
\label{\detokenize{matlab_octave/install:installation}}\label{\detokenize{matlab_octave/install:mlab-install}}\label{\detokenize{matlab_octave/install::doc}}
The installation of the \sphinxstyleemphasis{getfem\sphinxhyphen{}interface} toolbox can be somewhat tricky, since it combines a
C++ compiler, libraries and \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab} interaction… In case of troubles with a
non\sphinxhyphen{}GNU compiler, gcc/g++ (\textgreater{}= 8.0) should be a safe solution.

See the \sphinxhref{../download.html}{download and install} page for the installation of \sphinxstyleemphasis{GetFEM} on different plateforms.


\chapter{Preliminary}
\label{\detokenize{matlab_octave/pre:preliminary}}\label{\detokenize{matlab_octave/pre:mlab-pre}}\label{\detokenize{matlab_octave/pre::doc}}
This is just a short summary of the terms employed in this manual. If you are not
familiar with finite elements, this should be useful (but in any case, you should
definitively read the \DUrole{xref,std,std-ref}{dp}).

The \index{mesh@\spxentry{mesh}}\index{environment variable@\spxentry{environment variable}!mesh@\spxentry{mesh}}\sphinxcode{\sphinxupquote{mesh}} is composed of \index{convexes@\spxentry{convexes}}\index{environment variable@\spxentry{environment variable}!convexes@\spxentry{convexes}}\sphinxcode{\sphinxupquote{convexes}}. What we call convexes can be
simple line segments, prisms, tetrahedrons, curved triangles, of even something
which is not convex (in the geometrical sense). They all have an associated
\index{reference convex@\spxentry{reference convex}}\index{environment variable@\spxentry{environment variable}!reference convex@\spxentry{reference convex}}\sphinxcode{\sphinxupquote{reference convex}}: for segments, this will be the \([0,1]\) segment,
for triangles this will be the canonical triangle \((0,0)-(0,1)-(1,0)\), etc.
All convexes of the mesh are constructed from the reference convex through a
\index{geometric transformation@\spxentry{geometric transformation}}\index{environment variable@\spxentry{environment variable}!geometric transformation@\spxentry{geometric transformation}}\sphinxcode{\sphinxupquote{geometric transformation}}. In simple cases (when the convexes are
simplices for example), this transformation will be linear (hence it is easily
inverted, which can be a great advantage). In order to define the geometric
transformation, one defines \index{geometrical nodes@\spxentry{geometrical nodes}}\index{environment variable@\spxentry{environment variable}!geometrical nodes@\spxentry{geometrical nodes}}\sphinxcode{\sphinxupquote{geometrical nodes}} on the reference convex.
The geometrical transformation maps these nodes to the \index{mesh nodes@\spxentry{mesh nodes}}\index{environment variable@\spxentry{environment variable}!mesh nodes@\spxentry{mesh nodes}}\sphinxcode{\sphinxupquote{mesh nodes}}.

On the mesh, one defines a set of basis functions: the \index{FEM@\spxentry{FEM}}\index{environment variable@\spxentry{environment variable}!FEM@\spxentry{FEM}}\sphinxcode{\sphinxupquote{FEM}}. A FEM is
associated at each convex. The basis functions are also attached to some
geometrical points (which can be arbitrarily chosen). These points are similar to
the mesh nodes, but \sphinxstylestrong{they don’t have to be the same} (this only happens on very
simple cases, such as a classical \(P_1\) fem on a triangular mesh). The set
of all basis functions on the mesh forms the basis of a vector space, on which the
PDE will be solved. These basis functions (and their associated geometrical point)
are the \index{degrees of freedom@\spxentry{degrees of freedom}}\index{environment variable@\spxentry{environment variable}!degrees of freedom@\spxentry{degrees of freedom}}\sphinxcode{\sphinxupquote{degrees of freedom}} (contracted to \index{dof@\spxentry{dof}}\index{environment variable@\spxentry{environment variable}!dof@\spxentry{dof}}\sphinxcode{\sphinxupquote{dof}}). The FEM is
said to be \index{Lagrangian@\spxentry{Lagrangian}}\index{environment variable@\spxentry{environment variable}!Lagrangian@\spxentry{Lagrangian}}\sphinxcode{\sphinxupquote{Lagrangian}} when each of its basis functions is equal to one
at its attached geometrical point, and is null at the geometrical points of others
basis functions. This is an important property as it is very easy to
\index{interpolate@\spxentry{interpolate}}\index{environment variable@\spxentry{environment variable}!interpolate@\spxentry{interpolate}}\sphinxcode{\sphinxupquote{interpolate}} an arbitrary function on the finite elements space.

The finite elements method involves evaluation of integrals of these basis
functions (or product of basis functions etc.) on convexes (and faces of
convexes). In simple cases (polynomial basis functions and linear geometrical
transformation), one can evaluate analytically these integrals. In other cases,
one has to approximate it using \index{quadrature formulas@\spxentry{quadrature formulas}}\index{environment variable@\spxentry{environment variable}!quadrature formulas@\spxentry{quadrature formulas}}\sphinxcode{\sphinxupquote{quadrature formulas}}. Hence, at each
convex is attached an \index{integration method@\spxentry{integration method}}\index{environment variable@\spxentry{environment variable}!integration method@\spxentry{integration method}}\sphinxcode{\sphinxupquote{integration method}} along with the FEM. If you have
to use an approximate integration method, always choose carefully its order (i.e.
highest degree of the polynomials who are exactly integrated with the method): the
degree of the FEM, of the polynomial degree of the geometrical transformation, and
the nature of the elementary matrix have to be taken into account. If you are
unsure about the appropriate degree, always prefer a high order integration method
(which will slow down the assembly) to a low order one which will produce a
useless linear\sphinxhyphen{}system.

The process of construction of a global linear system from integrals of basis
functions on each convex is the \index{assembly@\spxentry{assembly}}\index{environment variable@\spxentry{environment variable}!assembly@\spxentry{assembly}}\sphinxcode{\sphinxupquote{assembly}}.

A mesh, with a set of FEM attached to its convexes is called a \index{mesh\_fem@\spxentry{mesh\_fem}}\index{environment variable@\spxentry{environment variable}!mesh\_fem@\spxentry{mesh\_fem}}\sphinxcode{\sphinxupquote{mesh\_fem}}
object in \sphinxstyleemphasis{GetFEM}.

A mesh, with a set of integration methods attached to its convexes is called a
\index{mesh\_im@\spxentry{mesh\_im}}\index{environment variable@\spxentry{environment variable}!mesh\_im@\spxentry{mesh\_im}}\sphinxcode{\sphinxupquote{mesh\_im}} object in \sphinxstyleemphasis{GetFEM}.

A \sphinxtitleref{mesh\_fem} can be used to approximate scalar fields (heat, pression, …), or vector
fields (displacement, electric field, …). A \sphinxtitleref{mesh\_im} will be used to perform
numerical integrations on these fields. Most of the finite elements implemented in
\sphinxstyleemphasis{GetFEM} are scalar (however, \(TR_0\) and edges elements are also available). Of
course, these scalar FEMs can be used to approximate each component of a vector
field. This is done by setting the \(Qdim\) of the \sphinxtitleref{mesh\_fem} to the dimension of
the vector field (i.e. \(Qdim=1\) \(\rm I\hspace{-0.15em}Rightarrow\) scalar field,
\(Qdim=2\) \(\rm I\hspace{-0.15em}Rightarrow\) 2D vector field etc.).

When solving a PDE, one often has to use more than one FEM. The most important one
will be of course the one on which is defined the solution of the PDE. But most
PDEs involve various coefficients, for example:
\begin{equation*}
\begin{split}\nabla\cdot(\lambda(x)\nabla u) = f(x).\end{split}
\end{equation*}
Hence one has to define an FEM for the main unknown \(u\), but also for the
data \(\lambda(x)\) and \(f(x)\) if they are not constant. In order to
interpolate easily these coefficients in their finite element space, one often
choose a Lagrangian FEM.

The convexes, mesh nodes, and dof are all numbered. We sometimes refer to the
number associated to a convex as its \index{convex id@\spxentry{convex id}}\index{environment variable@\spxentry{environment variable}!convex id@\spxentry{convex id}}\sphinxcode{\sphinxupquote{convex id}} (contracted to
\index{cvid@\spxentry{cvid}}\index{environment variable@\spxentry{environment variable}!cvid@\spxentry{cvid}}\sphinxcode{\sphinxupquote{cvid}}). Mesh node numbers are also called \index{point id@\spxentry{point id}}\index{environment variable@\spxentry{environment variable}!point id@\spxentry{point id}}\sphinxcode{\sphinxupquote{point id}} (contracted
to \index{pid@\spxentry{pid}}\index{environment variable@\spxentry{environment variable}!pid@\spxentry{pid}}\sphinxcode{\sphinxupquote{pid}}). Faces of convexes do not have a global numbering, but only a
local number in each convex. Hence functions which need or return a list of faces
will always use a two\sphinxhyphen{}rows matrix, the first one containing convex ids, and the
second one containing local face number.

While the dof are always numbered consecutively, \sphinxstylestrong{this is not always the case for
point ids and convex ids}, especially if you have removed points or convexes from
the mesh. To ensure that they form a continuous sequence (starting from 1), you
have to call:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{optimize structure\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\chapter{\sphinxstyleemphasis{GetFEM} organization}
\label{\detokenize{matlab_octave/mlabgf:gfm-organization}}\label{\detokenize{matlab_octave/mlabgf:mlab-mlabgf}}\label{\detokenize{matlab_octave/mlabgf::doc}}
The \sphinxstyleemphasis{GetFEM} toolbox is just a convenient interface to the \sphinxstyleemphasis{GetFEM} library: you must
have a working \sphinxstyleemphasis{GetFEM} installed on your computer. This toolbox provides a big
\index{mex\sphinxhyphen{}file@\spxentry{mex\sphinxhyphen{}file}}\index{environment variable@\spxentry{environment variable}!mex\sphinxhyphen{}file@\spxentry{mex\sphinxhyphen{}file}}\sphinxcode{\sphinxupquote{mex\sphinxhyphen{}file}} (c++ binary callable from \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab}) and some additional
\sphinxcode{\sphinxupquote{m\sphinxhyphen{}files}} (documentation and extra\sphinxhyphen{}functionalities). All the functions of \sphinxstyleemphasis{GetFEM}
are prefixed by \sphinxcode{\sphinxupquote{gf\_}} (hence typing \sphinxcode{\sphinxupquote{gf\_}} at the \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab} prompt and then
pressing the \sphinxcode{\sphinxupquote{\textless{}tab\textgreater{}}} key is a quick way to obtain the list of getfem
functions).


\section{Functions}
\label{\detokenize{matlab_octave/mlabgf:functions}}\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{gf\_workspace}} : workspace management.

\item {} 
\sphinxcode{\sphinxupquote{gf\_util}} : miscellanous utility functions.

\item {} 
\sphinxcode{\sphinxupquote{gf\_delete}} : destroy a \sphinxstyleemphasis{GetFEM} object (gfMesh , gfMeshFem , gfMeshIm etc.).

\item {} 
\sphinxcode{\sphinxupquote{gf\_cvstruct\_get}} : retrieve informations from a gfCvStruct object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_geotrans}} : define a geometric transformation.

\item {} 
\sphinxcode{\sphinxupquote{gf\_geotrans\_get}} : retrieve informations from a gfGeoTrans object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh}} : creates a new gfMesh object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_get}} : retrieve informations from a gfMesh object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_set}} : modify a gfMesh object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_eltm}} : define an elementary matrix.

\item {} 
\sphinxcode{\sphinxupquote{gf\_fem}} : define a gfFem.

\item {} 
\sphinxcode{\sphinxupquote{gf\_fem\_get}} : retrieve informations from a gfFem object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_integ}} : define a integration method.

\item {} 
\sphinxcode{\sphinxupquote{gf\_integ\_get}} : retrieve informations from an gfInteg object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_fem}} : creates a new gfMeshFem object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get}} : retrieve informations from a gfMeshFem object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set}} : modify a gfMeshFem object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_im}} : creates a new gfMeshIm object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_im\_get}} : retrieve informations from a gfMeshIm object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mesh\_im\_set}} : modify a gfMeshIm object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_slice}} : create a new gfSlice object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_slice\_get}} : retrieve informations from a gfSlice object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_slice\_set}} : modify a gfSlice object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_spmat}} : create a gfSpMat object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_spmat\_get}} : perform computations with the gfSpMat.

\item {} 
\sphinxcode{\sphinxupquote{gf\_spmat\_set}} : modify the gfSpMat.

\item {} 
\sphinxcode{\sphinxupquote{gf\_precond}} : create a gfPrecond object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_precond\_get}} : perform computations with the gfPrecond.

\item {} 
\sphinxcode{\sphinxupquote{gf\_linsolve}} : interface to various linear solvers provided by getfem
(\sphinxstyleemphasis{SuperLU}, conjugated gradient, etc.).

\item {} 
\sphinxcode{\sphinxupquote{gf\_asm}} : assembly routines.

\item {} 
\sphinxcode{\sphinxupquote{gf\_solve}} : various solvers for usual PDEs (obsoleted by the gfMdBrick
objects).

\item {} 
\sphinxcode{\sphinxupquote{gf\_compute}} : computations involving the solution of a PDE (norm,
derivative, etc.).

\item {} 
\sphinxcode{\sphinxupquote{gf\_mdbrick}} : create a (“model brick”) gfMdBrick object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mdbrick\_get}} : retrieve information from a gfMdBrick object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mdbrick\_set}} : modify a gfMdBrick object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mdstate}} : create a (“model state”) gfMdState object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mdstate\_get}} : retrieve information from a gfMdState object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_mdstate\_set}} : modify a gfMdState object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_model}} : create a gfModel object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_model\_get}} : retrieve information from a gfModel object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_model\_set}} : modify a gfModel object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_global\_function}} : create a gfGlobalFunction object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_model\_get}} : retrieve information from a gfGlobalFunction object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_model\_set}} : modify a GlobalFunction object.

\item {} 
\sphinxcode{\sphinxupquote{gf\_plot\_mesh}} : plotting of mesh.

\item {} 
\sphinxcode{\sphinxupquote{gf\_plot}} : plotting of 2D and 3D fields.

\item {} 
\sphinxcode{\sphinxupquote{gf\_plot\_1D}} : plotting of 1D fields.

\item {} 
\sphinxcode{\sphinxupquote{gf\_plot\_slice}} : plotting of a mesh slice.

\end{itemize}


\section{Objects}
\label{\detokenize{matlab_octave/mlabgf:objects}}
Various “objects” can be manipulated by the \sphinxstyleemphasis{GetFEM} toolbox, see fig.
{\hyperref[\detokenize{matlab_octave/mlabgf:malb-fig-hierarchy}]{\sphinxcrossref{\DUrole{std,std-ref}{GetFEM objects hierarchy.}}}}. The MESH and MESHFEM objects are the two most
important objects.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{hierarchy}.png}
\caption{\sphinxstyleemphasis{GetFEM} objects hierarchy.}\label{\detokenize{matlab_octave/mlabgf:id1}}\label{\detokenize{matlab_octave/mlabgf:malb-fig-hierarchy}}\end{figure}
\begin{itemize}
\item {} 
\index{gfGeoTrans@\spxentry{gfGeoTrans}}\index{environment variable@\spxentry{environment variable}!gfGeoTrans@\spxentry{gfGeoTrans}}\sphinxcode{\sphinxupquote{gfGeoTrans}}: geometric transformations (defines the shape/position of
the convexes), created with \sphinxcode{\sphinxupquote{gf\_geotrans}}

\item {} 
\index{gfGlobalFunction@\spxentry{gfGlobalFunction}}\index{environment variable@\spxentry{environment variable}!gfGlobalFunction@\spxentry{gfGlobalFunction}}\sphinxcode{\sphinxupquote{gfGlobalFunction}}: represent a global function for the enrichment of finite element methods.

\item {} 
\index{gfMesh@\spxentry{gfMesh}}\index{environment variable@\spxentry{environment variable}!gfMesh@\spxentry{gfMesh}}\sphinxcode{\sphinxupquote{gfMesh}} : mesh structure (nodes, convexes, geometric transformations for
each convex), created with \sphinxcode{\sphinxupquote{gf\_mesh}}

\item {} 
\index{gfInteg@\spxentry{gfInteg}}\index{environment variable@\spxentry{environment variable}!gfInteg@\spxentry{gfInteg}}\sphinxcode{\sphinxupquote{gfInteg}} : integration method (exact, quadrature formula…).  Although
not linked directly to GEOTRANS, an integration method is usually specific to a
given convex structure. Created with \sphinxcode{\sphinxupquote{gf\_integ}}

\item {} 
\index{gfFem@\spxentry{gfFem}}\index{environment variable@\spxentry{environment variable}!gfFem@\spxentry{gfFem}}\sphinxcode{\sphinxupquote{gfFem}} : the finite element method (one per convex, can be PK, QK,
HERMITE, etc.). Created with \sphinxcode{\sphinxupquote{gf\_fem}}

\item {} 
\index{gfCvStruct@\spxentry{gfCvStruct}}\index{environment variable@\spxentry{environment variable}!gfCvStruct@\spxentry{gfCvStruct}}\sphinxcode{\sphinxupquote{gfCvStruct}} : stores formal information convex structures (nb. of points,
nb. of faces which are themselves convex structures).

\item {} 
\index{gfMeshFem@\spxentry{gfMeshFem}}\index{environment variable@\spxentry{environment variable}!gfMeshFem@\spxentry{gfMeshFem}}\sphinxcode{\sphinxupquote{gfMeshFem}} : object linked to a mesh, where each convex has been assigned
an FEM. Created with \sphinxcode{\sphinxupquote{gf\_mesh\_fem}}.

\item {} 
\index{gfMeshImM@\spxentry{gfMeshImM}}\index{environment variable@\spxentry{environment variable}!gfMeshImM@\spxentry{gfMeshImM}}\sphinxcode{\sphinxupquote{gfMeshImM}} : object linked to a mesh, where each convex has been assigned
an integration method. Created with \sphinxcode{\sphinxupquote{gf\_mesh\_im}}.

\item {} 
\index{gfMeshSlice@\spxentry{gfMeshSlice}}\index{environment variable@\spxentry{environment variable}!gfMeshSlice@\spxentry{gfMeshSlice}}\sphinxcode{\sphinxupquote{gfMeshSlice}} : object linked to a mesh, very similar to a
P1\sphinxhyphen{}discontinuous gfMeshFem. Used for fast interpolation and plotting.

\item {} 
\index{gfMdBrick@\spxentry{gfMdBrick}}\index{environment variable@\spxentry{environment variable}!gfMdBrick@\spxentry{gfMdBrick}}\sphinxcode{\sphinxupquote{gfMdBrick}} : gfMdBrick , an abstraction of a part of solver (for
example, the part which build the tangent matrix, the part which handles the
dirichlet conditions, etc.). These objects are stacked to build a complete
solver for a wide variety of problems. They typically use a number of
gfMeshFem, gfMeshIm etc. Deprecated object, replaced now by gfModel.

\item {} 
\index{gfMdState@\spxentry{gfMdState}}\index{environment variable@\spxentry{environment variable}!gfMdState@\spxentry{gfMdState}}\sphinxcode{\sphinxupquote{gfMdState}} : “model state”, holds the global data for a stack of mdbricks
(global tangent matrix, right hand side etc.). Deprecated object, replaced now by gfModel.

\item {} 
\index{gfModel@\spxentry{gfModel}}\index{environment variable@\spxentry{environment variable}!gfModel@\spxentry{gfModel}}\sphinxcode{\sphinxupquote{gfModel}} : “model”, holds the global data, variables and description of a
model. Evolution of “model state” object for 4.0 version of \sphinxstyleemphasis{GetFEM}.

\end{itemize}

The \sphinxstyleemphasis{GetFEM} toolbox uses its own \index{memory management@\spxentry{memory management}}\index{environment variable@\spxentry{environment variable}!memory management@\spxentry{memory management}}\sphinxcode{\sphinxupquote{memory management}}. Hence \sphinxstyleemphasis{GetFEM} objects
are not cleared when a:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{clear} \PYG{n}{all}
\end{sphinxVerbatim}

is issued at the \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab} prompt, but instead the function:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{clear all\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

should be used. The various \sphinxstyleemphasis{GetFEM} object can be accessed via \sphinxstyleemphasis{handles} (or
\sphinxstyleemphasis{descriptors}), which are just \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} structures containing 32\sphinxhyphen{}bits integer
identifiers to the real objects. Hence the \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab} command:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{whos}
\end{sphinxVerbatim}

does not report the memory consumption of \sphinxstyleemphasis{GetFEM} objects (except the marginal space
used by the handle). Instead, you should use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{stats\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

There are two kinds of \sphinxstyleemphasis{GetFEM} objects:
\begin{itemize}
\item {} 
static ones, which can not be deleted: ELTM, FEM, INTEG, GEOTRANS and CVSTRUCT.
Hopefully their memory consumption is very low.

\item {} 
dynamic ones, which can be destroyed, and are handled by the \sphinxcode{\sphinxupquote{gf\_workspace}}
function: MESH, MESHFEM, MESHIM, SLICE, SPMAT, PRECOND.

\end{itemize}

The objects MESH and MESHFEM are not independent: a MESHFEM object is always
linked to a MESH object, and a MESH object can be used by several MESHFEM
objects. Hence when you request the destruction of a MESH object, its destruction
might be delayed until it is not used anymore by any MESHFEM (these objects
waiting for deletion are listed in the \sphinxstyleemphasis{anonymous workspace} section of
\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}stats\textquotesingle{})}}).


\chapter{Examples}
\label{\detokenize{matlab_octave/examples:examples}}\label{\detokenize{matlab_octave/examples:mlab-examples}}\label{\detokenize{matlab_octave/examples::doc}}

\section{A step\sphinxhyphen{}by\sphinxhyphen{}step basic example}
\label{\detokenize{matlab_octave/examples:a-step-by-step-basic-example}}\label{\detokenize{matlab_octave/examples:mlab-laplacianexample}}
This example shows the basic usage of getfem, on the über\sphinxhyphen{}canonical problem above
all others: solving the \index{Laplacian@\spxentry{Laplacian}}\index{environment variable@\spxentry{environment variable}!Laplacian@\spxentry{Laplacian}}\sphinxcode{\sphinxupquote{Laplacian}}, \(-\Delta u = f\) on a square,
with the Dirichlet condition \(u = g(x)\) on the domain boundary. You can find
the \sphinxstylestrong{m\sphinxhyphen{}file} of this example under the name \sphinxstylestrong{demo\_step\_by\_step.m} in the
directory \sphinxcode{\sphinxupquote{interface/tests/matlab\sphinxhyphen{}octave/}} of the \sphinxstyleemphasis{GetFEM} distribution.

The first step is to \sphinxstylestrong{create a mesh}. It is possible to create simple structured meshes or unstructured meshes for simple geometries (see \sphinxcode{\sphinxupquote{gf\_mesh(\textquotesingle{}generate\textquotesingle{}, mesher\_object mo, scalar h)}}) or to rely on an external mesher (see \sphinxcode{\sphinxupquote{gf\_mesh(\textquotesingle{}import\textquotesingle{}, string
FORMAT, string FILENAME))}}).  For this example, we
just consider a regular \sphinxstylestrong{cartesian mesh} whose nodes are
\(\{x_{i=0\ldots10,j=0..10}=(i/10,j/10)\}\):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} creation of a simple cartesian mesh}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cartesian\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m} \PYG{p}{=}
     \PYG{n}{id}\PYG{p}{:} \PYG{l+m+mi}{0}
    \PYG{n}{cid}\PYG{p}{:} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

If you try to look at the value of \sphinxcode{\sphinxupquote{m}}, you’ll notice that it appears to be a
structure containing two integers. The first one is its identifier, the second one
is its class\sphinxhyphen{}id, i.e. an identifier of its type. This small structure is just an
“handle” or “descriptor” to the real object, which is stored in the \sphinxstyleemphasis{GetFEM} memory
and cannot be represented via \sphinxstyleemphasis{Octave} and \sphinxstyleemphasis{MatLab} data structures. Anyway, you can still inspect the \sphinxstyleemphasis{GetFEM} objects via the command \sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}stats\textquotesingle{})}}.

Now we can try to have a \sphinxstylestrong{look at the mesh}, with its vertices numbering and the
convexes numbering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} we enable vertices and convexes labels}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}plot\PYGZus{}mesh}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{vertices\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convexes\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

As you can see, the mesh is regular, and the numbering of its nodes and convexes
is also regular (this is guaranteed for cartesian meshes, but do not hope a
similar numbering for the degrees of freedom).

The next step is to \sphinxstylestrong{create a mesh\_fem object}. This one links a mesh with a set
of FEM:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} create a mesh\PYGZus{}fem of for a field of dimension 1 (i.e. a scalar field)}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fem\PYGZsq{}}\PYG{p}{,}\PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}QK(2,2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The first instruction builds a new gfMeshFem object, the second argument specifies
that this object will be used to interpolate scalar fields (since the unknown
\(u\) is a scalar field). The second instruction assigns the \(Q_2\) FEM
to every convex (each basis function is a polynomial of degree 4, remember that
\(P_k\) are polynomials of degree \(k\), while
\(Q_k\) are polynomials of degree \(2k\)). As \(Q_2\) is a
polynomial FEM, you can view the expression of its basis functions on the
reference element:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}QK(2,2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{poly\PYGZus{}str\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nb}{ans} \PYG{p}{=}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{1 \PYGZhy{} 3*x \PYGZhy{} 3*y + 2*x\PYGZca{}2 + 9*x*y + 2*y\PYGZca{}2 \PYGZhy{} 6*x\PYGZca{}2*y \PYGZhy{} 6*x*y\PYGZca{}2 + 4*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{4*x \PYGZhy{} 4*x\PYGZca{}2 \PYGZhy{} 12*x*y + 12*x\PYGZca{}2*y + 8*x*y\PYGZca{}2 \PYGZhy{} 8*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}x + 2*x\PYGZca{}2 + 3*x*y \PYGZhy{} 6*x\PYGZca{}2*y \PYGZhy{} 2*x*y\PYGZca{}2 + 4*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{4*y \PYGZhy{} 12*x*y \PYGZhy{} 4*y\PYGZca{}2 + 8*x\PYGZca{}2*y + 12*x*y\PYGZca{}2 \PYGZhy{} 8*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{16*x*y \PYGZhy{} 16*x\PYGZca{}2*y \PYGZhy{} 16*x*y\PYGZca{}2 + 16*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}4*x*y + 8*x\PYGZca{}2*y + 4*x*y\PYGZca{}2 \PYGZhy{} 8*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}y + 3*x*y + 2*y\PYGZca{}2 \PYGZhy{} 2*x\PYGZca{}2*y \PYGZhy{} 6*x*y\PYGZca{}2 + 4*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZhy{}4*x*y + 4*x\PYGZca{}2*y + 8*x*y\PYGZca{}2 \PYGZhy{} 8*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
    \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x*y \PYGZhy{} 2*x\PYGZca{}2*y \PYGZhy{} 2*x*y\PYGZca{}2 + 4*x\PYGZca{}2*y\PYGZca{}2\PYGZsq{}}
\end{sphinxVerbatim}

It is also possible to make use of the “object oriented” features of \sphinxstyleemphasis{Octave} and \sphinxstyleemphasis{MatLab}. As
you may have noticed, when a class “foo” is provided by the \sphinxstyleemphasis{getfem\sphinxhyphen{}interface}, it is build
with the function \sphinxcode{\sphinxupquote{gf\_foo}}, and manipulated with the functions \sphinxcode{\sphinxupquote{gf\_foo\_get}}
and \sphinxcode{\sphinxupquote{gf\_foo\_set}}. But you may also create the
object with the \sphinxcode{\sphinxupquote{gfFoo}} constructor , and manipulated with the \sphinxcode{\sphinxupquote{get(..)}} and
\sphinxcode{\sphinxupquote{set(..)}} methods. For example, the previous steps could have been:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gfFem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}QK(2,2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gfFem} \PYG{l+s}{object} \PYG{l+s}{ID=0} \PYG{l+s}{dim=2,} \PYG{l+s}{target\PYGZus{}dim=1,} \PYG{l+s}{nbdof=9,[EQUIV,} \PYG{l+s}{POLY,} \PYG{l+s}{LAGR],} \PYG{l+s}{est.degree=4}
  \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{FEM\PYGZus{}QK}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{=}\PYG{n}{gfMesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cartesian\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gfMesh} \PYG{l+s}{object} \PYG{l+s}{ID=0} \PYG{l+s}{[16512} \PYG{l+s}{bytes],} \PYG{l+s}{dim=2,} \PYG{l+s}{nbpts=121,} \PYG{l+s}{nbcvs=100}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf}\PYG{p}{=}\PYG{n}{gfMeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gfMeshFem} \PYG{l+s}{object:} \PYG{l+s}{ID=1} \PYG{l+s}{[804} \PYG{l+s}{bytes],} \PYG{l+s}{qdim=1,} \PYG{l+s}{nbdof=0,}
  \PYG{n}{linked} \PYG{l+s}{gfMesh} \PYG{l+s}{object:} \PYG{l+s}{dim=2,} \PYG{l+s}{nbpts=121,} \PYG{l+s}{nbcvs=100}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{set}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fem\PYGZsq{}}\PYG{p}{,} \PYG{n}{gfFem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}QK(2,2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf}
\PYG{n}{gfMeshFem} \PYG{l+s}{object:} \PYG{l+s}{ID=1} \PYG{l+s}{[1316} \PYG{l+s}{bytes],} \PYG{l+s}{qdim=1,} \PYG{l+s}{nbdof=441,}
  \PYG{n}{linked} \PYG{l+s}{gfMesh} \PYG{l+s}{object:} \PYG{l+s}{dim=2,} \PYG{l+s}{nbpts=121,} \PYG{l+s}{nbcvs=100}
\end{sphinxVerbatim}

Now, in order to perform numerical integrations on \sphinxcode{\sphinxupquote{mf}}, we need to \sphinxstylestrong{build a
mesh\_im object}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} assign the same integration method on all convexes}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mim} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{gf\PYGZus{}integ}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IM\PYGZus{}EXACT\PYGZus{}PARALLELEPIPED(2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The integration method will be used to compute the various integrals on each
element: here we choose to perform exact computations (no \index{quadrature formula@\spxentry{quadrature formula}}\index{environment variable@\spxentry{environment variable}!quadrature formula@\spxentry{quadrature formula}}\sphinxcode{\sphinxupquote{quadrature
formula}}), which is possible since the geometric transformation of these convexes
from the reference convex is linear (this is true for all simplices, and this is
also true for the parallelepipeds of our regular mesh, but it is not true for
general quadrangles), and the chosen FEM is polynomial. Hence it is possible to
analytically integrate every basis function/product of basis
functions/gradients/etc. There are many alternative FEM methods and integration
methods (see \DUrole{xref,std,std-ref}{ud}).

Note however that in the general case, approximate integration methods are a
better choice than exact integration methods.

Now we have to \sphinxstylestrong{find the} “\index{boundary@\spxentry{boundary}}\index{environment variable@\spxentry{environment variable}!boundary@\spxentry{boundary}}\sphinxcode{\sphinxupquote{boundary}}” \sphinxstylestrong{of the domain}, in order to
set a Dirichlet condition. A mesh object has the ability to store some sets of
convexes and convex faces. These sets (called “regions”) are accessed via an
integer \#id:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} detect the border of the mesh}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{border} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{outer faces\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} mark it as boundary \PYGZsh{}42}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{region\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{n}{border}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}plot\PYGZus{}mesh}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{regions\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{42}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c}{\PYGZpc{} the boundary edges appears in red}
\end{sphinxVerbatim}

Here we find the faces of the convexes which are on the boundary of the mesh (i.e.
the faces which are not shared by two convexes).
\begin{quote}

Remark:
\begin{quote}

we could have used \sphinxcode{\sphinxupquote{gf\_mesh\_get(m, \textquotesingle{}OuTEr\_faCes\textquotesingle{})}}, as the interface is
case\sphinxhyphen{}insensitive, and whitespaces can be replaced by underscores.
\end{quote}
\end{quote}

The array \sphinxcode{\sphinxupquote{border}} has two rows, on the first row is a convex number, on the
second row is a face number (which is local to the convex, there is no global
numbering of faces). Then this set of faces is assigned to the region number 42.

At this point, we just have to describe the model and run the solver to get the
solution! The “\index{model@\spxentry{model}}\index{environment variable@\spxentry{environment variable}!model@\spxentry{model}}\sphinxcode{\sphinxupquote{model}}” is created with the \sphinxcode{\sphinxupquote{gf\_model}} (or \sphinxcode{\sphinxupquote{gfModel}})
constructor. A model is basically an object which build a global linear system
(tangent matrix for non\sphinxhyphen{}linear problems) and its associated right hand side.
Typical modifications are insertion of the stiffness matrix for the problem
considered (linear elasticity, laplacian, etc), handling of a set of contraints,
Dirichlet condition, addition of a source term to the right hand side etc. The
global tangent matrix and its right hand side are stored in the “\index{model@\spxentry{model}}\index{environment variable@\spxentry{environment variable}!model@\spxentry{model}}\sphinxcode{\sphinxupquote{model}}”
structure.

Let us build a problem with an easy solution: \(u=x(x-1)y(y-1)+x^5\), then we
have \(\Delta u=2(x^2+y^2)-2(x+y)+20x^3\) (the FEM won’t be able to catch the
exact solution since we use a \(Q^2\) method).

We start with an empty real model:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} empty real model}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{md} \PYG{p}{=} \PYG{n}{gf\PYGZus{}model}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{real\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

(a model is either \sphinxcode{\sphinxupquote{\textquotesingle{}real\textquotesingle{}}} or \sphinxcode{\sphinxupquote{\textquotesingle{}complex\textquotesingle{}}}). And we declare that \sphinxcode{\sphinxupquote{u}} is an
unknown of the system on the finite element method \sphinxtitleref{mf} by:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} declare that \PYGZdq{}u\PYGZdq{} is an unknown of the system}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} on the finite element method `mf`}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add fem variable\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Now, we add a “generic elliptic” brick, which handles \(-\nabla\cdot(A:\nabla
u) = \ldots\) problems, where \(A\) can be a scalar field, a matrix field, or
an order 4 tensor field. By default, \(A=1\). We add it on our main variable
\sphinxcode{\sphinxupquote{u}} with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} add generic elliptic brick on \PYGZdq{}u\PYGZdq{}}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add Laplacian brick\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

Next we add a Dirichlet condition on the domain boundary:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} add Dirichlet condition}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{Uexact} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eval\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{(x\PYGZhy{}.5).\PYGZca{}2 + (y\PYGZhy{}.5).\PYGZca{}2 + x/5 \PYGZhy{} y/3\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add initialized fem data\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DirichletData\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{Uexact}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add Dirichlet condition with multipliers\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{l+m+mi}{42}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DirichletData\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The two first lines defines a data of the model which represents the value of the
Dirichlet condition. The third one add a Dirichlet condition to the variable \sphinxcode{\sphinxupquote{u}}
on the boundary number \sphinxcode{\sphinxupquote{42}}. The dirichlet condition is imposed with lagrange
multipliers. Another possibility is to use a penalization. A gfMeshFem argument is
also required, as the Dirichlet condition \(u=g\) is imposed in a weak form
\(\int_\Gamma u(x)v(x) = \int_\Gamma g(x)v(x) ~ \forall v\) where \(v\) is
taken in the space of multipliers given by here by \sphinxcode{\sphinxupquote{mf}}.

\begin{sphinxShadowBox}
\sphinxstyletopictitle{Remark:}

the polynomial expression was interpolated on \sphinxcode{\sphinxupquote{mf}}. It is possible only if
\sphinxcode{\sphinxupquote{mf}} is of Lagrange type. In this first example we use the same gfMeshFem for
the unknown and for the data such as \sphinxcode{\sphinxupquote{g}}, but in the general case, \sphinxcode{\sphinxupquote{mf}}
won’t be Lagrangian and another (Lagrangian) \sphinxtitleref{mesh\_fem} will be used for the
description of Dirichlet conditions, source terms etc.
\end{sphinxShadowBox}

A source term can be added with the following lines:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} add source term}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{f} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eval\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{2(x\PYGZca{}2+y\PYGZca{}2)\PYGZhy{}2(x+y)+20x\PYGZca{}3\PYGZsq{}} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add initialized fem data\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VolumicData\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{f}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add source term brick\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VolumicData\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

It only remains now to launch the solver. The linear system is assembled and solve
with the instruction:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} solve the linear system}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solve\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The model now contains the solution (as well as other things, such as the linear
system which was solved). It is extracted, a display into a \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab} figure:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} extracted solution}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{u} \PYG{p}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{variable\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{c}{\PYGZpc{} display}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}plot}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{n}{u}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Another Laplacian with exact solution}
\label{\detokenize{matlab_octave/examples:another-laplacian-with-exact-solution}}
This is the \sphinxcode{\sphinxupquote{tests/matlab\sphinxhyphen{}octave/demo\_laplacian.m}} example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZpc{} trace on;}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{clear all\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{m} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cartesian\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}m=gf\PYGZus{}mesh(\PYGZsq{}import\PYGZsq{},\PYGZsq{}structured\PYGZsq{},\PYGZsq{}GT=\PYGZdq{}GT\PYGZus{}QK(2,1)\PYGZdq{};SIZES=[1,1];NOISED=1;NSUBDIV=[1,1];\PYGZsq{})}

\PYG{c}{\PYGZpc{} create a mesh\PYGZus{}fem of for a field of dimension 1 (i.e. a scalar field)}
\PYG{n}{mf} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} assign the Q2 fem to all convexes of the mesh\PYGZus{}fem,}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fem\PYGZsq{}}\PYG{p}{,}\PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}QK(2,2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} Integration which will be used}
\PYG{n}{mim} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{n}{gf\PYGZus{}integ}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IM\PYGZus{}GAUSS\PYGZus{}PARALLELEPIPED(2,4)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{}mim = gf\PYGZus{}mesh\PYGZus{}im(m, gf\PYGZus{}integ(\PYGZsq{}IM\PYGZus{}STRUCTURED\PYGZus{}COMPOSITE(IM\PYGZus{}GAUSS\PYGZus{}PARALLELEPIPED(2,5),4)\PYGZsq{}));}
\PYG{c}{\PYGZpc{} detect the border of the mesh}
\PYG{n}{border} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{outer faces\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} mark it as boundary \PYGZsh{}1}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{boundary\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{border}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}plot\PYGZus{}mesh}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{regions\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c}{\PYGZpc{} the boundary edges appears in red}
\PYG{n}{pause}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} interpolate the exact solution}
\PYG{n}{Uexact} \PYG{p}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eval\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y.*(y\PYGZhy{}1).*x.*(x\PYGZhy{}1)+x.\PYGZca{}5\PYGZsq{}} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} its second derivative}
\PYG{n}{F}      \PYG{l+s}{=} \PYG{l+s}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get(mf,} \PYG{l+s}{\PYGZsq{}eval\PYGZsq{}}\PYG{l+s}{,} \PYG{l+s}{\PYGZob{}} \PYG{l+s}{\PYGZsq{}\PYGZhy{}(2*(x.\PYGZca{}2+y.\PYGZca{}2)\PYGZhy{}2*x\PYGZhy{}2*y+20*x.\PYGZca{}3)\PYGZsq{}} \PYG{l+s}{\PYGZcb{})}\PYG{p}{;}


\PYG{n}{md}\PYG{p}{=}\PYG{n}{gf\PYGZus{}model}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{real\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add fem variable\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add Laplacian brick\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add initialized fem data\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VolumicData\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{F}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add source term brick\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{VolumicData\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add initialized fem data\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DirichletData\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{Uexact}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{add Dirichlet condition with multipliers\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{DirichletData\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solve\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{U} \PYG{p}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{md}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{variable\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{u\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} Version with old bricks}
\PYG{c}{\PYGZpc{} b0=gf\PYGZus{}mdbrick(\PYGZsq{}generic elliptic\PYGZsq{},mim,mf);}
\PYG{c}{\PYGZpc{} b1=gf\PYGZus{}mdbrick(\PYGZsq{}dirichlet\PYGZsq{}, b0, 1, mf, \PYGZsq{}penalized\PYGZsq{});}
\PYG{c}{\PYGZpc{} gf\PYGZus{}mdbrick\PYGZus{}set(b1, \PYGZsq{}param\PYGZsq{}, \PYGZsq{}R\PYGZsq{}, mf, Uexact); }
\PYG{c}{\PYGZpc{} b2=gf\PYGZus{}mdbrick(\PYGZsq{}source term\PYGZsq{},b1);}
\PYG{c}{\PYGZpc{} gf\PYGZus{}mdbrick\PYGZus{}set(b2, \PYGZsq{}param\PYGZsq{}, \PYGZsq{}source\PYGZus{}term\PYGZsq{}, mf, F);}
\PYG{c}{\PYGZpc{} mds=gf\PYGZus{}mdstate(b1);}
\PYG{c}{\PYGZpc{} gf\PYGZus{}mdbrick\PYGZus{}get(b2, \PYGZsq{}solve\PYGZsq{}, mds)}
\PYG{c}{\PYGZpc{} U=gf\PYGZus{}mdstate\PYGZus{}get(mds, \PYGZsq{}state\PYGZsq{});}

\PYG{n+nb}{disp}\PYG{p}{(}\PYG{n}{sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{H1 norm of error: \PYGZpc{}g\PYGZsq{}}\PYG{p}{,} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{U}\PYG{o}{\PYGZhy{}}\PYG{n}{Uexact}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{H1 norm\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;} \PYG{n}{gf\PYGZus{}plot}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{contour\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{.01}\PYG{p}{:}\PYG{l+m+mf}{.01}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{)}\PYG{p}{;} 
\PYG{n}{colorbar}\PYG{p}{;} \PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{computed solution\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;} \PYG{n}{gf\PYGZus{}plot}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{U}\PYG{o}{\PYGZhy{}}\PYG{n}{Uexact}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} 
\PYG{n}{colorbar}\PYG{p}{;}\PYG{n}{title}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{difference with exact solution\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Linear and non\sphinxhyphen{}linear elasticity}
\label{\detokenize{matlab_octave/examples:linear-and-non-linear-elasticity}}
This example uses a mesh that was generated with \sphinxhref{http://gid.cimne.upc.es}{GiD}. The object is meshed
with quadratic tetrahedrons. You can find the \sphinxcode{\sphinxupquote{m\sphinxhyphen{}file}} of this example under
the name \sphinxcode{\sphinxupquote{demo\_tripod.m}} in the directory \sphinxcode{\sphinxupquote{tests/matlab\sphinxhyphen{}octave}} of the
toolbox distribution.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{This demo is an adaption of the original tripod demo\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{which uses the new \PYGZdq{}brick\PYGZdq{} framework of getfem\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{The code is shorter, faster and much more powerful\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{You can easily switch between linear/non linear\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{compressible/incompressible elasticity!\PYGZsq{}}\PYG{p}{)}

\PYG{n}{linear} \PYG{p}{=} \PYG{l+m+mi}{1}
\PYG{n}{incompressible} \PYG{p}{=} \PYG{l+m+mi}{0}


\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{clear all\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} import the mesh}
\PYG{n}{m}\PYG{p}{=}\PYG{n}{gfMesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{import\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{gid\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{../meshes/tripod.GiD.msh\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mfu}\PYG{p}{=}\PYG{n}{gfMeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}     \PYG{c}{\PYGZpc{} mesh\PYGZhy{}fem supporting a 3D\PYGZhy{}vector field}
\PYG{n}{mfd}\PYG{p}{=}\PYG{n}{gfMeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}     \PYG{c}{\PYGZpc{} scalar mesh\PYGZus{}fem, for data fields.}
\PYG{c}{\PYGZpc{} the mesh\PYGZus{}im stores the integration methods for each tetrahedron}
\PYG{n}{mim}\PYG{p}{=}\PYG{n}{gfMeshIm}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{n}{gf\PYGZus{}integ}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{IM\PYGZus{}TETRAHEDRON(5)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} we choose a P2 fem for the main unknown}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mfu}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fem\PYGZsq{}}\PYG{p}{,}\PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}PK(3,2)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} the material is homogeneous, hence we use a P0 fem for the data}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mfd}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fem\PYGZsq{}}\PYG{p}{,}\PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}PK(3,0)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} display some informations about the mesh}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{n}{sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbcvs=\PYGZpc{}d, nbpts=\PYGZpc{}d, nbdof=\PYGZpc{}d\PYGZsq{}}\PYG{p}{,}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbcvs\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{c}{...}
             \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbpts\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mfu}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbdof\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{P}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pts\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} \PYG{c}{\PYGZpc{} get list of mesh points coordinates}
\PYG{n}{pidtop}\PYG{p}{=}\PYG{n+nb}{find}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;} \PYG{c}{\PYGZpc{} find those on top of the object}
\PYG{n}{pidbot}\PYG{p}{=}\PYG{n+nb}{find}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{P}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{:}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{)}\PYG{p}{;} \PYG{c}{\PYGZpc{} find those on the bottom}
\PYG{c}{\PYGZpc{} build the list of faces from the list of points}
\PYG{n}{ftop}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{faces from pid\PYGZsq{}}\PYG{p}{,}\PYG{n}{pidtop}\PYG{p}{)}\PYG{p}{;} 
\PYG{n}{fbot}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{faces from pid\PYGZsq{}}\PYG{p}{,}\PYG{n}{pidbot}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} assign boundary numbers}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{ftop}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{boundary\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{fbot}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{E} \PYG{p}{=} \PYG{l+m+mf}{1e3}\PYG{p}{;} \PYG{n}{Nu} \PYG{p}{=} \PYG{l+m+mf}{0.3}\PYG{p}{;}
\PYG{c}{\PYGZpc{} set the Lame coefficients}
\PYG{n}{lambda} \PYG{p}{=} \PYG{n}{E}\PYG{o}{*}\PYG{n}{Nu}\PYG{o}{/}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{Nu}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{Nu}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{mu} \PYG{p}{=} \PYG{n}{E}\PYG{o}{/}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{n}{Nu}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} create a meshfem for the pressure field (used if incompressible \PYGZti{}= 0)}
\PYG{n}{mfp}\PYG{p}{=}\PYG{n}{gfMeshFem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;} \PYG{n}{set}\PYG{p}{(}\PYG{n}{mfp}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fem\PYGZsq{}}\PYG{p}{,}\PYG{n}{gfFem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}PK\PYGZus{}DISCONTINUOUS(3,0)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{linear}\PYG{p}{)}
  \PYG{c}{\PYGZpc{} the linearized elasticity , for small displacements}
  \PYG{n}{b0} \PYG{p}{=} \PYG{n}{gfMdBrick}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{isotropic\PYGZus{}linearized\PYGZus{}elasticity\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{,}\PYG{n}{mfu}\PYG{p}{)}
  \PYG{n}{set}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{param\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lambda\PYGZsq{}}\PYG{p}{,} \PYG{n}{lambda}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{set}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{param\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mu\PYGZsq{}}\PYG{p}{,} \PYG{n}{mu}\PYG{p}{)}\PYG{p}{;}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{incompressible}\PYG{p}{)}
    \PYG{n}{b1} \PYG{p}{=} \PYG{n}{gfMdBrick}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear incompressibility term\PYGZsq{}}\PYG{p}{,} \PYG{n}{b0}\PYG{p}{,} \PYG{n}{mfp}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{else}
    \PYG{l+s}{b1} \PYG{l+s}{=} \PYG{l+s}{b0}\PYG{p}{;}
  \PYG{k}{end}\PYG{p}{;}
\PYG{n}{else}
  \PYG{l+s}{\PYGZpc{}} \PYG{l+s}{See} \PYG{l+s}{also} \PYG{l+s}{demo\PYGZus{}nonlinear\PYGZus{}elasticity} \PYG{l+s}{for} \PYG{l+s}{a} \PYG{l+s}{better} \PYG{l+s}{example}
  \PYG{k}{if} \PYG{p}{(}\PYG{n}{incompressible}\PYG{p}{)}
    \PYG{n}{b0} \PYG{p}{=} \PYG{n}{gfMdBrick}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nonlinear elasticity\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Mooney Rivlin\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{b1} \PYG{p}{=} \PYG{n}{gfMdBrick}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nonlinear elasticity incompressibility term\PYGZsq{}}\PYG{p}{,}\PYG{n}{b0}\PYG{p}{,}\PYG{n}{mfp}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{set}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{param\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{params\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{n}{lambda}\PYG{p}{;}\PYG{n}{mu}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{else}
    \PYG{l+s}{\PYGZpc{}} \PYG{l+s}{large} \PYG{l+s}{deformation} \PYG{l+s}{with} \PYG{l+s}{a} \PYG{l+s}{linearized} \PYG{l+s}{material} \PYG{l+s}{law..} \PYG{l+s}{not}
    \PYG{c}{\PYGZpc{} a very good choice!}
    \PYG{n}{b0} \PYG{p}{=} \PYG{n}{gfMdBrick}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nonlinear elasticity\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{SaintVenant Kirchhoff\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{set}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{param\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{params\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{n}{lambda}\PYG{p}{;}\PYG{n}{mu}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{c}{\PYGZpc{}b0 = gfMdBrick(\PYGZsq{}nonlinear elasticity\PYGZsq{},mim, mfu, \PYGZsq{}Ciarlet Geymonat\PYGZsq{});}
    \PYG{n}{b1} \PYG{p}{=} \PYG{n}{b0}\PYG{p}{;}
  \PYG{k}{end}\PYG{p}{;}
\PYG{n}{end}

\PYG{l+s}{\PYGZpc{}} \PYG{l+s}{set} \PYG{l+s}{a} \PYG{l+s}{vertical} \PYG{l+s}{force} \PYG{l+s}{on} \PYG{l+s}{the} \PYG{l+s}{top} \PYG{l+s}{of} \PYG{l+s}{the} \PYG{l+s}{tripod}
\PYG{n}{b2} \PYG{p}{=} \PYG{n}{gfMdBrick}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{source term\PYGZsq{}}\PYG{p}{,} \PYG{n}{b1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{set}\PYG{p}{(}\PYG{n}{b2}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{param\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{source\PYGZus{}term\PYGZsq{}}\PYG{p}{,} \PYG{n}{mfd}\PYG{p}{,} \PYG{n}{get}\PYG{p}{(}\PYG{n}{mfd}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{eval\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} attach the tripod to the ground}
\PYG{n}{b3} \PYG{p}{=} \PYG{n}{gfMdBrick}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dirichlet\PYGZsq{}}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{penalized\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{mds}\PYG{p}{=}\PYG{n}{gfMdState}\PYG{p}{(}\PYG{n}{b3}\PYG{p}{)}

\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{running solve...\PYGZsq{}}\PYG{p}{)}

\PYG{n}{t0}\PYG{p}{=}\PYG{n}{cputime}\PYG{p}{;} 

\PYG{n}{get}\PYG{p}{(}\PYG{n}{b3}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solve\PYGZsq{}}\PYG{p}{,} \PYG{n}{mds}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{noisy\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{max\PYGZus{}iter\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{max\PYGZus{}res\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mf}{1e\PYGZhy{}6}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{lsolver\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{superlu\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{n}{sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solve done in \PYGZpc{}.2f sec\PYGZsq{}}\PYG{p}{,} \PYG{n}{cputime}\PYG{o}{\PYGZhy{}}\PYG{n}{t0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{mfdu}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{c}{\PYGZpc{} the P2 fem is not derivable across elements, hence we use a discontinuous}
\PYG{c}{\PYGZpc{} fem for the derivative of U.}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mfdu}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{fem\PYGZsq{}}\PYG{p}{,}\PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{FEM\PYGZus{}PK\PYGZus{}DISCONTINUOUS(3,1)\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{VM}\PYG{p}{=}\PYG{n}{get}\PYG{p}{(}\PYG{n}{b0}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{von mises\PYGZsq{}}\PYG{p}{,}\PYG{n}{mds}\PYG{p}{,}\PYG{n}{mfdu}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{U}\PYG{p}{=}\PYG{n}{get}\PYG{p}{(}\PYG{n}{mds}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{state\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{U}\PYG{p}{=}\PYG{n}{U}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{get}\PYG{p}{(}\PYG{n}{mfu}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbdof\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{plotting ... can also take some minutes!\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} we plot the von mises on the deformed object, in superposition}
\PYG{c}{\PYGZpc{} with the initial mesh.}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{linear}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{gf\PYGZus{}plot}\PYG{p}{(}\PYG{n}{mfdu}\PYG{p}{,}\PYG{n}{VM}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cvlst\PYGZsq{}}\PYG{p}{,} \PYG{n}{get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{outer faces\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{c}{...}
	  \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZsq{}}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZus{}mf\PYGZsq{}}\PYG{p}{,}\PYG{n}{mfu}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{else}
  \PYG{l+s}{gf\PYGZus{}plot(mfdu,VM,}\PYG{l+s}{\PYGZsq{}mesh\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}on\PYGZsq{}}\PYG{l+s}{,} \PYG{l+s}{\PYGZsq{}cvlst\PYGZsq{}}\PYG{l+s}{,} \PYG{l+s}{get(m,} \PYG{l+s}{\PYGZsq{}outer faces\PYGZsq{}}\PYG{l+s}{),...}
	  \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZsq{}}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZus{}mf\PYGZsq{}}\PYG{p}{,}\PYG{n}{mfu}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZus{}scale\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{end}\PYG{p}{;}

\PYG{n}{caxis}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{colorbar}\PYG{p}{;} \PYG{n}{view}\PYG{p}{(}\PYG{l+m+mi}{180}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{50}\PYG{p}{)}\PYG{p}{;} \PYG{n}{camlight}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}colormap}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tripod\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} the von mises stress is exported into a VTK file}
\PYG{c}{\PYGZpc{} (which can be viewed with \PYGZsq{}mayavi \PYGZhy{}d tripod.vtk \PYGZhy{}m BandedSurfaceMap\PYGZsq{})}
\PYG{c}{\PYGZpc{} see http://mayavi.sourceforge.net/}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mfdu}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{export to vtk\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tripod.vtk\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ascii\PYGZsq{}}\PYG{p}{,}\PYG{n}{VM}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{vm\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Here is the final figure, displaying the \index{Von Mises@\spxentry{Von Mises}}\index{environment variable@\spxentry{environment variable}!Von Mises@\spxentry{Von Mises}}\sphinxcode{\sphinxupquote{Von Mises}} stress:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=300bp]{{tripodvonmiseswithmesh}.png}
\caption{deformed tripod}\label{\detokenize{matlab_octave/examples:id1}}\label{\detokenize{matlab_octave/examples:malb-fig-tripod-vm}}\end{figure}


\section{Avoiding the bricks framework}
\label{\detokenize{matlab_octave/examples:avoiding-the-bricks-framework}}
The model bricks are very convenient, as they hide most of the details of the
assembly of the final linear systems. However it is also possible to stay at a
lower level, and handle the assembly of linear systems, and their resolution,
directly in \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab}. For example, the demonstration \sphinxcode{\sphinxupquote{demo\_tripod\_alt.m}} is
very similar to the \sphinxcode{\sphinxupquote{demo\_tripod.m}} except that the assembly is explicit:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nbd}\PYG{p}{=}\PYG{n}{get}\PYG{p}{(}\PYG{n}{mfd}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbdof\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{F} \PYG{p}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{boundary\PYGZus{}source\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{mfd}\PYG{p}{,} \PYG{n+nb}{repmat}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbd}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{K} \PYG{p}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear\PYGZus{}elasticity\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{mfd}\PYG{p}{,} \PYG{c}{...}
           \PYG{n}{lambda}\PYG{o}{*}\PYG{n+nb}{ones}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbd}\PYG{p}{)}\PYG{p}{,}\PYG{n}{mu}\PYG{o}{*}\PYG{n+nb}{ones}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbd}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} handle Dirichlet condition}
\PYG{p}{[}\PYG{n}{H}\PYG{p}{,}\PYG{n}{R}\PYG{p}{]}\PYG{p}{=}\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dirichlet\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mfu}\PYG{p}{,} \PYG{n}{mfd}\PYG{p}{,} \PYG{n+nb}{repmat}\PYG{p}{(}\PYG{n+nb}{eye}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{nbd}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{zeros}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{nbd}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{N}\PYG{p}{,}\PYG{n}{U0}\PYG{p}{]}\PYG{p}{=}\PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dirichlet\PYGZus{}nullspace\PYGZsq{}}\PYG{p}{,} \PYG{n}{R}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{KK}\PYG{p}{=}\PYG{n}{N}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{K}\PYG{o}{*}\PYG{n}{N}\PYG{p}{;}
\PYG{n}{FF}\PYG{p}{=}\PYG{n}{N}\PYG{o}{\PYGZsq{}}\PYG{o}{*}\PYG{n}{F}\PYG{p}{;}
\PYG{c}{\PYGZpc{} solve ...}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{solving...\PYGZsq{}}\PYG{p}{)}\PYG{p}{;} \PYG{n}{t0} \PYG{p}{=} \PYG{n}{cputime}\PYG{p}{;}
\PYG{n}{lsolver} \PYG{p}{=} \PYG{l+m+mi}{1} \PYG{c}{\PYGZpc{} change this to compare the different solvers}
\PYG{k}{if} \PYG{p}{(}\PYG{n}{lsolver} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}     \PYG{c}{\PYGZpc{} conjugate gradient}
  \PYG{n}{P}\PYG{p}{=}\PYG{n}{gfPrecond}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{ildlt\PYGZsq{}}\PYG{p}{,}\PYG{n}{KK}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{UU}\PYG{p}{=}\PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cg\PYGZsq{}}\PYG{p}{,}\PYG{n}{KK}\PYG{p}{,}\PYG{n}{FF}\PYG{p}{,}\PYG{n}{P}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{noisy\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{res\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{1e\PYGZhy{}9}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{elseif} \PYG{p}{(}\PYG{n}{lsolver} \PYG{o}{==} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,} \PYG{c}{\PYGZpc{} superlu}
  \PYG{n}{UU}\PYG{p}{=}\PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{superlu\PYGZsq{}}\PYG{p}{,}\PYG{n}{KK}\PYG{p}{,}\PYG{n}{FF}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{else}                   \PYG{l+s}{\PYGZpc{}} \PYG{l+s}{the} \PYG{l+s}{matlab} \PYG{l+s}{\PYGZdq{}slash\PYGZdq{}} \PYG{l+s}{operator}
  \PYG{n}{UU}\PYG{p}{=}\PYG{n}{KK} \PYG{o}{\PYGZbs{}} \PYG{n}{FF}\PYG{p}{;}
\PYG{k}{end}\PYG{p}{;}
\PYG{n+nb}{disp}\PYG{p}{(}\PYG{n}{sprintf}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{linear system solved in \PYGZbs{}\PYGZpc{}.2f sec\PYGZsq{}}\PYG{p}{,} \PYG{n}{cputime}\PYG{o}{\PYGZhy{}}\PYG{n}{t0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{U}\PYG{p}{=}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{n}{UU}\PYG{p}{)}\PYG{p}{.}\PYG{o}{\PYGZsq{}}\PYG{o}{+}\PYG{n}{U0}\PYG{p}{;}
\end{sphinxVerbatim}

In \sphinxstyleemphasis{getfem\sphinxhyphen{}interface}, the assembly of vectors, and matrices is done via the \sphinxcode{\sphinxupquote{gf\_asm}}
function. The Dirichlet condition \(u(x) = r(x)\) is handled in the weak form
\(\int (h(x)u(x)).v(x) = \int r(x).v(x)\quad \forall v\) (where \(h(x)\)
is a \(3\times3\) matrix field \textendash{} here it is constant and equal to the
identity). The reduced system \sphinxcode{\sphinxupquote{KK UU = FF}} is then built via the elimination of
Dirichlet constraints from the original system. Note that it might be more
efficient (and simpler) to deal with Dirichlet condition via a penalization
technique.


\section{Other examples}
\label{\detokenize{matlab_octave/examples:other-examples}}\begin{itemize}
\item {} 
the \sphinxcode{\sphinxupquote{demo\_refine.m}} script shows a simple 2D or 3D bar whose extremity is
clamped. An adaptative refinement is used to obtain a better approximation in
the area where the stress is singular (the transition between the clamped area
and the neumann boundary).

\item {} 
the \sphinxcode{\sphinxupquote{demo\_nonlinear\_elasticity.m}} script shows a 3D bar which is is
bended and twisted. This is a quasi\sphinxhyphen{}static problem as the deformation is
applied in many steps. At each step, a non\sphinxhyphen{}linear (large deformations)
elasticity problem is solved.

\item {} 
the \sphinxcode{\sphinxupquote{demo\_stokes\_3D\_tank.m}} script shows a Stokes (viscous fluid) problem
in a tank. The \sphinxcode{\sphinxupquote{demo\_stokes\_3D\_tank\_draw.m}} shows how to draw a nice plot
of the solution, with mesh slices and stream lines. Note that the
\sphinxcode{\sphinxupquote{demo\_stokes\_3D\_tank\_alt.m}} is the old example, which uses the deprecated
\sphinxcode{\sphinxupquote{gf\_solve}} function.

\item {} 
the \sphinxcode{\sphinxupquote{demo\_bilaplacian.m}} script is just an adaption of the \sphinxstyleemphasis{GetFEM} example
\sphinxcode{\sphinxupquote{tests/bilaplacian.cc}}. Solve the bilaplacian (or a Kirchhoff\sphinxhyphen{}Love plate
model) on a square.

\item {} 
the \sphinxcode{\sphinxupquote{demo\_plasticity.m}} script is an adaptation of the \sphinxstyleemphasis{GetFEM} example
\sphinxcode{\sphinxupquote{tests/plasticity.cc}}: a 2D or 3D bar is bended in many steps, and the
plasticity of the material is taken into account (plastification occurs when
the material’s Von Mises exceeds a given threshold).

\item {} 
the \sphinxcode{\sphinxupquote{demo\_wave2D.m}} is a 2D scalar wave equation example (diffraction of
a plane wave by a cylinder), with high order geometric transformations and high
order FEMs.

\end{itemize}


\section{Using Octave/Matlab Object\sphinxhyphen{}Oriented features}
\label{\detokenize{matlab_octave/examples:using-octave-matlab-object-oriented-features}}
The basic functions of the \sphinxstyleemphasis{GetFEM} toolbox do not use any advanced \sphinxstyleemphasis{Octave} or \sphinxstyleemphasis{MatLab} features
(except that the handles to getfem objects are stored in a small structure). But the toolbox comes with a set of objects, which encapsulate
the handles and make them look as real \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} objects. The aim is not to provide
extra\sphinxhyphen{}functionalities, but to have a better integration of the toolbox.

Here is an example of its use:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cartesian\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{m} \PYG{p}{=}
     \PYG{n}{id}\PYG{p}{:} \PYG{l+m+mi}{0}
    \PYG{n}{cid}\PYG{p}{:} \PYG{l+m+mi}{0}

\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m2}\PYG{p}{=}\PYG{n}{gfMesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cartesian\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{l+m+mf}{.1}\PYG{p}{:}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{gfMesh} \PYG{l+s}{object} \PYG{l+s}{ID=1} \PYG{l+s}{[17512} \PYG{l+s}{bytes],} \PYG{l+s}{dim=2,} \PYG{l+s}{nbpts=121,} \PYG{l+s}{nbcvs=100}
\PYG{c}{\PYGZpc{} while \PYGZbs{}kw\PYGZob{}m\PYGZcb{} is a simple structure, \PYGZbs{}kw\PYGZob{}m2\PYGZcb{} has been flagged}
\PYG{c}{\PYGZpc{} as  an object of class gfMesh.  Since the \PYGZbs{}texttt\PYGZob{}display\PYGZcb{} method for}
\PYG{c}{\PYGZpc{} these  objects  have  been  overloaded,  the  toolbox  displays  some}
\PYG{c}{\PYGZpc{} information about the mesh instead of the content of the structure.}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbpts\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{ans} \PYG{p}{=}
   \PYG{n}{121}
\PYG{l+s}{\PYGZpc{}} \PYG{l+s}{pseudo} \PYG{l+s}{member} \PYG{l+s}{access} \PYG{l+s}{(which} \PYG{l+s}{calls} \PYG{l+s}{\PYGZsh{}\PYGZsh{}gf\PYGZus{}mesh\PYGZus{}get(m2,}\PYG{l+s}{\PYGZsq{}nbpts\PYGZsq{}}\PYG{l+s}{))}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m2}\PYG{p}{.}\PYG{n}{nbpts}
\PYG{n+nb}{ans} \PYG{p}{=}
   \PYG{n}{121}
\end{sphinxVerbatim}

Refer to the OO\sphinxhyphen{}commands reference {\hyperref[\detokenize{matlab_octave/oocmd:mlab-oocmd}]{\sphinxcrossref{\DUrole{std,std-ref}{GetFEM OO\sphinxhyphen{}commands}}}} for more details.


\chapter{Draw Command reference}
\label{\detokenize{matlab_octave/plotcmdref:draw-command-reference}}\label{\detokenize{matlab_octave/plotcmdref:mlab-plotcmdref}}\label{\detokenize{matlab_octave/plotcmdref::doc}}

\section{gf\_colormap}
\label{\detokenize{matlab_octave/plotcmdref:gf-colormap}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}\PYG{p}{=}\PYG{n}{gf\PYGZus{}colormap}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

return a colormap, or change the current colormap.
name can be: ‘tripod’, ‘chouette’, ‘froid’, ‘tank’
or ‘earth’.
\end{quote}


\section{gf\_plot}
\label{\detokenize{matlab_octave/plotcmdref:gf-plot}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{hsurf}\PYG{p}{,} \PYG{n}{hcontour}\PYG{p}{,} \PYG{n}{hquiver}\PYG{p}{,} \PYG{n}{hmesh}\PYG{p}{,} \PYG{n}{hdefmesh}\PYG{p}{]}\PYG{p}{=}\PYG{n}{gf\PYGZus{}plot}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{c}{...)}

\PYG{n}{The} \PYG{l+s}{options} \PYG{l+s}{are} \PYG{l+s}{specified} \PYG{l+s}{as} \PYG{l+s}{pairs} \PYG{l+s}{of} \PYG{l+s}{\PYGZdq{}option} \PYG{l+s}{name\PYGZdq{}/\PYGZdq{}option} \PYG{l+s}{value\PYGZdq{}}

\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{zplot\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}       \PYG{p}{:} \PYG{n}{values} \PYG{n}{of} ``\PYG{n}{U}`` \PYG{n}{are} \PYG{n}{mapped} \PYG{n}{on} \PYG{n}{the} \PYGZdl{}\PYG{n}{z}\PYGZdl{}\PYG{o}{\PYGZhy{}}\PYG{n}{axis} \PYG{p}{(}\PYG{n}{only} \PYG{n}{possible} \PYG{n}{when} \PYG{n}{qdim}\PYG{p}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{mdim}\PYG{p}{=}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{norm\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}       \PYG{p}{:} \PYG{k}{if} \PYG{n}{qdim} \PYG{o}{\PYGZgt{}=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{\PYGZhy{}}\PYG{n}{plot} \PYG{n}{the} \PYG{n}{norm} \PYG{n}{of} \PYG{n}{the} \PYG{n}{field}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}                    \PYG{p}{:} \PYG{n}{or} \PYG{n}{the} \PYG{n}{scalar} \PYG{n}{product} \PYG{n}{of} \PYG{n}{the} \PYG{n}{field} \PYG{n}{with} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dir\PYGZsq{}} \PYG{p}{(}\PYG{n}{can} \PYG{n}{be} \PYG{n}{a} \PYG{n}{vector}\PYG{p}{,} \PYG{n}{or} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{x\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{y\PYGZsq{}} \PYG{n}{etc}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{refine\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{8}                  \PYG{p}{:} \PYG{n}{nb} \PYG{n}{of} \PYG{n}{refinments} \PYG{k}{for} \PYG{n}{curved} \PYG{n}{edges} \PYG{n}{and} \PYG{n}{surface} \PYG{n}{plots}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{interpolated\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{:} \PYG{k}{if} \PYG{n}{triangular} \PYG{n}{patch} \PYG{n}{are} \PYG{n}{interpolated}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pcolor\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{\PYGZcb{}}      \PYG{p}{:} \PYG{k}{if} \PYG{n}{the} \PYG{n}{field} \PYG{n}{is} \PYG{n}{scalar}\PYG{p}{,} \PYG{n}{a} \PYG{n}{color} \PYG{n}{plot} \PYG{n}{of} \PYG{n}{its} \PYG{n}{values} \PYG{n}{is} \PYG{n}{plotted}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quiver\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{\PYGZcb{}}      \PYG{p}{:} \PYG{k}{if} \PYG{n}{the} \PYG{n}{field} \PYG{n}{is} \PYG{n}{vector}\PYG{p}{,} \PYG{n}{represent} \PYG{n}{arrows}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quiver\PYGZus{}density\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{50}        \PYG{p}{:} \PYG{n}{density} \PYG{n}{of} \PYG{n}{arrows} \PYG{n}{in} \PYG{n}{quiver} \PYG{n}{plot}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quiver\PYGZus{}scale\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}           \PYG{p}{:} \PYG{n}{scaling} \PYG{n}{of} \PYG{n}{arrows} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{=}\PYG{o}{\PYGZgt{}}\PYG{n}{no} \PYG{n}{scaling}\PYG{p}{)}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}         \PYG{p}{:} \PYG{n}{show} \PYG{n}{the} \PYG{n}{mesh} ?
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{meshopts\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{n}{cell}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}           \PYG{p}{:} \PYG{n}{cell} \PYG{n}{array} \PYG{n}{of} \PYG{n}{options} \PYG{n}{passed} \PYG{n}{to} \PYG{n}{gf\PYGZus{}plot\PYGZus{}slice} \PYG{k}{for} \PYG{n}{the} \PYG{n}{mesh}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformed\PYGZus{}mesh\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}} \PYG{p}{:} \PYG{n}{shows} \PYG{n}{the} \PYG{n}{deformed} \PYG{n}{mesh} \PYG{p}{(}\PYG{n}{only} \PYG{n}{when} \PYG{n}{qdim} \PYG{o}{==} \PYG{n}{mdim}\PYG{p}{)}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformed\PYGZus{}meshopts\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{cell}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{:} \PYG{n}{cell} \PYG{n}{array} \PYG{n}{of} \PYG{n}{options} \PYG{n}{passed} \PYG{n}{to} \PYG{n}{gf\PYGZus{}plot\PYGZus{}slice} \PYG{k}{for} \PYG{n}{the} \PYG{n}{deformed} \PYG{n}{mesh}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}            \PYG{p}{:} \PYG{n}{plots} \PYG{n}{on} \PYG{n}{the} \PYG{n}{deformed} \PYG{n}{object} \PYG{p}{(}\PYG{n}{only} \PYG{n}{when} \PYG{n}{qdim} \PYG{o}{==} \PYG{n}{mdim}\PYG{p}{)}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZus{}mf\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}        \PYG{p}{:} \PYG{n}{plots} \PYG{n}{on} \PYG{n}{the} \PYG{n}{deformed} \PYG{n}{object} \PYG{p}{(}\PYG{n}{only} \PYG{n}{when} \PYG{n}{qdim} \PYG{o}{==} \PYG{n}{mdim}\PYG{p}{)}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZus{}scale\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{10\PYGZpc{}\PYGZsq{}}  \PYG{p}{:} \PYG{n}{indicate} \PYG{n}{the} \PYG{n}{amplitude} \PYG{n}{of} \PYG{n}{the} \PYG{n}{deformation}\PYG{p}{.} \PYG{n}{Can} \PYG{n}{be} \PYG{n}{a} \PYG{n}{percentage} \PYG{n}{of} \PYG{n}{the} \PYG{n}{mesh} \PYG{n}{width} \PYG{k}{if} \PYG{n}{given} \PYG{n}{as} \PYG{n}{a} \PYG{n}{string}\PYG{p}{,} \PYG{n}{or} \PYG{n}{an} \PYG{n}{absolute} \PYG{n}{value} \PYG{k}{if} \PYG{n}{given} \PYG{n}{as} \PYG{n}{a} \PYG{n}{number}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cvlst\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}                  \PYG{p}{:} \PYG{n}{list} \PYG{n}{of} \PYG{n}{convexes} \PYG{n}{to} \PYG{n}{plot} \PYG{p}{(}\PYG{n}{empty}\PYG{p}{=}\PYG{o}{\PYGZgt{}}\PYG{n}{all} \PYG{n}{convexes}\PYG{p}{)}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{title\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}                 \PYG{p}{:} \PYG{n}{set} \PYG{n}{the} \PYG{n}{title}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{contour\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}               \PYG{p}{:} \PYG{n}{list} \PYG{n}{of} \PYG{n}{contour} \PYG{n}{values}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{disp\PYGZus{}options\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}} \PYG{p}{:} \PYG{n}{shows} \PYG{n}{the} \PYG{n}{option} \PYG{n}{or} \PYG{n}{not}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

The function expects \sphinxcode{\sphinxupquote{U}} to be a row vector. If \sphinxcode{\sphinxupquote{U}} is a scalar
field, then \sphinxcode{\sphinxupquote{gf\textbackslash{}\_plot(mf,U)}} will fill the mesh with colors
representing the values of \sphinxcode{\sphinxupquote{U}}. If \sphinxcode{\sphinxupquote{U}} is a vector field, then
the default behavior of \sphinxcode{\sphinxupquote{gf\_plot}} is to draw vectors representing
the values of \sphinxcode{\sphinxupquote{U}}.

On output, this function returns the handles to the various
graphical objects created: \sphinxcode{\sphinxupquote{hmesh}} is the handles to the mesh
lines, \sphinxcode{\sphinxupquote{hbound}} is the handles to the edges of the boundaries, \sphinxcode{\sphinxupquote{hfill}}
is the handle of the patch objects of faces, \sphinxcode{\sphinxupquote{hvert}} (resp
\sphinxcode{\sphinxupquote{hconv}}, \sphinxcode{\sphinxupquote{hdof}}) is the handles of the vertices (resp. convexes,
dof) labels.

For example, plotting a scalar field on the border of a 3D mesh can be done with

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZpc{} load the \PYGZsq{}strange.mesh\PYGZus{}fem\PYGZsq{} (found in the getfem\PYGZus{}matlab/tests directory)}
\PYG{n}{mf}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{load\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{strange.mesh\PYGZus{}fem\PYGZsq{}}\PYG{p}{)}
\PYG{n}{U}\PYG{p}{=}\PYG{n+nb}{rand}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{nbdof\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYGZsh{} \PYG{n}{random} \PYG{n}{field} \PYG{n}{that} \PYG{n}{will} \PYG{n}{be} \PYG{n}{drawn}
\PYG{n}{gf\PYGZus{}plot}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{refine\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cvlst\PYGZsq{}}\PYG{p}{,} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{outer faces\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}


\section{gf\_plot\_1D}
\label{\detokenize{matlab_octave/plotcmdref:gf-plot-1d}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}plot\PYGZus{}1D}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{c}{...)}

\PYG{n}{The} \PYG{l+s}{options} \PYG{l+s}{are} \PYG{l+s}{specified} \PYG{l+s}{as} \PYG{l+s}{pairs} \PYG{l+s}{of} \PYG{l+s}{\PYGZdq{}option} \PYG{l+s}{name\PYGZdq{}/\PYGZdq{}option} \PYG{l+s}{value\PYGZdq{}}


\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{style\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{bo\PYGZhy{}\PYGZsq{}}       \PYG{p}{:} \PYG{n}{the} \PYG{n}{line} \PYG{n}{style} \PYG{n}{and} \PYG{n}{dof} \PYG{n}{marker} \PYG{n}{style} \PYG{p}{(}\PYG{n}{same} \PYG{n}{syntax} \PYG{n}{as} \PYG{n}{in} \PYG{n}{the} \PYG{n}{matlab} \PYG{n}{command} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{plot\PYGZsq{}}\PYG{p}{)}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{color\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}          \PYG{p}{:} \PYG{n}{override} \PYG{n}{the} \PYG{n}{line} \PYG{n}{color}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dof\PYGZus{}color\PYGZsq{}}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{:} \PYG{n}{color} \PYG{n}{of} \PYG{n}{the} \PYG{n}{markers} \PYG{k}{for} \PYG{n}{the} \PYG{n}{degrees} \PYG{n}{of} \PYG{n}{freedom}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{width\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{2}           \PYG{p}{:} \PYG{n}{line} \PYG{n}{width}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

This function plots a 1D finite elements field.
\end{quote}


\section{gf\_plot\_mesh}
\label{\detokenize{matlab_octave/plotcmdref:gf-plot-mesh}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}plot\PYGZus{}mesh}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{c}{...)}

\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{vertices\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}    \PYG{p}{:} \PYG{n}{displays} \PYG{n}{also} \PYG{n}{vertices} \PYG{n}{numbers}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{convexes\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}    \PYG{p}{:} \PYG{n}{displays} \PYG{n}{also} \PYG{n}{convexes} \PYG{n}{numbers}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{dof\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}          \PYG{p}{:} \PYG{n}{displays} \PYG{n}{also} \PYG{n}{finite} \PYG{n}{element} \PYG{n}{nodes}\PYG{p}{.} \PYG{n}{In} \PYG{n}{that} \PYG{k}{case}\PYG{p}{,} ``\PYG{n}{m}`` \PYG{n}{should} \PYG{n}{be} \PYG{n}{a} ``\PYG{n}{mesh\PYGZus{}fem}`` \PYG{n}{identifier}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{regions\PYGZsq{}}\PYG{p}{,}\PYG{n}{BLST}              \PYG{p}{:} \PYG{n}{displays} \PYG{n}{the} \PYG{n}{boundaries} \PYG{n}{listed} \PYG{n}{in} \PYG{n}{BLST}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cvlst\PYGZsq{}}\PYG{p}{,}\PYG{n}{CVLST}               \PYG{p}{:} \PYG{n}{display} \PYG{n}{only} \PYG{n}{the} \PYG{n}{listed} \PYG{n}{convexes}\PYG{p}{.} \PYG{n}{If} \PYG{n}{CVLST} \PYG{n}{has} \PYG{n}{two} \PYG{n}{rows}\PYG{p}{,} \PYG{n}{display} \PYG{n}{only} \PYG{n}{the} \PYG{n}{faces} \PYG{n}{listed} \PYG{n}{in} \PYG{n}{the} \PYG{n}{second} \PYG{n}{row}\PYG{p}{.}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{edges\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}} \PYG{o}{|} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{\PYGZcb{}}     \PYG{p}{:} \PYG{n}{display} \PYG{n}{edges} ?
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{faces\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}       \PYG{p}{:} \PYG{n}{fills} \PYG{n}{each} 2\PYG{n}{D}\PYG{o}{\PYGZhy{}}\PYG{n}{face} \PYG{n}{of} \PYG{n}{the} \PYG{n}{mesh}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{curved\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{o}{|}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{\PYGZcb{}}      \PYG{p}{:} \PYG{n}{displays} \PYG{n}{curved} \PYG{n}{edges}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{refine\PYGZsq{}}\PYG{p}{,}\PYG{n}{N}                  \PYG{p}{:} \PYG{n}{refine} \PYG{n}{curved} \PYG{n}{edges} \PYG{n}{and} \PYG{n}{filled} \PYG{n}{faces} \PYG{n}{N} \PYG{n}{times}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{deformation\PYGZsq{}}\PYG{p}{,} \PYG{n}{Udef}         \PYG{p}{:} \PYG{n}{optionnal} \PYG{n}{deformation} \PYG{n}{applied} \PYG{n}{to} \PYG{n}{the} \PYG{n}{mesh} \PYG{p}{(}\PYG{n}{M} \PYG{n}{must} \PYG{n}{be} \PYG{n}{a} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{object}\PYG{p}{)}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{edges\PYGZus{}color\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{.6} \PYG{l+m+mf}{.6} \PYG{l+m+mi}{1}\PYG{p}{]}     \PYG{p}{:} \PYG{n}{RGB} \PYG{n}{values} \PYG{k}{for} \PYG{n}{the} \PYG{n}{color} \PYG{n}{of} \PYG{n}{edges}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{edges\PYGZus{}width\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}             \PYG{p}{:} \PYG{n}{width} \PYG{n}{of} \PYG{n}{edges}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{faces\PYGZus{}color\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{.75} \PYG{l+m+mf}{.75} \PYG{l+m+mf}{.75}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{n}{RGB} \PYG{n}{values} \PYG{k}{for} \PYG{n}{the} \PYG{n}{color} \PYG{n}{of} \PYG{n}{faces}
\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{quality\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}} \PYG{o}{|} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}} \PYG{p}{\PYGZcb{}}  \PYG{p}{:} \PYG{n}{Display} \PYG{n}{the} \PYG{n}{quality} \PYG{n}{of} \PYG{n}{the} \PYG{n}{mesh}\PYG{p}{.}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

This function is used to display a mesh.

Example

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZpc{} the mesh is in the tests directory of the distribution}
\PYG{n}{m}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{import\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{gid\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{donut\PYGZus{}with\PYGZus{}quadratic\PYGZus{}tetra\PYGZus{}314\PYGZus{}elements.msh\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}plot\PYGZus{}mesh}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{refine\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{cvlst\PYGZsq{}}\PYG{p}{,}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{outer faces\PYGZsq{}}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{faces\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{n}{ldots}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{faces\PYGZus{}color\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{1.} \PYG{l+m+mf}{.9} \PYG{l+m+mf}{.2}\PYG{p}{]}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{curved\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{edges\PYGZus{}width\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{camlight} \PYG{l+s}{\PYGZpc{}} \PYG{l+s}{turn} \PYG{l+s}{on} \PYG{l+s}{the} \PYG{l+s}{light!}
\end{sphinxVerbatim}
\end{quote}


\section{gf\_plot\_slice}
\label{\detokenize{matlab_octave/plotcmdref:gf-plot-slice}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}plot\PYGZus{}slice}\PYG{p}{(}\PYG{n}{sl}\PYG{p}{,} \PYG{c}{...)}

\PYG{n}{The} \PYG{l+s}{options} \PYG{l+s}{are} \PYG{l+s}{specified} \PYG{l+s}{as} \PYG{l+s}{pairs} \PYG{l+s}{of} \PYG{l+s}{\PYGZdq{}option} \PYG{l+s}{name\PYGZdq{}/\PYGZdq{}option} \PYG{l+s}{value\PYGZdq{}}


\PYG{n}{data}    \PYG{l+s}{[]}          \PYG{l+s}{:} \PYG{l+s}{data} \PYG{l+s}{to} \PYG{l+s}{be} \PYG{l+s}{plotted} \PYG{l+s}{(one} \PYG{l+s}{value} \PYG{l+s}{per} \PYG{l+s}{slice} \PYG{l+s}{node)}
\PYG{n}{convex\PYGZus{}data}    \PYG{l+s}{[]}   \PYG{l+s}{:} \PYG{l+s}{data} \PYG{l+s}{to} \PYG{l+s}{be} \PYG{l+s}{plotted} \PYG{l+s}{(one} \PYG{l+s}{value} \PYG{l+s}{per} \PYG{l+s}{mesh} \PYG{l+s}{convex)}
\PYG{n}{mesh}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{auto\PYGZsq{}}\PYG{p}{]}      \PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{show} \PYG{n}{the} \PYG{n}{mesh} \PYG{p}{(}\PYG{n}{faces} \PYG{n}{of} \PYG{n}{edges}\PYG{p}{)}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ignore} \PYG{n}{mesh}
\PYG{n}{mesh\PYGZus{}edges}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{]}  \PYG{p}{:} \PYG{n}{show} \PYG{n}{mesh} \PYG{n}{edges} ?
\PYG{n}{mesh\PYGZus{}edges\PYGZus{}color}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.60} \PYG{l+m+mf}{0.60} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{:} \PYG{n}{color} \PYG{n}{of} \PYG{n}{mesh} \PYG{n}{edges}
\PYG{n}{mesh\PYGZus{}edges\PYGZus{}width}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.70}\PYG{p}{]} \PYG{p}{:} \PYG{n}{width} \PYG{n}{of} \PYG{n}{mesh} \PYG{n}{edges}
\PYG{n}{mesh\PYGZus{}slice\PYGZus{}edges}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{]} \PYG{p}{:} \PYG{n}{show} \PYG{n}{edges} \PYG{n}{of} \PYG{n}{the} \PYG{n}{slice} ?
\PYG{n}{mesh\PYGZus{}slice\PYGZus{}edges\PYGZus{}color}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.70} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{:} \PYG{n}{color} \PYG{n}{of} \PYG{n}{slice} \PYG{n}{edges}
\PYG{n}{mesh\PYGZus{}slice\PYGZus{}edges\PYGZus{}width}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.50}\PYG{p}{]} \PYG{p}{:} \PYG{n}{width} \PYG{n}{of} \PYG{n}{slice} \PYG{n}{edges}
\PYG{n}{mesh\PYGZus{}faces}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{]} \PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{fill} \PYG{n}{mesh} \PYG{n}{faces} \PYG{p}{(}\PYG{k}{otherwise} \PYG{n}{they} \PYG{n}{are} \PYG{n}{transparent}\PYG{p}{)}
\PYG{n}{mesh\PYGZus{}faces\PYGZus{}color}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mf}{0.75} \PYG{l+m+mf}{0.75} \PYG{l+m+mf}{0.75}\PYG{p}{]}
\PYG{n}{pcolor}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{]}      \PYG{p}{:} \PYG{k}{if} \PYG{n}{the} \PYG{n}{field} \PYG{n}{is} \PYG{n}{scalar}\PYG{p}{,} \PYG{n}{a} \PYG{n}{color} \PYG{n}{plot} \PYG{n}{of} \PYG{n}{its} \PYG{n}{values} \PYG{n}{is} \PYG{n}{plotted}
\PYG{n}{quiver}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{]}      \PYG{p}{:} \PYG{k}{if} \PYG{n}{the} \PYG{n}{field} \PYG{n}{is} \PYG{n}{vector}\PYG{p}{,} \PYG{n}{represent} \PYG{n}{arrows}
\PYG{n}{quiver\PYGZus{}density}\PYG{p}{,} \PYG{l+m+mi}{50}  \PYG{p}{:} \PYG{n}{density} \PYG{n}{of} \PYG{n}{arrows} \PYG{n}{in} \PYG{n}{quiver} \PYG{n}{plot}
\PYG{n}{quiver\PYGZus{}scale}\PYG{p}{,} \PYG{l+m+mi}{1}     \PYG{p}{:} \PYG{n}{density} \PYG{n}{of} \PYG{n}{arrows} \PYG{n}{in} \PYG{n}{quiver} \PYG{n}{plot}
\PYG{n}{tube}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{]}        \PYG{p}{:} \PYG{n}{use} \PYG{n}{tube} \PYG{n}{plot} \PYG{k}{for} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{filar\PYGZsq{}} \PYG{p}{(}1\PYG{n}{D}\PYG{p}{)} \PYG{n}{parts} \PYG{n}{of} \PYG{n}{the} \PYG{n}{slice}
\PYG{n}{tube\PYGZus{}color}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{red\PYGZsq{}}\PYG{p}{]} \PYG{p}{:} \PYG{n}{color} \PYG{n}{of} \PYG{n}{tubes} \PYG{p}{(}\PYG{n}{ignored} \PYG{k}{if} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data\PYGZsq{}} \PYG{n}{is} \PYG{n}{not} \PYG{n}{empty} \PYG{n}{and} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pcolor\PYGZsq{}} \PYG{n}{is} \PYG{n}{on}\PYG{p}{)}
\PYG{n}{tube\PYGZus{}radius}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{0.5\PYGZpc{}\PYGZsq{}}\PYG{p}{]} \PYG{p}{:} \PYG{n}{tube} \PYG{n}{radius}\PYG{p}{;} \PYG{n}{you} \PYG{l+s}{can} \PYG{l+s}{use} \PYG{l+s}{a} \PYG{l+s}{constant,} \PYG{l+s}{or} \PYG{l+s}{a} \PYG{l+s}{percentage} \PYG{l+s}{(of} \PYG{l+s}{the} \PYG{l+s}{mesh} \PYG{l+s}{size)} \PYG{l+s}{or} \PYG{l+s}{a} \PYG{l+s}{vector} \PYG{l+s}{of} \PYG{l+s}{nodal} \PYG{l+s}{values}
\PYG{n}{showoptions}\PYG{p}{,} \PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{]} \PYG{p}{:} \PYG{n}{display} \PYG{n}{the} \PYG{n}{list} \PYG{n}{of} \PYG{n}{options}

\PYG{n}{the} \PYG{l+s}{\PYGZsq{}data\PYGZsq{}} \PYG{l+s}{and} \PYG{l+s}{\PYGZsq{}convex\PYGZus{}data\PYGZsq{}} \PYG{l+s}{are} \PYG{l+s}{mutually} \PYG{l+s}{exclusive.}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

This function can be used to plot mesh slices. It is also used by the \sphinxcode{\sphinxupquote{gf\_plot\_mesh}} and \sphinxcode{\sphinxupquote{gf\_plot}} functions.

Example : consider that you have a 3D mesh\_fem \sphinxcode{\sphinxupquote{mf}} and a vector field \sphinxcode{\sphinxupquote{U}} defined on this mesh\_fem, solution of the Stokes problem in a tank (see the demo \sphinxcode{\sphinxupquote{demo\_stokes\_3D\_tank\_draw.m}} in the tests directory).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{figure}\PYG{p}{;}
\PYG{c}{\PYGZpc{} slice the mesh with two half spaces, and take the boundary of the resulting quarter\PYGZhy{}cylinder}
\PYG{n}{sl}\PYG{p}{=}\PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{boundary\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intersection\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{planar\PYGZsq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{n}{ldots}
                                          \PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{planar\PYGZsq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Usl}\PYG{p}{=}\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{pde}\PYG{p}{.}\PYG{n}{mf\PYGZus{}u}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{interpolate on\PYGZsq{}}\PYG{p}{,} \PYG{n}{sl}\PYG{p}{)}\PYG{p}{;}  \PYG{c}{\PYGZpc{} interpolate the solution on the slice}
\PYG{c}{\PYGZpc{} show the norm of the displacement on this slice}
\PYG{n}{gf\PYGZus{}plot\PYGZus{}slice}\PYG{p}{(}\PYG{n}{sl}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{sqrt}\PYG{p}{(}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{Usl}\PYG{o}{.\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZus{}slice\PYGZus{}edges\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} another slice: now we take the lower part of the mesh}
\PYG{n}{sl}\PYG{p}{=}\PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{boundary\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{intersection\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{planar\PYGZsq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{n}{ldots}
                                        \PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{planar\PYGZsq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Usl}\PYG{p}{=}\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{pde}\PYG{p}{.}\PYG{n}{mf\PYGZus{}u}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{interpolate on\PYGZsq{}}\PYG{p}{,} \PYG{n}{sl}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{hold} \PYG{l+s}{on}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}plot\PYGZus{}slice}\PYG{p}{(}\PYG{n}{sl}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{data\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{sqrt}\PYG{p}{(}\PYG{n}{sum}\PYG{p}{(}\PYG{n}{Usl}\PYG{o}{.\PYGZca{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZus{}slice\PYGZus{}edges\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} this slice contains the transparent mesh faces displayed on the picture}
\PYG{n}{sl2}\PYG{p}{=}\PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{boundary\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{planar\PYGZsq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{o}{\PYGZbs{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{o}{\PYGZbs{}}\PYG{n}{ldots}
            \PYG{n}{m}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{setdiff}\PYG{p}{(}\PYG{n}{all\PYGZus{}faces}\PYG{o}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{TOPfaces}\PYG{o}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{rows\PYGZsq{}}\PYG{p}{)}\PYG{o}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{gf\PYGZus{}plot\PYGZus{}slice}\PYG{p}{(}\PYG{n}{sl2}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZus{}faces\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{on\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pcolor\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} last step is to plot the streamlines}
\PYG{n}{hh}\PYG{p}{=}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{5} \PYG{l+m+mi}{9} \PYG{l+m+mf}{12.5} \PYG{l+m+mi}{16} \PYG{l+m+mf}{19.5}\PYG{p}{]}\PYG{p}{;} \PYG{c}{\PYGZpc{} vertical position of the different starting points of the streamlines}
\PYG{n}{H}\PYG{p}{=}\PYG{p}{[}\PYG{n+nb}{zeros}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n+nb}{numel}\PYG{p}{(}\PYG{n}{hh}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{n}{hh}\PYG{p}{]}\PYG{p}{;}

\PYG{c}{\PYGZpc{} compute the streamlines}
\PYG{n}{tsl}\PYG{p}{=}\PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{streamlines\PYGZsq{}}\PYG{p}{,}\PYG{n}{pde}\PYG{p}{.}\PYG{n}{mf\PYGZus{}u}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{n}{H}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{Utsl}\PYG{p}{=}\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{pde}\PYG{p}{.}\PYG{n}{mf\PYGZus{}u}\PYG{p}{,}\PYG{n}{U}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{interpolate on\PYGZsq{}}\PYG{p}{,} \PYG{n}{tsl}\PYG{p}{)}\PYG{p}{;}

\PYG{c}{\PYGZpc{} render them with \PYGZdq{}tube plot\PYGZdq{}}
\PYG{p}{[}\PYG{n}{a}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{=}\PYG{n}{gf\PYGZus{}plot\PYGZus{}slice}\PYG{p}{(}\PYG{n}{tsl}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{mesh\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{off\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tube\PYGZus{}radius\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{.2}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{tube\PYGZus{}color\PYGZsq{}}\PYG{p}{,}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{white\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{hold} \PYG{l+s}{off}\PYG{p}{;}
\PYG{c}{\PYGZpc{} use a nice colormap}
\PYG{n}{caxis}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mf}{.7}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{c}\PYG{p}{=}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{0} \PYG{l+s}{.5} \PYG{l+s}{1}\PYG{p}{;} \PYG{n}{0} \PYG{l+s}{1} \PYG{l+s}{.5}\PYG{p}{;} \PYG{n}{0} \PYG{l+s}{1} \PYG{l+s}{0}\PYG{p}{;} \PYG{l+m+mf}{.5} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{1} \PYG{l+s}{.5} \PYG{l+s}{0}\PYG{p}{;} \PYG{n}{1} \PYG{l+s}{.4} \PYG{l+s}{0}\PYG{p}{;} \PYG{n}{1} \PYG{l+s}{0} \PYG{l+s}{0}\PYG{p}{;} \PYG{n}{1} \PYG{l+s}{.2} \PYG{l+s}{0}\PYG{p}{;} \PYG{n}{1} \PYG{l+s}{.4} \PYG{l+s}{0}\PYG{p}{;} \PYG{n}{1} \PYG{l+s}{.6} \PYG{l+s}{0}\PYG{p}{;} \PYG{n}{1} \PYG{l+s}{.8} \PYG{l+s}{0]}\PYG{p}{;}
\PYG{n}{colormap}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}


\chapter{Command reference}
\label{\detokenize{matlab_octave/cmdref:command-reference}}\label{\detokenize{matlab_octave/cmdref:mlab-cmdref}}\label{\detokenize{matlab_octave/cmdref::doc}}
Please remember that this documentation is not self contained.
You should in particular refer to the \sphinxhref{http://getfem.org/userdoc/index.html}{user documentation}
to have a more extensive description of the structures algorithms
and concepts used.

The expected type of each function argument is indicated in this
reference. Here is a list of these types:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

\sphinxtitleref{int}
&
integer value
\\
\hline
\sphinxtitleref{hobj}
&
a handle for any GetFEM object
\\
\hline
\sphinxtitleref{scalar}
&
scalar value
\\
\hline
\sphinxtitleref{string}
&
string
\\
\hline
\sphinxtitleref{ivec}
&
vector of integer values
\\
\hline
\sphinxtitleref{vec}
&
vector
\\
\hline
\sphinxtitleref{imat}
&
matrix of integer values
\\
\hline
\sphinxtitleref{mat}
&
matrix
\\
\hline
\sphinxtitleref{spmat}
&
sparse matrix (both matlab native sparse
matrices, and GetFEM sparse matrices)
\\
\hline
\sphinxtitleref{precond}
&
GetFEM preconditioner object
\\
\hline
\sphinxtitleref{mesh mesh}
&
object descriptor (or gfMesh object)
\\
\hline
\sphinxtitleref{mesh\_fem}
&
mesh fem object descriptor (or gfMeshFem object)
\\
\hline
\sphinxtitleref{mesh\_im}
&
mesh im object descriptor (or gfMeshIm object)
\\
\hline
\sphinxtitleref{mesh\_im\_data}
&
mesh im data object descriptor (or gfMeshImData object)
\\
\hline
\sphinxtitleref{mesh\_slice}
&
mesh slice object descriptor (or gfSlice object)
\\
\hline
\sphinxtitleref{cvstruct}
&
convex structure descriptor (or gfCvStruct object)
\\
\hline
\sphinxtitleref{geotrans}
&
geometric transformation descriptor (or
gfGeoTrans object)
\\
\hline
\sphinxtitleref{fem}
&
fem descriptor (or gfFem object)
\\
\hline
\sphinxtitleref{eltm}
&
elementary matrix descriptor (or gfEltm object)
\\
\hline
\sphinxtitleref{integ}
&
integration method descriptor (or gfInteg object)
\\
\hline
\sphinxtitleref{model}
&
model descriptor (or gfModel object)
\\
\hline
\sphinxtitleref{global\_function}
&
global function descriptor
\\
\hline
\sphinxtitleref{mesher\_object}
&
mesher object descriptor
\\
\hline
\sphinxtitleref{cont\_struct}
&
continuation\sphinxhyphen{}structure descriptor
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

Arguments listed between square brackets are optional. Lists between braces indicate that the argument must match one of the elements of the list. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{p}{[}\PYG{n}{X}\PYG{p}{,}\PYG{n}{Y}\PYG{p}{]}\PYG{p}{=}\PYG{n}{dummy}\PYG{p}{(}\PYG{n}{int} \PYG{n+nb}{i}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{foo\PYGZsq{}} \PYG{o}{|} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{bar\PYGZsq{}} \PYG{p}{[}\PYG{p}{,}\PYG{n}{vec} \PYG{n}{v}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

means that the dummy function takes two or three arguments, its first being an integer value, the second a string which is either ‘foo’ or ‘bar’, and a third optional argument. It returns two values (with the usual matlab meaning, i.e. the caller can always choose to ignore them).


\section{gf\_asm}
\label{\detokenize{matlab_octave/cmdref_gf_asm:gf-asm}}\label{\detokenize{matlab_octave/cmdref_gf_asm::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{order}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{p}{[}\PYG{n}{model} \PYG{n}{model}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Secondary\PYGZus{}domain}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}variable}\PYG{p}{[}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}imd} \PYG{n}{mimd}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{value}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{select\PYGZus{}output}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{varname1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{varname2]], ...)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mass matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{L} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{laplacian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{a}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Le} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linear elasticity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{lambda\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{mu\PYGZus{}d}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{TRHS} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nonlinear elasticity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{n}{string} \PYG{n}{law}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{params}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tangent matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{|}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rhs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{|}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{incompressible tangent matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}p}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{P}\PYG{o}{|}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{incompressible rhs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}p}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{P}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{helmholtz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{k}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bilaplacian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{a}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bilaplacian KL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{a}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{nu}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volumic source}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{fd}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{B} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundary source}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{bnum}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{G}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{HH}\PYG{p}{,} \PYG{n}{RR}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dirichlet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{bnum}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{H}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{R} \PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{threshold}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Q} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundary qu term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{int} \PYG{n}{boundary\PYGZus{}num}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{q}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{define function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{nb\PYGZus{}args}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression\PYGZus{}derivative\PYGZus{}t}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression\PYGZus{}derivative\PYGZus{}u}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{undefine function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{define linear hardening function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{sigma\PYGZus{}y0}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{H}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{p}{[}\PYG{n}{string} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Frobenius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{define Ramberg Osgood hardening function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{sigma\PYGZus{}ref}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{scalar} \PYG{n}{eps\PYGZus{}ref} \PYG{o}{|} \PYG{n}{scalar} \PYG{n}{E}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{alpha}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{n}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Frobenius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{expression analysis}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression} \PYG{p}{[}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{mesh} \PYG{n}{mesh} \PYG{o}{|} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{\PYGZcb{}}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{der\PYGZus{}order}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{model} \PYG{n}{model}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}variable}\PYG{p}{[}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf} \PYG{o}{|} \PYG{n}{mesh\PYGZus{}imd} \PYG{n}{mimd}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volumic}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{[}\PYG{p}{,}\PYG{n}{CVLST}\PYG{p}{]}\PYG{p}{,} \PYG{n}{expr} \PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}ims}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fems}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{bnum}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr} \PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{data}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Mi} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interpolation matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mfi} \PYG{o}{|} \PYG{n}{vec} \PYG{n}{pts}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{Me} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extrapolation matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,}  \PYG{p}{\PYGZob{}}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mfe} \PYG{o}{|} \PYG{n}{vec} \PYG{n}{pts}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{B} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integral contact Uzawa projection}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{bnum}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}lambda}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{vec\PYGZus{}lambda}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}obstacle}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{obstacle}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{r} \PYG{p}{[}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{scalar} \PYG{n}{coeff} \PYG{o}{|} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}coeff}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{coeff}\PYG{p}{\PYGZcb{}} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{option}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{alpha}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{W}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{B} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{level set normal source term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{bnum}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}lambda}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{vec\PYGZus{}lambda}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}levelset}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{levelset}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lsneuman matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{,} \PYG{n}{levelset} \PYG{n}{ls}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nlsgrad matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{,} \PYG{n}{levelset} \PYG{n}{ls}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{stabilization patch matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nd}{@tm} \PYG{n}{mesh}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{real} \PYG{n}{ratio}\PYG{p}{,} \PYG{n}{real} \PYG{n}{h}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{Q}\PYG{p}{,} \PYG{n}{G}\PYG{p}{,} \PYG{n}{H}\PYG{p}{,} \PYG{n}{R}\PYG{p}{,} \PYG{n}{F}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdetool boundary conditions}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mf\PYGZus{}u}\PYG{p}{,} \PYG{n}{mf\PYGZus{}d}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{e}\PYG{p}{[}\PYG{p}{,} \PYG{n}{f\PYGZus{}expr}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General assembly function.

Many of the functions below use more than one mesh\_fem: the main
mesh\_fem (mf\_u) used for the main unknown, and data mesh\_fem (mf\_d)
used for the data. It is always assumed that the Qdim of mf\_d is
equal to 1: if mf\_d is used to describe vector or tensor data, you
just have to “stack” (in fortran ordering) as many scalar fields as
necessary.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{\{...\} = gf\_asm(\textquotesingle{}generic\textquotesingle{}, mesh\_im mim, int order, string expression, int region, {[}model model, {[}\textquotesingle{}Secondary\_domain\textquotesingle{}, \textquotesingle{}name\textquotesingle{},{]}{]} {[}string varname, int is\_variable{[}, \{mesh\_fem mf, mesh\_imd mimd\}{]}, value{]}, {[}\textquotesingle{}select\_output\textquotesingle{}, \textquotesingle{}varname1\textquotesingle{}{[}, \textquotesingle{}varname2{]}{]}, ...)}}
\begin{quote}

High\sphinxhyphen{}level generic assembly procedure for volumic or boundary assembly.

Performs the generic assembly of \sphinxtitleref{expression} with the integration
method \sphinxtitleref{mim} on the mesh region of index \sphinxtitleref{region} (\sphinxhyphen{}1 means all
elements of the mesh). The same mesh should be shared by
the integration method and all the finite element methods or
mesh\_im\_data corresponding to the variables.

\sphinxtitleref{order} indicates either that the (scalar) potential
(order = 0) or the (vector) residual (order = 1) or the
tangent (matrix) (order = 2) is to be computed.

\sphinxtitleref{model} is an optional parameter allowing to take into account
all variables and data of a model. Note that all enabled variables
of the model will occupy space in the returned vector/matrix
corresponding to their degrees of freedom in the global system, even
if they are not present in \sphinxtitleref{expression}.

The variables and constants (data) are listed after the region number
(or optionally the model).
For each variable/constant, a name must be given first (as it is
referred in the assembly string), then an integer equal to 1 or 0
is expected respectively for declaring a variable or a constant,
then the finite element method if it is a fem variable/constant or
the mesh\_im\_data if it is data defined on integration points, and
the vector representing the value of the variable/constant.
It is possible to give an arbitrary number of variable/constant.
The difference between a variable and a constant is that test
functions are only available for variables, not for constants.

\sphinxtitleref{select\_output} is an optional parameter which allows to reduce the
output vector (for \sphinxtitleref{order} equal to 1) or the matrix (for \sphinxtitleref{order}
equal to 2) to the degrees of freedom of the specified variables.
One variable has to be specified for a vector output and two for a
matrix output.

Note that if several variables are given, the assembly of the
tangent matrix/residual vector will be done considering the order
in the call of the function (the degrees of freedom of the first
variable, then of the second one, and so on). If a model is provided,
all degrees of freedom of the model will be counted first, even if
some of the model variables do not appear in \sphinxtitleref{expression}.

For example, the L2 norm of a vector field “u” can be computed with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L2 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o+ow}{or} \PYG{k}{with} \PYG{n}{the} \PYG{n}{square} \PYG{n}{root} \PYG{n}{of}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u.u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{U}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

The nonhomogeneous Laplacian stiffness matrix of a scalar field can be evaluated with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{laplacian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{mf\PYGZus{}data}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{equivalently} \PYG{k}{with}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A*Grad\PYGZus{}Test2\PYGZus{}u.Grad\PYGZus{}Test\PYGZus{}u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{mf\PYGZus{}data}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_asm(\textquotesingle{}mass matrix\textquotesingle{}, mesh\_im mim, mesh\_fem mf1{[}, mesh\_fem mf2{[}, int region{]}{]})}}
\begin{quote}

Assembly of a mass matrix.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{L = gf\_asm(\textquotesingle{}laplacian\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, vec a{[}, int region{]})}}
\begin{quote}

Assembly of the matrix for the Laplacian problem.

\(\nabla\cdot(a(x)\nabla u)\)  with \sphinxtitleref{a} a scalar.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{Le = gf\_asm(\textquotesingle{}linear elasticity\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, vec lambda\_d, vec mu\_d{[}, int region{]})}}
\begin{quote}

Assembles of the matrix for the linear (isotropic) elasticity problem.

\(\nabla\cdot(C(x):\nabla u)\)
with \(C\) defined via \sphinxtitleref{lambda\_d} and \sphinxtitleref{mu\_d}.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{TRHS = gf\_asm(\textquotesingle{}nonlinear elasticity\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_u, vec U, string law, mesh\_fem mf\_d, mat params, \{\textquotesingle{}tangent matrix\textquotesingle{}|\textquotesingle{}rhs\textquotesingle{}|\textquotesingle{}incompressible tangent matrix\textquotesingle{}, mesh\_fem mf\_p, vec P|\textquotesingle{}incompressible rhs\textquotesingle{}, mesh\_fem mf\_p, vec P\})}}
\begin{quote}

Assembles terms (tangent matrix and right hand side) for nonlinear elasticity.

The solution \sphinxtitleref{U} is required at the current time\sphinxhyphen{}step. The \sphinxtitleref{law}
may be choosen among:
\begin{itemize}
\item {} 
‘SaintVenant Kirchhoff’:
Linearized law, should be avoided. This law has the two usual
Lame coefficients as parameters, called lambda and mu.

\item {} 
‘Mooney Rivlin’:
This law has three parameters, called C1, C2 and D1.
Can be preceded with the words ‘compressible’ or ‘incompressible’ to force
a specific version. By default, the incompressible version is considered
which requires only the first two material coefficients.

\item {} 
‘neo Hookean’:
A special case of the ‘Mooney Rivlin’ law that requires one material
coefficient less (C2 = 0). By default, its compressible version is used.

\item {} 
‘Ciarlet Geymonat’:
This law has 3 parameters, called lambda, mu and gamma, with
gamma chosen such that gamma is in {]}\sphinxhyphen{}lambda/2\sphinxhyphen{}mu, \sphinxhyphen{}mu{[}.

\end{itemize}

The parameters of the material law are described on the mesh\_fem \sphinxtitleref{mf\_d}.
The matrix \sphinxtitleref{params} should have \sphinxtitleref{nbdof(mf\_d)} columns, each row
correspounds to a parameter.

The last argument selects what is to be built: either the tangent
matrix, or the right hand side. If the incompressibility is
considered, it should be followed by a mesh\_fem \sphinxtitleref{mf\_p}, for the
pression.

Return a spmat object (tangent matrix), vec object (right hand
side), tuple of spmat objects (incompressible tangent matrix), or
tuple of vec objects (incompressible right hand side).
\end{quote}

\sphinxcode{\sphinxupquote{A = gf\_asm(\textquotesingle{}helmholtz\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, vec k{[}, int region{]})}}
\begin{quote}

Assembly of the matrix for the Helmholtz problem.

\(\Delta u + k^2 u\) = 0,  with \sphinxtitleref{k} complex scalar.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{A = gf\_asm(\textquotesingle{}bilaplacian\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, vec a{[}, int region{]})}}
\begin{quote}

Assembly of the matrix for the Bilaplacian problem.

\(\Delta(a(x)\Delta u) = 0\)   with \sphinxtitleref{a} scalar.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{A = gf\_asm(\textquotesingle{}bilaplacian KL\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, vec a, vec nu{[}, int region{]})}}
\begin{quote}

Assembly of the matrix for the Bilaplacian problem with Kirchhoff\sphinxhyphen{}Love formulation.

\(\Delta(a(x)\Delta u) = 0\)   with \sphinxtitleref{a} scalar.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_asm(\textquotesingle{}volumic source\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, vec fd{[}, int region{]})}}
\begin{quote}

Assembly of a volumic source term.

Output a vector \sphinxtitleref{V}, assembled on the mesh\_fem \sphinxtitleref{mf\_u}, using the data
vector \sphinxtitleref{fd} defined on the data mesh\_fem \sphinxtitleref{mf\_d}. \sphinxtitleref{fd} may be real or
complex\sphinxhyphen{}valued.

Return a vec object.
\end{quote}

\sphinxcode{\sphinxupquote{B = gf\_asm(\textquotesingle{}boundary source\textquotesingle{}, int bnum, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, vec G)}}
\begin{quote}

Assembly of a boundary source term.

\sphinxtitleref{G} should be a {[}Qdim x N{]} matrix, where N is the number of dof
of \sphinxtitleref{mf\_d}, and Qdim is the dimension of the unkown u (that is set
when creating the mesh\_fem).

Return a vec object.
\end{quote}

\sphinxcode{\sphinxupquote{\{HH, RR\} = gf\_asm(\textquotesingle{}dirichlet\textquotesingle{}, int bnum, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, mat H, vec R {[}, scalar threshold{]})}}
\begin{quote}

Assembly of Dirichlet conditions of type \sphinxtitleref{h.u = r}.

Handle \sphinxtitleref{h.u = r} where h is a square matrix (of any rank) whose
size is equal to the dimension of the unkown u. This matrix is
stored in \sphinxtitleref{H}, one column per dof in \sphinxtitleref{mf\_d}, each column containing
the values of the matrix h stored in fortran order:
\begin{equation*}
\begin{split}`H(:,j) = [h11(x_j) h21(x_j) h12(x_j) h22(x_j)]`\end{split}
\end{equation*}
if u is a 2D vector field.

Of course, if the unknown is a scalar field, you just have to set
\sphinxtitleref{H = ones(1, N)}, where N is the number of dof of \sphinxtitleref{mf\_d}.

This is basically the same than calling gf\_asm(‘boundary qu term’)
for \sphinxtitleref{H} and calling gf\_asm(‘neumann’) for \sphinxtitleref{R}, except that this
function tries to produce a ‘better’ (more diagonal) constraints
matrix (when possible).

See also gf\_spmat\_get(spmat S, ‘Dirichlet\_nullspace’).
\end{quote}

\sphinxcode{\sphinxupquote{Q = gf\_asm(\textquotesingle{}boundary qu term\textquotesingle{},int boundary\_num, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_d, mat q)}}
\begin{quote}

Assembly of a boundary qu term.

\sphinxtitleref{q} should be be a {[}Qdim x Qdim x N{]} array, where N is the number
of dof of \sphinxtitleref{mf\_d}, and Qdim is the dimension of the unkown u (that
is set when creating the mesh\_fem).

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_asm(\textquotesingle{}define function\textquotesingle{}, string name, int nb\_args, string expression{[}, string expression\_derivative\_t{[}, string expression\_derivative\_u{]}{]})}}
\begin{quote}

Define a new function \sphinxtitleref{name} which can be used in high level
generic assembly. The function can have one or two parameters.
In \sphinxtitleref{expression} all available predefined function or operation
of the generic assembly can be used. However, no reference to
some variables or data can be specified. The argument of the
function is \sphinxtitleref{t} for a one parameter function and \sphinxtitleref{t} and \sphinxtitleref{u}
for a two parameter function. For instance ‘sin(pi*t)+2*t*t’
is a valid expression for a one parameter function and
‘sin(max(t,u)*pi)’ is a valid expression for a two parameters
function. \sphinxtitleref{expression\_derivative\_t} and \sphinxtitleref{expression\_derivative\_u}
are optional expressions for the derivatives with respect
to \sphinxtitleref{t} and \sphinxtitleref{u}. If they are not furnished, a symbolic derivation
is used.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_asm(\textquotesingle{}undefine function\textquotesingle{}, string name)}}
\begin{quote}

Cancel the definition of a previously defined function \sphinxtitleref{name}
for the high level generic assembly.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_asm(\textquotesingle{}define linear hardening function\textquotesingle{}, string name, scalar sigma\_y0, scalar H, ... {[}string \textquotesingle{}Frobenius\textquotesingle{}{]})}}
\begin{quote}

Define a new linear hardening function under the name \sphinxtitleref{name}, with
initial yield stress \sphinxtitleref{sigma\_y0} and hardening modulus H.
If an extra string argument with the value ‘Frobenius’ is provided,
the hardening function is expressed in terms of Frobenius norms of its
input strain and output stress, instead of their Von\sphinxhyphen{}Mises equivalents.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_asm(\textquotesingle{}define Ramberg Osgood hardening function\textquotesingle{}, string name, scalar sigma\_ref, \{scalar eps\_ref | scalar E, scalar alpha\}, scalar n{[}, string \textquotesingle{}Frobenius\textquotesingle{}{]})}}
\begin{quote}

Define a new Ramberg Osgood hardening function under the name \sphinxtitleref{name},
with initial yield stress \sphinxtitleref{sigma\_y0} and hardening modulus H.
If an extra string argument with the value ‘Frobenius’ is provided,
the hardening function is expressed in terms of Frobenius norms of its
input strain and output stress, instead of their Von\sphinxhyphen{}Mises equivalents.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_asm(\textquotesingle{}expression analysis\textquotesingle{}, string expression {[}, \{mesh mesh | mesh\_im mim\}{]} {[}, der\_order{]} {[}, model model{]} {[}, string varname, int is\_variable{[}, \{mesh\_fem mf | mesh\_imd mimd\}{]}, ...{]})}}
\begin{quote}

Analyse a high\sphinxhyphen{}level generic assembly expression and print
information about the provided expression.
\end{quote}

\sphinxcode{\sphinxupquote{\{...\} = gf\_asm(\textquotesingle{}volumic\textquotesingle{} {[},CVLST{]}, expr {[}, mesh\_ims, mesh\_fems, data...{]})}}
\begin{quote}

Low\sphinxhyphen{}level generic assembly procedure for volumic assembly.

The expression \sphinxtitleref{expr} is evaluated over the mesh\_fem’s listed in the
arguments (with optional data) and assigned to the output arguments.
For details about the syntax of assembly expressions, please refer
to the getfem user manual (or look at the file getfem\_assembling.h
in the GetFEM sources).

For example, the L2 norm of a field can be computed with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L2 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{o+ow}{or} \PYG{k}{with} \PYG{n}{the} \PYG{n}{square} \PYG{n}{root} \PYG{n}{of}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volumic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{u=data(\PYGZsh{}1); V()+=u(i).u(j).comp(Base(\PYGZsh{}1).Base(\PYGZsh{}1))(i,j)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)}
\end{sphinxVerbatim}

The Laplacian stiffness matrix can be evaluated with:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{laplacian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mim}\PYG{p}{,} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{mf\PYGZus{}data}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)} \PYG{o+ow}{or} \PYG{n}{equivalently} \PYG{k}{with}\PYG{p}{:}

\PYG{n}{gf\PYGZus{}asm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{volumic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a=data(\PYGZsh{}2);M(\PYGZsh{}1,\PYGZsh{}1)+=sym(comp(Grad(\PYGZsh{}1).Grad(\PYGZsh{}1).Base(\PYGZsh{}2))(:,i,:,i,j).a(j))}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mim}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{mf\PYGZus{}data}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxcode{\sphinxupquote{\{...\} = gf\_asm(\textquotesingle{}boundary\textquotesingle{}, int bnum, string expr {[}, mesh\_im mim, mesh\_fem mf, data...{]})}}
\begin{quote}

Low\sphinxhyphen{}level generic boundary assembly.

See the help for gf\_asm(‘volumic’).
\end{quote}

\sphinxcode{\sphinxupquote{Mi = gf\_asm(\textquotesingle{}interpolation matrix\textquotesingle{}, mesh\_fem mf, \{mesh\_fem mfi | vec pts\})}}
\begin{quote}

Build the interpolation matrix from a mesh\_fem onto another mesh\_fem or a set of points.

Return a matrix \sphinxtitleref{Mi}, such that \sphinxtitleref{V = Mi.U} is equal to
gf\_compute(‘interpolate\_on’,mfi). Useful for repeated interpolations.
Note that this is just interpolation, no elementary integrations
are involved here, and \sphinxtitleref{mfi} has to be lagrangian. In the more
general case, you would have to do a L2 projection via the mass
matrix.

\sphinxtitleref{Mi} is a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{Me = gf\_asm(\textquotesingle{}extrapolation matrix\textquotesingle{},mesh\_fem mf,  \{mesh\_fem mfe | vec pts\})}}
\begin{quote}

Build the extrapolation matrix from a mesh\_fem onto another mesh\_fem or a set of points.

Return a matrix \sphinxtitleref{Me}, such that \sphinxtitleref{V = Me.U} is equal to
gf\_compute(‘extrapolate\_on’,mfe). Useful for repeated
extrapolations.

\sphinxtitleref{Me} is a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{B = gf\_asm(\textquotesingle{}integral contact Uzawa projection\textquotesingle{}, int bnum, mesh\_im mim, mesh\_fem mf\_u, vec U, mesh\_fem mf\_lambda, vec vec\_lambda, mesh\_fem mf\_obstacle, vec obstacle, scalar r {[}, \{scalar coeff | mesh\_fem mf\_coeff, vec coeff\} {[}, int option{[}, scalar alpha, vec W{]}{]}{]})}}
\begin{quote}
\begin{description}
\item[{Specific assembly procedure for the use of an Uzawa algorithm to solve}] \leavevmode
contact problems. Projects the term \$\sphinxhyphen{}(lambda \sphinxhyphen{} r (u\_N\sphinxhyphen{}g))\_\sphinxhyphen{}\$ on the
finite element space of \$lambda\$.

\end{description}

Return a vec object.
\end{quote}

\sphinxcode{\sphinxupquote{B = gf\_asm(\textquotesingle{}level set normal source term\textquotesingle{}, int bnum, mesh\_im mim, mesh\_fem mf\_u, mesh\_fem mf\_lambda, vec vec\_lambda, mesh\_fem mf\_levelset, vec levelset)}}
\begin{quote}

Performs an assembly of the source term represented by \sphinxtitleref{vec\_lambda}
on \sphinxtitleref{mf\_lambda} considered to be a component in the direction of the
gradient of a levelset function (normal to the levelset) of a vector
field defined on \sphinxtitleref{mf\_u} on the boundary \sphinxtitleref{bnum}.

Return a vec object.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_asm(\textquotesingle{}lsneuman matrix\textquotesingle{}, mesh\_im mim, mesh\_fem mf1, mesh\_fem mf2, levelset ls{[}, int region{]})}}
\begin{quote}

Assembly of a level set Neuman  matrix.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_asm(\textquotesingle{}nlsgrad matrix\textquotesingle{}, mesh\_im mim, mesh\_fem mf1, mesh\_fem mf2, levelset ls{[}, int region{]})}}
\begin{quote}

Assembly of a nlsgrad matrix.

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_asm(\textquotesingle{}stabilization patch matrix\textquotesingle{}, @tm mesh, mesh\_fem mf,  mesh\_im mim, real ratio, real h)}}
\begin{quote}

Assembly of stabilization patch matrix .

Return a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{\{Q, G, H, R, F\} = gf\_asm(\textquotesingle{}pdetool boundary conditions\textquotesingle{}, mf\_u, mf\_d, b, e{[}, f\_expr{]})}}
\begin{quote}

Assembly of pdetool boundary conditions.

\sphinxtitleref{B} is the boundary matrix exported by pdetool, and \sphinxtitleref{E} is the
edges array. \sphinxtitleref{f\_expr} is an optionnal expression (or vector) for
the volumic term. On return \sphinxtitleref{Q, G, H, R, F} contain the assembled
boundary conditions (\sphinxtitleref{Q} and \sphinxtitleref{H} are matrices), similar to the
ones returned by the function ASSEMB from PDETOOL.
\end{quote}
\end{quote}


\section{gf\_compute}
\label{\detokenize{matlab_octave/cmdref_gf_compute:gf-compute}}\label{\detokenize{matlab_octave/cmdref_gf_compute::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L2 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{L2 dist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U2}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H1 semi norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H1 semi dist}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U2}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H1 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2 semi norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H2 norm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{DU} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gradient}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}du}\PYG{p}{)}
\PYG{n}{HU} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hessian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}h}\PYG{p}{)}
\PYG{n}{UP} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eval on triangulated surface}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{Nrefine}\PYG{p}{,} \PYG{p}{[}\PYG{n}{vec} \PYG{n}{CVLIST}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Ui} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interpolate on}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mfi} \PYG{o}{|} \PYG{n+nb}{slice} \PYG{n}{sli} \PYG{o}{|} \PYG{n}{vec} \PYG{n}{pts}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{Ue} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extrapolate on}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mfe}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error estimate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error estimate nitsche}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{GAMMAC}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{GAMMAN}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{lambda\PYGZus{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{mu\PYGZus{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{gamma0}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{f\PYGZus{}coeff}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{vertical\PYGZus{}force}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{convect}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}v}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{dt}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{nt}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{option}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{per\PYGZus{}min}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{per\PYGZus{}max}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{U2}\PYG{p}{[}\PYG{p}{,}\PYG{n}{MF2}\PYG{p}{,}\PYG{p}{[}\PYG{p}{,}\PYG{n}{X}\PYG{p}{[}\PYG{p}{,}\PYG{n}{Y}\PYG{p}{[}\PYG{p}{,}\PYG{n}{Z}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gf\PYGZus{}compute}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interpolate on Q1 grid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{regular h}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{hxyz} \PYG{o}{|} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{regular N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{Nxyz} \PYG{o}{|} \PYG{n}{X}\PYG{p}{[}\PYG{p}{,}\PYG{n}{Y}\PYG{p}{[}\PYG{p}{,}\PYG{n}{Z}\PYG{p}{]}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Various computations involving the solution U to a finite element problem.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{n = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}L2 norm\textquotesingle{}, mesh\_im mim{[}, mat CVids{]})}}
\begin{quote}

Compute the L2 norm of the (real or complex) field \sphinxtitleref{U}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}L2 dist\textquotesingle{}, mesh\_im mim, mesh\_fem mf2, vec U2{[}, mat CVids{]})}}
\begin{quote}

Compute the L2 distance between \sphinxtitleref{U} and \sphinxtitleref{U2}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}H1 semi norm\textquotesingle{}, mesh\_im mim{[}, mat CVids{]})}}
\begin{quote}

Compute the L2 norm of grad(\sphinxtitleref{U}).

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}H1 semi dist\textquotesingle{}, mesh\_im mim, mesh\_fem mf2, vec U2{[}, mat CVids{]})}}
\begin{quote}

Compute the semi H1 distance between \sphinxtitleref{U} and \sphinxtitleref{U2}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}H1 norm\textquotesingle{}, mesh\_im mim{[}, mat CVids{]})}}
\begin{quote}

Compute the H1 norm of \sphinxtitleref{U}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}H2 semi norm\textquotesingle{}, mesh\_im mim{[}, mat CVids{]})}}
\begin{quote}

Compute the L2 norm of D\textasciicircum{}2(\sphinxtitleref{U}).

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}H2 norm\textquotesingle{}, mesh\_im mim{[}, mat CVids{]})}}
\begin{quote}

Compute the H2 norm of \sphinxtitleref{U}.

If \sphinxtitleref{CVids} is given, the norm will be computed only on the listed
elements.
\end{quote}

\sphinxcode{\sphinxupquote{DU = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}gradient\textquotesingle{}, mesh\_fem mf\_du)}}
\begin{quote}

Compute the gradient of the field \sphinxtitleref{U} defined on mesh\_fem \sphinxtitleref{mf\_du}.

The gradient is interpolated on the mesh\_fem \sphinxtitleref{mf\_du}, and returned in
\sphinxtitleref{DU}. For example, if \sphinxtitleref{U} is defined on a P2 mesh\_fem, \sphinxtitleref{DU} should be
evaluated on a P1\sphinxhyphen{}discontinuous mesh\_fem. \sphinxtitleref{mf} and \sphinxtitleref{mf\_du} should
share the same mesh.

\sphinxtitleref{U} may have any number of dimensions (i.e. this function is not
restricted to the gradient of scalar fields, but may also be used
for tensor fields). However the last dimension of \sphinxtitleref{U} has to be
equal to the number of dof of \sphinxtitleref{mf}. For example, if \sphinxtitleref{U} is a
{[}3x3xNmf{]} array (where Nmf is the number of dof of \sphinxtitleref{mf}), \sphinxtitleref{DU} will
be a {[}Nx3x3{[}xQ{]}xNmf\_du{]} array, where N is the dimension of the mesh,
Nmf\_du is the number of dof of \sphinxtitleref{mf\_du}, and the optional Q dimension
is inserted if \sphinxtitleref{Qdim\_mf != Qdim\_mf\_du}, where Qdim\_mf is the Qdim of
\sphinxtitleref{mf} and Qdim\_mf\_du is the Qdim of \sphinxtitleref{mf\_du}.
\end{quote}

\sphinxcode{\sphinxupquote{HU = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}hessian\textquotesingle{}, mesh\_fem mf\_h)}}
\begin{quote}

Compute the hessian of the field \sphinxtitleref{U} defined on mesh\_fem \sphinxtitleref{mf\_h}.

See also gf\_compute(‘gradient’, mesh\_fem mf\_du).
\end{quote}

\sphinxcode{\sphinxupquote{UP = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}eval on triangulated surface\textquotesingle{}, int Nrefine, {[}vec CVLIST{]})}}
\begin{quote}

{[}OBSOLETE FUNCTION! will be removed in a future release{]}
Utility function designed for 2D triangular meshes : returns a list
of triangles coordinates with interpolated U values. This can be
used for the accurate visualization of data defined on a
discontinous high order element. On output, the six first rows of UP
contains the triangle coordinates, and the others rows contain the
interpolated values of U (one for each triangle vertex) CVLIST may
indicate the list of convex number that should be consider, if not
used then all the mesh convexes will be used. U should be a row
vector.
\end{quote}

\sphinxcode{\sphinxupquote{Ui = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}interpolate on\textquotesingle{}, \{mesh\_fem mfi | slice sli | vec pts\})}}
\begin{quote}

Interpolate a field on another mesh\_fem or a slice or a list of points.
\begin{itemize}
\item {} \begin{description}
\item[{Interpolation on another mesh\_fem \sphinxtitleref{mfi}:}] \leavevmode
\sphinxtitleref{mfi} has to be Lagrangian. If \sphinxtitleref{mf} and \sphinxtitleref{mfi} share the same
mesh object, the interpolation will be much faster.

\end{description}

\item {} \begin{description}
\item[{Interpolation on a slice \sphinxtitleref{sli}:}] \leavevmode
this is similar to interpolation on a refined P1\sphinxhyphen{}discontinuous
mesh, but it is much faster. This can also be used with
gf\_slice(‘points’) to obtain field values at a given set of
points.

\end{description}

\item {} 
Interpolation on a set of points \sphinxtitleref{pts}

\end{itemize}

See also gf\_asm(‘interpolation matrix’)
\end{quote}

\sphinxcode{\sphinxupquote{Ue = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}extrapolate on\textquotesingle{}, mesh\_fem mfe)}}
\begin{quote}

Extrapolate a field on another mesh\_fem.

If the mesh of \sphinxtitleref{mfe} is stricly included in the mesh of \sphinxtitleref{mf}, this
function does stricly the same job as gf\_compute(‘interpolate\_on’).
However, if the mesh of \sphinxtitleref{mfe} is not exactly included in \sphinxtitleref{mf}
(imagine interpolation between a curved refined mesh and a coarse
mesh), then values which are outside \sphinxtitleref{mf} will be
extrapolated.

See also gf\_asm(‘extrapolation matrix’)
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}error estimate\textquotesingle{}, mesh\_im mim)}}
\begin{quote}

Compute an a posteriori error estimate.

Currently there is only one which is available: for each convex,
the jump of the normal derivative is integrated on its faces.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}error estimate nitsche\textquotesingle{}, mesh\_im mim, int GAMMAC, int GAMMAN, scalar lambda\_, scalar mu\_, scalar gamma0, scalar f\_coeff, scalar vertical\_force)}}
\begin{quote}

Compute an a posteriori error estimate in the case of Nitsche method.

Currently there is only one which is available: for each convex,
the jump of the normal derivative is integrated on its faces.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}convect\textquotesingle{}, mesh\_fem mf\_v, vec V, scalar dt, int nt{[}, string option{[}, vec per\_min, vec per\_max{]}{]})}}
\begin{quote}

Compute a convection of \sphinxtitleref{U} with regards to a steady state velocity
field \sphinxtitleref{V} with a Characteristic\sphinxhyphen{}Galerkin method. The result is returned
in\sphinxhyphen{}place in \sphinxtitleref{U}.
This method is restricted to pure Lagrange fems for U. \sphinxtitleref{mf\_v} should
represent a continuous finite element method. \sphinxtitleref{dt} is the integration time
and \sphinxtitleref{nt} is the number of integration step on the caracteristics. \sphinxtitleref{option}
is an option for the part of the boundary where there is a re\sphinxhyphen{}entrant
convection.
\sphinxtitleref{option = ‘extrapolation’} for an extrapolation on the nearest element,
\sphinxtitleref{option = ‘unchanged’} for a constant value on that boundary or
\sphinxtitleref{option = ‘periodicity’} for a peridiodic boundary. For this latter option
the two vectors per\_min, per\_max has to be given and represent the limits
of the periodic domain (on components where per\_max{[}k{]} \textless{} per\_min{[}k{]}
no operation is done).
This method is rather dissipative, but stable.
\end{quote}

\sphinxcode{\sphinxupquote{{[}U2{[},MF2,{[},X{[},Y{[},Z{]}{]}{]}{]}{]} = gf\_compute(mesh\_fem MF, vec U, \textquotesingle{}interpolate on Q1 grid\textquotesingle{}, \{\textquotesingle{}regular h\textquotesingle{}, hxyz | \textquotesingle{}regular N\textquotesingle{}, Nxyz | X{[},Y{[},Z{]}{]}\})}}
\begin{quote}

Creates a cartesian Q1 mesh fem and interpolates U on it. The
returned field U2 is organized in a matrix such that in can be drawn
via the MATLAB command ‘pcolor’. The first dimension is the Qdim of
MF (i.e.  1 if U is a scalar field)

example (mf\_u is a 2D mesh\_fem):
\textgreater{}\textgreater{} Uq=gf\_compute(mf\_u, U, ‘interpolate on Q1 grid’, ‘regular h’, {[}.05, .05{]});
\textgreater{}\textgreater{} pcolor(squeeze(Uq(1,:,:)));
\end{quote}
\end{quote}


\section{gf\_cont\_struct}
\label{\detokenize{matlab_octave/cmdref_gf_cont_struct:gf-cont-struct}}\label{\detokenize{matlab_octave/cmdref_gf_cont_struct::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct}\PYG{p}{(}\PYG{n}{model} \PYG{n}{md}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}parameter}\PYG{p}{[}\PYG{p}{,}\PYG{n}{string} \PYG{n}{dataname\PYGZus{}init}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}final}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}current}\PYG{p}{]}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{sc\PYGZus{}fac}\PYG{p}{[}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for cont\_struct objects.
\begin{quote}

This object serves for storing parameters and data used in numerical
continuation of solution branches of models (for more details about
continuation see the GetFEM user documentation).
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{S = gf\_cont\_struct(model md, string dataname\_parameter{[},string dataname\_init, string dataname\_final, string dataname\_current{]}, scalar sc\_fac{[}, ...{]})}}
\begin{quote}

The variable \sphinxtitleref{dataname\_parameter} should parametrise the model given by
\sphinxtitleref{md}. If the parameterization is done via a vector datum, \sphinxtitleref{dataname\_init}
and \sphinxtitleref{dataname\_final} should store two given values of this datum
determining the parameterization, and \sphinxtitleref{dataname\_current} serves for actual
values of this datum. \sphinxtitleref{sc\_fac} is a scale factor involved in the weighted
norm used in the continuation.

Additional options:
\begin{itemize}
\item {} \begin{description}
\item[{‘lsolver’, string SOLVER\_NAME}] \leavevmode
name of the solver to be used for the incorporated linear systems
(the default value is ‘auto’, which lets getfem choose itself);
possible values are ‘superlu’, ‘mumps’ (if supported), ‘cg/ildlt’,
‘gmres/ilu’ and ‘gmres/ilut’;

\end{description}

\item {} \begin{description}
\item[{‘h\_init’, scalar HIN}] \leavevmode
initial step size (the default value is 1e\sphinxhyphen{}2);

\end{description}

\item {} \begin{description}
\item[{‘h\_max’, scalar HMAX}] \leavevmode
maximum step size (the default value is 1e\sphinxhyphen{}1);

\end{description}

\item {} \begin{description}
\item[{‘h\_min’, scalar HMIN}] \leavevmode
minimum step size (the default value is 1e\sphinxhyphen{}5);

\end{description}

\item {} \begin{description}
\item[{‘h\_inc’, scalar HINC}] \leavevmode
factor for enlarging the step size (the default value is 1.3);

\end{description}

\item {} \begin{description}
\item[{‘h\_dec’, scalar HDEC}] \leavevmode
factor for diminishing the step size (the default value is 0.5);

\end{description}

\item {} \begin{description}
\item[{‘max\_iter’, int MIT}] \leavevmode
maximum number of iterations allowed in the correction (the default
value is 10);

\end{description}

\item {} \begin{description}
\item[{‘thr\_iter’, int TIT}] \leavevmode
threshold number of iterations of the correction for enlarging the
step size (the default value is 4);

\end{description}

\item {} \begin{description}
\item[{‘max\_res’, scalar RES}] \leavevmode
target residual value of a new point on the solution curve (the
default value is 1e\sphinxhyphen{}6);

\end{description}

\item {} \begin{description}
\item[{‘max\_diff’, scalar DIFF}] \leavevmode
determines a convergence criterion for two consecutive points (the
default value is 1e\sphinxhyphen{}6);

\end{description}

\item {} \begin{description}
\item[{‘min\_cos’, scalar MCOS}] \leavevmode
minimal value of the cosine of the angle between tangents to the
solution curve at an old point and a new one (the default value is
0.9);

\end{description}

\item {} \begin{description}
\item[{‘max\_res\_solve’, scalar RES\_SOLVE}] \leavevmode
target residual value for the linear systems to be solved (the
default value is 1e\sphinxhyphen{}8);

\end{description}

\item {} \begin{description}
\item[{‘singularities’, int SING}] \leavevmode
activates tools for detection and treatment of singular points (1 for
limit points, 2 for bifurcation points and points requiring special
branching techniques);

\end{description}

\item {} \begin{description}
\item[{‘non\sphinxhyphen{}smooth’}] \leavevmode
determines that some special methods for non\sphinxhyphen{}smooth problems can be
used;

\end{description}

\item {} \begin{description}
\item[{‘delta\_max’, scalar DMAX}] \leavevmode
maximum size of division for evaluating the test function on the
convex combination of two augmented Jacobians that belong to different
smooth pieces (the default value is 0.005);

\end{description}

\item {} \begin{description}
\item[{‘delta\_min’, scalar DMIN}] \leavevmode
minimum size of division for evaluating the test function on the
convex combination (the default value is 0.00012);

\end{description}

\item {} \begin{description}
\item[{‘thr\_var’, scalar TVAR}] \leavevmode
threshold variation for refining the division (the default value is
0.02);

\end{description}

\item {} \begin{description}
\item[{‘nb\_dir’, int NDIR}] \leavevmode
total number of the linear combinations of one couple of reference
vectors when searching for new tangent predictions during location of
new one\sphinxhyphen{}sided branches (the default value is 40);

\end{description}

\item {} \begin{description}
\item[{‘nb\_span’, int NSPAN}] \leavevmode
total number of the couples of the reference vectors forming the
linear combinations (the default value is 1);

\end{description}

\item {} \begin{description}
\item[{‘noisy’ or ‘very\_noisy’}] \leavevmode
determines how detailed information has to be displayed during the
continuation process (residual values etc.).

\end{description}

\end{itemize}
\end{quote}
\end{quote}


\section{gf\_cont\_struct\_get}
\label{\detokenize{matlab_octave/cmdref_gf_cont_struct_get:gf-cont-struct-get}}\label{\detokenize{matlab_octave/cmdref_gf_cont_struct_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{h} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{init step size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{h} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{min step size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{h} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max step size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{h} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{step size decrement}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{h} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{step size increment}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{vec} \PYG{n}{tangent\PYGZus{}sol}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{tangent\PYGZus{}par}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute tangent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{solution}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{parameter}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{tangent\PYGZus{}sol}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{tangent\PYGZus{}par}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{init Moore\PYGZhy{}Penrose continuation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{solution}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{parameter}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{init\PYGZus{}dir}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Moore\PYGZhy{}Penrose continuation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{solution}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{parameter}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{tangent\PYGZus{}sol}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{tangent\PYGZus{}par}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{h}\PYG{p}{)}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{non\PYGZhy{}smooth bifurcation test}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{solution1}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{parameter1}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{tangent\PYGZus{}sol1}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{tangent\PYGZus{}par1}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{solution2}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{parameter2}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{tangent\PYGZus{}sol2}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{tangent\PYGZus{}par2}\PYG{p}{)}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bifurcation test function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{X}\PYG{p}{,} \PYG{n}{gamma}\PYG{p}{,} \PYG{n}{T\PYGZus{}X}\PYG{p}{,} \PYG{n}{T\PYGZus{}gamma}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sing\PYGZus{}data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}cont\PYGZus{}struct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cont\PYGZus{}struct} \PYG{n}{CS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about cont\_struct objects and for
applying them to numerical continuation.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{h = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}init step size\textquotesingle{})}}
\begin{quote}

Return an initial step size for continuation.
\end{quote}

\sphinxcode{\sphinxupquote{h = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}min step size\textquotesingle{})}}
\begin{quote}

Return the minimum step size for continuation.
\end{quote}

\sphinxcode{\sphinxupquote{h = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}max step size\textquotesingle{})}}
\begin{quote}

Return the maximum step size for continuation.
\end{quote}

\sphinxcode{\sphinxupquote{h = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}step size decrement\textquotesingle{})}}
\begin{quote}

Return the decrement ratio of the step size for continuation.
\end{quote}

\sphinxcode{\sphinxupquote{h = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}step size increment\textquotesingle{})}}
\begin{quote}

Return the increment ratio of the step size for continuation.
\end{quote}

\sphinxcode{\sphinxupquote{{[}vec tangent\_sol, scalar tangent\_par{]} = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}compute tangent\textquotesingle{}, vec solution, scalar parameter, vec tangent\_sol, scalar tangent\_par)}}
\begin{quote}

Compute and return an updated tangent.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}init Moore\sphinxhyphen{}Penrose continuation\textquotesingle{}, vec solution, scalar parameter, scalar init\_dir)}}
\begin{quote}

Initialise the Moore\sphinxhyphen{}Penrose continuation: Return a unit tangent to
the solution curve at the point given by \sphinxtitleref{solution} and \sphinxtitleref{parameter},
and an initial step size for the continuation. Orientation of the
computed tangent with respect to the parameter is determined by the
sign of \sphinxtitleref{init\_dir}.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}Moore\sphinxhyphen{}Penrose continuation\textquotesingle{}, vec solution, scalar parameter, vec tangent\_sol, scalar tangent\_par, scalar h)}}
\begin{quote}

Compute one step of the Moore\sphinxhyphen{}Penrose continuation: Take the point
given by \sphinxtitleref{solution} and \sphinxtitleref{parameter}, the tangent given by \sphinxtitleref{tangent\_sol}
and \sphinxtitleref{tangent\_par}, and the step size \sphinxtitleref{h}. Return a new point on the
solution curve, the corresponding tangent, a step size for the next
step and optionally the current step size. If the returned step
size equals zero, the continuation has failed. Optionally, return
the type of any detected singular point.
NOTE: The new point need not to be saved in the model in the end!
\end{quote}

\sphinxcode{\sphinxupquote{t = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}non\sphinxhyphen{}smooth bifurcation test\textquotesingle{}, vec solution1, scalar parameter1, vec tangent\_sol1, scalar tangent\_par1, vec solution2, scalar parameter2, vec tangent\_sol2, scalar tangent\_par2)}}
\begin{quote}

Test for a non\sphinxhyphen{}smooth bifurcation point between the point given by
\sphinxtitleref{solution1} and \sphinxtitleref{parameter1} with the tangent given by \sphinxtitleref{tangent\_sol1}
and \sphinxtitleref{tangent\_par1} and the point given by \sphinxtitleref{solution2} and \sphinxtitleref{parameter2}
with the tangent given by \sphinxtitleref{tangent\_sol2} and \sphinxtitleref{tangent\_par2}.
\end{quote}

\sphinxcode{\sphinxupquote{t = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}bifurcation test function\textquotesingle{})}}
\begin{quote}

Return the last value of the bifurcation test function and eventually
the whole calculated graph when passing between different sub\sphinxhyphen{}domains
of differentiability.
\end{quote}

\sphinxcode{\sphinxupquote{\{X, gamma, T\_X, T\_gamma\} = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}sing\_data\textquotesingle{})}}
\begin{quote}

Return a singular point (\sphinxtitleref{X}, \sphinxtitleref{gamma}) stored in the cont\_struct object and a
couple of arrays (\sphinxtitleref{T\_X}, \sphinxtitleref{T\_gamma}) of tangents to all located solution
branches that emanate from there.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the cont\_struct.

This can be used for performing comparisons between two
different cont\_struct objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_cont\_struct\_get(cont\_struct CS, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

Display a short summary for a cont\_struct object.
\end{quote}
\end{quote}


\section{gf\_cvstruct\_get}
\label{\detokenize{matlab_octave/cmdref_gf_cvstruct_get:gf-cvstruct-get}}\label{\detokenize{matlab_octave/cmdref_gf_cvstruct_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cvstruct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cvstruct} \PYG{n}{CVS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbpts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cvstruct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cvstruct} \PYG{n}{CVS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{cs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cvstruct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cvstruct} \PYG{n}{CVS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basic structure}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{cs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cvstruct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cvstruct} \PYG{n}{CVS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{face}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{F}\PYG{p}{)}
\PYG{n}{I} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cvstruct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cvstruct} \PYG{n}{CVS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{facepts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{F}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}cvstruct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cvstruct} \PYG{n}{CVS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}cvstruct\PYGZus{}get}\PYG{p}{(}\PYG{n}{cvstruct} \PYG{n}{CVS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about convex\_structure objects.

The convex structures are internal structures of GetFEM. They do not
contain points positions. These structures are recursive, since the faces
of a convex structures are convex structures.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{n = gf\_cvstruct\_get(cvstruct CVS, \textquotesingle{}nbpts\textquotesingle{})}}
\begin{quote}

Get the number of points of the convex structure.
\end{quote}

\sphinxcode{\sphinxupquote{d = gf\_cvstruct\_get(cvstruct CVS, \textquotesingle{}dim\textquotesingle{})}}
\begin{quote}

Get the dimension of the convex structure.
\end{quote}

\sphinxcode{\sphinxupquote{cs = gf\_cvstruct\_get(cvstruct CVS, \textquotesingle{}basic structure\textquotesingle{})}}
\begin{quote}

Get the simplest convex structure.

For example, the ‘basic structure’ of the 6\sphinxhyphen{}node triangle, is the
canonical 3\sphinxhyphen{}noded triangle.
\end{quote}

\sphinxcode{\sphinxupquote{cs = gf\_cvstruct\_get(cvstruct CVS, \textquotesingle{}face\textquotesingle{}, int F)}}
\begin{quote}

Return the convex structure of the face \sphinxtitleref{F}.
\end{quote}

\sphinxcode{\sphinxupquote{I = gf\_cvstruct\_get(cvstruct CVS, \textquotesingle{}facepts\textquotesingle{}, int F)}}
\begin{quote}

Return the list of point indices for the face \sphinxtitleref{F}.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_cvstruct\_get(cvstruct CVS, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a string description of the cvstruct.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_cvstruct\_get(cvstruct CVS, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a cvstruct object.
\end{quote}
\end{quote}


\section{gf\_delete}
\label{\detokenize{matlab_octave/cmdref_gf_delete:gf-delete}}\label{\detokenize{matlab_octave/cmdref_gf_delete::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}delete}\PYG{p}{(}\PYG{n}{I}\PYG{p}{[}\PYG{p}{,} \PYG{n}{J}\PYG{p}{,} \PYG{n}{K}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Delete an existing getfem object from memory (mesh, mesh\_fem, etc.).
\begin{description}
\item[{SEE ALSO:}] \leavevmode
gf\_workspace, gf\_mesh, gf\_mesh\_fem.

\end{description}
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_delete(I{[}, J, K,...{]})}}
\begin{quote}

I should be a descriptor given by gf\_mesh(),
gf\_mesh\_im(), gf\_slice() etc.

Note that if another object uses I, then object I will be deleted only
when both have been asked for deletion.

Only objects listed in the output of gf\_workspace(‘stats’) can be
deleted (for example gf\_fem objects cannot be destroyed).

You may also use gf\_workspace(‘clear all’) to erase everything at
once.
\end{quote}
\end{quote}


\section{gf\_eltm}
\label{\detokenize{matlab_octave/cmdref_gf_eltm:gf-eltm}}\label{\detokenize{matlab_octave/cmdref_gf_eltm::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}eltm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{base}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fem} \PYG{n}{FEM}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}eltm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grad}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fem} \PYG{n}{FEM}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}eltm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hessian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fem} \PYG{n}{FEM}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}eltm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}eltm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grad\PYGZus{}geotrans}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}eltm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grad\PYGZus{}geotrans\PYGZus{}inv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}eltm}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{eltm} \PYG{n}{A}\PYG{p}{,} \PYG{n}{eltm} \PYG{n}{B}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for eltm objects.
\begin{quote}

This object represents a type of elementary matrix. In order to obtain a
numerical value of these matrices, see gf\_mesh\_im\_get(mesh\_im MI, ‘eltm’).

If you have very particular assembling needs, or if you just want to check
the content of an elementary matrix, this function might be useful. But
the generic assembly abilities of gf\_asm(…) should suit most needs.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{E = gf\_eltm(\textquotesingle{}base\textquotesingle{}, fem FEM)}}
\begin{quote}

return a descriptor for the integration of shape functions on
elements, using the fem \sphinxtitleref{FEM}.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_eltm(\textquotesingle{}grad\textquotesingle{}, fem FEM)}}
\begin{quote}

return a descriptor for the integration of the gradient of shape
functions on elements, using the fem \sphinxtitleref{FEM}.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_eltm(\textquotesingle{}hessian\textquotesingle{}, fem FEM)}}
\begin{quote}

return a descriptor for the integration of the hessian of shape
functions on elements, using the fem \sphinxtitleref{FEM}.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_eltm(\textquotesingle{}normal\textquotesingle{})}}
\begin{quote}

return a descriptor for the unit normal of convex faces.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_eltm(\textquotesingle{}grad\_geotrans\textquotesingle{})}}
\begin{quote}

return a descriptor to the gradient matrix of the geometric
transformation.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_eltm(\textquotesingle{}grad\_geotrans\_inv\textquotesingle{})}}
\begin{quote}

return a descriptor to the inverse of the gradient matrix of the
geometric transformation (this is rarely used).
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_eltm(\textquotesingle{}product\textquotesingle{}, eltm A, eltm B)}}
\begin{quote}

return a descriptor for the integration of the tensorial product of
elementary matrices \sphinxtitleref{A} and \sphinxtitleref{B}.
\end{quote}
\end{quote}


\section{gf\_fem}
\label{\detokenize{matlab_octave/cmdref_gf_fem:gf-fem}}\label{\detokenize{matlab_octave/cmdref_gf_fem::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{F} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interpolated\PYGZus{}fem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}source}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim\PYGZus{}target}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ivec} \PYG{n}{blocked\PYGZus{}dofs}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{bool} \PYG{n}{caching}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{F} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{projected\PYGZus{}fem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}source}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim\PYGZus{}target}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rg\PYGZus{}source}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rg\PYGZus{}target}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{blocked\PYGZus{}dofs}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{bool} \PYG{n}{caching}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{F} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem}\PYG{p}{(}\PYG{n}{string} \PYG{n}{fem\PYGZus{}name}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for fem objects.
\begin{quote}

This object represents a finite element method on a reference element.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{F = gf\_fem(\textquotesingle{}interpolated\_fem\textquotesingle{}, mesh\_fem mf\_source, mesh\_im mim\_target, {[}ivec blocked\_dofs{[}, bool caching{]}{]})}}
\begin{quote}

Build a special fem which is interpolated from another mesh\_fem.

Using this special finite element, it is possible to interpolate a given
mesh\_fem \sphinxtitleref{mf\_source} on another mesh, given the integration method \sphinxtitleref{mim\_target}
that will be used on this mesh.

Note that this finite element may be quite slow or consume much
memory depending if caching is used or not. By default \sphinxtitleref{caching} is
True
\end{quote}

\sphinxcode{\sphinxupquote{F = gf\_fem(\textquotesingle{}projected\_fem\textquotesingle{}, mesh\_fem mf\_source, mesh\_im mim\_target, int rg\_source, int rg\_target{[}, ivec blocked\_dofs{[}, bool caching{]}{]})}}
\begin{quote}

Build a special fem which is interpolated from another mesh\_fem.

Using this special finite element, it is possible to interpolate a given
mesh\_fem \sphinxtitleref{mf\_source} on another mesh, given the integration method \sphinxtitleref{mim\_target}
that will be used on this mesh.

Note that this finite element may be quite slow or consume much
memory depending if caching is used or not. By default \sphinxtitleref{caching} is
True
\end{quote}

\sphinxcode{\sphinxupquote{F = gf\_fem(string fem\_name)}}
\begin{quote}

The \sphinxtitleref{fem\_name} should contain a description of the finite element
method. Please refer to the GetFEM manual (especially the
description of finite element and integration methods) for a complete
reference. Here is a list of some of them:
\begin{itemize}
\item {} 
FEM\_PK(n,k) :
classical Lagrange element Pk on a simplex of dimension \sphinxtitleref{n}.

\item {} 
FEM\_PK\_DISCONTINUOUS(n,k{[},alpha{]}) :
discontinuous Lagrange element Pk on a simplex of dimension \sphinxtitleref{n}.

\item {} 
FEM\_QK(n,k) :
classical Lagrange element Qk on quadrangles, hexahedrons etc.

\item {} 
FEM\_QK\_DISCONTINUOUS(n,k{[},alpha{]}) :
discontinuous Lagrange element Qk on quadrangles, hexahedrons etc.

\item {} 
FEM\_Q2\_INCOMPLETE(n) :
incomplete Q2 elements with 8 and 20 dof (serendipity Quad 8 and
Hexa 20 elements).

\item {} 
FEM\_PK\_PRISM(n,k) :
classical Lagrange element Pk on a prism of dimension \sphinxtitleref{n}.

\item {} 
FEM\_PK\_PRISM\_DISCONTINUOUS(n,k{[},alpha{]}) :
classical discontinuous Lagrange element Pk on a prism.

\item {} 
FEM\_PK\_WITH\_CUBIC\_BUBBLE(n,k) :
classical Lagrange element Pk on a simplex with an additional
volumic bubble function.

\item {} 
FEM\_P1\_NONCONFORMING :
non\sphinxhyphen{}conforming P1 method on a triangle.

\item {} 
FEM\_P1\_BUBBLE\_FACE(n) :
P1 method on a simplex with an additional bubble function on face 0.

\item {} 
FEM\_P1\_BUBBLE\_FACE\_LAG :
P1 method on a simplex with an additional lagrange dof on face 0.

\item {} 
FEM\_PK\_HIERARCHICAL(n,k) :
PK element with a hierarchical basis.

\item {} 
FEM\_QK\_HIERARCHICAL(n,k) :
QK element with a hierarchical basis.

\item {} 
FEM\_PK\_PRISM\_HIERARCHICAL(n,k) :
PK element on a prism with a hierarchical basis.

\item {} 
FEM\_STRUCTURED\_COMPOSITE(fem f,k) :
Composite fem \sphinxtitleref{f} on a grid with \sphinxtitleref{k} divisions.

\item {} 
FEM\_PK\_HIERARCHICAL\_COMPOSITE(n,k,s) :
Pk composite element on a grid with \sphinxtitleref{s} subdivisions and with a
hierarchical basis.

\item {} 
FEM\_PK\_FULL\_HIERARCHICAL\_COMPOSITE(n,k,s) :
Pk composite element with \sphinxtitleref{s} subdivisions and a hierarchical basis
on both degree and subdivision.

\item {} 
FEM\_PRODUCT(A,B) :
tensorial product of two polynomial elements.

\item {} 
FEM\_HERMITE(n) :
Hermite element P3 on a simplex of dimension \sphinxtitleref{n = 1, 2, 3}.

\item {} 
FEM\_ARGYRIS :
Argyris element P5 on the triangle.

\item {} 
FEM\_HCT\_TRIANGLE :
Hsieh\sphinxhyphen{}Clough\sphinxhyphen{}Tocher element on the triangle (composite P3 element
which is C1), should be used with IM\_HCT\_COMPOSITE() integration
method.

\item {} 
FEM\_QUADC1\_COMPOSITE :
Quadrilateral element, composite P3 element and C1 (16 dof).

\item {} 
FEM\_REDUCED\_QUADC1\_COMPOSITE :
Quadrilateral element, composite P3 element and C1 (12 dof).

\item {} 
FEM\_RT0(n) :
Raviart\sphinxhyphen{}Thomas element of order 0 on a simplex of dimension \sphinxtitleref{n}.

\item {} 
FEM\_NEDELEC(n) :
Nedelec edge element of order 0 on a simplex of dimension \sphinxtitleref{n}.

\end{itemize}

Of course, you have to ensure that the selected fem is compatible with
the geometric transformation: a Pk fem has no meaning on a quadrangle.
\end{quote}
\end{quote}


\section{gf\_fem\_get}
\label{\detokenize{matlab_octave/cmdref_gf_fem_get:gf-fem-get}}\label{\detokenize{matlab_octave/cmdref_gf_fem_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbdof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{cv}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{index of global dof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{cv}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{td} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{target\PYGZus{}dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{P} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{cv}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}equivalent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}lagrange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}polynomial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{estimated\PYGZus{}degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{E} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{base\PYGZus{}value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{p}\PYG{p}{)}
\PYG{n}{ED} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grad\PYGZus{}base\PYGZus{}value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{p}\PYG{p}{)}
\PYG{n}{EH} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hess\PYGZus{}base\PYGZus{}value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{p}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{poly\PYGZus{}str}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{string} \PYG{o}{=} \PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{fem} \PYG{n}{F}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about FEM objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{n = gf\_fem\_get(fem F, \textquotesingle{}nbdof\textquotesingle{}{[}, int cv{]})}}
\begin{quote}

Return the number of dof for the fem.

Some specific fem (for example ‘interpolated\_fem’) may require a
convex number \sphinxtitleref{cv} to give their result. In most of the case, you
can omit this convex number.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_fem\_get(fem F, \textquotesingle{}index of global dof\textquotesingle{}, cv)}}
\begin{quote}

Return the index of global dof for special fems such as interpolated fem.
\end{quote}

\sphinxcode{\sphinxupquote{d = gf\_fem\_get(fem F, \textquotesingle{}dim\textquotesingle{})}}
\begin{quote}

Return the dimension (dimension of the reference convex) of the fem.
\end{quote}

\sphinxcode{\sphinxupquote{td = gf\_fem\_get(fem F, \textquotesingle{}target\_dim\textquotesingle{})}}
\begin{quote}

Return the dimension of the target space.

The target space dimension is usually 1, except for vector fem.
\end{quote}

\sphinxcode{\sphinxupquote{P = gf\_fem\_get(fem F, \textquotesingle{}pts\textquotesingle{}{[}, int cv{]})}}
\begin{quote}

Get the location of the dof on the reference element.

Some specific fem may require a convex number \sphinxtitleref{cv} to give their
result (for example ‘interpolated\_fem’). In most of the case, you
can omit this convex number.
\end{quote}

\sphinxcode{\sphinxupquote{b = gf\_fem\_get(fem F, \textquotesingle{}is\_equivalent\textquotesingle{})}}
\begin{quote}

Return 0 if the fem is not equivalent.

Equivalent fem are evaluated on the reference convex. This is
the case of most classical fem’s.
\end{quote}

\sphinxcode{\sphinxupquote{b = gf\_fem\_get(fem F, \textquotesingle{}is\_lagrange\textquotesingle{})}}
\begin{quote}

Return 0 if the fem is not of Lagrange type.
\end{quote}

\sphinxcode{\sphinxupquote{b = gf\_fem\_get(fem F, \textquotesingle{}is\_polynomial\textquotesingle{})}}
\begin{quote}

Return 0 if the basis functions are not polynomials.
\end{quote}

\sphinxcode{\sphinxupquote{d = gf\_fem\_get(fem F, \textquotesingle{}estimated\_degree\textquotesingle{})}}
\begin{quote}

Return an estimation of the polynomial degree of the fem.

This is an estimation for fem which are not polynomials.
\end{quote}

\sphinxcode{\sphinxupquote{E = gf\_fem\_get(fem F, \textquotesingle{}base\_value\textquotesingle{},mat p)}}
\begin{quote}

Evaluate all basis functions of the FEM at point \sphinxtitleref{p}.

\sphinxtitleref{p} is supposed to be in the reference convex!
\end{quote}

\sphinxcode{\sphinxupquote{ED = gf\_fem\_get(fem F, \textquotesingle{}grad\_base\_value\textquotesingle{},mat p)}}
\begin{quote}

Evaluate the gradient of all base functions of the fem at point \sphinxtitleref{p}.

\sphinxtitleref{p} is supposed to be in the reference convex!
\end{quote}

\sphinxcode{\sphinxupquote{EH = gf\_fem\_get(fem F, \textquotesingle{}hess\_base\_value\textquotesingle{},mat p)}}
\begin{quote}

Evaluate the Hessian of all base functions of the fem at point \sphinxtitleref{p}.

\sphinxtitleref{p} is supposed to be in the reference convex!
\end{quote}

\sphinxcode{\sphinxupquote{gf\_fem\_get(fem F, \textquotesingle{}poly\_str\textquotesingle{})}}
\begin{quote}

Return the polynomial expressions of its basis functions in
the reference convex.

The result is expressed as a cell array of
strings. Of course this will fail on non\sphinxhyphen{}polynomial fem’s.
\end{quote}

\sphinxcode{\sphinxupquote{string = gf\_fem\_get(fem F, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Ouput a (unique) string representation of the fem.

This can be used to perform comparisons between two different fem
objects.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_fem\_get(fem F, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a fem object.
\end{quote}
\end{quote}


\section{gf\_geotrans}
\label{\detokenize{matlab_octave/cmdref_gf_geotrans:gf-geotrans}}\label{\detokenize{matlab_octave/cmdref_gf_geotrans::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GT} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans}\PYG{p}{(}\PYG{n}{string} \PYG{n}{name}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for geotrans objects.
\begin{quote}

The geometric transformation must be used when you are building a custom
mesh convex by convex (see the add\_convex() function of mesh): it also
defines the kind of convex (triangle, hexahedron, prism, etc..)
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{GT = gf\_geotrans(string name)}}
\begin{quote}

The name argument contains the specification of the geometric transformation
as a string, which may be:
\begin{itemize}
\item {} 
GT\_PK(n,k) :
Transformation on simplexes, dim \sphinxtitleref{n}, degree \sphinxtitleref{k}.

\item {} 
GT\_QK(n,k) :
Transformation on parallelepipeds, dim \sphinxtitleref{n}, degree \sphinxtitleref{k}.

\item {} 
GT\_PRISM(n,k) :
Transformation on prisms, dim \sphinxtitleref{n}, degree \sphinxtitleref{k}.

\item {} 
GT\_PRODUCT(A,B) :
Tensorial product of two transformations.

\item {} 
GT\_LINEAR\_PRODUCT(geotrans gt1,geotrans gt2) :
Linear tensorial product of two transformations

\end{itemize}
\end{quote}
\end{quote}


\section{gf\_geotrans\_get}
\label{\detokenize{matlab_octave/cmdref_gf_geotrans_get:gf-geotrans-get}}\label{\detokenize{matlab_octave/cmdref_gf_geotrans_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}linear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbpts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{P} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{N} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normals}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Pt} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transform}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{G}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{Pr}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}geotrans\PYGZus{}get}\PYG{p}{(}\PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about geometric transformations
objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{d = gf\_geotrans\_get(geotrans GT, \textquotesingle{}dim\textquotesingle{})}}
\begin{quote}

Get the dimension of the geotrans.

This is the dimension of the source space, i.e. the dimension of
the reference convex.
\end{quote}

\sphinxcode{\sphinxupquote{b = gf\_geotrans\_get(geotrans GT, \textquotesingle{}is\_linear\textquotesingle{})}}
\begin{quote}

Return 0 if the geotrans is not linear.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_geotrans\_get(geotrans GT, \textquotesingle{}nbpts\textquotesingle{})}}
\begin{quote}

Return the number of points of the geotrans.
\end{quote}

\sphinxcode{\sphinxupquote{P = gf\_geotrans\_get(geotrans GT, \textquotesingle{}pts\textquotesingle{})}}
\begin{quote}

Return the reference convex points of the geotrans.

The points are stored in the columns of the output matrix.
\end{quote}

\sphinxcode{\sphinxupquote{N = gf\_geotrans\_get(geotrans GT, \textquotesingle{}normals\textquotesingle{})}}
\begin{quote}

Get the normals for each face of the reference convex of the geotrans.

The normals are stored in the columns of the output matrix.
\end{quote}

\sphinxcode{\sphinxupquote{Pt = gf\_geotrans\_get(geotrans GT, \textquotesingle{}transform\textquotesingle{},mat G, mat Pr)}}
\begin{quote}

Apply the geotrans to a set of points.

\sphinxtitleref{G} is the set of vertices of the real convex, \sphinxtitleref{Pr} is the set
of points (in the reference convex) that are to be transformed.
The corresponding set of points in the real convex is returned.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_geotrans\_get(geotrans GT, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the geotrans.

This can be used to perform comparisons between two
different geotrans objects.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_geotrans\_get(geotrans GT, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a geotrans object.
\end{quote}
\end{quote}


\section{gf\_global\_function}
\label{\detokenize{matlab_octave/cmdref_gf_global_function:gf-global-function}}\label{\detokenize{matlab_octave/cmdref_gf_global_function::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{GF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cutoff}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{fn}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{r}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{r1}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{r0}\PYG{p}{)}
\PYG{n}{GF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{crack}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{fn}\PYG{p}{)}
\PYG{n}{GF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{parser}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{val}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{grad}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{hess}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{GF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{global\PYGZus{}function} \PYG{n}{F}\PYG{p}{,} \PYG{n}{global\PYGZus{}function} \PYG{n}{G}\PYG{p}{)}
\PYG{n}{GF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{global\PYGZus{}function} \PYG{n}{gf1}\PYG{p}{,} \PYG{n}{global\PYGZus{}function} \PYG{n}{gf2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for global\_function objects.
\begin{quote}

Global function object is represented by three functions:
\begin{itemize}
\item {} 
The function \sphinxtitleref{val}.

\item {} 
The function gradient \sphinxtitleref{grad}.

\item {} 
The function Hessian \sphinxtitleref{hess}.

\end{itemize}

this type of function is used as local and global enrichment function. The
global function Hessian is an optional parameter (only for fourth order
derivative problems).
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{GF = gf\_global\_function(\textquotesingle{}cutoff\textquotesingle{}, int fn, scalar r, scalar r1, scalar r0)}}
\begin{quote}

Create a cutoff global function.
\end{quote}

\sphinxcode{\sphinxupquote{GF = gf\_global\_function(\textquotesingle{}crack\textquotesingle{}, int fn)}}
\begin{quote}

Create a near\sphinxhyphen{}tip asymptotic global function for modelling cracks.
\end{quote}

\sphinxcode{\sphinxupquote{GF = gf\_global\_function(\textquotesingle{}parser\textquotesingle{}, string val{[}, string grad{[}, string hess{]}{]})}}
\begin{quote}

Create a global function from strings \sphinxtitleref{val}, \sphinxtitleref{grad} and \sphinxtitleref{hess}.
This function could be improved by using the derivation of the generic
assembly language … to be done.
\end{quote}

\sphinxcode{\sphinxupquote{GF = gf\_global\_function(\textquotesingle{}product\textquotesingle{}, global\_function F, global\_function G)}}
\begin{quote}

Create a product of two global functions.
\end{quote}

\sphinxcode{\sphinxupquote{GF = gf\_global\_function(\textquotesingle{}add\textquotesingle{}, global\_function gf1, global\_function gf2)}}
\begin{quote}

Create a add of two global functions.
\end{quote}
\end{quote}


\section{gf\_global\_function\_get}
\label{\detokenize{matlab_octave/cmdref_gf_global_function_get:gf-global-function-get}}\label{\detokenize{matlab_octave/cmdref_gf_global_function_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{VALs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function\PYGZus{}get}\PYG{p}{(}\PYG{n}{global\PYGZus{}function} \PYG{n}{GF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{val}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{PTs}\PYG{p}{)}
\PYG{n}{GRADs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function\PYGZus{}get}\PYG{p}{(}\PYG{n}{global\PYGZus{}function} \PYG{n}{GF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grad}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{PTs}\PYG{p}{)}
\PYG{n}{HESSs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function\PYGZus{}get}\PYG{p}{(}\PYG{n}{global\PYGZus{}function} \PYG{n}{GF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hess}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{PTs}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}global\PYGZus{}function\PYGZus{}get}\PYG{p}{(}\PYG{n}{global\PYGZus{}function} \PYG{n}{GF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}global\PYGZus{}function\PYGZus{}get}\PYG{p}{(}\PYG{n}{global\PYGZus{}function} \PYG{n}{GF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about global\_function objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{VALs = gf\_global\_function\_get(global\_function GF, \textquotesingle{}val\textquotesingle{},mat PTs)}}
\begin{quote}

Return \sphinxtitleref{val} function evaluation in \sphinxtitleref{PTs} (column points).
\end{quote}

\sphinxcode{\sphinxupquote{GRADs = gf\_global\_function\_get(global\_function GF, \textquotesingle{}grad\textquotesingle{},mat PTs)}}
\begin{quote}

Return \sphinxtitleref{grad} function evaluation in \sphinxtitleref{PTs} (column points).

On return, each column of \sphinxtitleref{GRADs} is of the
form {[}Gx,Gy{]}.
\end{quote}

\sphinxcode{\sphinxupquote{HESSs = gf\_global\_function\_get(global\_function GF, \textquotesingle{}hess\textquotesingle{},mat PTs)}}
\begin{quote}

Return \sphinxtitleref{hess} function evaluation in \sphinxtitleref{PTs} (column points).

On return, each column of \sphinxtitleref{HESSs} is of the
form {[}Hxx,Hxy,Hyx,Hyy{]}.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_global\_function\_get(global\_function GF, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the global\_function.

This can be used to perform comparisons between two
different global\_function objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_global\_function\_get(global\_function GF, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a global\_function object.
\end{quote}
\end{quote}


\section{gf\_integ}
\label{\detokenize{matlab_octave/cmdref_gf_integ:gf-integ}}\label{\detokenize{matlab_octave/cmdref_gf_integ::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{I} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ}\PYG{p}{(}\PYG{n}{string} \PYG{n}{method}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for integ objects.
\begin{quote}

General object for obtaining handles to various integrations methods on
convexes (used when the elementary matrices are built).
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{I = gf\_integ(string method)}}
\begin{quote}

Here is a list of some integration methods defined in GetFEM (see the
description of finite element and integration methods for a complete
reference):
\begin{itemize}
\item {} 
IM\_EXACT\_SIMPLEX(n) :
Exact integration on simplices (works only with linear geometric
transformations and PK fem’s).

\item {} 
IM\_PRODUCT(A,B) :
Product of two integration methods.

\item {} 
IM\_EXACT\_PARALLELEPIPED(n) :
Exact integration on parallelepipeds.

\item {} 
IM\_EXACT\_PRISM(n) :
Exact integration on prisms.

\item {} 
IM\_GAUSS1D(k) :
Gauss method on the segment, order \sphinxtitleref{k=1,3,…,99}.

\item {} 
IM\_NC(n,k) :
Newton\sphinxhyphen{}Cotes approximative integration on simplexes, order \sphinxtitleref{k}.

\item {} 
IM\_NC\_PARALLELEPIPED(n,k) :
Product of Newton\sphinxhyphen{}Cotes integration on parallelepipeds.

\item {} 
IM\_NC\_PRISM(n,k) :
Product of Newton\sphinxhyphen{}Cotes integration on prisms.

\item {} 
IM\_GAUSS\_PARALLELEPIPED(n,k) :
Product of Gauss1D integration on parallelepipeds.

\item {} 
IM\_TRIANGLE(k) :
Gauss methods on triangles \sphinxtitleref{k=1,3,5,6,7,8,9,10,13,17,19}.

\item {} 
IM\_QUAD(k) :
Gauss methods on quadrilaterons \sphinxtitleref{k=2,3,5, …,17}. Note that
IM\_GAUSS\_PARALLELEPIPED should be prefered for QK fem’s.

\item {} 
IM\_TETRAHEDRON(k) :
Gauss methods on tetrahedrons \sphinxtitleref{k=1,2,3,5,6 or 8}.

\item {} 
IM\_SIMPLEX4D(3) :
Gauss method on a 4\sphinxhyphen{}dimensional simplex.

\item {} 
IM\_STRUCTURED\_COMPOSITE(im,k) :
Composite method on a grid with \sphinxtitleref{k} divisions.

\item {} 
IM\_HCT\_COMPOSITE(im) :
Composite integration suited to the HCT composite finite element.

\end{itemize}

Example:
\begin{itemize}
\item {} 
I = gf\_integ(‘IM\_PRODUCT(IM\_GAUSS1D(5),IM\_GAUSS1D(5))’)

\end{itemize}

is the same as:
\begin{itemize}
\item {} 
I = gf\_integ(‘IM\_GAUSS\_PARALLELEPIPED(2,5)’)

\end{itemize}

Note that ‘exact integration’ should be avoided in general, since they
only apply to linear geometric transformations, are quite slow, and
subject to numerical stability problems for high degree fem’s.
\end{quote}
\end{quote}


\section{gf\_integ\_get}
\label{\detokenize{matlab_octave/cmdref_gf_integ_get:gf-integ-get}}\label{\detokenize{matlab_octave/cmdref_gf_integ_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}exact}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbpts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Pp} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Pf} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{face\PYGZus{}pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{F}\PYG{p}{)}
\PYG{n}{Cp} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{coeffs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Cf} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{face\PYGZus{}coeffs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{F}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{n}{integ} \PYG{n}{I}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about integration method objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{b = gf\_integ\_get(integ I, \textquotesingle{}is\_exact\textquotesingle{})}}
\begin{quote}

Return 0 if the integration is an approximate one.
\end{quote}

\sphinxcode{\sphinxupquote{d = gf\_integ\_get(integ I, \textquotesingle{}dim\textquotesingle{})}}
\begin{quote}

Return the dimension of the reference convex of
the method.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_integ\_get(integ I, \textquotesingle{}nbpts\textquotesingle{})}}
\begin{quote}

Return the total number of integration points.

Count the points for the volume integration, and points for
surface integration on each face of the reference convex.

Only for approximate methods, this has no meaning for exact
integration methods!
\end{quote}

\sphinxcode{\sphinxupquote{Pp = gf\_integ\_get(integ I, \textquotesingle{}pts\textquotesingle{})}}
\begin{quote}

Return the list of integration points

Only for approximate methods, this has no meaning for exact
integration methods!
\end{quote}

\sphinxcode{\sphinxupquote{Pf = gf\_integ\_get(integ I, \textquotesingle{}face\_pts\textquotesingle{},F)}}
\begin{quote}

Return the list of integration points for a face.

Only for approximate methods, this has no meaning for exact
integration methods!
\end{quote}

\sphinxcode{\sphinxupquote{Cp = gf\_integ\_get(integ I, \textquotesingle{}coeffs\textquotesingle{})}}
\begin{quote}

Returns the coefficients associated to each integration point.

Only for approximate methods, this has no meaning for exact
integration methods!
\end{quote}

\sphinxcode{\sphinxupquote{Cf = gf\_integ\_get(integ I, \textquotesingle{}face\_coeffs\textquotesingle{},F)}}
\begin{quote}

Returns the coefficients associated to each integration of a face.

Only for approximate methods, this has no meaning for exact
integration methods!
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_integ\_get(integ I, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Ouput a (unique) string representation of the integration method.

This can be used to  comparisons between two different integ
objects.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_integ\_get(integ I, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a integ object.
\end{quote}
\end{quote}


\section{gf\_levelset}
\label{\detokenize{matlab_octave/cmdref_gf_levelset:gf-levelset}}\label{\detokenize{matlab_octave/cmdref_gf_levelset::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LS} \PYG{o}{=} \PYG{n}{gf\PYGZus{}levelset}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{d}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ws}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{|} \PYG{n}{string} \PYG{n}{f1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{f2} \PYG{o}{|} \PYG{n}{string} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ws}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for levelset objects.
\begin{quote}

The level\sphinxhyphen{}set object is represented by a primary level\sphinxhyphen{}set and optionally
a secondary level\sphinxhyphen{}set used to represent fractures (if p(x) is the primary
level\sphinxhyphen{}set function and s(x) is the secondary level\sphinxhyphen{}set, the crack is
defined by \(p(x)=0\) and \(s(x)\leq0\) : the role of the secondary is to determine
the crack front/tip).

note:
\begin{quote}

All tools listed below need the package qhull installed on your
system. This package is widely available. It computes convex hull and
delaunay triangulations in arbitrary dimension.
\end{quote}
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{LS = gf\_levelset(mesh m, int d{[}, string \textquotesingle{}ws\textquotesingle{}| string f1{[}, string f2 | string \textquotesingle{}ws\textquotesingle{}{]}{]})}}
\begin{quote}

Create a levelset object on a mesh represented by a primary function
(and optional secondary function, both) defined on a lagrange mesh\_fem of
degree \sphinxtitleref{d}.

If \sphinxtitleref{ws} (with secondary) is set; this levelset is represented by a
primary function and a secondary function. If \sphinxtitleref{f1} is set; the primary
function is defined by that expression (with the syntax of the high
generic assembly language). If \sphinxtitleref{f2} is set; this levelset
is represented by a primary function and a secondary function defined
by these expressions.
\end{quote}
\end{quote}


\section{gf\_levelset\_get}
\label{\detokenize{matlab_octave/cmdref_gf_levelset_get:gf-levelset-get}}\label{\detokenize{matlab_octave/cmdref_gf_levelset_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{values}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{nls}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mf} \PYG{o}{=} \PYG{n}{gf\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{gf\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{memsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about LEVELSET objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{V = gf\_levelset\_get(levelset LS, \textquotesingle{}values\textquotesingle{}, int nls)}}
\begin{quote}

Return the vector of dof for \sphinxtitleref{nls} function.

If \sphinxtitleref{nls} is 0, the method return the vector of dof for the primary
level\sphinxhyphen{}set function. If \sphinxtitleref{nls} is 1, the method return the vector of
dof for the secondary level\sphinxhyphen{}set function (if any).
\end{quote}

\sphinxcode{\sphinxupquote{d = gf\_levelset\_get(levelset LS, \textquotesingle{}degree\textquotesingle{})}}
\begin{quote}

Return the degree of lagrange representation.
\end{quote}

\sphinxcode{\sphinxupquote{mf = gf\_levelset\_get(levelset LS, \textquotesingle{}mf\textquotesingle{})}}
\begin{quote}

Return a reference on the mesh\_fem object.
\end{quote}

\sphinxcode{\sphinxupquote{z = gf\_levelset\_get(levelset LS, \textquotesingle{}memsize\textquotesingle{})}}
\begin{quote}

Return the amount of memory (in bytes) used by the level\sphinxhyphen{}set.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_levelset\_get(levelset LS, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the levelset.

This can be used to perform comparisons between two
different levelset objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_levelset\_get(levelset LS, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a levelset.
\end{quote}
\end{quote}


\section{gf\_levelset\_set}
\label{\detokenize{matlab_octave/cmdref_gf_levelset_set:gf-levelset-set}}\label{\detokenize{matlab_octave/cmdref_gf_levelset_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}levelset\PYGZus{}set}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{values}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{mat} \PYG{n}{v1}\PYG{o}{|}\PYG{n}{string} \PYG{n}{func\PYGZus{}1}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{v2}\PYG{o}{|}\PYG{n}{string} \PYG{n}{func\PYGZus{}2}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}levelset\PYGZus{}set}\PYG{p}{(}\PYG{n}{levelset} \PYG{n}{LS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{simplify}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{eps}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for modification of LEVELSET objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_levelset\_set(levelset LS, \textquotesingle{}values\textquotesingle{}, \{mat v1|string func\_1\}{[}, mat v2|string func\_2{]})}}
\begin{quote}

Set values of the vector of dof for the level\sphinxhyphen{}set functions.

Set the primary function with the vector of dof \sphinxtitleref{v1} (or the expression
\sphinxtitleref{func\_1}) and the secondary function (if any) with  the vector of dof
\sphinxtitleref{v2} (or the expression \sphinxtitleref{func\_2})
\end{quote}

\sphinxcode{\sphinxupquote{gf\_levelset\_set(levelset LS, \textquotesingle{}simplify\textquotesingle{}{[}, scalar eps=0.01{]})}}
\begin{quote}

Simplify dof of level\sphinxhyphen{}set optionally with the parameter \sphinxtitleref{eps}.
\end{quote}
\end{quote}


\section{gf\_linsolve}
\label{\detokenize{matlab_octave/cmdref_gf_linsolve:gf-linsolve}}\label{\detokenize{matlab_octave/cmdref_gf_linsolve::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X} \PYG{o}{=} \PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gmres}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{M}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{b}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{restart}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{precond} \PYG{n}{P}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{noisy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{res}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{maxiter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{X} \PYG{o}{=} \PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{M}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{b} \PYG{p}{[}\PYG{p}{,} \PYG{n}{precond} \PYG{n}{P}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{noisy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{res}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{maxiter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{X} \PYG{o}{=} \PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bicgstab}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{M}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{b} \PYG{p}{[}\PYG{p}{,} \PYG{n}{precond} \PYG{n}{P}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{noisy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{res}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{r}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{maxiter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{n}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{U}\PYG{p}{,} \PYG{n}{cond}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{M}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{U}\PYG{p}{,} \PYG{n}{cond}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{superlu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{M}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{U}\PYG{p}{,} \PYG{n}{cond}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}linsolve}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mumps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{M}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{b}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Various linear system solvers.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{X = gf\_linsolve(\textquotesingle{}gmres\textquotesingle{}, spmat M, vec b{[}, int restart{]}{[}, precond P{]}{[},\textquotesingle{}noisy\textquotesingle{}{]}{[},\textquotesingle{}res\textquotesingle{}, r{]}{[},\textquotesingle{}maxiter\textquotesingle{}, n{]})}}
\begin{quote}

Solve \sphinxtitleref{M.X = b} with the generalized minimum residuals method.

Optionally using \sphinxtitleref{P} as preconditioner. The default value of the
restart parameter is 50.
\end{quote}

\sphinxcode{\sphinxupquote{X = gf\_linsolve(\textquotesingle{}cg\textquotesingle{}, spmat M, vec b {[}, precond P{]}{[},\textquotesingle{}noisy\textquotesingle{}{]}{[},\textquotesingle{}res\textquotesingle{}, r{]}{[},\textquotesingle{}maxiter\textquotesingle{}, n{]})}}
\begin{quote}

Solve \sphinxtitleref{M.X = b} with the conjugated gradient method.

Optionally using \sphinxtitleref{P} as preconditioner.
\end{quote}

\sphinxcode{\sphinxupquote{X = gf\_linsolve(\textquotesingle{}bicgstab\textquotesingle{}, spmat M, vec b {[}, precond P{]}{[},\textquotesingle{}noisy\textquotesingle{}{]}{[},\textquotesingle{}res\textquotesingle{}, r{]}{[},\textquotesingle{}maxiter\textquotesingle{}, n{]})}}
\begin{quote}

Solve \sphinxtitleref{M.X = b} with the bi\sphinxhyphen{}conjugated gradient stabilized method.

Optionally using \sphinxtitleref{P} as a preconditioner.
\end{quote}

\sphinxcode{\sphinxupquote{\{U, cond\} = gf\_linsolve(\textquotesingle{}lu\textquotesingle{}, spmat M, vec b)}}
\begin{quote}

Alias for gf\_linsolve(‘superlu’,…)
\end{quote}

\sphinxcode{\sphinxupquote{\{U, cond\} = gf\_linsolve(\textquotesingle{}superlu\textquotesingle{}, spmat M, vec b)}}
\begin{quote}

Solve \sphinxtitleref{M.U = b} apply the SuperLU solver (sparse LU factorization).

The condition number estimate \sphinxtitleref{cond} is returned with the solution \sphinxtitleref{U}.
\end{quote}

\sphinxcode{\sphinxupquote{\{U, cond\} = gf\_linsolve(\textquotesingle{}mumps\textquotesingle{}, spmat M, vec b)}}
\begin{quote}

Solve \sphinxtitleref{M.U = b} using the MUMPS solver.
\end{quote}
\end{quote}


\section{gf\_mesh}
\label{\detokenize{matlab_octave/cmdref_gf_mesh:gf-mesh}}\label{\detokenize{matlab_octave/cmdref_gf_mesh::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{empty}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{dim}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cartesian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{X}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Y}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Z}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pyramidal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{X}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Y}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Z}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cartesian Q1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{X}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Y}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Z}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{triangles grid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{X}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Y}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{regular simplices}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{X}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Y}\PYG{p}{[}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{Z}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{degree}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{k}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{noised}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{curved}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{F}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{prismatic}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{nl}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{degree}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pt2D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{P}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{T}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{n}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ptND}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{P}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{T}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{load}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{from string}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{s}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{import}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n+nb}{format}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clone}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m2}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesher\PYGZus{}object} \PYG{n}{mo}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{h}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{K} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{vertices}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for mesh objects.
\begin{quote}

This object is able to store any element in any dimension even if you mix
elements with different dimensions.

Note that for recent (\textgreater{} 6.0) versions of matlab, you should
replace the calls to ‘gf\_mesh’ with ‘gfMesh’ (this will instruct Matlab to
consider the getfem mesh as a regular matlab object that can be
manipulated with get() and set() methods).
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}empty\textquotesingle{}, int dim)}}
\begin{quote}

Create a new empty mesh.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}cartesian\textquotesingle{}, vec X{[}, vec Y{[}, vec Z,..{]}{]})}}
\begin{quote}

Build quickly a regular mesh of quadrangles, cubes, etc.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}pyramidal\textquotesingle{}, vec X{[}, vec Y{[}, vec Z,..{]}{]})}}
\begin{quote}

Build quickly a regular mesh of pyramids, etc.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}cartesian Q1\textquotesingle{}, vec X, vec Y{[}, vec Z,..{]})}}
\begin{quote}

Build quickly a regular mesh of quadrangles, cubes, etc. with
Q1 elements.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}triangles grid\textquotesingle{}, vec X, vec Y)}}
\begin{quote}

Build quickly a regular mesh of triangles.

This is a very limited and somehow deprecated function (See also
\sphinxcode{\sphinxupquote{gf\_mesh(\textquotesingle{}ptND\textquotesingle{})}}, \sphinxcode{\sphinxupquote{gf\_mesh(\textquotesingle{}regular simplices\textquotesingle{})}} and
\sphinxcode{\sphinxupquote{gf\_mesh(\textquotesingle{}cartesian\textquotesingle{})}}).
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}regular simplices\textquotesingle{}, vec X{[}, vec Y{[}, vec Z,...{]}{]}{[}\textquotesingle{}degree\textquotesingle{}, int k{]}{[}\textquotesingle{}noised\textquotesingle{}{]})}}
\begin{quote}

Mesh a n\sphinxhyphen{}dimensional parallelepiped with simplices (triangles,
tetrahedrons etc) .

The optional degree may be used to build meshes with non linear
geometric transformations.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}curved\textquotesingle{}, mesh m, vec F)}}
\begin{quote}

Build a curved (n+1)\sphinxhyphen{}dimensions mesh from a n\sphinxhyphen{}dimensions mesh \sphinxtitleref{m}.

The points of the new mesh have one additional coordinate, given by
the vector \sphinxtitleref{F}. This can be used to obtain meshes for shells. \sphinxtitleref{m} may
be a mesh\_fem object, in that case its linked mesh will be used.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}prismatic\textquotesingle{}, mesh m, int nl{[}, int degree{]})}}
\begin{quote}

Extrude a prismatic mesh \sphinxtitleref{M} from a mesh \sphinxtitleref{m}.

In the additional dimension there are \sphinxtitleref{nl} layers of elements
distributed from \sphinxcode{\sphinxupquote{0}} to \sphinxcode{\sphinxupquote{1}}.
If the optional parameter \sphinxtitleref{degree} is provided with a value greater
than the default value of \sphinxcode{\sphinxupquote{1}}, a non\sphinxhyphen{}linear transformation of
corresponding degree is considered in the extrusion direction.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}pt2D\textquotesingle{}, mat P, imat T{[}, int n{]})}}
\begin{quote}

Build a mesh from a 2D triangulation.

Each column of \sphinxtitleref{P} contains a point coordinate, and each column of \sphinxtitleref{T}
contains the point indices of a triangle. \sphinxtitleref{n} is optional and is a
zone number. If \sphinxtitleref{n} is specified then only the zone number \sphinxtitleref{n} is
converted (in that case, \sphinxtitleref{T} is expected to have 4 rows, the fourth
containing these zone numbers).

Can be used to Convert a “pdetool” triangulation exported in
variables P and T into a GETFEM mesh.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}ptND\textquotesingle{}, mat P, imat T)}}
\begin{quote}

Build a mesh from a n\sphinxhyphen{}dimensional “triangulation”.

Similar function to ‘pt2D’, for building simplexes meshes from a
triangulation given in \sphinxtitleref{T}, and a list of points given in \sphinxtitleref{P}. The
dimension of the mesh will be the number of rows of \sphinxtitleref{P}, and the
dimension of the simplexes will be the number of rows of \sphinxtitleref{T}.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}load\textquotesingle{}, string filename)}}
\begin{quote}

Load a mesh from a GetFEM ascii mesh file.

See also \sphinxcode{\sphinxupquote{gf\_mesh\_get(mesh M, \textquotesingle{}save\textquotesingle{}, string filename)}}.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}from string\textquotesingle{}, string s)}}
\begin{quote}

Load a mesh from a string description.

For example, a string returned by \sphinxcode{\sphinxupquote{gf\_mesh\_get(mesh M, \textquotesingle{}char\textquotesingle{})}}.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}import\textquotesingle{}, string format, string filename)}}
\begin{quote}

Import a mesh.

\sphinxtitleref{format} may be:
\begin{itemize}
\item {} 
‘gmsh’ for a mesh created with \sphinxtitleref{Gmsh}

\item {} 
‘gid’ for a mesh created with \sphinxtitleref{GiD}

\item {} 
‘cdb’ for a mesh created with \sphinxtitleref{ANSYS}

\item {} 
‘am\_fmt’ for a mesh created with \sphinxtitleref{EMC2}

\end{itemize}
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}clone\textquotesingle{}, mesh m2)}}
\begin{quote}

Create a copy of a mesh.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh(\textquotesingle{}generate\textquotesingle{}, mesher\_object mo, scalar h{[}, int K = 1{[}, mat vertices{]}{]})}}
\begin{quote}

Call the experimental mesher of Getfem on the geometry
represented by \sphinxtitleref{mo}. please control the conformity of the produced mesh.
You can help the mesher by adding a priori vertices in the array
\sphinxtitleref{vertices} which should be of size \sphinxcode{\sphinxupquote{n x m}} where \sphinxcode{\sphinxupquote{n}} n is the
dimension of the mesh and \sphinxcode{\sphinxupquote{m}} the number of points. \sphinxtitleref{h} is
approximate diameter of the elements. \sphinxtitleref{K} is the degree of the
mesh ( \textgreater{} 1 for curved boundaries).  The mesher try to optimize the
quality of the elements. This operation may be time consuming.
Note that if the mesh generation fails, because of some random
procedure used, it can be run again since it will not give necessarily
the same result due to random procedures used.
The messages send to the console by the mesh generation can be
deactivated using \sphinxtitleref{gf\_util(‘trace level’, 2)}. More information
can be obtained by \sphinxtitleref{gf\_util(‘trace level’, 4)}. See \sphinxcode{\sphinxupquote{gf\_mesher\_object}}
to manipulate geometric primitives in order to describe the geometry.
\end{quote}
\end{quote}


\section{gf\_mesh\_get}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_get:gf-mesh-get}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{np} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbpts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{nc} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbcvs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{P} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{PIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Pid} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{PIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pid in faces}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{CVFIDs}\PYG{p}{)}
\PYG{n}{PIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pid in cvids}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{CVIDs}\PYG{p}{)}
\PYG{n}{PIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pid in regions}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{RIDs}\PYG{p}{)}
\PYG{n}{PIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pid from coords}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{PTS}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{Pid}\PYG{p}{,} \PYG{n}{IDx}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pid from cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{Pts}\PYG{p}{,} \PYG{n}{IDx}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts from cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVid} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max pid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{E}\PYG{p}{,}\PYG{n}{C}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{edges}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{[}\PYG{p}{,} \PYG{n}{CVLST}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{merge}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{E}\PYG{p}{,}\PYG{n}{C}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{curved edges}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{N} \PYG{p}{[}\PYG{p}{,} \PYG{n}{CVLST}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{PIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{orphaned pid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{CVIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cvid from pid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{PIDs}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{bool} \PYG{n}{share}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{faces from pid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{PIDs}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{outer faces}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{dim}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{inner faces}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{all faces}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{outer faces with direction}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{v}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{angle}\PYG{p}{[}\PYG{p}{,} \PYG{n}{dim}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{outer faces in box}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{pmin}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{pmax}\PYG{p}{[}\PYG{p}{,} \PYG{n}{dim}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{outer faces in ball}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{center}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{radius}\PYG{p}{[}\PYG{p}{,} \PYG{n}{dim}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adjacent face}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{cvid}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{fid}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{faces from cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{merge}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{mat} \PYG{n}{T}\PYG{p}{]} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{triangulated surface}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{Nrefine} \PYG{p}{[}\PYG{p}{,}\PYG{n}{CVLIST}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{N} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normal of face}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{cv}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{f}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{nfpt}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{N} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normal of faces}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{imat} \PYG{n}{CVFIDs}\PYG{p}{)}
\PYG{n}{CVIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{convexes in box}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{pmin}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{pmax}\PYG{p}{)}
\PYG{n}{Q} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quality}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{convex area}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{convex radius}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{S}\PYG{p}{,} \PYG{n}{CV2S}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cvstruct}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{GT}\PYG{p}{,} \PYG{n}{CV2GT}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{geotrans}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{RIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundaries}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{RIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{regions}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{RIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{CVFIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{RIDs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{save}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to vtk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ascii}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{quality}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to dx}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ascii}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{append}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{as}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{name}\PYG{p}{,}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{serie}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{serie\PYGZus{}name}\PYG{p}{]}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{edges}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to pos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{memsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General mesh inquiry function. All these functions accept also a
mesh\_fem argument instead of a mesh M (in that case, the mesh\_fem
linked mesh will be used). Note that when your mesh is
recognized as a Matlab object , you can simply use “get(M, ‘dim’)”
instead of “gf\_mesh\_get(M, ‘dim’)”.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{d = gf\_mesh\_get(mesh M, \textquotesingle{}dim\textquotesingle{})}}
\begin{quote}

Get the dimension of the mesh (2 for a 2D mesh, etc).
\end{quote}

\sphinxcode{\sphinxupquote{np = gf\_mesh\_get(mesh M, \textquotesingle{}nbpts\textquotesingle{})}}
\begin{quote}

Get the number of points of the mesh.
\end{quote}

\sphinxcode{\sphinxupquote{nc = gf\_mesh\_get(mesh M, \textquotesingle{}nbcvs\textquotesingle{})}}
\begin{quote}

Get the number of convexes of the mesh.
\end{quote}

\sphinxcode{\sphinxupquote{P = gf\_mesh\_get(mesh M, \textquotesingle{}pts\textquotesingle{}{[}, ivec PIDs{]})}}
\begin{quote}

Return the list of point coordinates of the mesh.

Each column of the returned matrix contains the coordinates of one
point. If the optional argument \sphinxtitleref{PIDs} was given, only the points
whose \#id is listed in this vector are returned. Otherwise, the
returned matrix will have gf\_mesh\_get(mesh M, ‘max\_pid’) columns, which might
be greater than gf\_mesh\_get(mesh M, ‘nbpts’) (if some points of the mesh have
been destroyed and no call to gf\_mesh\_set(mesh M, ‘optimize structure’) have
been issued). The columns corresponding to deleted points will be
filled with NaN. You can use gf\_mesh\_get(mesh M, ‘pid’) to filter such invalid
points.
\end{quote}

\sphinxcode{\sphinxupquote{Pid = gf\_mesh\_get(mesh M, \textquotesingle{}pid\textquotesingle{})}}
\begin{quote}

Return the list of points \#id of the mesh.

Note that their numbering is not supposed to be contiguous from
1 to gf\_mesh\_get(mesh M, ‘nbpts’),
especially if some points have been removed from the mesh. You
can use gf\_mesh\_set(mesh M, ‘optimize\_structure’) to enforce a contiguous
numbering. Pid is a row vector.
\end{quote}

\sphinxcode{\sphinxupquote{PIDs = gf\_mesh\_get(mesh M, \textquotesingle{}pid in faces\textquotesingle{}, imat CVFIDs)}}
\begin{quote}

Return point \#id listed in \sphinxtitleref{CVFIDs}.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers. On return, \sphinxtitleref{PIDs} is a
row vector containing points \#id.
\end{quote}

\sphinxcode{\sphinxupquote{PIDs = gf\_mesh\_get(mesh M, \textquotesingle{}pid in cvids\textquotesingle{}, imat CVIDs)}}
\begin{quote}

Return point \#id listed in \sphinxtitleref{CVIDs}.

\sphinxtitleref{PIDs} is a row vector containing points \#id.
\end{quote}

\sphinxcode{\sphinxupquote{PIDs = gf\_mesh\_get(mesh M, \textquotesingle{}pid in regions\textquotesingle{}, imat RIDs)}}
\begin{quote}

Return point \#id listed in \sphinxtitleref{RIDs}.

\sphinxtitleref{PIDs} is a row vector containing points \#id.
\end{quote}

\sphinxcode{\sphinxupquote{PIDs = gf\_mesh\_get(mesh M, \textquotesingle{}pid from coords\textquotesingle{}, mat PTS{[}, scalar radius=0{]})}}
\begin{quote}

Return point \#id whose coordinates are listed in \sphinxtitleref{PTS}.

\sphinxtitleref{PTS} is an array containing a list of point coordinates. On
return, \sphinxtitleref{PIDs} is a row vector containing points
\#id for each point found in \sphinxtitleref{eps} range, and \sphinxhyphen{}1 for those
which where not found in the mesh.
\end{quote}

\sphinxcode{\sphinxupquote{\{Pid, IDx\} = gf\_mesh\_get(mesh M, \textquotesingle{}pid from cvid\textquotesingle{}{[}, imat CVIDs{]})}}
\begin{quote}

Return the points attached to each convex of the mesh.

If \sphinxtitleref{CVIDs} is omitted, all the convexes will be considered
(equivalent to \sphinxtitleref{CVIDs = gf\_mesh\_get(mesh M, ‘max cvid’)}). \sphinxtitleref{IDx} is a
row vector, length(IDx) = length(CVIDs)+1. \sphinxtitleref{Pid} is a
row vector containing the concatenated list of \#id of
points of each convex in \sphinxtitleref{CVIDs}. Each entry of \sphinxtitleref{IDx} is the
position of the corresponding convex point list in \sphinxtitleref{Pid}. Hence,
for example, the list of \#id of points of the second convex is
Pid(IDx(2):IDx(3)\sphinxhyphen{}1).

If \sphinxtitleref{CVIDs} contains convex \#id which do not exist in the mesh,
their point list will be empty.
\end{quote}

\sphinxcode{\sphinxupquote{\{Pts, IDx\} = gf\_mesh\_get(mesh M, \textquotesingle{}pts from cvid\textquotesingle{}{[}, imat CVIDs{]})}}
\begin{quote}

Search point listed in \sphinxtitleref{CVID}.

Return \sphinxtitleref{Pts} and \sphinxtitleref{IDx}.
If \sphinxtitleref{CVIDs} is omitted, all the convexes will be considered
(equivalent to \sphinxtitleref{CVIDs = gf\_mesh\_get(mesh M, ‘max cvid’)}). \sphinxtitleref{IDx} is a
row vector, length(IDx) = length(CVIDs)+1. \sphinxtitleref{Pts} is a
row vector containing the concatenated list of points
of each convex in \sphinxtitleref{CVIDs}. Each entry of \sphinxtitleref{IDx} is the position
of the corresponding convex point list in \sphinxtitleref{Pts}. Hence, for
example, the list of points of the second convex is
Pts(:,IDx(2):IDx(3)\sphinxhyphen{}1).

If \sphinxtitleref{CVIDs} contains convex \#id which do not exist in the mesh,
their point list will be empty.
\end{quote}

\sphinxcode{\sphinxupquote{CVid = gf\_mesh\_get(mesh M, \textquotesingle{}cvid\textquotesingle{})}}
\begin{quote}

Return the list of all convex \#id.

Note that their numbering is not supposed to be contiguous from
1 to gf\_mesh\_get(mesh M, ‘nbcvs’),
especially if some points have been removed from the mesh. You
can use gf\_mesh\_set(mesh M, ‘optimize\_structure’) to enforce a contiguous
numbering. CVid is a row vector.
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_mesh\_get(mesh M, \textquotesingle{}max pid\textquotesingle{})}}
\begin{quote}

Return the maximum \#id of all points in the mesh (see ‘max cvid’).
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_mesh\_get(mesh M, \textquotesingle{}max cvid\textquotesingle{})}}
\begin{quote}

Return the maximum \#id of all convexes in the mesh (see ‘max pid’).
\end{quote}

\sphinxcode{\sphinxupquote{{[}E,C{]} = gf\_mesh\_get(mesh M, \textquotesingle{}edges\textquotesingle{} {[}, CVLST{]}{[}, \textquotesingle{}merge\textquotesingle{}{]})}}
\begin{quote}

{[}OBSOLETE FUNCTION! will be removed in a future release{]}

Return the list of edges of mesh M for the convexes listed in the
row vector CVLST. E is a 2 x nb\_edges matrix containing point
indices. If CVLST is omitted, then the edges of all convexes are
returned. If CVLST has two rows then the first row is supposed to
contain convex numbers, and the second face numbers, of which the
edges will be returned.  If ‘merge’ is indicated, all common
edges of convexes are merged in a single edge.  If the optional
output argument C is specified, it will contain the convex number
associated with each edge.
\end{quote}

\sphinxcode{\sphinxupquote{{[}E,C{]} = gf\_mesh\_get(mesh M, \textquotesingle{}curved edges\textquotesingle{}, int N {[}, CVLST{]})}}
\begin{quote}

{[}OBSOLETE FUNCTION! will be removed in a future release{]}

Return E and C.
More sophisticated version of gf\_mesh\_get(mesh M, ‘edges’) designed for
curved elements. This one will return N (N\textgreater{}=2) points of the
(curved) edges. With N==2, this is equivalent to
gf\_mesh\_get(mesh M, ‘edges’). Since the points are no more always part of
the mesh, their coordinates are returned instead of points
number, in the array E which is a {[} mesh\_dim x 2 x nb\_edges {]}
array.  If the optional output argument C is specified, it will
contain the convex number associated with each edge.
\end{quote}

\sphinxcode{\sphinxupquote{PIDs = gf\_mesh\_get(mesh M, \textquotesingle{}orphaned pid\textquotesingle{})}}
\begin{quote}

Return point \#id which are not linked to a convex.
\end{quote}

\sphinxcode{\sphinxupquote{CVIDs = gf\_mesh\_get(mesh M, \textquotesingle{}cvid from pid\textquotesingle{}, ivec PIDs{[}, bool share=False{]})}}
\begin{quote}

Return convex \#ids related with the point \#ids given in \sphinxtitleref{PIDs}.

If \sphinxtitleref{share=False}, search convex whose vertex \#ids are in \sphinxtitleref{PIDs}.
If \sphinxtitleref{share=True}, search convex \#ids that share the point \#ids
given in \sphinxtitleref{PIDs}. \sphinxtitleref{CVIDs} is a row vector (possibly
empty).
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}faces from pid\textquotesingle{}, ivec PIDs)}}
\begin{quote}

Return the convex faces whose vertex \#ids are in \sphinxtitleref{PIDs}.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers (local number in the convex).
For a convex face to be returned, EACH of its points have to be
listed in \sphinxtitleref{PIDs}.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}outer faces\textquotesingle{}{[}, dim{]}{[}, CVIDs{]})}}
\begin{quote}

Return the set of faces not shared by two elements.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists
convex \#ids, and the second one lists face numbers (local number
in the convex). If \sphinxtitleref{dim} is provided, the function is forced to
detect faces of elements that have dimension \sphinxtitleref{dim}, e.g. \sphinxtitleref{dim\textasciigrave{}=2 will
detect edges of surface elements, even if these belong to a 3D mesh.
If \textasciigrave{}CVIDs} is not given, all convexes are considered, and the
function basically returns the mesh boundary. If \sphinxtitleref{CVIDs}
is given, it returns the boundary of the convex set whose \#ids are
listed in \sphinxtitleref{CVIDs}.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}inner faces\textquotesingle{}{[}, CVIDs{]})}}
\begin{quote}

Return the set of faces shared at least by two elements in CVIDs.
Each face is represented only once and is arbitrarily chosen
between the two neighbor elements.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}all faces\textquotesingle{}{[}, CVIDs{]})}}
\begin{quote}

Return the set of faces of the in CVIDs (in all the mesh if CVIDs is
omitted). Note that the face shared by two neighbor elements will be
represented twice.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}outer faces with direction\textquotesingle{}, vec v, scalar angle{[}, dim{]}{[}, CVIDs{]})}}
\begin{quote}

Return the set of faces not shared by two convexes and with a mean outward vector lying within an angle \sphinxtitleref{angle} (in radians) from vector \sphinxtitleref{v}.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). The argument \sphinxtitleref{dim} works as in outer\_faces().
If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}outer faces in box\textquotesingle{}, vec pmin, vec pmax{[}, dim{]}{[}, CVIDs{]})}}
\begin{quote}

Return the set of faces not shared by two convexes and lying within the box defined by the corner points \sphinxtitleref{pmin} and \sphinxtitleref{pmax}.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). The argument \sphinxtitleref{dim} works as in outer\_faces().
If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}outer faces in ball\textquotesingle{}, vec center, scalar radius{[}, dim{]}{[}, CVIDs{]})}}
\begin{quote}

Return the set of faces not shared by two convexes and lying within the ball of corresponding \sphinxtitleref{center} and \sphinxtitleref{radius}.

The output \sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). The argument \sphinxtitleref{dim} works as in outer\_faces().
If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}adjacent face\textquotesingle{}, int cvid, int fid)}}
\begin{quote}

Return convex face of the neighbor element if it exists.
If the convex have more than one neighbor
relatively to the face \sphinxcode{\sphinxupquote{f}} (think to bar elements in 3D for instance),
return the first face found.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}faces from cvid\textquotesingle{}{[}, ivec CVIDs{]}{[}, \textquotesingle{}merge\textquotesingle{}{]})}}
\begin{quote}

Return a list of convex faces from a list of convex \#id.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers (local number in the convex).
If \sphinxtitleref{CVIDs} is not given, all convexes are considered. The optional
argument ‘merge’ merges faces shared by the convex of \sphinxtitleref{CVIDs}.
\end{quote}

\sphinxcode{\sphinxupquote{{[}mat T{]} = gf\_mesh\_get(mesh M, \textquotesingle{}triangulated surface\textquotesingle{}, int Nrefine {[},CVLIST{]})}}
\begin{quote}

{[}DEPRECATED FUNCTION! will be removed in a future release{]}

Similar function to gf\_mesh\_get(mesh M, ‘curved edges’) : split (if
necessary, i.e. if the geometric transformation if non\sphinxhyphen{}linear)
each face into sub\sphinxhyphen{}triangles and return their coordinates in T
(see also gf\_compute(‘eval on P1 tri mesh’))
\end{quote}

\sphinxcode{\sphinxupquote{N = gf\_mesh\_get(mesh M, \textquotesingle{}normal of face\textquotesingle{}, int cv, int f{[}, int nfpt{]})}}
\begin{quote}

Return the normal vector of convex \sphinxtitleref{cv}, face \sphinxtitleref{f} at the \sphinxtitleref{nfpt} point of the face.

If \sphinxtitleref{nfpt} is not specified, then the normal is evaluated at each
geometrical node of the face.
\end{quote}

\sphinxcode{\sphinxupquote{N = gf\_mesh\_get(mesh M, \textquotesingle{}normal of faces\textquotesingle{}, imat CVFIDs)}}
\begin{quote}

Return matrix of (at face centers) the normal vectors of convexes.

\sphinxtitleref{CVFIDs} is supposed a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second lists face numbers (local number in the convex).
\end{quote}

\sphinxcode{\sphinxupquote{CVIDs = gf\_mesh\_get(mesh M, \textquotesingle{}convexes in box\textquotesingle{}, vec pmin, vec pmax)}}
\begin{quote}

Return the set of convexes lying entirely within the box defined by the corner points \sphinxtitleref{pmin} and \sphinxtitleref{pmax}.

The output \sphinxtitleref{CVIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex
\#ids, and the second one lists face numbers (local number in the
convex). If \sphinxtitleref{CVIDs} is given, it returns portion of the boundary of
the convex set defined by the \#ids listed in \sphinxtitleref{CVIDs}.
\end{quote}

\sphinxcode{\sphinxupquote{Q = gf\_mesh\_get(mesh M, \textquotesingle{}quality\textquotesingle{}{[}, ivec CVIDs{]})}}
\begin{quote}

Return an estimation of the quality of each convex (\(0 \leq Q \leq 1\)).
\end{quote}

\sphinxcode{\sphinxupquote{A = gf\_mesh\_get(mesh M, \textquotesingle{}convex area\textquotesingle{}{[}, ivec CVIDs{]})}}
\begin{quote}

Return an estimate of the area of each convex.
\end{quote}

\sphinxcode{\sphinxupquote{A = gf\_mesh\_get(mesh M, \textquotesingle{}convex radius\textquotesingle{}{[}, ivec CVIDs{]})}}
\begin{quote}

Return an estimate of the radius of each convex.
\end{quote}

\sphinxcode{\sphinxupquote{\{S, CV2S\} = gf\_mesh\_get(mesh M, \textquotesingle{}cvstruct\textquotesingle{}{[}, ivec CVIDs{]})}}
\begin{quote}

Return an array of the convex structures.

If \sphinxtitleref{CVIDs} is not given, all convexes are considered. Each convex
structure is listed once in \sphinxtitleref{S}, and \sphinxtitleref{CV2S} maps the convexes
indice in \sphinxtitleref{CVIDs} to the indice of its structure in \sphinxtitleref{S}.
\end{quote}

\sphinxcode{\sphinxupquote{\{GT, CV2GT\} = gf\_mesh\_get(mesh M, \textquotesingle{}geotrans\textquotesingle{}{[}, ivec CVIDs{]})}}
\begin{quote}

Returns an array of the geometric transformations.

See also gf\_mesh\_get(mesh M, ‘cvstruct’).
\end{quote}

\sphinxcode{\sphinxupquote{RIDs = gf\_mesh\_get(mesh M, \textquotesingle{}boundaries\textquotesingle{})}}
\begin{quote}

DEPRECATED FUNCTION. Use ‘regions’ instead.
\end{quote}

\sphinxcode{\sphinxupquote{RIDs = gf\_mesh\_get(mesh M, \textquotesingle{}regions\textquotesingle{})}}
\begin{quote}

Return the list of valid regions stored in the mesh.
\end{quote}

\sphinxcode{\sphinxupquote{RIDs = gf\_mesh\_get(mesh M, \textquotesingle{}boundary\textquotesingle{})}}
\begin{quote}

DEPRECATED FUNCTION. Use ‘region’ instead.
\end{quote}

\sphinxcode{\sphinxupquote{CVFIDs = gf\_mesh\_get(mesh M, \textquotesingle{}region\textquotesingle{}, ivec RIDs)}}
\begin{quote}

Return the list of convexes/faces on the regions \sphinxtitleref{RIDs}.

\sphinxtitleref{CVFIDs} is a two\sphinxhyphen{}rows matrix, the first row lists convex \#ids,
and the second lists face numbers (local number in the convex).
(and 0 when the whole convex is in the
regions).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_get(mesh M, \textquotesingle{}save\textquotesingle{}, string filename)}}
\begin{quote}

Save the mesh object to an ascii file.

This mesh can be restored with gf\_mesh(‘load’, filename).
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_mesh\_get(mesh M, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a string description of the mesh.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_get(mesh M, \textquotesingle{}export to vtk\textquotesingle{}, string filename, ... {[},\textquotesingle{}ascii\textquotesingle{}{]}{[},\textquotesingle{}quality\textquotesingle{}{]})}}
\begin{quote}

Exports a mesh to a VTK file .

If ‘quality’ is specified, an estimation of the quality of each
convex will be written to the file.

See also gf\_mesh\_fem\_get(mesh\_fem MF, ‘export to vtk’), gf\_slice\_get(slice S, ‘export to vtk’).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_get(mesh M, \textquotesingle{}export to dx\textquotesingle{}, string filename, ... {[},\textquotesingle{}ascii\textquotesingle{}{]}{[},\textquotesingle{}append\textquotesingle{}{]}{[},\textquotesingle{}as\textquotesingle{},string name,{[},\textquotesingle{}serie\textquotesingle{},string serie\_name{]}{]}{[},\textquotesingle{}edges\textquotesingle{}{]})}}
\begin{quote}

Exports a mesh to an OpenDX file.

See also gf\_mesh\_fem\_get(mesh\_fem MF, ‘export to dx’), gf\_slice\_get(slice S, ‘export to dx’).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_get(mesh M, \textquotesingle{}export to pos\textquotesingle{}, string filename{[}, string name{]})}}
\begin{quote}

Exports a mesh to a POS file .

See also gf\_mesh\_fem\_get(mesh\_fem MF, ‘export to pos’), gf\_slice\_get(slice S, ‘export to pos’).
\end{quote}

\sphinxcode{\sphinxupquote{z = gf\_mesh\_get(mesh M, \textquotesingle{}memsize\textquotesingle{})}}
\begin{quote}

Return the amount of memory (in bytes) used by the mesh.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_get(mesh M, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a mesh object.
\end{quote}
\end{quote}


\section{gf\_mesh\_set}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_set:gf-mesh-set}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{PTS}\PYG{p}{)}
\PYG{n}{PIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add point}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{PTS}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{del point}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{PIDs}\PYG{p}{)}
\PYG{n}{CVIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add convex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{geotrans} \PYG{n}{GT}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{PTS}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{del convex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVIDs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{del convex of dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{DIMs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{translate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transform}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{T}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{boundary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rnum}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVFIDs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rnum}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVFIDs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extend region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rnum}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVFIDs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{region intersect}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{r1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{r2}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{region merge}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{r1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{r2}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{region subtract}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{r1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{r2}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{delete boundary}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rnum}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVFIDs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{delete region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{RIDs}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{merge}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m2}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar}  \PYG{n}{tol}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{optimize structure}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{with\PYGZus{}renumbering}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{refine}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDs}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for modification of a mesh object.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{PIDs = gf\_mesh\_set(mesh M, \textquotesingle{}pts\textquotesingle{}, mat PTS)}}
\begin{quote}

Replace the coordinates of the mesh points with those given in \sphinxtitleref{PTS}.
\end{quote}

\sphinxcode{\sphinxupquote{PIDs = gf\_mesh\_set(mesh M, \textquotesingle{}add point\textquotesingle{}, mat PTS)}}
\begin{quote}

Insert new points in the mesh and return their \#ids.

\sphinxtitleref{PTS} should be an \sphinxcode{\sphinxupquote{nxm}} matrix , where \sphinxcode{\sphinxupquote{n}} is the mesh
dimension, and \sphinxcode{\sphinxupquote{m}} is the number of points that will be
added to the mesh. On output, \sphinxtitleref{PIDs} contains the point \#ids
of these new points.

Remark: if some points are already part of the mesh (with a small
tolerance of approximately \sphinxcode{\sphinxupquote{1e\sphinxhyphen{}8}}), they won’t be inserted again,
and \sphinxtitleref{PIDs} will contain the previously assigned \#ids of these
points.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}del point\textquotesingle{}, ivec PIDs)}}
\begin{quote}

Removes one or more points from the mesh.

\sphinxtitleref{PIDs} should contain the point \#ids, such as the one returned by
the ‘add point’ command.
\end{quote}

\sphinxcode{\sphinxupquote{CVIDs = gf\_mesh\_set(mesh M, \textquotesingle{}add convex\textquotesingle{}, geotrans GT, mat PTS)}}
\begin{quote}

Add a new convex into the mesh.

The convex structure (triangle, prism,…) is given by \sphinxtitleref{GT}
(obtained with gf\_geotrans(‘…’)), and its points are given by
the columns of \sphinxtitleref{PTS}. On return, \sphinxtitleref{CVIDs} contains the convex \#ids.
\sphinxtitleref{PTS} might be a 3\sphinxhyphen{}dimensional array in order to insert more than
one convex (or a two dimensional array correctly shaped according
to Fortran ordering).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}del convex\textquotesingle{}, mat CVIDs)}}
\begin{quote}

Remove one or more convexes from the mesh.

\sphinxtitleref{CVIDs} should contain the convexes \#ids, such as the ones
returned by the ‘add convex’ command.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}del convex of dim\textquotesingle{}, ivec DIMs)}}
\begin{quote}

Remove all convexes of dimension listed in \sphinxtitleref{DIMs}.

For example; \sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}del convex of dim\textquotesingle{}, {[}1,2{]})}} remove
all line segments, triangles and quadrangles.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}translate\textquotesingle{}, vec V)}}
\begin{quote}

Translates each point of the mesh from \sphinxtitleref{V}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}transform\textquotesingle{}, mat T)}}
\begin{quote}

Applies the matrix \sphinxtitleref{T} to each point of the mesh.

Note that \sphinxtitleref{T} is not required to be a \sphinxcode{\sphinxupquote{NxN}} matrix (with
\sphinxcode{\sphinxupquote{N = gf\_mesh\_get(mesh M, \textquotesingle{}dim\textquotesingle{})}}). Hence it is possible to transform
a 2D mesh into a 3D one (and reciprocally).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}boundary\textquotesingle{}, int rnum, mat CVFIDs)}}
\begin{quote}

DEPRECATED FUNCTION. Use ‘region’ instead.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}region\textquotesingle{}, int rnum, mat CVFIDs)}}
\begin{quote}

Assigns the region number \sphinxtitleref{rnum} to the set of convexes or/and convex
faces provided in the matrix \sphinxtitleref{CVFIDs}.

The first row of \sphinxtitleref{CVFIDs} contains convex \#ids, and the second row
contains a face number in the convex (or 0
for the whole convex (regions are usually used to store a list of
convex faces, but you may also use them to store a list of convexes).

If a vector is provided (or a one row matrix) the region will represent
the corresponding set of convex.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}extend region\textquotesingle{}, int rnum, mat CVFIDs)}}
\begin{quote}

Extends the region identified by the region number \sphinxtitleref{rnum} to include
the set of convexes or/and convex faces provided in the matrix
\sphinxtitleref{CVFIDs}, see also \sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}set region)}}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}region intersect\textquotesingle{}, int r1, int r2)}}
\begin{quote}

Replace the region number \sphinxtitleref{r1} with its intersection with region number \sphinxtitleref{r2}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}region merge\textquotesingle{}, int r1, int r2)}}
\begin{quote}

Merge region number \sphinxtitleref{r2} into region number \sphinxtitleref{r1}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}region subtract\textquotesingle{}, int r1, int r2)}}
\begin{quote}

Replace the region number \sphinxtitleref{r1} with its difference with region
number \sphinxtitleref{r2}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}delete boundary\textquotesingle{}, int rnum, mat CVFIDs)}}
\begin{quote}

DEPRECATED FUNCTION. Use ‘delete region’ instead.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}delete region\textquotesingle{}, ivec RIDs)}}
\begin{quote}

Remove the regions whose \#ids are listed in \sphinxtitleref{RIDs}
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}merge\textquotesingle{}, mesh m2{[}, scalar  tol{]})}}
\begin{quote}

Merge with the mesh \sphinxtitleref{m2}.

Overlapping points, within a tolerance radius \sphinxtitleref{tol}, will not be
duplicated. If \sphinxtitleref{m2} is a mesh\_fem object, its linked mesh will be used.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}optimize structure\textquotesingle{}{[}, int with\_renumbering{]})}}
\begin{quote}

Reset point and convex numbering.

After optimisation, the points (resp. convexes) will
be consecutively numbered from 1 to gf\_mesh\_get(mesh M, ‘max pid’)
(resp. gf\_mesh\_get(mesh M, ‘max cvid’)).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_set(mesh M, \textquotesingle{}refine\textquotesingle{}{[}, ivec CVIDs{]})}}
\begin{quote}

Use a Bank strategy for mesh refinement.

If \sphinxtitleref{CVIDs} is not given, the whole mesh is refined. Note
that the regions, and the finite element methods and
integration methods of the mesh\_fem and mesh\_im objects linked
to this mesh will be automagically refined.
\end{quote}
\end{quote}


\section{gf\_mesh\_fem}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_fem:gf-mesh-fem}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_fem::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{m}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{Qdim1}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{Qdim2}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{load}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{fname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{from string}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{s}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clone}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sum}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf3}\PYG{p}{[}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{levelset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{mls}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{global function}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n}{levelset} \PYG{n}{ls}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{global\PYGZus{}function} \PYG{n}{GF1}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{Qdim\PYGZus{}m}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{partial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{DOFs}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{RCVs}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for mesh\_fem objects.
\begin{quote}

This object represents a finite element method defined on a whole mesh.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(mesh m{[}, int Qdim1=1{[}, int Qdim2=1, ...{]}{]})}}
\begin{quote}

Build a new mesh\_fem object.

The \sphinxtitleref{Qdim} parameters specifies the dimension of the field represented
by the finite element method. Qdim1 = 1 for a scalar field,
Qdim1 = n for a vector field off size n, Qdim1=m, Qdim2=n for
a matrix field of size mxn …
Returns the handle of the created object.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}load\textquotesingle{}, string fname{[}, mesh m{]})}}
\begin{quote}

Load a mesh\_fem from a file.

If the mesh \sphinxtitleref{m} is not supplied (this kind of file does not store the
mesh), then it is read from the file \sphinxtitleref{fname} and its descriptor is
returned as the second output argument.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}from string\textquotesingle{}, string s{[}, mesh m{]})}}
\begin{quote}

Create a mesh\_fem object from its string description.

See also \sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}char\textquotesingle{})}}
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}clone\textquotesingle{}, mesh\_fem mf)}}
\begin{quote}

Create a copy of a mesh\_fem.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}sum\textquotesingle{}, mesh\_fem mf1, mesh\_fem mf2{[}, mesh\_fem mf3{[}, ...{]}{]})}}
\begin{quote}

Create a mesh\_fem that spans two (or more) mesh\_fem’s.

All mesh\_fem must share the same mesh.

After that, you should not modify the FEM of \sphinxtitleref{mf1}, \sphinxtitleref{mf2} etc.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}product\textquotesingle{}, mesh\_fem mf1, mesh\_fem mf2)}}
\begin{quote}

Create a mesh\_fem that spans all the product of a selection of shape
functions of \sphinxtitleref{mf1} by all shape functions of \sphinxtitleref{mf2}.
Designed for Xfem enrichment.

\sphinxtitleref{mf1} and \sphinxtitleref{mf2} must share the same mesh.

After that, you should not modify the FEM of \sphinxtitleref{mf1}, \sphinxtitleref{mf2}.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}levelset\textquotesingle{}, mesh\_levelset mls, mesh\_fem mf)}}
\begin{quote}

Create a mesh\_fem that is conformal to implicit surfaces defined in
mesh\_levelset.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}global function\textquotesingle{}, mesh m, levelset ls, \{global\_function GF1,...\}{[}, int Qdim\_m{]})}}
\begin{quote}

Create a mesh\_fem whose base functions are global function given by the
user in the system of coordinate defined by the iso\sphinxhyphen{}values of the two
level\sphinxhyphen{}set function of \sphinxtitleref{ls}.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesh\_fem(\textquotesingle{}partial\textquotesingle{}, mesh\_fem mf, ivec DOFs{[}, ivec RCVs{]})}}
\begin{quote}

Build a restricted mesh\_fem by keeping only a subset of the degrees of
freedom of \sphinxtitleref{mf}.

If \sphinxtitleref{RCVs} is given, no FEM will be put on the convexes listed in
\sphinxtitleref{RCVs}.
\end{quote}
\end{quote}


\section{gf\_mesh\_fem\_get}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_fem_get:gf-mesh-fem-get}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_fem_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbdof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nb basic dof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{DOF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dof from cv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{)}
\PYG{n}{DOF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basic dof from cv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{DOFs}\PYG{p}{,} \PYG{n}{IDx}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dof from cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{DOFs}\PYG{p}{,} \PYG{n}{IDx}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basic dof from cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{non conformal dof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{non conformal basic dof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qdim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{FEMs}\PYG{p}{,} \PYG{n}{CV2F}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{convex\PYGZus{}index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{bB} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}lagrangian}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{bB} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}equivalent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{bB} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}polynomial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{bB} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}reduced}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{bB} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reduction matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{bB} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extension matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Vr} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reduce vector}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{Ve} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extend vector}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{DOFs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basic dof on region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{Rs}\PYG{p}{)}
\PYG{n}{DOFs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dof on region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{Rs}\PYG{p}{)}
\PYG{n}{DOFpts} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dof nodes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{DOFids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{DOFpts} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{basic dof nodes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{DOFids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{DOFP} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dof partition}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{save}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{opt}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{opt}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linked mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to vtk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ascii}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to dx}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{as}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{mesh\PYGZus{}name}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{edges}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{serie}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{serie\PYGZus{}name}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ascii}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{append}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{U}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to pos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{]}\PYG{p}{[}\PYG{p}{[}\PYG{p}{,}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{U1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{nameU1}\PYG{p}{[}\PYG{p}{[}\PYG{p}{,}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{U2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{nameU2}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dof\PYGZus{}from\PYGZus{}im}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{p}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interpolate\PYGZus{}convex\PYGZus{}data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mat} \PYG{n}{Ucv}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{memsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{has\PYGZus{}linked\PYGZus{}mesh\PYGZus{}levelset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linked\PYGZus{}mesh\PYGZus{}levelset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eval}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{expr} \PYG{p}{[}\PYG{p}{,} \PYG{n}{DOFLST}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for inquiry about mesh\_fem objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{n = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}nbdof\textquotesingle{})}}
\begin{quote}

Return the number of degrees of freedom (dof) of the mesh\_fem.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}nb basic dof\textquotesingle{})}}
\begin{quote}

Return the number of basic degrees of freedom (dof) of the mesh\_fem.
\end{quote}

\sphinxcode{\sphinxupquote{DOF = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}dof from cv\textquotesingle{},mat CVids)}}
\begin{quote}

Deprecated function. Use gf\_mesh\_fem\_get(mesh\_fem MF, ‘basic dof from cv’) instead.
\end{quote}

\sphinxcode{\sphinxupquote{DOF = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}basic dof from cv\textquotesingle{},mat CVids)}}
\begin{quote}

Return the dof of the convexes listed in \sphinxtitleref{CVids}.

WARNING: the Degree of Freedom might be returned in ANY order, do
not use this function in your assembly routines. Use ‘basic dof from cvid’
instead, if you want to be able to map a convex number with its
associated degrees of freedom.

One can also get the list of basic dof on a set on convex faces, by
indicating on the second row of \sphinxtitleref{CVids} the faces numbers (with
respect to the convex number on the first row).
\end{quote}

\sphinxcode{\sphinxupquote{\{DOFs, IDx\} = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}dof from cvid\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Deprecated function. Use gf\_mesh\_fem\_get(mesh\_fem MF, ‘basic dof from cvid’) instead.
\end{quote}

\sphinxcode{\sphinxupquote{\{DOFs, IDx\} = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}basic dof from cvid\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Return the degrees of freedom attached to each convex of the mesh.

If \sphinxtitleref{CVids} is omitted, all the convexes will be considered (equivalent
to \sphinxtitleref{CVids = 1 … gf\_mesh\_get(mesh M, ‘max cvid’)}).

\sphinxtitleref{IDx} is a row vector, \sphinxtitleref{length(IDx) = length(CVids)+1}.
\sphinxtitleref{DOFs} is a row vector containing the concatenated list
of dof of each convex in \sphinxtitleref{CVids}. Each entry of \sphinxtitleref{IDx} is the position
of the corresponding convex point list in \sphinxtitleref{DOFs}. Hence, for example,
the list of points of the second convex is DOFs(IDx(2):IDx(3)\sphinxhyphen{}1).

If \sphinxtitleref{CVids} contains convex \#id which do not exist in the mesh, their
point list will be empty.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}non conformal dof\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Deprecated function. Use gf\_mesh\_fem\_get(mesh\_fem MF, ‘non conformal basic dof’) instead.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}non conformal basic dof\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Return partially linked degrees of freedom.

Return the basic dof located on the border of a convex and which belong
to only one convex, except the ones which are located on the border
of the mesh.  For example, if the convex ‘a’ and ‘b’ share a common
face, ‘a’ has a P1 FEM, and ‘b’ has a P2 FEM, then the basic dof on the
middle of the face will be returned by this function (this can be
useful when searching the interfaces between classical FEM and
hierarchical FEM).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}qdim\textquotesingle{})}}
\begin{quote}

Return the dimension Q of the field interpolated by the mesh\_fem.

By default, Q=1 (scalar field). This has an impact on the dof numbering.
\end{quote}

\sphinxcode{\sphinxupquote{\{FEMs, CV2F\} = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}fem\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Return a list of FEM used by the mesh\_fem.

\sphinxtitleref{FEMs} is an array of all fem objects found in the convexes
given in \sphinxtitleref{CVids}. If \sphinxtitleref{CV2F} was supplied as an output argument,
it contains, for each convex listed in \sphinxtitleref{CVids}, the index of its
correspounding FEM in \sphinxtitleref{FEMs}.

Convexes which are not part of the mesh, or convexes which do not
have any FEM have their correspounding entry in \sphinxtitleref{CV2F} set to \sphinxhyphen{}1.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cvid}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{f}\PYG{p}{,}\PYG{n}{c2f}\PYG{p}{]}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{size}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sf}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{\PYGZcb{}}\PYG{o}{=}\PYG{n}{gf\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{f}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{end}\PYG{p}{;}
\PYG{k}{for} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{size}\PYG{p}{(}\PYG{n}{c2f}\PYG{p}{)}\PYG{p}{,}
   \PYG{n}{disp}\PYG{p}{(}\PYG{n}{sprintf}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the fem of convex }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{ is }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
      \PYG{n}{cvid}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{sf}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{end}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxcode{\sphinxupquote{CVs = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}convex\_index\textquotesingle{})}}
\begin{quote}

Return the list of convexes who have an FEM.
\end{quote}

\sphinxcode{\sphinxupquote{bB = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}is\_lagrangian\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Test if the mesh\_fem is Lagrangian.

Lagrangian means that each base function Phi{[}i{]} is such that
Phi{[}i{]}(P{[}j{]}) = delta(i,j), where P{[}j{]} is the dof location of
the jth base function, and delta(i,j) = 1 if i==j, else 0.

If \sphinxtitleref{CVids} is omitted, it returns 1 if all convexes in the mesh
are Lagrangian. If \sphinxtitleref{CVids} is used, it returns the convex indices
(with respect to \sphinxtitleref{CVids}) which are Lagrangian.
\end{quote}

\sphinxcode{\sphinxupquote{bB = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}is\_equivalent\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Test if the mesh\_fem is equivalent.

See gf\_mesh\_fem\_get(mesh\_fem MF, ‘is\_lagrangian’)
\end{quote}

\sphinxcode{\sphinxupquote{bB = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}is\_polynomial\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Test if all base functions are polynomials.

See gf\_mesh\_fem\_get(mesh\_fem MF, ‘is\_lagrangian’)
\end{quote}

\sphinxcode{\sphinxupquote{bB = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}is\_reduced\textquotesingle{})}}
\begin{quote}

Return 1 if the optional reduction matrix is applied to the dofs.
\end{quote}

\sphinxcode{\sphinxupquote{bB = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}reduction matrix\textquotesingle{})}}
\begin{quote}

Return the optional reduction matrix.
\end{quote}

\sphinxcode{\sphinxupquote{bB = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}extension matrix\textquotesingle{})}}
\begin{quote}

Return the optional extension matrix.
\end{quote}

\sphinxcode{\sphinxupquote{Vr = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}reduce vector\textquotesingle{}, vec V)}}
\begin{quote}

Multiply the provided vector V with the extension matrix of the mesh\_fem.
\end{quote}

\sphinxcode{\sphinxupquote{Ve = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}extend vector\textquotesingle{}, vec V)}}
\begin{quote}

Multiply the provided vector V with the reduction matrix of the mesh\_fem.
\end{quote}

\sphinxcode{\sphinxupquote{DOFs = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}basic dof on region\textquotesingle{},mat Rs)}}
\begin{quote}

Return the list of basic dof (before the optional reduction) lying on one
of the mesh regions listed in \sphinxtitleref{Rs}.

More precisely, this function returns the basic dof whose support is
non\sphinxhyphen{}null on one of regions whose \#ids are listed in \sphinxtitleref{Rs} (note
that for boundary regions, some dof nodes may not lie exactly
on the boundary, for example the dof of Pk(n,0) lies on the center
of the convex, but the base function in not null on the convex
border).
\end{quote}

\sphinxcode{\sphinxupquote{DOFs = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}dof on region\textquotesingle{},mat Rs)}}
\begin{quote}

Return the list of dof (after the optional reduction) lying on one
of the mesh regions listed in \sphinxtitleref{Rs}.

More precisely, this function returns the basic dof whose support is
non\sphinxhyphen{}null on one of regions whose \#ids are listed in \sphinxtitleref{Rs} (note
that for boundary regions, some dof nodes may not lie exactly
on the boundary, for example the dof of Pk(n,0) lies on the center
of the convex, but the base function in not null on the convex
border).

For a reduced mesh\_fem
a dof is lying on a region if its potential corresponding shape
function is nonzero on this region. The extension matrix is used
to make the correspondence between basic and reduced dofs.
\end{quote}

\sphinxcode{\sphinxupquote{DOFpts = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}dof nodes\textquotesingle{}{[}, mat DOFids{]})}}
\begin{quote}

Deprecated function. Use gf\_mesh\_fem\_get(mesh\_fem MF, ‘basic dof nodes’) instead.
\end{quote}

\sphinxcode{\sphinxupquote{DOFpts = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}basic dof nodes\textquotesingle{}{[}, mat DOFids{]})}}
\begin{quote}

Get location of basic degrees of freedom.

Return the list of interpolation points for the specified
dof \#IDs in \sphinxtitleref{DOFids} (if \sphinxtitleref{DOFids} is omitted, all basic dof are
considered).
\end{quote}

\sphinxcode{\sphinxupquote{DOFP = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}dof partition\textquotesingle{})}}
\begin{quote}

Get the ‘dof\_partition’ array.

Return the array which associates an integer (the partition number)
to each convex of the mesh\_fem. By default, it is an all\sphinxhyphen{}zero array.
The degrees of freedom of each convex of the mesh\_fem are connected
only to the dof of neighboring convexes which have the same
partition number, hence it is possible to create partially
discontinuous mesh\_fem very easily.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}save\textquotesingle{},string filename{[}, string opt{]})}}
\begin{quote}

Save a mesh\_fem in a text file (and optionally its linked mesh object
if \sphinxtitleref{opt} is the string ‘with\_mesh’).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}char\textquotesingle{}{[}, string opt{]})}}
\begin{quote}

Output a string description of the mesh\_fem.

By default, it does not include the description of the linked mesh
object, except if \sphinxtitleref{opt} is ‘with\_mesh’.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a mesh\_fem object.
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}linked mesh\textquotesingle{})}}
\begin{quote}

Return a reference to the mesh object linked to \sphinxtitleref{mf}.
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}mesh\textquotesingle{})}}
\begin{quote}

Return a reference to the mesh object linked to \sphinxtitleref{mf}.
(identical to gf\_mesh\_get(mesh M, ‘linked mesh’))
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}export to vtk\textquotesingle{},string filename, ... {[}\textquotesingle{}ascii\textquotesingle{}{]}, U, \textquotesingle{}name\textquotesingle{}...)}}
\begin{quote}

Export a mesh\_fem and some fields to a vtk file.

The FEM and geometric transformations will be mapped to order 1
or 2 isoparametric Pk (or Qk) FEMs (as VTK does not handle higher
order elements). If you need to represent high\sphinxhyphen{}order FEMs or
high\sphinxhyphen{}order geometric transformations, you should consider
gf\_slice\_get(slice S, ‘export to vtk’).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}export to dx\textquotesingle{},string filename, ...{[}\textquotesingle{}as\textquotesingle{}, string mesh\_name{]}{[},\textquotesingle{}edges\textquotesingle{}{]}{[}\textquotesingle{}serie\textquotesingle{},string serie\_name{]}{[},\textquotesingle{}ascii\textquotesingle{}{]}{[},\textquotesingle{}append\textquotesingle{}{]}, U, \textquotesingle{}name\textquotesingle{}...)}}
\begin{quote}

Export a mesh\_fem and some fields to an OpenDX file.

This function will fail if the mesh\_fem mixes different convex types
(i.e. quads and triangles), or if OpenDX does not handle a specific
element type (i.e. prism connections are not known by OpenDX).

The FEM will be mapped to order 1 Pk (or Qk) FEMs. If you need to
represent high\sphinxhyphen{}order FEMs or high\sphinxhyphen{}order geometric transformations,
you should consider gf\_slice\_get(slice S, ‘export to dx’).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}export to pos\textquotesingle{},string filename{[}, string name{]}{[}{[},mesh\_fem mf1{]}, mat U1, string nameU1{[}{[},mesh\_fem mf2{]}, mat U2, string nameU2,...{]}{]})}}
\begin{quote}

Export a mesh\_fem and some fields to a pos file.

The FEM and geometric transformations will be mapped to order 1
isoparametric Pk (or Qk) FEMs (as GMSH does not handle higher
order elements).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}dof\_from\_im\textquotesingle{},mesh\_im mim{[}, int p{]})}}
\begin{quote}

Return a selection of dof who contribute significantly to the
mass\sphinxhyphen{}matrix that would be computed with \sphinxtitleref{mf} and the integration
method \sphinxtitleref{mim}.

\sphinxtitleref{p} represents the dimension on what the integration method
operates (default \sphinxtitleref{p = mesh dimension}).

IMPORTANT: you still have to set a valid integration method on
the convexes which are not crosses by the levelset!
\end{quote}

\sphinxcode{\sphinxupquote{U = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}interpolate\_convex\_data\textquotesingle{},mat Ucv)}}
\begin{quote}

Interpolate data given on each convex of the mesh to the mesh\_fem dof.
The mesh\_fem has to be lagrangian, and should be discontinuous (typically
an FEM\_PK(N,0) or FEM\_QK(N,0) should be used).

The last dimension of the input vector Ucv should have
gf\_mesh\_get(mesh M, ‘max cvid’) elements.

Example of use: gf\_mesh\_fem\_get(mesh\_fem MF, ‘interpolate\_convex\_data’, gf\_mesh\_get(mesh M, ‘quality’))
\end{quote}

\sphinxcode{\sphinxupquote{z = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}memsize\textquotesingle{})}}
\begin{quote}

Return the amount of memory (in bytes) used by the mesh\_fem object.

The result does not take into account the linked mesh object.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}has\_linked\_mesh\_levelset\textquotesingle{})}}
\begin{quote}

Is a mesh\_fem\_level\_set or not.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}linked\_mesh\_levelset\textquotesingle{})}}
\begin{quote}

if it is a mesh\_fem\_level\_set gives the linked mesh\_level\_set.
\end{quote}

\sphinxcode{\sphinxupquote{U = gf\_mesh\_fem\_get(mesh\_fem MF, \textquotesingle{}eval\textquotesingle{}, expr {[}, DOFLST{]})}}
\begin{quote}

Call gf\_mesh\_fem\_get\_eval. This function interpolates an expression on a
lagrangian mesh\_fem (for all dof except if DOFLST is specified).
The expression can be a
numeric constant, or a cell array containing numeric constants, string
expressions or function handles. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{U1}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eval}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{U2}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eval}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{output} \PYG{n}{has} \PYG{n}{two} \PYG{n}{rows}
\PYG{n}{U3}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eval}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZpc{}} \PYG{n}{output} \PYG{n}{has} \PYG{n}{one} \PYG{n}{row}\PYG{p}{,} \PYG{n}{only} \PYG{n}{valid} \PYG{k}{if} \PYG{n}{qdim}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{2}
\PYG{n}{U4}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get}\PYG{p}{(}\PYG{n}{mf}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eval}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y.*z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}\PYG{l+m+mi}{4}\PYG{p}{;}\PYG{n+nd}{@myfunctionofxyz}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}
\end{quote}


\section{gf\_mesh\_fem\_set}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_fem_set:gf-mesh-fem-set}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_fem_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fem} \PYG{n}{f}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{classical fem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{k}\PYG{p}{[}\PYG{p}{[}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{complete}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{classical discontinuous fem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{k}\PYG{p}{[}\PYG{p}{[}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{complete}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n+nd}{@tscalar} \PYG{n}{alpha}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVIDX}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qdim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{Q}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reduction matrices}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{R}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{E}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reduction}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{s}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{reduce meshfem}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{RM}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dof partition}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{DOFP}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set partial}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{DOFs}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{RCVs}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adapt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{MF}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set enriched dofs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{DOFs}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for modifying mesh\_fem objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}fem\textquotesingle{}, fem f{[}, ivec CVids{]})}}
\begin{quote}

Set the Finite Element Method.

Assign an FEM \sphinxtitleref{f} to all convexes whose \#ids are listed in \sphinxtitleref{CVids}.
If \sphinxtitleref{CVids} is not given, the integration is assigned to all convexes.

See the help of gf\_fem to obtain a list of available FEM methods.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}classical fem\textquotesingle{}, int k{[}{[}, \textquotesingle{}complete\textquotesingle{}{]}, ivec CVids{]})}}
\begin{quote}

Assign a classical (Lagrange polynomial) fem of order \sphinxtitleref{k} to the mesh\_fem.
The option ‘complete’ requests complete Langrange polynomial elements,
even if the element geometric transformation is an incomplete one
(e.g. 8\sphinxhyphen{}node quadrilateral or 20\sphinxhyphen{}node hexahedral).

Uses FEM\_PK for simplexes, FEM\_QK for parallelepipeds etc.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}classical discontinuous fem\textquotesingle{}, int k{[}{[}, \textquotesingle{}complete\textquotesingle{}{]}, @tscalar alpha{[}, ivec CVIDX{]}{]})}}
\begin{quote}

Assigns a classical (Lagrange polynomial) discontinuous fem of order k.

Similar to gf\_mesh\_fem\_set(mesh\_fem MF, ‘set classical fem’) except that
FEM\_PK\_DISCONTINUOUS is used. Param \sphinxtitleref{alpha} the node inset,
\(0 \leq alpha < 1\), where 0 implies usual dof nodes, greater values
move the nodes toward the center of gravity, and 1 means that all
degrees of freedom collapse on the center of gravity.
The option ‘complete’ requests complete Langrange polynomial elements,
even if the element geometric transformation is an incomplete one
(e.g. 8\sphinxhyphen{}node quadrilateral or 20\sphinxhyphen{}node hexahedral).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}qdim\textquotesingle{}, int Q)}}
\begin{quote}

Change the \sphinxtitleref{Q} dimension of the field that is interpolated by the mesh\_fem.

\sphinxtitleref{Q = 1} means that the mesh\_fem describes a scalar field, \sphinxtitleref{Q = N} means
that the mesh\_fem describes a vector field of dimension N.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}reduction matrices\textquotesingle{}, mat R, mat E)}}
\begin{quote}

Set the reduction and extension matrices and valid their use.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}reduction\textquotesingle{}, int s)}}
\begin{quote}

Set or unset the use of the reduction/extension matrices.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}reduce meshfem\textquotesingle{}, mat RM)}}
\begin{quote}

Set reduction mesh fem
This function selects the degrees of freedom of the finite element
method by selecting a set of independent vectors of the matrix RM.
The numer of columns of RM should corresponds to the number of degrees
of freedom of the finite element method.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}dof partition\textquotesingle{}, ivec DOFP)}}
\begin{quote}

Change the ‘dof\_partition’ array.

\sphinxtitleref{DOFP} is a vector holding a integer value for each convex of the mesh\_fem.
See gf\_mesh\_fem\_get(mesh\_fem MF, ‘dof partition’) for a description of “dof partition”.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}set partial\textquotesingle{}, ivec DOFs{[}, ivec RCVs{]})}}
\begin{quote}

Can only be applied to a partial mesh\_fem. Change the subset of the
degrees of freedom of \sphinxtitleref{mf}.

If \sphinxtitleref{RCVs} is given, no FEM will be put on the convexes listed
in \sphinxtitleref{RCVs}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}adapt\textquotesingle{})}}
\begin{quote}

For a mesh\_fem levelset object only. Adapt the mesh\_fem object to a
change of the levelset function.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_fem\_set(mesh\_fem MF, \textquotesingle{}set enriched dofs\textquotesingle{}, ivec DOFs)}}
\begin{quote}

For a mesh\_fem product object only. Set te enriched dofs and adapt the mesh\_fem product.
\end{quote}
\end{quote}


\section{gf\_mesh\_im}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_im:gf-mesh-im}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_im::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MIM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{load}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{fname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MIM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{from string}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{s}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MIM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clone}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{)}
\PYG{n}{MIM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{levelset}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{mls}\PYG{p}{,} \PYG{n}{string} \PYG{n}{where}\PYG{p}{,} \PYG{n}{integ} \PYG{n}{im}\PYG{p}{[}\PYG{p}{,} \PYG{n}{integ} \PYG{n}{im\PYGZus{}tip}\PYG{p}{[}\PYG{p}{,} \PYG{n}{integ} \PYG{n}{im\PYGZus{}set}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MIM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{p}{[}\PYG{p}{\PYGZob{}}\PYG{n}{integ} \PYG{n}{im}\PYG{o}{|}\PYG{n+nb}{int} \PYG{n}{im\PYGZus{}degree}\PYG{p}{\PYGZcb{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for mesh\_im objects.
\begin{quote}

This object represents an integration method defined on a whole mesh (an
potentially on its boundaries).
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{MIM = gf\_mesh\_im(\textquotesingle{}load\textquotesingle{}, string fname{[}, mesh m{]})}}
\begin{quote}

Load a mesh\_im from a file.

If the mesh \sphinxtitleref{m} is not supplied (this kind of file does not store the
mesh), then it is read from the file and its descriptor is returned as
the second output argument.
\end{quote}

\sphinxcode{\sphinxupquote{MIM = gf\_mesh\_im(\textquotesingle{}from string\textquotesingle{}, string s{[}, mesh m{]})}}
\begin{quote}

Create a mesh\_im object from its string description.

See also \sphinxcode{\sphinxupquote{gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}char\textquotesingle{})}}
\end{quote}

\sphinxcode{\sphinxupquote{MIM = gf\_mesh\_im(\textquotesingle{}clone\textquotesingle{}, mesh\_im mim)}}
\begin{quote}

Create a copy of a mesh\_im.
\end{quote}

\sphinxcode{\sphinxupquote{MIM = gf\_mesh\_im(\textquotesingle{}levelset\textquotesingle{}, mesh\_levelset mls, string where, integ im{[}, integ im\_tip{[}, integ im\_set{]}{]})}}
\begin{quote}

Build an integration method conformal to a partition defined
implicitly by a levelset.

The \sphinxtitleref{where} argument define the domain of integration with respect to
the levelset, it has to be chosen among ‘ALL’, ‘INSIDE’, ‘OUTSIDE’ and
‘BOUNDARY’.

it can be completed by a string defining the boolean operation
to define the integration domain when there is more than one levelset.

the syntax is very simple, for example if there are 3 different
levelset,
\begin{quote}

“a*b*c” is the intersection of the domains defined by each
levelset (this is the default behaviour if this function is not
called).

“a+b+c” is the union of their domains.

“c\sphinxhyphen{}(a+b)” is the domain of the third levelset minus the union of
the domains of the two others.

“!a” is the complementary of the domain of a (i.e. it is the
domain where a(x)\textgreater{}0)

The first levelset is always referred to with “a”, the second
with “b”, and so on.
\end{quote}

for intance INSIDE(a*b*c)

CAUTION: this integration method will be defined only on the element
cut by the level\sphinxhyphen{}set. For the ‘ALL’, ‘INSIDE’ and ‘OUTSIDE’ options
it is mandatory to use the method \sphinxcode{\sphinxupquote{gf\_mesh\_im\_set(mesh\_im MI, \textquotesingle{}integ\textquotesingle{})}} to define
the integration method on the remaining elements.
\end{quote}

\sphinxcode{\sphinxupquote{MIM = gf\_mesh\_im(mesh m, {[}\{integ im|int im\_degree\}{]})}}
\begin{quote}

Build a new mesh\_im object.

For convenience, optional arguments (\sphinxtitleref{im} or \sphinxtitleref{im\_degree}) can be
provided, in that case a call to \sphinxcode{\sphinxupquote{gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}integ\textquotesingle{})}} is issued
with these arguments.
\end{quote}
\end{quote}


\section{gf\_mesh\_im\_get}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_get:gf-mesh-im-get}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n}{I}\PYG{p}{,} \PYG{n}{CV2I}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{CVids} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{convex\PYGZus{}index}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{eltm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{eltm} \PYG{n}{em}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{cv} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{f}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Ip} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{im\PYGZus{}nodes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{save}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{string} \PYG{n}{filename}\PYG{p}{[}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{with mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linked mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{memsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function extracting information from mesh\_im objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{\{I, CV2I\} = gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}integ\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Return a list of integration methods used by the mesh\_im.

\sphinxtitleref{I} is an array of all integ objects found in the convexes
given in \sphinxtitleref{CVids}. If \sphinxtitleref{CV2I} was supplied as an output argument, it
contains, for each convex listed in \sphinxtitleref{CVids}, the index of its
correspounding integration method in \sphinxtitleref{I}.

Convexes which are not part of the mesh, or convexes which do
not have any integration method have their correspounding entry
in \sphinxtitleref{CV2I} set to \sphinxhyphen{}1.

Example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cvid}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}get}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cvid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{f}\PYG{p}{,}\PYG{n}{c2f}\PYG{p}{]}\PYG{o}{=}\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}get}\PYG{p}{(}\PYG{n}{mim}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{size}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{sf}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{\PYGZcb{}}\PYG{o}{=}\PYG{n}{gf\PYGZus{}integ\PYGZus{}get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{f}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;} \PYG{n}{end}\PYG{p}{;}
\PYG{k}{for} \PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{size}\PYG{p}{(}\PYG{n}{c2f}\PYG{p}{)}\PYG{p}{,}
  \PYG{n}{disp}\PYG{p}{(}\PYG{n}{sprintf}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the integration of convex }\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s1}{ is }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
  \PYG{n}{cvid}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{sf}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{end}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

\sphinxcode{\sphinxupquote{CVids = gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}convex\_index\textquotesingle{})}}
\begin{quote}

Return the list of convexes who have a integration method.

Convexes who have the dummy IM\_NONE method are not listed.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}eltm\textquotesingle{}, eltm em, int cv {[}, int f{]})}}
\begin{quote}

Return the elementary matrix (or tensor) integrated on the convex \sphinxtitleref{cv}.

\sphinxstylestrong{WARNING}

Be sure that the fem used for the construction of \sphinxtitleref{em} is compatible
with the fem assigned to element \sphinxtitleref{cv} ! This is not checked by the
function ! If the argument \sphinxtitleref{f} is given, then the elementary tensor
is integrated on the face \sphinxtitleref{f} of \sphinxtitleref{cv} instead of the whole convex.
\end{quote}

\sphinxcode{\sphinxupquote{Ip = gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}im\_nodes\textquotesingle{}{[}, mat CVids{]})}}
\begin{quote}

Return the coordinates of the integration points, with their weights.

\sphinxtitleref{CVids} may be a list of convexes, or a list of convex faces, such
as returned by gf\_mesh\_get(mesh M, ‘region’)

\sphinxstylestrong{WARNING}

Convexes which are not part of the mesh, or convexes which
do not have an approximate integration method do not have
their corresponding entry (this has no meaning for exact
integration methods!).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}save\textquotesingle{},string filename{[}, \textquotesingle{}with mesh\textquotesingle{}{]})}}
\begin{quote}

Saves a mesh\_im in a text file (and optionally its linked mesh object).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}char\textquotesingle{}{[},\textquotesingle{}with mesh\textquotesingle{}{]})}}
\begin{quote}

Output a string description of the mesh\_im.

By default, it does not include the description of the linked
mesh object.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a mesh\_im object.
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}linked mesh\textquotesingle{})}}
\begin{quote}

Returns a reference to the mesh object linked to \sphinxtitleref{mim}.
\end{quote}

\sphinxcode{\sphinxupquote{z = gf\_mesh\_im\_get(mesh\_im MI, \textquotesingle{}memsize\textquotesingle{})}}
\begin{quote}

Return the amount of memory (in bytes) used by the mesh\_im object.

The result does not take into account the linked mesh object.
\end{quote}
\end{quote}


\section{gf\_mesh\_im\_set}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_set:gf-mesh-im-set}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{integ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{n}{integ} \PYG{n}{im}\PYG{o}{|}\PYG{n+nb}{int} \PYG{n}{im\PYGZus{}degree}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{CVids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{MI}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adapt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for modifying mesh\_im objects
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_set(mesh\_im MI, \textquotesingle{}integ\textquotesingle{},\{integ im|int im\_degree\}{[}, ivec CVids{]})}}
\begin{quote}

Set the integration method.

Assign an integration method to all convexes whose \#ids are
listed in \sphinxtitleref{CVids}. If \sphinxtitleref{CVids} is not given, the integration is
assigned to all convexes. It is possible to assign a specific
integration method with an integration method handle \sphinxtitleref{im} obtained
via gf\_integ(‘IM\_SOMETHING’), or to let getfem choose a suitable
integration method with \sphinxtitleref{im\_degree} (choosen such that polynomials
of \(\text{degree} \leq \text{im\_degree}\) are exactly integrated.
If \sphinxtitleref{im\_degree=\sphinxhyphen{}1}, then the dummy integration method IM\_NONE will
be used.)
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_set(mesh\_im MI, \textquotesingle{}adapt\textquotesingle{})}}
\begin{quote}

For a mesh\_im levelset object only. Adapt the integration methods to a
change of the levelset function.
\end{quote}
\end{quote}


\section{gf\_mesh\_im\_data}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_data:gf-mesh-im-data}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_data::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MIMD} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{size}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for mesh\_im\_data objects.
\begin{quote}

This object represents data defined on a mesh\_im object.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{MIMD = gf\_mesh\_im\_data(mesh\_im mim, int region, ivec size)}}
\begin{quote}

Build a new mesh\_imd object linked to a mesh\_im object. If \sphinxtitleref{region} is
provided, considered integration points are filtered in this region.
\sphinxtitleref{size} is a vector of integers that specifies the dimensions of the
stored data per integration point. If not given, the scalar stored
data are considered.
\end{quote}
\end{quote}


\section{gf\_mesh\_im\_data\_get}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_data_get:gf-mesh-im-data-get}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_data_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbpts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nb tensor elements}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tensor size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linked mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function extracting information from mesh\_im\_data objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_data\_get(mesh\_im\_data MID, \textquotesingle{}region\textquotesingle{})}}
\begin{quote}

Output the region that the mesh\_imd is restricted to.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_data\_get(mesh\_im\_data MID, \textquotesingle{}nbpts\textquotesingle{})}}
\begin{quote}

Output the number of integration points (filtered in the considered region).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_data\_get(mesh\_im\_data MID, \textquotesingle{}nb tensor elements\textquotesingle{})}}
\begin{quote}

Output the size of the stored data (per integration point).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_data\_get(mesh\_im\_data MID, \textquotesingle{}tensor size\textquotesingle{})}}
\begin{quote}

Output the dimensions of the stored data (per integration point).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_data\_get(mesh\_im\_data MID, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a mesh\_imd object.
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_mesh\_im\_data\_get(mesh\_im\_data MID, \textquotesingle{}linked mesh\textquotesingle{})}}
\begin{quote}

Returns a reference to the mesh object linked to \sphinxtitleref{mim}.
\end{quote}
\end{quote}


\section{gf\_mesh\_im\_data\_set}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_data_set:gf-mesh-im-data-set}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_im_data_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{region}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rnum}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}im\PYGZus{}data\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}im\PYGZus{}data} \PYG{n}{MID}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tensor size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for modifying mesh\_im objects
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_data\_set(mesh\_im\_data MID, \textquotesingle{}region\textquotesingle{}, int rnum)}}
\begin{quote}

Set the considered region to \sphinxtitleref{rnum}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_im\_data\_set(mesh\_im\_data MID, \textquotesingle{}tensor size\textquotesingle{},)}}
\begin{quote}

Set the size of the data per integration point.
\end{quote}
\end{quote}


\section{gf\_mesh\_levelset}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_levelset:gf-mesh-levelset}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_levelset::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MLS} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset}\PYG{p}{(}\PYG{n}{mesh} \PYG{n}{m}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for mesh\_levelset objects.
\begin{quote}

General constructor for mesh\_levelset objects. The role of this object is
to provide a mesh cut by a certain number of level\_set. This object is
used to build conformal integration method (object mim and enriched finite
element methods (Xfem)).
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{MLS = gf\_mesh\_levelset(mesh m)}}
\begin{quote}

Build a new mesh\_levelset object from a mesh and returns its handle.
\end{quote}
\end{quote}


\section{gf\_mesh\_levelset\_get}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_levelset_get:gf-mesh-levelset-get}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_levelset_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cut\PYGZus{}mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{LM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linked\PYGZus{}mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{nbls} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nb\PYGZus{}ls}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{LS} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{levelsets}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{CVIDs} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{crack\PYGZus{}tip\PYGZus{}convexes}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{SIZE} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{memsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about mesh\_levelset objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{M = gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}cut\_mesh\textquotesingle{})}}
\begin{quote}

Return a mesh cut by the linked levelset’s.
\end{quote}

\sphinxcode{\sphinxupquote{LM = gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}linked\_mesh\textquotesingle{})}}
\begin{quote}

Return a reference to the linked mesh.
\end{quote}

\sphinxcode{\sphinxupquote{nbls = gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}nb\_ls\textquotesingle{})}}
\begin{quote}

Return the number of linked levelset’s.
\end{quote}

\sphinxcode{\sphinxupquote{LS = gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}levelsets\textquotesingle{})}}
\begin{quote}

Return a list of references to the linked levelset’s.
\end{quote}

\sphinxcode{\sphinxupquote{CVIDs = gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}crack\_tip\_convexes\textquotesingle{})}}
\begin{quote}

Return the list of convex \#id’s of the linked mesh on
which have a tip of any linked levelset’s.
\end{quote}

\sphinxcode{\sphinxupquote{SIZE = gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}memsize\textquotesingle{})}}
\begin{quote}

Return the amount of memory (in bytes) used by the mesh\_levelset.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the mesh\_levelsetn.

This can be used to perform comparisons between two
different mesh\_levelset objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_levelset\_get(mesh\_levelset MLS, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a mesh\_levelset object.
\end{quote}
\end{quote}


\section{gf\_mesh\_levelset\_set}
\label{\detokenize{matlab_octave/cmdref_gf_mesh_levelset_set:gf-mesh-levelset-set}}\label{\detokenize{matlab_octave/cmdref_gf_mesh_levelset_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{levelset} \PYG{n}{ls}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sup}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{levelset} \PYG{n}{ls}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesh\PYGZus{}levelset\PYGZus{}set}\PYG{p}{(}\PYG{n}{mesh\PYGZus{}levelset} \PYG{n}{MLS}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adapt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for modification of mesh\_levelset objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_levelset\_set(mesh\_levelset MLS, \textquotesingle{}add\textquotesingle{}, levelset ls)}}
\begin{quote}

Add a link to the levelset \sphinxtitleref{ls}.

Only a reference is kept, no copy is done. In order to indicate
that the linked mesh is cut by a levelset one has to call this
method, where \sphinxtitleref{ls} is an levelset object. An arbitrary number of
levelset can be added.

\sphinxstylestrong{WARNING}

The mesh of \sphinxtitleref{ls} and the linked mesh must be the same.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_levelset\_set(mesh\_levelset MLS, \textquotesingle{}sup\textquotesingle{}, levelset ls)}}
\begin{quote}

Remove a link to the levelset \sphinxtitleref{ls}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesh\_levelset\_set(mesh\_levelset MLS, \textquotesingle{}adapt\textquotesingle{})}}
\begin{quote}

Do all the work (cut the convexes with the levelsets).

To initialice the mesh\_levelset object or to actualize it when the
value of any levelset function is modified, one has to call
this method.
\end{quote}
\end{quote}


\section{gf\_mesher\_object}
\label{\detokenize{matlab_octave/cmdref_gf_mesher_object:gf-mesher-object}}\label{\detokenize{matlab_octave/cmdref_gf_mesher_object::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ball}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{center}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{radius}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{half space}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{origin}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{normal\PYGZus{}vector}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cylinder}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{origin}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{n}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{length}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{radius}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cone}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{origin}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{n}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{length}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{half\PYGZus{}angle}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{torus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{R}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{r}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rectangle}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{rmin}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{rmax}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{intersect}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesher\PYGZus{}object} \PYG{n}{object1} \PYG{p}{,} \PYG{n}{mesher\PYGZus{}object} \PYG{n}{object2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{union}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesher\PYGZus{}object} \PYG{n}{object1} \PYG{p}{,} \PYG{n}{mesher\PYGZus{}object} \PYG{n}{object2}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{MF} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set minus}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesher\PYGZus{}object} \PYG{n}{object1} \PYG{p}{,} \PYG{n}{mesher\PYGZus{}object} \PYG{n}{object2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for mesher\_object objects.
\begin{quote}

This object represents a geometric object to be meshed by the
experimental meshing procedure of Getfem.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}ball\textquotesingle{}, vec center, scalar radius)}}
\begin{quote}

Represents a ball of corresponding center and radius.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}half space\textquotesingle{}, vec origin, vec normal\_vector)}}
\begin{quote}

Represents an half space delimited by the plane which contains the
origin and normal to \sphinxtitleref{normal\_vector}. The selected part is the part
in the direction of the normal vector. This allows to cut a geometry
with a plane for instance to build a polygon or a polyhedron.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}cylinder\textquotesingle{}, vec origin, vec n, scalar length, scalar radius)}}
\begin{quote}

Represents a cylinder (in any dimension) of a certain radius whose axis
is determined by the origin, a vector \sphinxtitleref{n} and a certain length.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}cone\textquotesingle{}, vec origin, vec n, scalar length, scalar half\_angle)}}
\begin{quote}

Represents a cone (in any dimension) of a certain half\sphinxhyphen{}angle (in radians)
whose axis is determined by the origin, a vector \sphinxtitleref{n} and a certain length.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}torus\textquotesingle{}, scalar R, scalar r)}}
\begin{quote}

Represents a torus in 3d of axis along the z axis with a great radius
equal to \sphinxtitleref{R} and small radius equal to \sphinxtitleref{r}. For the moment, the
possibility to change the axis is not given.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}rectangle\textquotesingle{}, vec rmin, vec rmax)}}
\begin{quote}

Represents a rectangle (or parallelepiped in 3D) parallel to the axes.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}intersect\textquotesingle{}, mesher\_object object1 , mesher\_object object2, ...)}}
\begin{quote}

Intersection of several objects.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}union\textquotesingle{}, mesher\_object object1 , mesher\_object object2, ...)}}
\begin{quote}

Union of several objects.
\end{quote}

\sphinxcode{\sphinxupquote{MF = gf\_mesher\_object(\textquotesingle{}set minus\textquotesingle{}, mesher\_object object1 , mesher\_object object2)}}
\begin{quote}

Geometric object being object1 minus object2.
\end{quote}
\end{quote}


\section{gf\_mesher\_object\_get}
\label{\detokenize{matlab_octave/cmdref_gf_mesher_object_get:gf-mesher-object-get}}\label{\detokenize{matlab_octave/cmdref_gf_mesher_object_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}mesher\PYGZus{}object\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesher\PYGZus{}object} \PYG{n}{MO}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}mesher\PYGZus{}object\PYGZus{}get}\PYG{p}{(}\PYG{n}{mesher\PYGZus{}object} \PYG{n}{MO}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about mesher\_object objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{s = gf\_mesher\_object\_get(mesher\_object MO, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the mesher\_object.

This can be used to perform comparisons between two
different mesher\_object objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_mesher\_object\_get(mesher\_object MO, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a mesher\_object object.
\end{quote}
\end{quote}


\section{gf\_model}
\label{\detokenize{matlab_octave/cmdref_gf_model:gf-model}}\label{\detokenize{matlab_octave/cmdref_gf_model::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MD} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{real}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{MD} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{complex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for model objects.
\begin{quote}

model variables store the variables and the state data and the
description of a model. This includes the global tangent matrix, the right
hand side and the constraints. There are two kinds of models, the \sphinxtitleref{real}
and the \sphinxtitleref{complex} models.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{MD = gf\_model(\textquotesingle{}real\textquotesingle{})}}
\begin{quote}

Build a model for real unknowns.
\end{quote}

\sphinxcode{\sphinxupquote{MD = gf\_model(\textquotesingle{}complex\textquotesingle{})}}
\begin{quote}

Build a model for complex unknowns.
\end{quote}
\end{quote}


\section{gf\_model\_get}
\label{\detokenize{matlab_octave/cmdref_gf_model_get:gf-model-get}}\label{\detokenize{matlab_octave/cmdref_gf_model_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{b} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}complex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{T} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbdof}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{dt} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{get time step}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{t} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{get time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{T} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tangent\PYGZus{}matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rhs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brick term rhs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}brick}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}term}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{sym}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}iter}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{memsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{variable list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{brick list}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{list residuals}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interpolation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf} \PYG{o}{|} \PYG{n}{mesh\PYGZus{}imd} \PYG{n}{mimd} \PYG{o}{|} \PYG{n}{vec} \PYG{n}{pts}\PYG{p}{,}  \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{extrapolation}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rg\PYGZus{}source}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{local\PYGZus{}projection}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{mf} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mesh fem of variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{)}
\PYG{n}{name} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mult varname Dirichlet}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}brick}\PYG{p}{)}
\PYG{n}{I} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interval of variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{from variables}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{assembly}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{option}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{nbit}\PYG{p}{,} \PYG{n}{converged}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{solve}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test tangent matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{EPS}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{NB}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{scale}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test tangent matrix term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname2}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{EPS}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{NB}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{scale}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{expr} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Neumann term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute isotropic linearized Von Mises or Tresca}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}lambda}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}mu}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{version}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute isotropic linearized Von Mises pstrain}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}E}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}nu}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute isotropic linearized Von Mises pstress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}E}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}nu}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute Von Mises or Tresca}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{version}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute finite strain elasticity Von Mises}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute second Piola Kirchhoff tensor}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}sigma}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{elastoplasticity next iter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{previous\PYGZus{}dep\PYGZus{}name}\PYG{p}{,} \PYG{n}{string} \PYG{n}{projname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datalambda}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datamu}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datathreshold}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datasigma}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{small strain elastoplasticity next iter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,}  \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{unknowns\PYGZus{}type} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varnames}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{theta} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dt} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{timestep}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{small strain elastoplasticity Von Mises}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{unknowns\PYGZus{}type} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varnames}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{theta} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dt} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{timestep}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute elastoplasticity Von Mises or Tresca}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datasigma}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{version}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute plastic part}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}pl}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{previous\PYGZus{}dep\PYGZus{}name}\PYG{p}{,} \PYG{n}{string} \PYG{n}{projname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datalambda}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datamu}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datathreshold}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datasigma}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{finite strain elastoplasticity next iter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{unknowns\PYGZus{}type}\PYG{p}{,} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varnames}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{compute finite strain elastoplasticity Von Mises}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}vm}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{unknowns\PYGZus{}type}\PYG{p}{,} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varnames}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sliding data group name of large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{displacement group name of large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transformation name of large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sliding data group name of Nitsche large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{displacement group name of Nitsche large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transformation name of Nitsche large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{)}
\PYG{n}{M} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matrix term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}brick}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}term}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}get}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Get information from a model object.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{b = gf\_model\_get(model M, \textquotesingle{}is\_complex\textquotesingle{})}}
\begin{quote}

Return 0 is the model is real, 1 if it is complex.
\end{quote}

\sphinxcode{\sphinxupquote{T = gf\_model\_get(model M, \textquotesingle{}nbdof\textquotesingle{})}}
\begin{quote}

Return the total number of degrees of freedom of the model.
\end{quote}

\sphinxcode{\sphinxupquote{dt = gf\_model\_get(model M, \textquotesingle{}get time step\textquotesingle{})}}
\begin{quote}

Gives the value of the time step.
\end{quote}

\sphinxcode{\sphinxupquote{t = gf\_model\_get(model M, \textquotesingle{}get time\textquotesingle{})}}
\begin{quote}

Give the value of the data \sphinxtitleref{t} corresponding to the current time.
\end{quote}

\sphinxcode{\sphinxupquote{T = gf\_model\_get(model M, \textquotesingle{}tangent\_matrix\textquotesingle{})}}
\begin{quote}

Return the tangent matrix stored in the model .
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}rhs\textquotesingle{})}}
\begin{quote}

Return the right hand side of the tangent problem.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}brick term rhs\textquotesingle{}, int ind\_brick{[}, int ind\_term, int sym, int ind\_iter{]})}}
\begin{quote}

Gives the access to the part of the right hand side of a term
of a particular nonlinear brick. Does not account of the eventual
time dispatcher. An assembly of the rhs has to be done first.
\sphinxtitleref{ind\_brick} is the brick index. \sphinxtitleref{ind\_term} is the index of the
term inside the brick (default value : 1).
\sphinxtitleref{sym} is to access to the second right hand side of for symmetric
terms acting on two different variables (default is 0).
\sphinxtitleref{ind\_iter} is the iteration number when time dispatchers are
used (default is 1).
\end{quote}

\sphinxcode{\sphinxupquote{z = gf\_model\_get(model M, \textquotesingle{}memsize\textquotesingle{})}}
\begin{quote}

Return a rough approximation of the amount of memory (in bytes) used by
the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}variable list\textquotesingle{})}}
\begin{quote}

print to the output the list of variables and constants of the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}brick list\textquotesingle{})}}
\begin{quote}

print to the output the list of bricks of the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}list residuals\textquotesingle{})}}
\begin{quote}

print to the output the residuals corresponding to all terms
included in the model.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}variable\textquotesingle{}, string name)}}
\begin{quote}

Gives the value of a variable or data.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}interpolation\textquotesingle{}, string expr, \{mesh\_fem mf | mesh\_imd mimd | vec pts,  mesh m\}{[}, int region{[}, int extrapolation{[}, int rg\_source{]}{]}{]})}}
\begin{quote}

Interpolate a certain expression with respect to the mesh\_fem \sphinxtitleref{mf}
or the mesh\_im\_data \sphinxtitleref{mimd} or the set of points \sphinxtitleref{pts} on mesh \sphinxtitleref{m}.
The expression has to be valid according to the high\sphinxhyphen{}level generic
assembly language possibly including references to the variables
and data of the model.

The options \sphinxtitleref{extrapolation} and \sphinxtitleref{rg\_source} are specific to
interpolations with respect to a set of points \sphinxtitleref{pts}.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}local\_projection\textquotesingle{}, mesh\_im mim, string expr, mesh\_fem mf{[}, int region{]})}}
\begin{quote}

Make an elementwise L2 projection of an expression with respect
to the mesh\_fem \sphinxtitleref{mf}. This mesh\_fem has to be
a discontinuous one.
The expression has to be valid according to the high\sphinxhyphen{}level generic
assembly language possibly including references to the variables
and data of the model.
\end{quote}

\sphinxcode{\sphinxupquote{mf = gf\_model\_get(model M, \textquotesingle{}mesh fem of variable\textquotesingle{}, string name)}}
\begin{quote}

Gives access to the \sphinxtitleref{mesh\_fem} of a variable or data.
\end{quote}

\sphinxcode{\sphinxupquote{name = gf\_model\_get(model M, \textquotesingle{}mult varname Dirichlet\textquotesingle{}, int ind\_brick)}}
\begin{quote}

Gives the name of the multiplier variable for a Dirichlet brick.
If the brick is not a Dirichlet condition with multiplier brick,
this function has an undefined behavior
\end{quote}

\sphinxcode{\sphinxupquote{I = gf\_model\_get(model M, \textquotesingle{}interval of variable\textquotesingle{}, string varname)}}
\begin{quote}

Gives the interval of the variable \sphinxtitleref{varname} in the linear system of
the model.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}from variables\textquotesingle{})}}
\begin{quote}

Return the vector of all the degrees of freedom of the model consisting
of the concatenation of the variables of the model (useful
to solve your problem with you own solver).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}assembly\textquotesingle{}{[}, string option{]})}}
\begin{quote}

Assembly of the tangent system taking into account the terms
from all bricks. \sphinxtitleref{option}, if specified, should be ‘build\_all’,
‘build\_rhs’, ‘build\_matrix’.
The default is to build the whole
tangent linear system (matrix and rhs). This function is useful
to solve your problem with you own solver.
\end{quote}

\sphinxcode{\sphinxupquote{\{nbit, converged\} = gf\_model\_get(model M, \textquotesingle{}solve\textquotesingle{}{[}, ...{]})}}
\begin{quote}

Run the standard getfem solver.

Note that you should be able to use your own solver if you want
(it is possible to obtain the tangent matrix and its right hand
side with the gf\_model\_get(model M, ‘tangent matrix’) etc.).

Various options can be specified:
\begin{itemize}
\item {} \begin{description}
\item[{‘noisy’ or ‘very\_noisy’}] \leavevmode
the solver will display some information showing the progress
(residual values etc.).

\end{description}

\item {} \begin{description}
\item[{‘max\_iter’, int NIT}] \leavevmode
set the maximum iterations numbers.

\end{description}

\item {} \begin{description}
\item[{‘max\_res’, @float RES}] \leavevmode
set the target residual value.

\end{description}

\item {} \begin{description}
\item[{‘diverged\_res’, @float RES}] \leavevmode
set the threshold value of the residual beyond which the iterative
method is considered to diverge (default is 1e200).

\end{description}

\item {} \begin{description}
\item[{‘lsolver’, string SOLVER\_NAME}] \leavevmode
select explicitely the solver used for the linear systems (the
default value is ‘auto’, which lets getfem choose itself).
Possible values are ‘superlu’, ‘mumps’ (if supported),
‘cg/ildlt’, ‘gmres/ilu’ and ‘gmres/ilut’.

\end{description}

\item {} \begin{description}
\item[{‘lsearch’, string LINE\_SEARCH\_NAME}] \leavevmode
select explicitely the line search method used for the linear systems (the
default value is ‘default’).
Possible values are ‘simplest’, ‘systematic’, ‘quadratic’ or ‘basic’.

\end{description}

Return the number of iterations, if an iterative method is used.

Note that it is possible to disable some variables
(see gf\_model\_set(model M, ‘disable variable’) ) in order to
solve the problem only with respect to a subset of variables (the
disabled variables are then considered as data) for instance to
replace the global Newton strategy with a fixed point one.

\end{itemize}
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}test tangent matrix\textquotesingle{}{[}, scalar EPS{[}, int NB{[}, scalar scale{]}{]}{]})}}
\begin{quote}

Test the consistency of the tangent matrix in some random positions
and random directions (useful to test newly created bricks).
\sphinxtitleref{EPS} is the value of the small parameter for the finite difference
computation of the derivative is the random direction (default is 1E\sphinxhyphen{}6).
\sphinxtitleref{NN} is the number of tests (default is 100). \sphinxtitleref{scale} is a parameter
for the random position (default is 1, 0 is an acceptable value) around
the current position.
Each dof of the random position is chosen in the range
{[}current\sphinxhyphen{}scale, current+scale{]}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}test tangent matrix term\textquotesingle{}, string varname1, string varname2{[}, scalar EPS{[}, int NB{[}, scalar scale{]}{]}{]})}}
\begin{quote}

Test the consistency of a part of the tangent matrix in some
random positions and random directions
(useful to test newly created bricks).
The increment is only made on variable \sphinxtitleref{varname2} and tested on the
part of the residual corresponding to \sphinxtitleref{varname1}. This means that
only the term (\sphinxtitleref{varname1}, \sphinxtitleref{varname2}) of the tangent matrix is tested.
\sphinxtitleref{EPS} is the value of the small parameter for the finite difference
computation of the derivative is the random direction (default is 1E\sphinxhyphen{}6).
\sphinxtitleref{NN} is the number of tests (default is 100). \sphinxtitleref{scale} is a parameter
for the random position (default is 1, 0 is an acceptable value)
around the current position.
Each dof of the random position is chosen in the range
{[}current\sphinxhyphen{}scale, current+scale{]}.
\end{quote}

\sphinxcode{\sphinxupquote{expr = gf\_model\_get(model M, \textquotesingle{}Neumann term\textquotesingle{}, string varname, int region)}}
\begin{quote}

Gives the assembly string corresponding to the Neumann term of
the fem variable \sphinxtitleref{varname} on \sphinxtitleref{region}. It is deduced from the
assembly string declared by the model bricks.
\sphinxtitleref{region} should be the index of a boundary region
on the mesh where \sphinxtitleref{varname} is defined. Care to call this function
only after all the volumic bricks have been declared.
Complains, if a brick
omit to declare an assembly string.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute isotropic linearized Von Mises or Tresca\textquotesingle{}, string varname, string dataname\_lambda, string dataname\_mu, mesh\_fem mf\_vm{[}, string version{]})}}
\begin{quote}

Compute the Von\sphinxhyphen{}Mises stress or the Tresca stress of a field (only
valid for isotropic linearized elasticity in 3D). \sphinxtitleref{version} should
be  ‘Von\_Mises’ or ‘Tresca’ (‘Von\_Mises’ is the default).
Parametrized by Lame coefficients.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute isotropic linearized Von Mises pstrain\textquotesingle{}, string varname, string data\_E, string data\_nu, mesh\_fem mf\_vm)}}
\begin{quote}

Compute the Von\sphinxhyphen{}Mises stress  of a displacement field for isotropic
linearized elasticity in 3D or in 2D with plane strain assumption.
Parametrized by Young modulus and Poisson ratio.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute isotropic linearized Von Mises pstress\textquotesingle{}, string varname, string data\_E, string data\_nu, mesh\_fem mf\_vm)}}
\begin{quote}

Compute the Von\sphinxhyphen{}Mises stress  of a displacement field for isotropic
linearized elasticity in 3D or in 2D with plane stress assumption.
Parametrized by Young modulus and Poisson ratio.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute Von Mises or Tresca\textquotesingle{}, string varname, string lawname, string dataname, mesh\_fem mf\_vm{[}, string version{]})}}
\begin{quote}

Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises stress or the Tresca stress of a field
for nonlinear elasticity in 3D. \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘neo Hookean’ or
‘Ciarlet Geymonat’.
\sphinxtitleref{dataname} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable coefficients.
\sphinxtitleref{version} should be  ‘Von\_Mises’ or ‘Tresca’ (‘Von\_Mises’ is the default).
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute finite strain elasticity Von Mises\textquotesingle{},  string lawname, string varname, string params, mesh\_fem mf\_vm{[}, int region{]})}}
\begin{quote}

Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises stress of a field \sphinxtitleref{varname}
for nonlinear elasticity in 3D. \sphinxtitleref{lawname} is the constitutive law which
should be a valid name. \sphinxtitleref{params} are the parameters law. It could be
a short vector of constant values or may depend on data or variables
of the model.
Uses the high\sphinxhyphen{}level generic assembly.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute second Piola Kirchhoff tensor\textquotesingle{}, string varname, string lawname, string dataname, mesh\_fem mf\_sigma)}}
\begin{quote}

Compute on \sphinxtitleref{mf\_sigma} the second Piola Kirchhoff stress tensor of a field
for nonlinear elasticity in 3D. \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘neo Hookean’ or
‘Ciarlet Geymonat’.
\sphinxtitleref{dataname} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable
coefficients.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}elastoplasticity next iter\textquotesingle{}, mesh\_im mim, string varname, string previous\_dep\_name, string projname, string datalambda, string datamu, string datathreshold, string datasigma)}}
\begin{quote}

Used with the old (obsolete) elastoplasticity brick to pass from an
iteration to the next one.
Compute and save the stress constraints sigma for the next iterations.
‘mim’ is the integration method to use for the computation.
‘varname’ is the main variable of the problem.
‘previous\_dep\_name’ represents the displacement at the previous time step.
‘projname’ is the type of projection to use. For the moment it could only be ‘Von Mises’ or ‘VM’.
‘datalambda’ and ‘datamu’ are the Lame coefficients of the material.
‘datasigma’ is a vector which will contain the new stress constraints values.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}small strain elastoplasticity next iter\textquotesingle{}, mesh\_im mim,  string lawname, string unknowns\_type {[}, string varnames, ...{]} {[}, string params, ...{]} {[}, string theta = \textquotesingle{}1\textquotesingle{} {[}, string dt = \textquotesingle{}timestep\textquotesingle{}{]}{]} {[}, int region = \sphinxhyphen{}1{]})}}
\begin{quote}

Function that allows to pass from a time step to another for the
small strain plastic brick. The parameters have to be exactly the
same than the one of \sphinxtitleref{add\_small\_strain\_elastoplasticity\_brick},
so see the documentation of this function for the explanations.
Basically, this brick computes the plastic strain
and the plastic multiplier and stores them for the next step.
Additionaly, it copies the computed displacement to the data
that stores the displacement of the previous time step (typically
‘u’ to ‘Previous\_u’). It has to be called before any use of
\sphinxtitleref{compute\_small\_strain\_elastoplasticity\_Von\_Mises}.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}small strain elastoplasticity Von Mises\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_vm, string lawname, string unknowns\_type {[}, string varnames, ...{]} {[}, string params, ...{]} {[}, string theta = \textquotesingle{}1\textquotesingle{} {[}, string dt = \textquotesingle{}timestep\textquotesingle{}{]}{]} {[}, int region{]})}}
\begin{quote}

This function computes the Von Mises stress field with respect to
a small strain elastoplasticity term, approximated on \sphinxtitleref{mf\_vm},
and stores the result into \sphinxtitleref{VM}.  All other parameters have to be
exactly the same as for \sphinxtitleref{add\_small\_strain\_elastoplasticity\_brick}.
Remember that \sphinxtitleref{small\_strain\_elastoplasticity\_next\_iter} has to be called
before any call of this function.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute elastoplasticity Von Mises or Tresca\textquotesingle{}, string datasigma, mesh\_fem mf\_vm{[}, string version{]})}}
\begin{quote}

Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises or the Tresca stress of a field for plasticity and return it into the vector V.
\sphinxtitleref{datasigma} is a vector which contains the stress constraints values supported by the mesh.
\sphinxtitleref{version} should be  ‘Von\_Mises’ or ‘Tresca’ (‘Von\_Mises’ is the default).
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute plastic part\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_pl, string varname, string previous\_dep\_name, string projname, string datalambda, string datamu, string datathreshold, string datasigma)}}
\begin{quote}

Compute on \sphinxtitleref{mf\_pl} the plastic part and return it into the vector V.
\sphinxtitleref{datasigma} is a vector which contains the stress constraints values supported by the mesh.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}finite strain elastoplasticity next iter\textquotesingle{}, mesh\_im mim, string lawname, string unknowns\_type, {[}, string varnames, ...{]} {[}, string params, ...{]} {[}, int region = \sphinxhyphen{}1{]})}}
\begin{quote}

Function that allows to pass from a time step to another for the
finite strain plastic brick. The parameters have to be exactly the
same than the one of \sphinxtitleref{add\_finite\_strain\_elastoplasticity\_brick},
so see the documentation of this function for the explanations.
Basically, this brick computes the plastic strain
and the plastic multiplier and stores them for the next step.
For the Simo\sphinxhyphen{}Miehe law which is currently the only one implemented,
this function updates the state variables defined in the last two
entries of \sphinxtitleref{varnames}, and resets the plastic multiplier field given
as the second entry of \sphinxtitleref{varnames}.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}compute finite strain elastoplasticity Von Mises\textquotesingle{}, mesh\_im mim, mesh\_fem mf\_vm, string lawname, string unknowns\_type, {[}, string varnames, ...{]} {[}, string params, ...{]} {[}, int region = \sphinxhyphen{}1{]})}}
\begin{quote}

Compute on \sphinxtitleref{mf\_vm} the Von\sphinxhyphen{}Mises or the Tresca stress of a field for plasticity and return it into the vector V.
The first input parameters ar as in the function ‘finite strain elastoplasticity next iter’.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}sliding data group name of large sliding contact brick\textquotesingle{}, int indbrick)}}
\begin{quote}

Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}displacement group name of large sliding contact brick\textquotesingle{}, int indbrick)}}
\begin{quote}

Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}transformation name of large sliding contact brick\textquotesingle{}, int indbrick)}}
\begin{quote}

Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}sliding data group name of Nitsche large sliding contact brick\textquotesingle{}, int indbrick)}}
\begin{quote}

Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}displacement group name of Nitsche large sliding contact brick\textquotesingle{}, int indbrick)}}
\begin{quote}

Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_model\_get(model M, \textquotesingle{}transformation name of Nitsche large sliding contact brick\textquotesingle{}, int indbrick)}}
\begin{quote}

Gives the name of the group of variables corresponding to the
sliding data for an existing large sliding contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{M = gf\_model\_get(model M, \textquotesingle{}matrix term\textquotesingle{}, int ind\_brick, int ind\_term)}}
\begin{quote}

Gives the matrix term ind\_term of the brick ind\_brick if it exists
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_model\_get(model M, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the model.

This can be used to perform comparisons between two
different model objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_get(model M, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a model object.
\end{quote}
\end{quote}


\section{gf\_model\_set}
\label{\detokenize{matlab_octave/cmdref_gf_model_set:gf-model-set}}\label{\detokenize{matlab_octave/cmdref_gf_model_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add fem variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add filtered fem variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add im variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}imd} \PYG{n}{mimd}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add internal im variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}imd} \PYG{n}{mimd}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{sizes}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{delete variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{resize variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{sizes}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add multiplier}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{string} \PYG{n}{primalname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add im data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}imd} \PYG{n}{mimd}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add fem data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{[}\PYG{p}{,} \PYG{n}{sizes}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add initialized fem data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{[}\PYG{p}{,} \PYG{n}{sizes}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{size}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add macro}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{del macro}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add initialized data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{[}\PYG{p}{,} \PYG{n}{sizes}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{to variables}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{delete brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}brick}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{define variable group}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add elementary rotated RT0 projection}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add elementary P0 projection}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add HHO reconstructed gradient}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add HHO reconstructed symmetrized gradient}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add HHO reconstructed value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add HHO reconstructed symmetrized value}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add HHO stabilization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add HHO symmetrized stabilization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add interpolate transformation from expression}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{source\PYGZus{}mesh}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{target\PYGZus{}mesh}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add element extrapolation transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{source\PYGZus{}mesh}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{elt\PYGZus{}corr}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add standard secondary domain}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set element extrapolation correspondence}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{elt\PYGZus{}corr}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add raytracing transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{release\PYGZus{}distance}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add master contact boundary to raytracing transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add slave contact boundary to raytracing transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add rigid obstacle to raytracing transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{N}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add projection transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{release\PYGZus{}distance}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add master contact boundary to projection transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add slave contact boundary to projection transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add rigid obstacle to projection transformation}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{transname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{N}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add linear term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}symmetric}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}coercive}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add linear twodomain term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{secondary\PYGZus{}domain}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}symmetric}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}coercive}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add linear generic assembly brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}symmetric}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}coercive}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nonlinear term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}symmetric}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}coercive}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nonlinear twodomain term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{secondary\PYGZus{}domain}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}symmetric}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}coercive}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nonlinear generic assembly brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}symmetric}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{is\PYGZus{}coercive}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add source term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add twodomain source term}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{secondary\PYGZus{}domain}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add source term generic assembly brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add assembly assignment}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expression}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{order}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{before}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clear assembly assignment}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Laplacian brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add generic elliptic brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add source term brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataexpr}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{directdataname}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add normal source term brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Dirichlet condition with simplification}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Dirichlet condition with multipliers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{mult\PYGZus{}description}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Dirichlet condition with Nitsche method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Neumannterm}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datagamma0}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Dirichlet condition with penalization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{coeff}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}mult}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add normal Dirichlet condition with multipliers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{mult\PYGZus{}description}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add normal Dirichlet condition with penalization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{coeff}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}mult}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add normal Dirichlet condition with Nitsche method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Neumannterm}\PYG{p}{,} \PYG{n}{string} \PYG{n}{gamma0name}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add generalized Dirichlet condition with multipliers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{mult\PYGZus{}description}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Hname}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add generalized Dirichlet condition with penalization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{coeff}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Hname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf\PYGZus{}mult}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add generalized Dirichlet condition with Nitsche method}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Neumannterm}\PYG{p}{,} \PYG{n}{string} \PYG{n}{gamma0name}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Hname}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add pointwise constraints with multipliers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}pt}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}unitv}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}val}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add pointwise constraints with given multipliers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}pt}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}unitv}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}val}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add pointwise constraints with penalization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{coeff}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}pt}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}unitv}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}val}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{change penalization coeff}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{ind\PYGZus{}brick}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{coeff}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Helmholtz brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataexpr}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Fourier Robin brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataexpr}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add constraint with multipliers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{B}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{vec} \PYG{n}{L} \PYG{o}{|} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add constraint with penalization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{coeff}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{B}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n}{vec} \PYG{n}{L} \PYG{o}{|} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add explicit matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname2}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{B}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{issymmetric}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{iscoercive}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add explicit rhs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{L}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set private matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set private rhs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add isotropic linearized elasticity brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}lambda}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}mu}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add isotropic linearized elasticity brick pstrain}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}E}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}nu}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add isotropic linearized elasticity brick pstress}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}E}\PYG{p}{,} \PYG{n}{string} \PYG{n}{data\PYGZus{}nu}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add linear incompressibility brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}pressure}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataexpr\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nonlinear elasticity brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{constitutive\PYGZus{}law}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add finite strain elasticity brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{constitutive\PYGZus{}law}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add small strain elastoplasticity brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,}  \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{unknowns\PYGZus{}type} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varnames}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{theta} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dt} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{timestep}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add elastoplasticity brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim} \PYG{p}{,}\PYG{n}{string} \PYG{n}{projname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{previous\PYGZus{}dep\PYGZus{}name}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datalambda}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datamu}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datathreshold}\PYG{p}{,} \PYG{n}{string} \PYG{n}{datasigma}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add finite strain elastoplasticity brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim} \PYG{p}{,} \PYG{n}{string} \PYG{n}{lawname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{unknowns\PYGZus{}type} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varnames}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{params}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nonlinear incompressibility brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}pressure}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add finite strain incompressibility brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}pressure}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add bilaplacian brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Kirchhoff\PYGZhy{}Love plate brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}D}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}nu} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add normal derivative source term brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Kirchhoff\PYGZhy{}Love Neumann term brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}M}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}divM}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add normal derivative Dirichlet condition with multipliers}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{mult\PYGZus{}description}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{R\PYGZus{}must\PYGZus{}be\PYGZus{}derivated}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add normal derivative Dirichlet condition with penalization}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{coeff}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{R\PYGZus{}must\PYGZus{}be\PYGZus{}derivated}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Mindlin Reissner plate brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim\PYGZus{}reduced}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u3}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}theta} \PYG{p}{,} \PYG{n}{string} \PYG{n}{param\PYGZus{}E}\PYG{p}{,} \PYG{n}{string} \PYG{n}{param\PYGZus{}nu}\PYG{p}{,} \PYG{n}{string} \PYG{n}{param\PYGZus{}epsilon}\PYG{p}{,} \PYG{n}{string} \PYG{n}{param\PYGZus{}kappa} \PYG{p}{[}\PYG{p}{,}\PYG{n+nb}{int} \PYG{n}{variant} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add enriched Mindlin Reissner plate brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim\PYGZus{}reduced1}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim\PYGZus{}reduced2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}ua}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}theta}\PYG{p}{,}\PYG{n}{string} \PYG{n}{varname\PYGZus{}u3}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}theta3} \PYG{p}{,} \PYG{n}{string} \PYG{n}{param\PYGZus{}E}\PYG{p}{,} \PYG{n}{string} \PYG{n}{param\PYGZus{}nu}\PYG{p}{,} \PYG{n}{string} \PYG{n}{param\PYGZus{}epsilon} \PYG{p}{[}\PYG{p}{,}\PYG{n+nb}{int} \PYG{n}{variant} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add mass brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataexpr\PYGZus{}rho}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{shift variables for time integration}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{perform init time derivative}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{ddt}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set time step}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{dt}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{set time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{t}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add theta method for first order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add theta method for second order}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Newmark scheme}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{beta}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{gamma}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add\PYGZus{}Houbolt\PYGZus{}scheme}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disable bricks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{bricks\PYGZus{}indices}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{enable bricks}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{bricks\PYGZus{}indices}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{disable variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{enable variable}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{first iter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{next iter}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add basic contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}n}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{BN}\PYG{p}{[}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{BT}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}gap}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{augmented\PYGZus{}version}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}gamma}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add basic contact brick two deformable bodies}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}n}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{BN1}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{BN2}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}gap}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{augmented\PYGZus{}version}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact brick set BN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{BN}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{contact brick set BT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{BT}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nodal contact with rigid obstacle brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}n}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{obstacle}\PYG{p}{[}\PYG{p}{,}  \PYG{n+nb}{int} \PYG{n}{augmented\PYGZus{}version}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add contact with rigid obstacle brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}n}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{obstacle}\PYG{p}{[}\PYG{p}{,}  \PYG{n+nb}{int} \PYG{n}{augmented\PYGZus{}version}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add integral contact with rigid obstacle brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}obstacle}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{option} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}gamma} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}vt}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add penalized contact with rigid obstacle brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}obstacle}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{option}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}lambda}\PYG{p}{,} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Nitsche contact with rigid obstacle brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Neumannterm}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}obstacle}\PYG{p}{,} \PYG{n}{string} \PYG{n}{gamma0name}\PYG{p}{,}  \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Nitsche midpoint contact with rigid obstacle brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Neumannterm}\PYG{p}{,} \PYG{n}{string} \PYG{n}{Neumannterm\PYGZus{}wt}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}obstacle}\PYG{p}{,} \PYG{n}{string} \PYG{n}{gamma0name}\PYG{p}{,}  \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Nitsche fictitious domain contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}d1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}d2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{gamma0name} \PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{theta}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt1}\PYG{p}{,}\PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nodal contact between nonmatching meshes brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}n}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}fr}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rg1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rg2}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{slave1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{slave2}\PYG{p}{,}  \PYG{n+nb}{int} \PYG{n}{augmented\PYGZus{}version}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add nonmatching meshes contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u1}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}n}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname\PYGZus{}t}\PYG{p}{]}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}fr}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rg1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{rg2}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{slave1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{slave2}\PYG{p}{,}  \PYG{n+nb}{int} \PYG{n}{augmented\PYGZus{}version}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add integral contact between nonmatching meshes brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{multname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}friction\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region2} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{option} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt1} \PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add penalized contact between nonmatching meshes brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{varname\PYGZus{}u2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}coeff}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region1}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region2} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{option} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}lambda}\PYG{p}{,} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}wt2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add integral large sliding contact brick raytracing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{release\PYGZus{}distance}\PYG{p}{,} \PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}fr}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{version}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add rigid obstacle to large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{N}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add master contact boundary to large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{wname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add slave contact boundary to large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lambdaname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{wname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add master slave contact boundary to large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lambdaname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{wname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{ind} \PYG{o}{=} \PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add Nitsche large sliding contact brick raytracing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{bool} \PYG{n}{unbiased\PYGZus{}version}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}r}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{release\PYGZus{}distance}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}fr}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dataname\PYGZus{}alpha}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{version}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add rigid obstacle to Nitsche large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{string} \PYG{n}{expr}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{N}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add master contact boundary to biased Nitsche large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{wname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add slave contact boundary to biased Nitsche large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lambdaname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{wname}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}model\PYGZus{}set}\PYG{p}{(}\PYG{n}{model} \PYG{n}{M}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add contact boundary to unbiased Nitsche large sliding contact brick}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{indbrick}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}im} \PYG{n}{mim}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{region}\PYG{p}{,} \PYG{n}{string} \PYG{n}{dispname}\PYG{p}{,} \PYG{n}{string} \PYG{n}{lambdaname}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{wname}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Modifies a model object.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}clear\textquotesingle{})}}
\begin{quote}

Clear the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add fem variable\textquotesingle{}, string name, mesh\_fem mf)}}
\begin{quote}

Add a variable to the model linked to a mesh\_fem. \sphinxtitleref{name} is the variable
name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add filtered fem variable\textquotesingle{}, string name, mesh\_fem mf, int region)}}
\begin{quote}

Add a variable to the model linked to a mesh\_fem. The variable is filtered
in the sense that only the dof on the region are considered.
\sphinxtitleref{name} is the variable name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add im variable\textquotesingle{}, string name, mesh\_imd mimd)}}
\begin{quote}

Add a variable to the model linked to a mesh\_imd. \sphinxtitleref{name} is the variable
name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add internal im variable\textquotesingle{}, string name, mesh\_imd mimd)}}
\begin{quote}

Add a variable to the model, which is linked to a mesh\_imd and will be
condensed out during the assemblage of the tangent matrix. \sphinxtitleref{name} is
the variable name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add variable\textquotesingle{}, string name, sizes)}}
\begin{quote}

Add a variable to the model of constant sizes. \sphinxtitleref{sizes} is either a
integer (for a scalar or vector variable) or a vector of dimensions
for a tensor variable. \sphinxtitleref{name} is the variable name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}delete variable\textquotesingle{}, string name)}}
\begin{quote}

Delete a variable or a data from the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}resize variable\textquotesingle{}, string name, sizes)}}
\begin{quote}

Resize a  constant size variable of the model.  \sphinxtitleref{sizes} is either a
integer (for a scalar or vector variable) or a vector of dimensions
for a tensor variable. \sphinxtitleref{name} is the variable name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add multiplier\textquotesingle{}, string name, mesh\_fem mf, string primalname{[}, mesh\_im mim, int region{]})}}
\begin{quote}

Add a particular variable linked to a fem being a multiplier with
respect to a primal variable. The dof will be filtered with the
\sphinxcode{\sphinxupquote{gmm::range\_basis}} function applied on the terms of the model
which link the multiplier and the primal variable. This in order to
retain only linearly independent constraints on the primal variable.
Optimized for boundary multipliers.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add im data\textquotesingle{}, string name, mesh\_imd mimd)}}
\begin{quote}

Add a data set to the model linked to a mesh\_imd. \sphinxtitleref{name} is the data
name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add fem data\textquotesingle{}, string name, mesh\_fem mf{[}, sizes{]})}}
\begin{quote}

Add a data to the model linked to a mesh\_fem. \sphinxtitleref{name} is the data name,
\sphinxtitleref{sizes} an optional parameter which is either an
integer  or a vector of suplementary dimensions with respect to \sphinxtitleref{mf}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add initialized fem data\textquotesingle{}, string name, mesh\_fem mf, vec V{[}, sizes{]})}}
\begin{quote}

Add a data to the model linked to a mesh\_fem. \sphinxtitleref{name} is the data name.
The data is initiakized with \sphinxtitleref{V}. The data can be a scalar or vector
field. \sphinxtitleref{sizes} an optional parameter which is either an
integer or a vector of suplementary dimensions with respect to \sphinxtitleref{mf}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add data\textquotesingle{}, string name, int size)}}
\begin{quote}

Add a fixed size data to the model.  \sphinxtitleref{sizes} is either a
integer (for a scalar or vector data) or a vector of dimensions
for a tensor data. \sphinxtitleref{name} is the data name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add macro\textquotesingle{}, string name, string expr)}}
\begin{quote}

Define a new macro for the high generic assembly language.
The name include the parameters. For instance name=’sp(a,b)’, expr=’a.b’
is a valid definition. Macro without parameter can also be defined.
For instance name=’x1’, expr=’X{[}1{]}’ is valid. The form name=’grad(u)’,
expr=’Grad\_u’ is also allowed but in that case, the parameter ‘u’ will
only be allowed to be a variable name when using the macro. Note that
macros can be directly defined inside the assembly strings with the
keyword ‘Def’.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}del macro\textquotesingle{}, string name)}}
\begin{quote}

Delete a previously defined macro for the high generic assembly language.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add initialized data\textquotesingle{}, string name, vec V{[}, sizes{]})}}
\begin{quote}

Add an initialized fixed size data to the model. \sphinxtitleref{sizes} an
optional parameter which is either an
integer  or a vector dimensions that describes the format of the
data. By default, the data is considered to b a vector field.
\sphinxtitleref{name} is the data name and \sphinxtitleref{V} is the value of the data.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}variable\textquotesingle{}, string name, vec V)}}
\begin{quote}

Set the value of a variable or data. \sphinxtitleref{name} is the data name.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}to variables\textquotesingle{}, vec V)}}
\begin{quote}

Set the value of the variables of the model with the vector \sphinxtitleref{V}.
Typically, the vector \sphinxtitleref{V} results of the solve of the tangent
linear system (useful to solve your problem with you own solver).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}delete brick\textquotesingle{}, int ind\_brick)}}
\begin{quote}

Delete a variable or a data from the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}define variable group\textquotesingle{}, string name{[}, string varname, ...{]})}}
\begin{quote}

Defines a group of variables for the interpolation (mainly for the
raytracing interpolation transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add elementary rotated RT0 projection\textquotesingle{}, string transname)}}
\begin{quote}

Add the elementary transformation corresponding to the projection
on rotated RT0 element for two\sphinxhyphen{}dimensional elements to the model.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add elementary P0 projection\textquotesingle{}, string transname)}}
\begin{quote}

Add the elementary transformation corresponding to the projection
P0 element.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add HHO reconstructed gradient\textquotesingle{}, string transname)}}
\begin{quote}

Add to the model the elementary transformation corresponding to the
reconstruction of a gradient for HHO methods.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add HHO reconstructed symmetrized gradient\textquotesingle{}, string transname)}}
\begin{quote}

Add to the model the elementary transformation corresponding to the
reconstruction of a symmetrized gradient for HHO methods.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add HHO reconstructed value\textquotesingle{}, string transname)}}
\begin{quote}

Add to the model the elementary transformation corresponding to the
reconstruction of the variable for HHO methods.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add HHO reconstructed symmetrized value\textquotesingle{}, string transname)}}
\begin{quote}

Add to the model the elementary transformation corresponding to the
reconstruction of the variable for HHO methods using a symmetrized
gradient.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add HHO stabilization\textquotesingle{}, string transname)}}
\begin{quote}

Add to the model the elementary transformation corresponding to the
HHO stabilization operator.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add HHO symmetrized stabilization\textquotesingle{}, string transname)}}
\begin{quote}

Add to the model the elementary transformation corresponding to the
HHO stabilization operator using a symmetrized gradient.
The name is the name given to the elementary transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add interpolate transformation from expression\textquotesingle{}, string transname, mesh source\_mesh, mesh target\_mesh, string expr)}}
\begin{quote}

Add a transformation to the model from mesh \sphinxtitleref{source\_mesh} to mesh
\sphinxtitleref{target\_mesh} given by the expression \sphinxtitleref{expr} which corresponds to a
high\sphinxhyphen{}level generic assembly expression which may contains some
variable of the model. CAUTION: the derivative of the
transformation with used variable is taken into account in the
computation of the tangen system. However, order two derivative is not
implemented, so such tranformation is not allowed in the definition
of a potential.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add element extrapolation transformation\textquotesingle{}, string transname, mesh source\_mesh, mat elt\_corr)}}
\begin{quote}

Add a special interpolation transformation which represents the identity
transformation but allows to evaluate the expression on another element
than the current element by polynomial extrapolation. It is used for
stabilization term in fictitious domain applications. the array elt\_cor
should be a two entry array whose first line contains the elements
concerned by the transformation and the second line the respective
elements on which the extrapolation has to be made. If an element
is not listed in elt\_cor the evaluation is just made on the current
element.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add standard secondary domain\textquotesingle{}, string name, mesh\_im mim, int region = \sphinxhyphen{}1)}}
\begin{quote}

Add a secondary domain to the model which can be used in a weak\sphinxhyphen{}form language expression for integration on the product of two domains. \sphinxtitleref{name} is the name
of the secondary domain, \sphinxtitleref{mim} is an integration method on this domain
and \sphinxtitleref{region} the region on which the integration is to be performed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}set element extrapolation correspondence\textquotesingle{}, string transname, mat elt\_corr)}}
\begin{quote}

Change the correspondence map of an element extrapolation interpolate
transformation.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add raytracing transformation\textquotesingle{}, string transname, scalar release\_distance)}}
\begin{quote}

Add a raytracing interpolate transformation called \sphinxtitleref{transname} to a model
to be used by the generic assembly bricks.
CAUTION: For the moment, the derivative of the
transformation is not taken into account in the model solve.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add master contact boundary to raytracing transformation\textquotesingle{}, string transname, mesh m, string dispname, int region)}}
\begin{quote}

Add a master contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing raytracing
interpolate transformation called \sphinxtitleref{transname}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add slave contact boundary to raytracing transformation\textquotesingle{}, string transname, mesh m, string dispname, int region)}}
\begin{quote}

Add a slave contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing raytracing
interpolate transformation called \sphinxtitleref{transname}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add rigid obstacle to raytracing transformation\textquotesingle{}, string transname, string expr, int N)}}
\begin{quote}

Add a rigid obstacle whose geometry corresponds to the zero level\sphinxhyphen{}set
of the high\sphinxhyphen{}level generic assembly expression \sphinxtitleref{expr}
to an existing raytracing interpolate transformation called \sphinxtitleref{transname}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add projection transformation\textquotesingle{}, string transname, scalar release\_distance)}}
\begin{quote}

Add a projection interpolate transformation called \sphinxtitleref{transname} to a model
to be used by the generic assembly bricks.
CAUTION: For the moment, the derivative of the
transformation is not taken into account in the model solve.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add master contact boundary to projection transformation\textquotesingle{}, string transname, mesh m, string dispname, int region)}}
\begin{quote}

Add a master contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing projection
interpolate transformation called \sphinxtitleref{transname}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add slave contact boundary to projection transformation\textquotesingle{}, string transname, mesh m, string dispname, int region)}}
\begin{quote}

Add a slave contact boundary with corresponding displacement variable
\sphinxtitleref{dispname} on a specific boundary \sphinxtitleref{region} to an existing projection
interpolate transformation called \sphinxtitleref{transname}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add rigid obstacle to projection transformation\textquotesingle{}, string transname, string expr, int N)}}
\begin{quote}

Add a rigid obstacle whose geometry corresponds to the zero level\sphinxhyphen{}set
of the high\sphinxhyphen{}level generic assembly expression \sphinxtitleref{expr}
to an existing projection interpolate transformation called \sphinxtitleref{transname}.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add linear term\textquotesingle{}, mesh\_im mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})}}
\begin{quote}

Adds a matrix term given by the assembly string \sphinxtitleref{expr} which will
be assembled in region \sphinxtitleref{region} and with the integration method \sphinxtitleref{mim}.
Only the matrix term will be taken into account, assuming that it is
linear.
The advantage of declaring a term linear instead of nonlinear is that
it will be assembled only once and no assembly is necessary for the
residual.
Take care that if the expression contains some variables and if the
expression is a potential or of first order (i.e. describe the weak
form, not the derivative of the weak form), the expression will be
derivated with respect to all variables.
You can specify if the term is symmetric, coercive or not.
If you are not sure, the better is to declare the term not symmetric
and not coercive. But some solvers (conjugate gradient for instance)
are not allowed for non\sphinxhyphen{}coercive problems.
\sphinxtitleref{brickname} is an optional name for the brick.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add linear twodomain term\textquotesingle{}, mesh\_im mim, string expression, int region, string secondary\_domain{[}, int is\_symmetric{[}, int is\_coercive{]}{]})}}
\begin{quote}

Adds a linear term given by a weak form language expression like
gf\_model\_set(model M, ‘add linear term’) but for an integration on a direct
product of two domains, a first specfied by \sphinxcode{\sphinxupquote{mim}} and \sphinxcode{\sphinxupquote{region}}
and a second one by \sphinxcode{\sphinxupquote{secondary\_domain}} which has to be declared
first into the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add linear generic assembly brick\textquotesingle{}, mesh\_im mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})}}
\begin{quote}

Deprecated. Use gf\_model\_set(model M, ‘add linear term’) instead.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nonlinear term\textquotesingle{}, mesh\_im mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})}}
\begin{quote}

Adds a nonlinear term given by the assembly string \sphinxtitleref{expr} which will
be assembled in region \sphinxtitleref{region} and with the integration method \sphinxtitleref{mim}.
The expression can describe a potential or a weak form. Second order
terms (i.e. containing second order test functions, Test2) are not
allowed.
You can specify if the term is symmetric, coercive or not.
If you are not sure, the better is to declare the term not symmetric
and not coercive. But some solvers (conjugate gradient for instance)
are not allowed for non\sphinxhyphen{}coercive problems.
\sphinxtitleref{brickname} is an optional name for the brick.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nonlinear twodomain term\textquotesingle{}, mesh\_im mim, string expression, int region, string secondary\_domain{[}, int is\_symmetric{[}, int is\_coercive{]}{]})}}
\begin{quote}

Adds a nonlinear term given by a weak form language expression like
gf\_model\_set(model M, ‘add nonlinear term’) but for an integration on a direct
product of two domains, a first specfied by \sphinxcode{\sphinxupquote{mim}} and \sphinxcode{\sphinxupquote{region}}
and a second one by \sphinxcode{\sphinxupquote{secondary\_domain}} which has to be declared
first into the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nonlinear generic assembly brick\textquotesingle{}, mesh\_im mim, string expression{[}, int region{[}, int is\_symmetric{[}, int is\_coercive{]}{]}{]})}}
\begin{quote}

Deprecated. Use gf\_model\_set(model M, ‘add nonlinear term’) instead.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add source term\textquotesingle{}, mesh\_im mim, string expression{[}, int region{]})}}
\begin{quote}

Adds a source term given by the assembly string \sphinxtitleref{expr} which will
be assembled in region \sphinxtitleref{region} and with the integration method \sphinxtitleref{mim}.
Only the residual term will be taken into account.
Take care that if the expression contains some variables and if the
expression is a potential, the expression will be
derivated with respect to all variables.
\sphinxtitleref{brickname} is an optional name for the brick.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add twodomain source term\textquotesingle{}, mesh\_im mim, string expression, int region, string secondary\_domain)}}
\begin{quote}

Adds a source term given by a weak form language expression like
gf\_model\_set(model M, ‘add source term’) but for an integration on a direct
product of two domains, a first specfied by \sphinxcode{\sphinxupquote{mim}} and \sphinxcode{\sphinxupquote{region}}
and a second one by \sphinxcode{\sphinxupquote{secondary\_domain}} which has to be declared
first into the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add source term generic assembly brick\textquotesingle{}, mesh\_im mim, string expression{[}, int region{]})}}
\begin{quote}

Deprecated. Use gf\_model\_set(model M, ‘add source term’) instead.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add assembly assignment\textquotesingle{}, string dataname, string expression{[}, int region{[}, int order{[}, int before{]}{]}{]})}}
\begin{quote}

Adds expression \sphinxtitleref{expr} to be evaluated at assembly time and being
assigned to the data \sphinxtitleref{dataname} which has to be of im\_data type.
This allows for instance to store a sub\sphinxhyphen{}expression of an assembly
computation to be used on an other assembly. It can be used for instance
to store the plastic strain in plasticity models.
\sphinxtitleref{order} represents the order of assembly where this assignement has to be
done (potential(0), weak form(1) or tangent system(2) or at each
order(\sphinxhyphen{}1)). The default value is 1.
If before = 1, the the assignement is perfromed before the computation
of the other assembly terms, such that the data can be used in the
remaining of the assembly as an intermediary result (be careful that it is
still considered as a data, no derivation of the expression is performed
for the tangent system).
If before = 0 (default), the assignement is done after the assembly terms.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}clear assembly assignment\textquotesingle{})}}
\begin{quote}

Delete all added assembly assignments
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Laplacian brick\textquotesingle{}, mesh\_im mim, string varname{[}, int region{]})}}
\begin{quote}

Add a Laplacian term to the model relatively to the variable \sphinxtitleref{varname}
(in fact with a minus : \(-\text{div}(\nabla u)\)).
If this is a vector valued variable, the Laplacian term is added
componentwise. \sphinxtitleref{region} is an optional mesh region on which the term
is added. If it is not specified, it is added on the whole mesh. Return
the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add generic elliptic brick\textquotesingle{}, mesh\_im mim, string varname, string dataname{[}, int region{]})}}
\begin{quote}

Add a generic elliptic term to the model relatively to the variable \sphinxtitleref{varname}.
The shape of the elliptic term depends both on the variable and the data.
This corresponds to a term
\(-\text{div}(a\nabla u)\)
where \(a\) is the data and \(u\) the variable. The data can be
a scalar,
a matrix or an order four tensor. The variable can be vector valued or
not. If the data is a scalar or a matrix and the variable is vector
valued then the term is added componentwise. An order four tensor data
is allowed for vector valued variable only. The data can be constant or
describbed on a fem. Of course, when the data is a tensor describe on a
finite element method (a tensor field) the data can be a huge vector.
The components of the matrix/tensor have to be stored with the fortran
order (columnwise) in the data vector (compatibility with blas). The
symmetry of the given matrix/tensor is not verified (but assumed). If
this is a vector valued variable, the elliptic term is added
componentwise. \sphinxtitleref{region} is an optional mesh region on which the term is
added. If it is not specified, it is added on the whole mesh. Note that
for the real
version which uses the high\sphinxhyphen{}level generic assembly language, \sphinxtitleref{dataname}
can be any regular expression of the high\sphinxhyphen{}level generic assembly
language (like “1”, “sin(X(1))” or “Norm(u)” for instance) even
depending on model variables. Return the
brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add source term brick\textquotesingle{}, mesh\_im mim, string varname, string dataexpr{[}, int region{[}, string directdataname{]}{]})}}
\begin{quote}

Add a source term to the model relatively to the variable \sphinxtitleref{varname}.
The source term is
represented by \sphinxtitleref{dataexpr} which could be any regular expression of the
high\sphinxhyphen{}level generic assembly language (except for the complex version
where it has to be a declared data of the model).
\sphinxtitleref{region} is an optional mesh region
on which the term is added. An additional optional data \sphinxtitleref{directdataname}
can be provided. The corresponding data vector will be directly added
to the right hand side without assembly. Note that when region is a
boundary, this brick allows to prescribe a nonzero Neumann boundary
condition. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add normal source term brick\textquotesingle{}, mesh\_im mim, string varname, string dataname, int region)}}
\begin{quote}

Add a source term on the variable \sphinxtitleref{varname} on a boundary \sphinxtitleref{region}.
This region should be a boundary. The source term is
represented by the data \sphinxtitleref{dataepxpr} which could be any regular
expression of the high\sphinxhyphen{}level generic assembly language (except
for the complex version where it has to be a declared data of
the model). A scalar
product with the outward normal unit vector to the boundary is performed.
The main aim of this brick is to represent a Neumann condition with a
vector data without performing the scalar product with the normal as a
pre\sphinxhyphen{}processing. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Dirichlet condition with simplification\textquotesingle{}, string varname, int region{[}, string dataname{]})}}
\begin{quote}

Adds a (simple) Dirichlet condition on the variable \sphinxtitleref{varname} and
the mesh region \sphinxtitleref{region}. The Dirichlet condition is prescribed by
a simple post\sphinxhyphen{}treatment of the final linear system (tangent system
for nonlinear problems) consisting of modifying the lines corresponding
to the degree of freedom of the variable on \sphinxtitleref{region} (0 outside the
diagonal, 1 on the diagonal of the matrix and the expected value on
the right hand side).
The symmetry of the linear system is kept if all other bricks are
symmetric.
This brick is to be reserved for simple Dirichlet conditions (only dof
declared on the corresponding boundary are prescribed). The application
of this brick on reduced dof may be problematic. Intrinsic vectorial
finite element method are not supported.
\sphinxtitleref{dataname} is the optional right hand side of  the Dirichlet condition.
It could be constant (but in that case, it can only be applied to
Lagrange f.e.m.) or (important) described on the same finite
element method as \sphinxtitleref{varname}.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Dirichlet condition with multipliers\textquotesingle{}, mesh\_im mim, string varname, mult\_description, int region{[}, string dataname{]})}}
\begin{quote}

Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with a multiplier variable described by
\sphinxtitleref{mult\_description}. If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is the optional right hand side of  the
Dirichlet condition. It could be constant or described on a fem; scalar
or vector valued, depending on the variable on which the Dirichlet
condition is prescribed. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Dirichlet condition with Nitsche method\textquotesingle{}, mesh\_im mim, string varname, string Neumannterm, string datagamma0, int region{[}, scalar theta{]}{[}, string dataname{]})}}
\begin{quote}

Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. \sphinxtitleref{Neumannterm}
is the expression of the Neumann term (obtained by the Green formula)
described as an expression of the high\sphinxhyphen{}level
generic assembly language. This term can be obtained by
gf\_model\_get(model M, ‘Neumann term’, varname, region) once all volumic bricks have
been added to the model. The Dirichlet
condition is prescribed with Nitsche’s method. \sphinxtitleref{datag} is the optional
right hand side of the Dirichlet condition. \sphinxtitleref{datagamma0} is the
Nitsche’s method parameter. \sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} (default) is the simplest method
for which the second derivative of the Neumann term is not necessary
even for nonlinear problems. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Dirichlet condition with penalization\textquotesingle{}, mesh\_im mim, string varname, scalar coeff, int region{[}, string dataname, mesh\_fem mf\_mult{]})}}
\begin{quote}

Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with penalization. The penalization coefficient
is initially \sphinxtitleref{coeff} and will be added to the data of the model.
\sphinxtitleref{dataname} is the optional right hand side of the Dirichlet condition.
It could be constant or described on a fem; scalar or vector valued,
depending on the variable on which the Dirichlet condition is prescribed.
\sphinxtitleref{mf\_mult} is an optional parameter which allows to weaken the
Dirichlet condition specifying a multiplier space.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add normal Dirichlet condition with multipliers\textquotesingle{}, mesh\_im mim, string varname, mult\_description, int region{[}, string dataname{]})}}
\begin{quote}

Add a Dirichlet condition to the normal component of the vector
(or tensor) valued variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with a multiplier variable described by
\sphinxtitleref{mult\_description}. If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is the optional right hand side of  the
Dirichlet condition. It could be constant or described on a fem; scalar
or vector valued, depending on the variable on which the Dirichlet
condition is prescribed (scalar if the variable
is vector valued, vector if the variable is tensor valued).
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add normal Dirichlet condition with penalization\textquotesingle{}, mesh\_im mim, string varname, scalar coeff, int region{[}, string dataname, mesh\_fem mf\_mult{]})}}
\begin{quote}

Add a Dirichlet condition to the normal component of the vector
(or tensor) valued variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This region should be a boundary. The Dirichlet
condition is prescribed with penalization. The penalization coefficient
is initially \sphinxtitleref{coeff} and will be added to the data of the model.
\sphinxtitleref{dataname} is the optional right hand side of the Dirichlet condition.
It could be constant or described on a fem; scalar or vector valued,
depending on the variable on which the Dirichlet condition is prescribed
(scalar if the variable
is vector valued, vector if the variable is tensor valued).
\sphinxtitleref{mf\_mult} is an optional parameter which allows to weaken the
Dirichlet condition specifying a multiplier space.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add normal Dirichlet condition with Nitsche method\textquotesingle{}, mesh\_im mim, string varname, string Neumannterm, string gamma0name, int region{[}, scalar theta{]}{[}, string dataname{]})}}
\begin{quote}

Add a Dirichlet condition to the normal component of the vector
(or tensor) valued variable \sphinxtitleref{varname} and the mesh region \sphinxtitleref{region}.
This region should be a boundary. \sphinxtitleref{Neumannterm}
is the expression of the Neumann term (obtained by the Green formula)
described as an expression of the high\sphinxhyphen{}level
generic assembly language. This term can be obtained by
gf\_model\_get(model M, ‘Neumann term’, varname, region) once all volumic bricks have
been added to the model. The Dirichlet
condition is prescribed with Nitsche’s method. \sphinxtitleref{dataname} is the optional
right hand side of the Dirichlet condition. It could be constant or
described on a fem. \sphinxtitleref{gamma0name} is the
Nitsche’s method parameter. \sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary
even for nonlinear problems.
Returns the brick index in the model.
(This brick is not fully tested)
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add generalized Dirichlet condition with multipliers\textquotesingle{}, mesh\_im mim, string varname, mult\_description, int region, string dataname, string Hname)}}
\begin{quote}

Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}.  This version is for vector field.
It prescribes a condition \(Hu = r\)
where \sphinxtitleref{H} is a matrix field. The region should be a boundary. The Dirichlet
condition is prescribed with a multiplier variable described by
\sphinxtitleref{mult\_description}. If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is the right hand side of  the
Dirichlet condition. It could be constant or described on a fem; scalar
or vector valued, depending on the variable on which the Dirichlet
condition is prescribed. \sphinxtitleref{Hname} is the data
corresponding to the matrix field \sphinxtitleref{H}.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add generalized Dirichlet condition with penalization\textquotesingle{}, mesh\_im mim, string varname, scalar coeff, int region, string dataname, string Hname{[}, mesh\_fem mf\_mult{]})}}
\begin{quote}

Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}. This version is for vector field.
It prescribes a condition \(Hu = r\)
where \sphinxtitleref{H} is a matrix field.
The region should be a boundary. The Dirichlet
condition is prescribed with penalization. The penalization coefficient
is intially \sphinxtitleref{coeff} and will be added to the data of the model.
\sphinxtitleref{dataname} is the right hand side of the Dirichlet condition.
It could be constant or described on a fem; scalar or vector valued,
depending on the variable on which the Dirichlet condition is prescribed.
\sphinxtitleref{Hname} is the data
corresponding to the matrix field \sphinxtitleref{H}. It has to be a constant matrix
or described on a scalar fem.
\sphinxtitleref{mf\_mult} is an optional parameter which allows to weaken the
Dirichlet condition specifying a multiplier space.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add generalized Dirichlet condition with Nitsche method\textquotesingle{}, mesh\_im mim, string varname, string Neumannterm, string gamma0name, int region{[}, scalar theta{]}, string dataname, string Hname)}}
\begin{quote}

Add a Dirichlet condition on the variable \sphinxtitleref{varname} and the mesh
region \sphinxtitleref{region}.
This version is for vector field. It prescribes a condition
@f\$ Hu = r @f\$ where \sphinxtitleref{H} is a matrix field.
CAUTION : the matrix H should have all eigenvalues equal to 1 or 0.
The region should be a boundary.   \sphinxtitleref{Neumannterm}
is the expression of the Neumann term (obtained by the Green formula)
described as an expression of the high\sphinxhyphen{}level
generic assembly language. This term can be obtained by
gf\_model\_get(model M, ‘Neumann term’, varname, region) once all volumic bricks have
been added to the model.  The Dirichlet
condition is prescribed with Nitsche’s method. \sphinxtitleref{dataname} is the optional
right hand side of the Dirichlet condition. It could be constant or
described on a fem. \sphinxtitleref{gamma0name} is the
Nitsche’s method parameter. \sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary
even for nonlinear problems. \sphinxtitleref{Hname} is the data
corresponding to the matrix field \sphinxtitleref{H}. It has to be a constant matrix
or described on a scalar fem. Returns the brick index in the model.
(This brick is not fully tested)
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add pointwise constraints with multipliers\textquotesingle{}, string varname, string dataname\_pt{[}, string dataname\_unitv{]} {[}, string dataname\_val{]})}}
\begin{quote}

Add some pointwise constraints on the variable \sphinxtitleref{varname} using
multiplier. The multiplier variable is automatically added to the model.
The conditions are prescribed on a set of points given in the data
\sphinxtitleref{dataname\_pt} whose dimension is the number of points times the dimension
of the mesh.
If the variable represents a vector field, one has to give the data
\sphinxtitleref{dataname\_unitv} which represents a vector of dimension the number of
points times the dimension of the vector field which should store some
unit vectors. In that case the prescribed constraint is the scalar
product of the variable at the corresponding point with the corresponding
unit vector.
The optional data \sphinxtitleref{dataname\_val} is the vector of values to be prescribed
at the different points.
This brick is specifically designed to kill rigid displacement
in a Neumann problem.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add pointwise constraints with given multipliers\textquotesingle{}, string varname, string multname, string dataname\_pt{[}, string dataname\_unitv{]} {[}, string dataname\_val{]})}}
\begin{quote}

Add some pointwise constraints on the variable \sphinxtitleref{varname} using a given
multiplier \sphinxtitleref{multname}.
The conditions are prescribed on a set of points given in the data
\sphinxtitleref{dataname\_pt} whose dimension is the number of points times the dimension
of the mesh.
The multiplier variable should be a fixed size variable of size the
number of points.
If the variable represents a vector field, one has to give the data
\sphinxtitleref{dataname\_unitv} which represents a vector of dimension the number of
points times the dimension of the vector field which should store some
unit vectors. In that case the prescribed constraint is the scalar
product of the variable at the corresponding point with the corresponding
unit vector.
The optional data \sphinxtitleref{dataname\_val} is the vector of values to be prescribed
at the different points.
This brick is specifically designed to kill rigid displacement
in a Neumann problem.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add pointwise constraints with penalization\textquotesingle{}, string varname, scalar coeff, string dataname\_pt{[}, string dataname\_unitv{]} {[}, string dataname\_val{]})}}
\begin{quote}

Add some pointwise constraints on the variable \sphinxtitleref{varname} thanks to
a penalization. The penalization coefficient is initially
\sphinxtitleref{penalization\_coeff} and will be added to the data of the model.
The conditions are prescribed on a set of points given in the data
\sphinxtitleref{dataname\_pt} whose dimension is the number of points times the dimension
of the mesh.
If the variable represents a vector field, one has to give the data
\sphinxtitleref{dataname\_unitv} which represents a vector of dimension the number of
points times the dimension of the vector field which should store some
unit vectors. In that case the prescribed constraint is the scalar
product of the variable at the corresponding point with the corresponding
unit vector.
The optional data \sphinxtitleref{dataname\_val} is the vector of values to be prescribed
at the different points.
This brick is specifically designed to kill rigid displacement
in a Neumann problem.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}change penalization coeff\textquotesingle{}, int ind\_brick, scalar coeff)}}
\begin{quote}

Change the penalization coefficient of a Dirichlet condition with
penalization brick. If the brick is not of this kind, this
function has an undefined behavior.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Helmholtz brick\textquotesingle{}, mesh\_im mim, string varname, string dataexpr{[}, int region{]})}}
\begin{quote}

Add a Helmholtz term to the model relatively to the variable \sphinxtitleref{varname}.
\sphinxtitleref{dataexpr} is the wave number. \sphinxtitleref{region} is an optional mesh
region on which the term is added. If it is not specified, it is added
on the whole mesh. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Fourier Robin brick\textquotesingle{}, mesh\_im mim, string varname, string dataexpr, int region)}}
\begin{quote}

Add a Fourier\sphinxhyphen{}Robin term to the model relatively to the variable
\sphinxtitleref{varname}. This corresponds to a weak term of the form
\(\int (qu).v\). \sphinxtitleref{dataexpr} is the parameter \(q\) of
the Fourier\sphinxhyphen{}Robin condition.  It can be an arbitrary valid expression
of the high\sphinxhyphen{}level generic assembly language (except for the complex version
for which it should be a data of the model). \sphinxtitleref{region} is the mesh region
on which the term is added. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add constraint with multipliers\textquotesingle{}, string varname, string multname, spmat B, \{vec L | string dataname\})}}
\begin{quote}

Add an additional explicit constraint on the variable \sphinxtitleref{varname} thank to
a multiplier \sphinxtitleref{multname} peviously added to the model (should be a fixed
size variable). The constraint is \(BU=L\)
with \sphinxtitleref{B} being a rectangular sparse matrix. It is possible to change
the constraint at any time with the methods gf\_model\_set(model M, ‘set private matrix’)
and gf\_model\_set(model M, ‘set private rhs’). If \sphinxtitleref{dataname} is specified instead of \sphinxtitleref{L},
the vector \sphinxtitleref{L} is defined in the model as data with the given name.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add constraint with penalization\textquotesingle{}, string varname, scalar coeff, spmat B, \{vec L | string dataname\})}}
\begin{quote}

Add an additional explicit penalized constraint on the variable \sphinxtitleref{varname}.
The constraint is :math\textasciigrave{}BU=L\textasciigrave{} with \sphinxtitleref{B} being a rectangular sparse matrix.
Be aware that \sphinxtitleref{B} should not contain a plain row, otherwise the whole
tangent matrix will be plain. It is possible to change the constraint
at any time with the methods gf\_model\_set(model M, ‘set private matrix’)
and gf\_model\_set(model M, ‘set private rhs’). The method
gf\_model\_set(model M, ‘change penalization coeff’) can be used.
If \sphinxtitleref{dataname} is specified instead of \sphinxtitleref{L}, the vector \sphinxtitleref{L} is defined
in the model as data with the given name.
Return the brick
index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add explicit matrix\textquotesingle{}, string varname1, string varname2, spmat B{[}, int issymmetric{[}, int iscoercive{]}{]})}}
\begin{quote}

Add a brick representing an explicit matrix to be added to the tangent
linear system relatively to the variables \sphinxtitleref{varname1} and \sphinxtitleref{varname2}.
The given matrix should have has many rows as the dimension of
\sphinxtitleref{varname1} and as many columns as the dimension of \sphinxtitleref{varname2}.
If the two variables are different and if \sphinxtitleref{issymmetric} is set to 1
then the transpose of the matrix is also added to the tangent system
(default is 0). Set \sphinxtitleref{iscoercive} to 1 if the term does not affect the
coercivity of the tangent system (default is 0). The matrix can be
changed by the command gf\_model\_set(model M, ‘set private matrix’). Return the
brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add explicit rhs\textquotesingle{}, string varname, vec L)}}
\begin{quote}

Add a brick representing an explicit right hand side to be added to
the right hand side of the tangent linear system relatively to the
variable \sphinxtitleref{varname}. The given rhs should have the same size than the
dimension of \sphinxtitleref{varname}. The rhs can be changed by the command
gf\_model\_set(model M, ‘set private rhs’). If \sphinxtitleref{dataname} is specified instead of
\sphinxtitleref{L}, the vector \sphinxtitleref{L} is defined in the model as data with the given name.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}set private matrix\textquotesingle{}, int indbrick, spmat B)}}
\begin{quote}

For some specific bricks having an internal sparse matrix
(explicit bricks: ‘constraint brick’ and ‘explicit matrix brick’),
set this matrix.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}set private rhs\textquotesingle{}, int indbrick, vec B)}}
\begin{quote}

For some specific bricks having an internal right hand side vector
(explicit bricks: ‘constraint brick’ and ‘explicit rhs brick’),
set this rhs.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add isotropic linearized elasticity brick\textquotesingle{}, mesh\_im mim, string varname, string dataname\_lambda, string dataname\_mu{[}, int region{]})}}
\begin{quote}

Add an isotropic linearized elasticity term to the model relatively to
the variable \sphinxtitleref{varname}. \sphinxtitleref{dataname\_lambda} and \sphinxtitleref{dataname\_mu} should
contain the Lame coefficients. \sphinxtitleref{region} is an optional mesh region
on which the term is added. If it is not specified, it is added
on the whole mesh. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add isotropic linearized elasticity brick pstrain\textquotesingle{}, mesh\_im mim, string varname, string data\_E, string data\_nu{[}, int region{]})}}
\begin{quote}

Add an isotropic linearized elasticity term to the model relatively to
the variable \sphinxtitleref{varname}. \sphinxtitleref{data\_E} and \sphinxtitleref{data\_nu} should
contain the Young modulus and Poisson ratio, respectively.
\sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added
on the whole mesh.
On two\sphinxhyphen{}dimensional meshes, the term will correpsond to a plain strain
approximation. On three\sphinxhyphen{}dimensional meshes, it will correspond to the
standard model.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add isotropic linearized elasticity brick pstress\textquotesingle{}, mesh\_im mim, string varname, string data\_E, string data\_nu{[}, int region{]})}}
\begin{quote}

Add an isotropic linearized elasticity term to the model relatively to
the variable \sphinxtitleref{varname}. \sphinxtitleref{data\_E} and \sphinxtitleref{data\_nu} should
contain the Young modulus and Poisson ratio, respectively.
\sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added
on the whole mesh.
On two\sphinxhyphen{}dimensional meshes, the term will correpsond to a plain stress
approximation. On three\sphinxhyphen{}dimensional meshes, it will correspond to the
standard model.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add linear incompressibility brick\textquotesingle{}, mesh\_im mim, string varname, string multname\_pressure{[}, int region{[}, string dataexpr\_coeff{]}{]})}}
\begin{quote}

Add a linear incompressibility condition on \sphinxtitleref{variable}. \sphinxtitleref{multname\_pressure}
is a variable which represent the pressure. Be aware that an inf\sphinxhyphen{}sup
condition between the finite element method describing the pressure and the
primal variable has to be satisfied. \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it is added on the whole
mesh. \sphinxtitleref{dataexpr\_coeff} is an optional penalization coefficient for nearly
incompressible elasticity for instance. In this case, it is the inverse
of the Lame coefficient \(\lambda\). Return the brick index in the
model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nonlinear elasticity brick\textquotesingle{}, mesh\_im mim, string varname, string constitutive\_law, string dataname{[}, int region{]})}}
\begin{quote}

Add a nonlinear elasticity term to the model relatively to the
variable \sphinxtitleref{varname} (deprecated brick, use add\_finite\_strain\_elaticity
instead). \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘neo Hookean’,
‘Ciarlet Geymonat’ or ‘generalized Blatz Ko’.
‘Mooney Rivlin’ and ‘neo Hookean’ law names can be preceded with the word
‘compressible’ or ‘incompressible’ to force using the corresponding version.
The compressible version of these laws requires one additional material
coefficient. By default, the incompressible version of ‘Mooney Rivlin’ law
and the compressible one of the ‘neo Hookean’ law are considered. In
general, ‘neo Hookean’ is a special case of the ‘Mooney Rivlin’ law that
requires one coefficient less.
IMPORTANT : if the variable is defined on a 2D mesh, the plane strain
approximation is automatically used.
\sphinxtitleref{dataname} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable
coefficients. \sphinxtitleref{region} is an optional mesh region on which the term
is added. If it is not specified, it is added on the whole mesh.
This brick use the low\sphinxhyphen{}level generic assembly.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add finite strain elasticity brick\textquotesingle{}, mesh\_im mim, string constitutive\_law, string varname, string params{[}, int region{]})}}
\begin{quote}

Add a nonlinear elasticity term to the model relatively to the
variable \sphinxtitleref{varname}. \sphinxtitleref{lawname} is the constitutive law which
could be ‘SaintVenant Kirchhoff’, ‘Mooney Rivlin’, ‘Neo Hookean’,
‘Ciarlet Geymonat’ or ‘Generalized Blatz Ko’.
‘Mooney Rivlin’ and ‘Neo Hookean’ law names have to be preceeded with
the word ‘Compressible’ or ‘Incompressible’ to force using the
corresponding version.
The compressible version of these laws requires one additional material
coefficient.

IMPORTANT : if the variable is defined on a 2D mesh, the plane strain
approximation is automatically used.
\sphinxtitleref{params} is a vector of parameters for the constitutive law. Its length
depends on the law. It could be a short vector of constant values or a
vector field described on a finite element method for variable
coefficients. \sphinxtitleref{region} is an optional mesh region on which the term
is added. If it is not specified, it is added on the whole mesh.
This brick use the high\sphinxhyphen{}level generic assembly.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add small strain elastoplasticity brick\textquotesingle{}, mesh\_im mim,  string lawname, string unknowns\_type {[}, string varnames, ...{]} {[}, string params, ...{]} {[}, string theta = \textquotesingle{}1\textquotesingle{} {[}, string dt = \textquotesingle{}timestep\textquotesingle{}{]}{]} {[}, int region = \sphinxhyphen{}1{]})}}
\begin{quote}

Adds a small strain plasticity term to the model \sphinxtitleref{M}. This is the
main GetFEM brick for small strain plasticity. \sphinxtitleref{lawname} is the name
of an implemented plastic law, \sphinxtitleref{unknowns\_type} indicates the choice
between a discretization where the plastic multiplier is an unknown of
the problem or (return mapping approach) just a data of the model
stored for the next iteration. Remember that in both cases, a multiplier
is stored anyway. \sphinxtitleref{varnames} is a set of variable and data names with
length which may depend on the plastic law (at least the displacement,
the plastic multiplier and the plastic strain). \sphinxtitleref{params} is a list of
expressions for the parameters (at least elastic coefficients and the
yield stress). These expressions can be some data names (or even
variable names) of the model but can also be any scalar valid expression
of the high level assembly language (such as ‘1/2’, ‘2+sin(X{[}0{]})’,
‘1+Norm(v)’ …). The last two parameters optionally provided in
\sphinxtitleref{params} are the \sphinxtitleref{theta} parameter of the \sphinxtitleref{theta}\sphinxhyphen{}scheme (generalized
trapezoidal rule) used for the plastic strain integration and the
time\sphinxhyphen{}step\textasciigrave{}dt\textasciigrave{}. The default value for \sphinxtitleref{theta} if omitted is 1, which
corresponds to the classical Backward Euler scheme which is first order
consistent. \sphinxtitleref{theta=1/2} corresponds to the Crank\sphinxhyphen{}Nicolson scheme
(trapezoidal rule) which is second order consistent. Any value
between 1/2 and 1 should be a valid value. The default value of \sphinxtitleref{dt} is
‘timestep’ which simply indicates the time step defined in the model
(by md.set\_time\_step(dt)). Alternatively it can be any expression
(data name, constant value …). The time step can be altered from one
iteration to the next one. \sphinxtitleref{region} is a mesh region.

The available plasticity laws are:
\begin{itemize}
\item {} 
‘Prandtl Reuss’ (or ‘isotropic perfect plasticity’).
Isotropic elasto\sphinxhyphen{}plasticity with no hardening. The variables are the
displacement, the plastic multiplier and the plastic strain.
The displacement should be a variable and have a corresponding data
having the same name preceded by ‘Previous\_’ corresponding to the
displacement at the previous time step (typically ‘u’ and ‘Previous\_u’).
The plastic multiplier should also have two versions (typically ‘xi’
and ‘Previous\_xi’) the first one being defined as data if
\sphinxtitleref{unknowns\_type \textasciigrave{} is ‘DISPLACEMENT\_ONLY’ or the integer value 0, or as
a variable if \textasciigrave{}unknowns\_type} is DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER
or the integer value 1.
The plastic strain should represent a n x n data tensor field stored
on mesh\_fem or (preferably) on an im\_data (corresponding to \sphinxtitleref{mim}).
The data are the first Lame coefficient, the second one (shear modulus)
and the uniaxial yield stress. A typical call is
gf\_model\_get(model M, ‘add small strain elastoplasticity brick’, mim, ‘Prandtl Reuss’, 0, ‘u’, ‘xi’, ‘Previous\_Ep’, ‘lambda’, ‘mu’, ‘sigma\_y’, ‘1’, ‘timestep’);
IMPORTANT: Note that this law implements
the 3D expressions. If it is used in 2D, the expressions are just
transposed to the 2D. For the plane strain approximation, see below.

\item {} 
“plane strain Prandtl Reuss”
(or “plane strain isotropic perfect plasticity”)
The same law as the previous one but adapted to the plane strain
approximation. Can only be used in 2D.

\item {} 
“Prandtl Reuss linear hardening”
(or “isotropic plasticity linear hardening”).
Isotropic elasto\sphinxhyphen{}plasticity with linear isotropic and kinematic
hardening. An additional variable compared to “Prandtl Reuss” law:
the accumulated plastic strain. Similarly to the plastic strain, it
is only stored at the end of the time step, so a simple data is
required (preferably on an im\_data).
Two additional parameters: the kinematic hardening modulus and the
isotropic one. 3D expressions only. A typical call is
gf\_model\_get(model M, ‘add small strain elastoplasticity brick’, mim, ‘Prandtl Reuss linear hardening’, 0, ‘u’, ‘xi’, ‘Previous\_Ep’, ‘Previous\_alpha’, ‘lambda’, ‘mu’, ‘sigma\_y’, ‘H\_k’, H\_i’, ‘1’, ‘timestep’);

\item {} 
“plane strain Prandtl Reuss linear hardening”
(or “plane strain isotropic plasticity linear hardening”).
The same law as the previous one but adapted to the plane strain
approximation. Can only be used in 2D.

\end{itemize}

See GetFEM user documentation for further explanations on the
discretization of the plastic flow and on the implemented plastic laws.
See also GetFEM user documentation on time integration strategy
(integration of transient problems).

IMPORTANT : remember that \sphinxtitleref{small\_strain\_elastoplasticity\_next\_iter} has
to be called at the end of each time step, before the next one
(and before any post\sphinxhyphen{}treatment : this sets the value of the plastic
strain and plastic multiplier).
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add elastoplasticity brick\textquotesingle{}, mesh\_im mim ,string projname, string varname, string previous\_dep\_name, string datalambda, string datamu, string datathreshold, string datasigma{[}, int region{]})}}
\begin{quote}

Old (obsolete) brick which do not use the high level generic
assembly. Add a nonlinear elastoplastic term to the model relatively
to the variable \sphinxtitleref{varname}, in small deformations, for an isotropic
material and for a quasistatic model. \sphinxtitleref{projname} is the type of
projection that used: only the Von Mises projection is
available with ‘VM’ or ‘Von Mises’.
\sphinxtitleref{datasigma} is the variable representing the constraints on the material.
\sphinxtitleref{previous\_dep\_name} represents the displacement at the previous time step.
Moreover, the finite element method on which \sphinxtitleref{varname} is described
is an K ordered mesh\_fem, the \sphinxtitleref{datasigma} one have to be at least
an K\sphinxhyphen{}1 ordered mesh\_fem.
\sphinxtitleref{datalambda} and \sphinxtitleref{datamu} are the Lame coefficients of the studied
material.
\sphinxtitleref{datathreshold} is the plasticity threshold of the material.
The three last variables could be constants or described on the
same finite element method.
\sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added on the whole mesh.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add finite strain elastoplasticity brick\textquotesingle{}, mesh\_im mim , string lawname, string unknowns\_type {[}, string varnames, ...{]} {[}, string params, ...{]} {[}, int region = \sphinxhyphen{}1{]})}}
\begin{quote}

Add a finite strain elastoplasticity brick to the model.
For the moment there is only one supported law defined through
\sphinxtitleref{lawname} as “Simo\_Miehe”.
This law supports to possibilities of unknown variables to solve for
defined by means of \sphinxtitleref{unknowns\_type} set to either
‘DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER’ (integer value 1) or
‘DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER\_AND\_PRESSURE’ (integer value 3).
The  “Simo\_Miehe” law expects as \sphinxtitleref{varnames} a set of the
following names that have to be defined as variables in the model:
\begin{itemize}
\item {} 
the displacement variable which has to be defined as an unknown,

\item {} 
the plastic multiplier which has also defined as an unknown,

\item {} 
optionally the pressure variable for a mixed displacement\sphinxhyphen{}pressure
formulation for ‘DISPLACEMENT\_AND\_PLASTIC\_MULTIPLIER\_AND\_PRESSURE’
as \sphinxtitleref{unknowns\_type},

\item {} 
the name of a (scalar) fem\_data or im\_data field that holds the
plastic strain at the previous time step, and

\item {} 
the name of a fem\_data or im\_data field that holds all
non\sphinxhyphen{}repeated components of the inverse of the plastic right
Cauchy\sphinxhyphen{}Green tensor at the previous time step
(it has to be a 4 element vector for plane strain 2D problems
and a 6 element vector for 3D problems).

\end{itemize}

The  “Simo\_Miehe” law also expects as \sphinxtitleref{params} a set of the
following three parameters:
\begin{itemize}
\item {} 
an expression for the initial bulk modulus K,

\item {} 
an expression for the initial shear modulus G,

\item {} 
the name of a user predefined function that decribes
the yield limit as a function of the hardening variable
(both the yield limit and the hardening variable values are
assumed to be Frobenius norms of appropriate stress and strain
tensors, respectively).

\end{itemize}

As usual, \sphinxtitleref{region} is an optional mesh region on which the term is added.
If it is not specified, it is added on the whole mesh.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nonlinear incompressibility brick\textquotesingle{}, mesh\_im mim, string varname, string multname\_pressure{[}, int region{]})}}
\begin{quote}

Add a nonlinear incompressibility condition on \sphinxtitleref{variable} (for large
strain elasticity). \sphinxtitleref{multname\_pressure}
is a variable which represent the pressure. Be aware that an inf\sphinxhyphen{}sup
condition between the finite element method describing the pressure and the
primal variable has to be satisfied. \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it is added on the
whole mesh. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add finite strain incompressibility brick\textquotesingle{}, mesh\_im mim, string varname, string multname\_pressure{[}, int region{]})}}
\begin{quote}

Add a finite strain incompressibility condition on \sphinxtitleref{variable} (for large
strain elasticity). \sphinxtitleref{multname\_pressure}
is a variable which represent the pressure. Be aware that an inf\sphinxhyphen{}sup
condition between the finite element method describing the pressure and the
primal variable has to be satisfied. \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it is added on the
whole mesh. Return the brick index in the model.
This brick is equivalent to the \sphinxcode{\sphinxupquote{nonlinear incompressibility brick}} but
uses the high\sphinxhyphen{}level generic assembly adding the term
\sphinxcode{\sphinxupquote{p*(1\sphinxhyphen{}Det(Id(meshdim)+Grad\_u))}} if \sphinxcode{\sphinxupquote{p}} is the multiplier and
\sphinxcode{\sphinxupquote{u}} the variable which represent the displacement.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add bilaplacian brick\textquotesingle{}, mesh\_im mim, string varname, string dataname {[}, int region{]})}}
\begin{quote}

Add a bilaplacian brick on the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region}.
This represent a term \(\Delta(D \Delta u)\).
where \(D(x)\) is a coefficient determined by \sphinxtitleref{dataname} which
could be constant or described on a f.e.m. The corresponding weak form
is \(\int D(x)\Delta u(x) \Delta v(x) dx\).
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Kirchhoff\sphinxhyphen{}Love plate brick\textquotesingle{}, mesh\_im mim, string varname, string dataname\_D, string dataname\_nu {[}, int region{]})}}
\begin{quote}

Add a bilaplacian brick on the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region}.
This represent a term \(\Delta(D \Delta u)\) where \(D(x)\)
is a the flexion modulus determined by \sphinxtitleref{dataname\_D}. The term is
integrated by part following a Kirchhoff\sphinxhyphen{}Love plate model
with \sphinxtitleref{dataname\_nu} the poisson ratio.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add normal derivative source term brick\textquotesingle{}, mesh\_im mim, string varname, string dataname, int region)}}
\begin{quote}

Add a normal derivative source term brick
\(F = \int b.\partial_n v\) on the variable \sphinxtitleref{varname} and the
mesh region \sphinxtitleref{region}.

Update the right hand side of the linear system.
\sphinxtitleref{dataname} represents \sphinxtitleref{b} and \sphinxtitleref{varname} represents \sphinxtitleref{v}.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Kirchhoff\sphinxhyphen{}Love Neumann term brick\textquotesingle{}, mesh\_im mim, string varname, string dataname\_M, string dataname\_divM, int region)}}
\begin{quote}

Add a Neumann term brick for Kirchhoff\sphinxhyphen{}Love model
on the variable \sphinxtitleref{varname} and the mesh region \sphinxtitleref{region}.
\sphinxtitleref{dataname\_M} represents the bending moment tensor and  \sphinxtitleref{dataname\_divM}
its divergence.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add normal derivative Dirichlet condition with multipliers\textquotesingle{}, mesh\_im mim, string varname, mult\_description, int region {[}, string dataname, int R\_must\_be\_derivated{]})}}
\begin{quote}

Add a Dirichlet condition on the normal derivative of the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region} (which should be a boundary).
The general form is
\(\int \partial_n u(x)v(x) = \int r(x)v(x) \forall v\)
where \(r(x)\) is
the right hand side for the Dirichlet condition (0 for
homogeneous conditions) and \(v\) is in a space of multipliers
defined by \sphinxtitleref{mult\_description}.
If \sphinxtitleref{mult\_description} is a string this is assumed
to be the variable name corresponding to the multiplier (which should be
first declared as a multiplier variable on the mesh region in the model).
If it is a finite element method (mesh\_fem object) then a multiplier
variable will be added to the model and build on this finite element
method (it will be restricted to the mesh region \sphinxtitleref{region} and eventually
some conflicting dofs with some other multiplier variables will be
suppressed). If it is an integer, then a  multiplier variable will be
added to the model and build on a classical finite element of degree
that integer. \sphinxtitleref{dataname} is an optional parameter which represents
the right hand side of the Dirichlet condition.
If \sphinxtitleref{R\_must\_be\_derivated} is set to \sphinxtitleref{true} then the normal
derivative of \sphinxtitleref{dataname} is considered.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add normal derivative Dirichlet condition with penalization\textquotesingle{}, mesh\_im mim, string varname, scalar coeff, int region {[}, string dataname, int R\_must\_be\_derivated{]})}}
\begin{quote}

Add a Dirichlet condition on the normal derivative of the variable
\sphinxtitleref{varname} and on the mesh region \sphinxtitleref{region} (which should be a boundary).
The general form is
\(\int \partial_n u(x)v(x) = \int r(x)v(x) \forall v\)
where \(r(x)\) is
the right hand side for the Dirichlet condition (0 for
homogeneous conditions).
The penalization coefficient
is initially \sphinxtitleref{coeff} and will be added to the data of the model.
It can be changed with the command gf\_model\_set(model M, ‘change penalization coeff’).
\sphinxtitleref{dataname} is an optional parameter which represents
the right hand side of the Dirichlet condition.
If \sphinxtitleref{R\_must\_be\_derivated} is set to \sphinxtitleref{true} then the normal
derivative of \sphinxtitleref{dataname} is considered.
Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Mindlin Reissner plate brick\textquotesingle{}, mesh\_im mim, mesh\_im mim\_reduced, string varname\_u3, string varname\_theta , string param\_E, string param\_nu, string param\_epsilon, string param\_kappa {[},int variant {[}, int region{]}{]})}}
\begin{quote}

Add a term corresponding to the classical Reissner\sphinxhyphen{}Mindlin plate
model for which \sphinxtitleref{varname\_u3} is the transverse displacement,
\sphinxtitleref{varname\_theta} the rotation of
fibers normal to the midplane, ‘param\_E’ the Young Modulus,
\sphinxtitleref{param\_nu} the poisson ratio,
\sphinxtitleref{param\_epsilon} the plate thickness,
\sphinxtitleref{param\_kappa} the shear correction factor. Note that since this brick
uses the high level generic assembly language, the parameter can
be regular expression of this language.
There are three variants.
\sphinxtitleref{variant = 0} corresponds to the an
unreduced formulation and in that case only the integration
method \sphinxtitleref{mim} is used. Practically this variant is not usable since
it is subject to a strong locking phenomenon.
\sphinxtitleref{variant = 1} corresponds to a reduced integration where \sphinxtitleref{mim} is
used for the rotation term and \sphinxtitleref{mim\_reduced} for the transverse
shear term. \sphinxtitleref{variant = 2} (default) corresponds to the projection onto
a rotated RT0 element of the transverse shear term. For the moment, this
is adapted to quadrilateral only (because it is not sufficient to
remove the locking phenomenon on triangle elements). Note also that if
you use high order elements, the projection on RT0 will reduce the order
of the approximation.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add enriched Mindlin Reissner plate brick\textquotesingle{}, mesh\_im mim, mesh\_im mim\_reduced1, mesh\_im mim\_reduced2, string varname\_ua, string varname\_theta,string varname\_u3, string varname\_theta3 , string param\_E, string param\_nu, string param\_epsilon {[},int variant {[}, int region{]}{]})}}
\begin{quote}

Add a term corresponding to the enriched Reissner\sphinxhyphen{}Mindlin plate
model for which \sphinxtitleref{varname\_ua} is the membrane displacements,
\sphinxtitleref{varname\_u3} is the transverse displacement,
\sphinxtitleref{varname\_theta} the rotation of
fibers normal to the midplane,
\sphinxtitleref{varname\_theta3} the pinching,
‘param\_E’ the Young Modulus,
\sphinxtitleref{param\_nu} the poisson ratio,
\sphinxtitleref{param\_epsilon} the plate thickness. Note that since this brick
uses the high level generic assembly language, the parameter can
be regular expression of this language.
There are four variants.
\sphinxtitleref{variant = 0} corresponds to the an
unreduced formulation and in that case only the integration
method \sphinxtitleref{mim} is used. Practically this variant is not usable since
it is subject to a strong locking phenomenon.
\sphinxtitleref{variant = 1} corresponds to a reduced integration where \sphinxtitleref{mim} is
used for the rotation term and \sphinxtitleref{mim\_reduced1} for the transverse
shear term and \sphinxtitleref{mim\_reduced2} for the pinching term.
\sphinxtitleref{variant = 2} (default) corresponds to the projection onto
a rotated RT0 element of the transverse shear term and a reduced integration for the pinching term.
For the moment, this is adapted to quadrilateral only (because it is not sufficient to
remove the locking phenomenon on triangle elements). Note also that if
you use high order elements, the projection on RT0 will reduce the order
of the approximation.
\sphinxtitleref{variant = 3} corresponds to the projection onto
a rotated RT0 element of the transverse shear term and the projection onto P0 element of the pinching term.
For the moment, this is adapted to quadrilateral only (because it is not sufficient to
remove the locking phenomenon on triangle elements). Note also that if
you use high order elements, the projection on RT0 will reduce the order
of the approximation.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add mass brick\textquotesingle{}, mesh\_im mim, string varname{[}, string dataexpr\_rho{[}, int region{]}{]})}}
\begin{quote}

Add mass term to the model relatively to the variable \sphinxtitleref{varname}.
If specified, the data \sphinxtitleref{dataexpr\_rho} is the
density (1 if omitted). \sphinxtitleref{region} is an optional mesh region on
which the term is added. If it is not specified, it
is added on the whole mesh. Return the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}shift variables for time integration\textquotesingle{})}}
\begin{quote}

Function used to shift the variables of a model to the data
corresponding of ther value on the previous time step for time
integration schemes. For each variable for which a time integration
scheme has been declared, the scheme is called to perform the shift.
This function has to be called between two time steps.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}perform init time derivative\textquotesingle{}, scalar ddt)}}
\begin{quote}

By calling this function, indicates that the next solve will compute
the solution for a (very) small time step \sphinxtitleref{ddt} in order to initalize
the data corresponding to the derivatives needed by time integration
schemes (mainly the initial time derivative for order one in time
problems  and the second order time derivative for second order in time
problems). The next solve will not change the value of the variables.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}set time step\textquotesingle{}, scalar dt)}}
\begin{quote}

Set the value of the time step to \sphinxtitleref{dt}. This value can be change
from a step to another for all one\sphinxhyphen{}step schemes (i.e. for the moment
to all proposed time integration schemes).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}set time\textquotesingle{}, scalar t)}}
\begin{quote}

Set the value of the data \sphinxtitleref{t} corresponding to the current time to \sphinxtitleref{t}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add theta method for first order\textquotesingle{}, string varname, scalar theta)}}
\begin{quote}

Attach a theta method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most first order time derivative
of the variable.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add theta method for second order\textquotesingle{}, string varname, scalar theta)}}
\begin{quote}

Attach a theta method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most second order time derivative
of the variable.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add Newmark scheme\textquotesingle{}, string varname, scalar beta, scalar gamma)}}
\begin{quote}

Attach a theta method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most second order time derivative
of the variable.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add\_Houbolt\_scheme\textquotesingle{}, string varname)}}
\begin{quote}

Attach a Houbolt method for the time discretization of the variable
\sphinxtitleref{varname}. Valid only if there is at most second order time derivative
of the variable
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}disable bricks\textquotesingle{}, ivec bricks\_indices)}}
\begin{quote}

Disable a brick (the brick will no longer participate to the
building of the tangent linear system).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}enable bricks\textquotesingle{}, ivec bricks\_indices)}}
\begin{quote}

Enable a disabled brick.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}disable variable\textquotesingle{}, string varname)}}
\begin{quote}

Disable a variable for a solve (and its attached multipliers).
The next solve will operate only on
the remaining variables. This allows to solve separately different
parts of a model. If there is a strong coupling of the variables,
a fixed point strategy can the be used.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}enable variable\textquotesingle{}, string varname)}}
\begin{quote}

Enable a disabled variable (and its attached multipliers).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}first iter\textquotesingle{})}}
\begin{quote}

To be executed before the first iteration of a time integration
scheme.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}next iter\textquotesingle{})}}
\begin{quote}

To be executed at the end of each iteration of a time
integration scheme.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add basic contact brick\textquotesingle{}, string varname\_u, string multname\_n{[}, string multname\_t{]}, string dataname\_r, spmat BN{[}, spmat BT, string dataname\_friction\_coeff{]}{[}, string dataname\_gap{[}, string dataname\_alpha{[}, int augmented\_version{[}, string dataname\_gamma, string dataname\_wt{]}{]}{]})}}
\begin{quote}

Add a contact with or without friction brick to the model.
If U is the vector
of degrees of freedom on which the unilateral constraint is applied,
the matrix \sphinxtitleref{BN} have to be such that this constraint is defined by
\(B_N U \le 0\). A friction condition can be considered by adding
the three parameters \sphinxtitleref{multname\_t}, \sphinxtitleref{BT} and \sphinxtitleref{dataname\_friction\_coeff}.
In this case, the tangential displacement is \(B_T U\) and
the matrix \sphinxtitleref{BT} should have as many rows as \sphinxtitleref{BN} multiplied by
\(d-1\) where \(d\) is the domain dimension.
In this case also, \sphinxtitleref{dataname\_friction\_coeff} is a data which represents
the coefficient of friction. It can be a scalar or a vector representing a
value on each contact condition.  The unilateral constraint is prescribed
thank to a multiplier
\sphinxtitleref{multname\_n} whose dimension should be equal to the number of rows of
\sphinxtitleref{BN}. If a friction condition is added, it is prescribed with a
multiplier \sphinxtitleref{multname\_t} whose dimension should be equal to the number
of rows of \sphinxtitleref{BT}. The augmentation parameter \sphinxtitleref{r} should be chosen in
a range of
acceptabe values (see Getfem user documentation). \sphinxtitleref{dataname\_gap} is an
optional parameter representing the initial gap. It can be a single value
or a vector of value. \sphinxtitleref{dataname\_alpha} is an optional homogenization
parameter for the augmentation parameter
(see Getfem user documentation).  The parameter \sphinxtitleref{augmented\_version}
indicates the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric
Alart\sphinxhyphen{}Curnier augmented Lagrangian, 2 for the symmetric one (except for
the coupling between contact and Coulomb friction), 3 for the
unsymmetric method with augmented multipliers, 4 for the unsymmetric
method with augmented multipliers and De Saxce projection.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add basic contact brick two deformable bodies\textquotesingle{}, string varname\_u1, string varname\_u2, string multname\_n, string dataname\_r, spmat BN1, spmat BN2{[}, string dataname\_gap{[}, string dataname\_alpha{[}, int augmented\_version{]}{]}{]})}}
\begin{quote}
\begin{description}
\item[{Add a frictionless contact condition to the model between two deformable}] \leavevmode
bodies. If U1, U2 are the vector
of degrees of freedom on which the unilateral constraint is applied,
the matrices \sphinxtitleref{BN1} and \sphinxtitleref{BN2} have to be such that this condition
is defined by
\$B\_\{N1\} U\_1 B\_\{N2\} U\_2 + le gap\$. The constraint is prescribed thank
to a multiplier
\sphinxtitleref{multname\_n} whose dimension should be equal to the number of lines of
\sphinxtitleref{BN}. The augmentation parameter \sphinxtitleref{r} should be chosen in a range of
acceptabe values (see Getfem user documentation). \sphinxtitleref{dataname\_gap} is an
optional parameter representing the initial gap. It can be a single value
or a vector of value. \sphinxtitleref{dataname\_alpha} is an optional homogenization
parameter for the augmentation parameter
(see Getfem user documentation). The parameter \sphinxtitleref{aug\_version} indicates
the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier
augmented Lagrangian, 2 for the symmetric one, 3 for the unsymmetric
method with augmented multiplier.

\end{description}
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}contact brick set BN\textquotesingle{}, int indbrick, spmat BN)}}
\begin{quote}

Can be used to set the BN matrix of a basic contact/friction brick.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}contact brick set BT\textquotesingle{}, int indbrick, spmat BT)}}
\begin{quote}

Can be used to set the BT matrix of a basic contact with
friction brick.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nodal contact with rigid obstacle brick\textquotesingle{},  mesh\_im mim, string varname\_u, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_friction\_coeff{]}, int region, string obstacle{[},  int augmented\_version{]})}}
\begin{quote}

Add a contact with or without friction condition with a rigid obstacle
to the model. The condition is applied on the variable \sphinxtitleref{varname\_u}
on the boundary corresponding to \sphinxtitleref{region}. The rigid obstacle should
be described with the string \sphinxtitleref{obstacle} being a signed distance to
the obstacle. This string should be an expression where the coordinates
are ‘x’, ‘y’ in 2D and ‘x’, ‘y’, ‘z’ in 3D. For instance, if the rigid
obstacle correspond to \(z \le 0\), the corresponding signed distance
will be simply “z”. \sphinxtitleref{multname\_n} should be a fixed size variable whose size
is the number of degrees of freedom on boundary \sphinxtitleref{region}. It represents the
contact equivalent nodal forces. In order to add a friction condition
one has to add the \sphinxtitleref{multname\_t} and \sphinxtitleref{dataname\_friction\_coeff} parameters.
\sphinxtitleref{multname\_t} should be a fixed size variable whose size is
the number of degrees of freedom on boundary \sphinxtitleref{region} multiplied by
\(d-1\) where \(d\) is the domain dimension. It represents
the friction equivalent nodal forces.
The augmentation parameter \sphinxtitleref{r} should be chosen in a
range of acceptabe values (close to the Young modulus of the elastic
body, see Getfem user documentation).  \sphinxtitleref{dataname\_friction\_coeff} is
the friction coefficient. It could be a scalar or a vector of values
representing the friction coefficient on each contact node.
The parameter \sphinxtitleref{augmented\_version}
indicates the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric
Alart\sphinxhyphen{}Curnier augmented Lagrangian, 2 for the symmetric one (except for
the coupling between contact and Coulomb friction),
3 for the new unsymmetric method.
Basically, this brick compute the matrix BN
and the vectors gap and alpha and calls the basic contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add contact with rigid obstacle brick\textquotesingle{},  mesh\_im mim, string varname\_u, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_friction\_coeff{]}, int region, string obstacle{[},  int augmented\_version{]})}}
\begin{quote}

DEPRECATED FUNCTION. Use ‘add nodal contact with rigid obstacle brick’ instead.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add integral contact with rigid obstacle brick\textquotesingle{},  mesh\_im mim, string varname\_u, string multname, string dataname\_obstacle, string dataname\_r {[}, string dataname\_friction\_coeff{]}, int region {[}, int option {[}, string dataname\_alpha {[}, string dataname\_wt {[}, string dataname\_gamma {[}, string dataname\_vt{]}{]}{]}{]}{]})}}
\begin{quote}

Add a contact with or without friction condition with a rigid obstacle
to the model. This brick adds a contact which is defined
in an integral way. It is the direct approximation of an augmented
Lagrangian formulation (see Getfem user documentation) defined at the
continuous level. The advantage is a better scalability: the number of
Newton iterations should be more or less independent of the mesh size.
The contact condition is applied on the variable \sphinxtitleref{varname\_u}
on the boundary corresponding to \sphinxtitleref{region}. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
\sphinxtitleref{multname} should be a fem variable representing the contact stress.
An inf\sphinxhyphen{}sup condition beetween \sphinxtitleref{multname} and \sphinxtitleref{varname\_u} is required.
The augmentation parameter \sphinxtitleref{dataname\_r} should be chosen in a
range of acceptabe values.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element method.
Possible values for \sphinxtitleref{option} is 1 for the non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier
augmented Lagrangian method, 2 for the symmetric one, 3 for the
non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier method with an additional augmentation
and 4 for a new unsymmetric method. The default value is 1.
In case of contact with friction, \sphinxtitleref{dataname\_alpha} and \sphinxtitleref{dataname\_wt}
are optional parameters to solve evolutionary friction problems.
\sphinxtitleref{dataname\_gamma} and \sphinxtitleref{dataname\_vt} represent optional data for adding
a parameter\sphinxhyphen{}dependent sliding velocity to the friction condition.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add penalized contact with rigid obstacle brick\textquotesingle{},  mesh\_im mim, string varname\_u, string dataname\_obstacle, string dataname\_r {[}, string dataname\_coeff{]}, int region {[}, int option, string dataname\_lambda, {[}, string dataname\_alpha {[}, string dataname\_wt{]}{]}{]})}}
\begin{quote}

Add a penalized contact with or without friction condition with a
rigid obstacle to the model.
The condition is applied on the variable \sphinxtitleref{varname\_u}
on the boundary corresponding to \sphinxtitleref{region}. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
The penalization parameter \sphinxtitleref{dataname\_r} should be chosen
large enough to prescribe approximate non\sphinxhyphen{}penetration and friction
conditions but not too large not to deteriorate too much the
conditionning of the tangent system.
\sphinxtitleref{dataname\_lambda} is an optional parameter used if option
is 2. In that case, the penalization term is shifted by lambda (this
allows the use of an Uzawa algorithm on the corresponding augmented
Lagrangian formulation)
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Nitsche contact with rigid obstacle brick\textquotesingle{}, mesh\_im mim, string varname, string Neumannterm, string dataname\_obstacle, string gamma0name,  int region{[}, scalar theta{[}, string dataname\_friction\_coeff{[}, string dataname\_alpha, string dataname\_wt{]}{]}{]})}}
\begin{quote}

Adds a contact condition with or without Coulomb friction on the variable
\sphinxtitleref{varname} and the mesh boundary \sphinxtitleref{region}. The contact condition
is prescribed with Nitsche’s method. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
\sphinxtitleref{gamma0name} is the Nitsche’s method parameter.
\sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method.
CAUTION: This brick has to be added in the model after all the bricks
corresponding to partial differential terms having a Neumann term.
Moreover, This brick can only be applied to bricks declaring their
Neumann terms. Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Nitsche midpoint contact with rigid obstacle brick\textquotesingle{}, mesh\_im mim, string varname, string Neumannterm, string Neumannterm\_wt, string dataname\_obstacle, string gamma0name,  int region, scalar theta, string dataname\_friction\_coeff, string dataname\_alpha, string dataname\_wt)}}
\begin{quote}

EXPERIMENTAL BRICK: for midpoint scheme only !!
Adds a contact condition with or without Coulomb friction on the variable
\sphinxtitleref{varname} and the mesh boundary \sphinxtitleref{region}. The contact condition
is prescribed with Nitsche’s method. The rigid obstacle should
be described with the data \sphinxtitleref{dataname\_obstacle} being a signed distance to
the obstacle (interpolated on a finite element method).
\sphinxtitleref{gamma0name} is the Nitsche’s method parameter.
\sphinxtitleref{theta} is a scalar value which can be
positive or negative. \sphinxtitleref{theta = 1} corresponds to the standard symmetric
method which is conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is
inconditionally coercive. \sphinxtitleref{theta = 0} is the simplest method
for which the second derivative of the Neumann term is not necessary.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method.
Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Nitsche fictitious domain contact brick\textquotesingle{}, mesh\_im mim, string varname1, string varname2, string dataname\_d1, string dataname\_d2, string gamma0name {[}, scalar theta{[}, string dataname\_friction\_coeff{[}, string dataname\_alpha, string dataname\_wt1,string dataname\_wt2{]}{]}{]})}}
\begin{quote}

Adds a contact condition with or without Coulomb friction between
two bodies in a fictitious domain. The contact condition is applied on
the variable \sphinxtitleref{varname\_u1} corresponds with the first and slave body
with Nitsche’s method and on the variable \sphinxtitleref{varname\_u2} corresponds
with the second and master body with Nitsche’s method.
The contact condition is evaluated on the fictitious slave boundary.
The first body should be described by the level\sphinxhyphen{}set \sphinxtitleref{dataname\_d1}
and the second body should be described by the level\sphinxhyphen{}set \sphinxtitleref{dataname\_d2}.
\sphinxtitleref{gamma0name} is the Nitsche’s method parameter.
\sphinxtitleref{theta} is a scalar value which can be positive or negative.
\sphinxtitleref{theta = 1} corresponds to the standard symmetric method which is
conditionally coercive for  \sphinxtitleref{gamma0} small.
\sphinxtitleref{theta = \sphinxhyphen{}1} corresponds to the skew\sphinxhyphen{}symmetric method which is inconditionally coercive.
\sphinxtitleref{theta = 0} is the simplest method for which the second derivative of
the Neumann term is not necessary. The optional parameter \sphinxtitleref{dataname\_friction\_coeff}
is the friction coefficient which could be constant or defined on a finite element method.
CAUTION: This brick has to be added in the model after all the bricks
corresponding to partial differential terms having a Neumann term.
Moreover, This brick can only be applied to bricks declaring their
Neumann terms. Returns the brick index in the model.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nodal contact between nonmatching meshes brick\textquotesingle{},  mesh\_im mim1{[}, mesh\_im mim2{]}, string varname\_u1{[}, string varname\_u2{]}, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_fr{]}, int rg1, int rg2{[}, int slave1, int slave2,  int augmented\_version{]})}}
\begin{quote}

Add a contact with or without friction condition between two faces of
one or two elastic bodies. The condition is applied on the variable
\sphinxtitleref{varname\_u1} or the variables \sphinxtitleref{varname\_u1} and \sphinxtitleref{varname\_u2} depending
if a single or two distinct displacement fields are given. Integers
\sphinxtitleref{rg1} and \sphinxtitleref{rg2} represent the regions expected to come in contact with
each other. In the single displacement variable case the regions defined
in both \sphinxtitleref{rg1} and \sphinxtitleref{rg2} refer to the variable \sphinxtitleref{varname\_u1}. In the case
of two displacement variables, \sphinxtitleref{rg1} refers to \sphinxtitleref{varname\_u1} and \sphinxtitleref{rg2}
refers to \sphinxtitleref{varname\_u2}. \sphinxtitleref{multname\_n} should be a fixed size variable
whose size is the number of degrees of freedom on those regions among
the ones defined in \sphinxtitleref{rg1} and \sphinxtitleref{rg2} which are characterized as “slaves”.
It represents the contact equivalent nodal normal forces. \sphinxtitleref{multname\_t}
should be a fixed size variable whose size corresponds to the size of
\sphinxtitleref{multname\_n} multiplied by qdim \sphinxhyphen{} 1 . It represents the contact
equivalent nodal tangent (frictional) forces. The augmentation parameter
\sphinxtitleref{r} should be chosen in a range of acceptabe values (close to the Young
modulus of the elastic body, see Getfem user documentation). The
friction coefficient stored in the parameter \sphinxtitleref{fr} is either a single
value or a vector of the same size as \sphinxtitleref{multname\_n}. The optional
parameters \sphinxtitleref{slave1} and \sphinxtitleref{slave2} declare if the regions defined in \sphinxtitleref{rg1}
and \sphinxtitleref{rg2} are correspondingly considered as “slaves”. By default
\sphinxtitleref{slave1} is true and \sphinxtitleref{slave2} is false, i.e. \sphinxtitleref{rg1} contains the slave
surfaces, while ‘rg2’ the master surfaces. Preferrably only one of
\sphinxtitleref{slave1} and \sphinxtitleref{slave2} is set to true.  The parameter \sphinxtitleref{augmented\_version}
indicates the augmentation strategy : 1 for the non\sphinxhyphen{}symmetric
Alart\sphinxhyphen{}Curnier augmented Lagrangian, 2 for the symmetric one (except for
the coupling between contact and Coulomb friction),
3 for the new unsymmetric method.
Basically, this brick computes the matrices BN and BT and the vectors
gap and alpha and calls the basic contact brick.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add nonmatching meshes contact brick\textquotesingle{},  mesh\_im mim1{[}, mesh\_im mim2{]}, string varname\_u1{[}, string varname\_u2{]}, string multname\_n{[}, string multname\_t{]}, string dataname\_r{[}, string dataname\_fr{]}, int rg1, int rg2{[}, int slave1, int slave2,  int augmented\_version{]})}}
\begin{quote}

DEPRECATED FUNCTION. Use ‘add nodal contact between nonmatching meshes brick’ instead.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add integral contact between nonmatching meshes brick\textquotesingle{},  mesh\_im mim, string varname\_u1, string varname\_u2, string multname, string dataname\_r {[}, string dataname\_friction\_coeff{]}, int region1, int region2 {[}, int option {[}, string dataname\_alpha {[}, string dataname\_wt1 , string dataname\_wt2{]}{]}{]})}}
\begin{quote}

Add a contact with or without friction condition between nonmatching
meshes to the model. This brick adds a contact which is defined
in an integral way. It is the direct approximation of an augmented
agrangian formulation (see Getfem user documentation) defined at the
continuous level. The advantage should be a better scalability:
the number of Newton iterations should be more or less independent
of the mesh size.
The condition is applied on the variables \sphinxtitleref{varname\_u1} and \sphinxtitleref{varname\_u2}
on the boundaries corresponding to \sphinxtitleref{region1} and \sphinxtitleref{region2}.
\sphinxtitleref{multname} should be a fem variable representing the contact stress
for the frictionless case and the contact and friction stress for the
case with friction. An inf\sphinxhyphen{}sup condition between \sphinxtitleref{multname} and
\sphinxtitleref{varname\_u1} and \sphinxtitleref{varname\_u2} is required.
The augmentation parameter \sphinxtitleref{dataname\_r} should be chosen in a
range of acceptable values.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method on the same mesh as \sphinxtitleref{varname\_u1}.
Possible values for \sphinxtitleref{option} is 1 for the non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier
augmented Lagrangian method, 2 for the symmetric one, 3 for the
non\sphinxhyphen{}symmetric Alart\sphinxhyphen{}Curnier method with an additional augmentation
and 4 for a new unsymmetric method. The default value is 1.
In case of contact with friction, \sphinxtitleref{dataname\_alpha}, \sphinxtitleref{dataname\_wt1} and
\sphinxtitleref{dataname\_wt2} are optional parameters to solve evolutionary friction
problems.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add penalized contact between nonmatching meshes brick\textquotesingle{},  mesh\_im mim, string varname\_u1, string varname\_u2, string dataname\_r {[}, string dataname\_coeff{]}, int region1, int region2 {[}, int option {[}, string dataname\_lambda, {[}, string dataname\_alpha {[}, string dataname\_wt1, string dataname\_wt2{]}{]}{]}{]})}}
\begin{quote}

Add a penalized contact condition with or without friction between
nonmatching meshes to the model.
The condition is applied on the variables \sphinxtitleref{varname\_u1} and  \sphinxtitleref{varname\_u2}
on the boundaries corresponding to \sphinxtitleref{region1} and \sphinxtitleref{region2}.
The penalization parameter \sphinxtitleref{dataname\_r} should be chosen
large enough to prescribe approximate non\sphinxhyphen{}penetration and friction
conditions but not too large not to deteriorate too much the
conditionning of the tangent system.
The optional parameter \sphinxtitleref{dataname\_friction\_coeff} is the friction
coefficient which could be constant or defined on a finite element
method on the same mesh as \sphinxtitleref{varname\_u1}.
\sphinxtitleref{dataname\_lambda} is an optional parameter used if option
is 2. In that case, the penalization term is shifted by lambda (this
allows the use of an Uzawa algorithm on the corresponding augmented
Lagrangian formulation)
In case of contact with friction, \sphinxtitleref{dataname\_alpha}, \sphinxtitleref{dataname\_wt1} and
\sphinxtitleref{dataname\_wt2} are optional parameters to solve evolutionary friction
problems.
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add integral large sliding contact brick raytracing\textquotesingle{}, string dataname\_r, scalar release\_distance, {[}, string dataname\_fr{[}, string dataname\_alpha{[}, int version{]}{]}{]})}}
\begin{quote}

Adds a large sliding contact with friction brick to the model.
This brick is able to deal with self\sphinxhyphen{}contact, contact between
several deformable bodies and contact with rigid obstacles.
It uses the high\sphinxhyphen{}level generic assembly. It adds to the model
a raytracing\_interpolate\_transformation object.
For each slave boundary a multiplier variable should be defined.
The release distance should be determined with care
(generally a few times a mean element size, and less than the
thickness of the body). Initially, the brick is added with no contact
boundaries. The contact boundaries and rigid bodies are added with
special functions. \sphinxtitleref{version} is 0 (the default value) for the
non\sphinxhyphen{}symmetric version and 1 for the more symmetric one
(not fully symmetric even without friction).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add rigid obstacle to large sliding contact brick\textquotesingle{}, int indbrick, string expr, int N)}}
\begin{quote}

Adds a rigid obstacle to an existing large sliding contact
with friction brick. \sphinxtitleref{expr} is an expression using the high\sphinxhyphen{}level
generic assembly language (where \sphinxtitleref{x} is the current point n the mesh)
which should be a signed distance to the obstacle.
\sphinxtitleref{N} is the mesh dimension.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add master contact boundary to large sliding contact brick\textquotesingle{}, int indbrick, mesh\_im mim, int region, string dispname{[}, string wname{]})}}
\begin{quote}

Adds a master contact boundary to an existing large sliding contact
with friction brick.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add slave contact boundary to large sliding contact brick\textquotesingle{}, int indbrick, mesh\_im mim, int region, string dispname, string lambdaname{[}, string wname{]})}}
\begin{quote}

Adds a slave contact boundary to an existing large sliding contact
with friction brick.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add master slave contact boundary to large sliding contact brick\textquotesingle{}, int indbrick, mesh\_im mim, int region, string dispname, string lambdaname{[}, string wname{]})}}
\begin{quote}

Adds a contact boundary to an existing large sliding contact
with friction brick which is both master and slave
(allowing the self\sphinxhyphen{}contact).
\end{quote}

\sphinxcode{\sphinxupquote{ind = gf\_model\_set(model M, \textquotesingle{}add Nitsche large sliding contact brick raytracing\textquotesingle{}, bool unbiased\_version, string dataname\_r, scalar release\_distance{[}, string dataname\_fr{[}, string dataname\_alpha{[}, int version{]}{]}{]})}}
\begin{quote}

Adds a large sliding contact with friction brick to the model based on the Nitsche’s method.
This brick is able to deal with self\sphinxhyphen{}contact, contact between
several deformable bodies and contact with rigid obstacles.
It uses the high\sphinxhyphen{}level generic assembly. It adds to the model
a raytracing\_interpolate\_transformation object. “unbiased\_version” refers to the version of Nische’s method to be used.
(unbiased or biased one).
For each slave boundary a  material law should be defined as a function of the dispacement variable on this boundary.
The release distance should be determined with care
(generally a few times a mean element size, and less than the
thickness of the body). Initially, the brick is added with no contact
boundaries. The contact boundaries and rigid bodies are added with
special functions. \sphinxtitleref{version} is 0 (the default value) for the
non\sphinxhyphen{}symmetric version and 1 for the more symmetric one
(not fully symmetric even without friction).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add rigid obstacle to Nitsche large sliding contact brick\textquotesingle{}, int indbrick, string expr, int N)}}
\begin{quote}

Adds a rigid obstacle to an existing large sliding contact
with friction brick. \sphinxtitleref{expr} is an expression using the high\sphinxhyphen{}level
generic assembly language (where \sphinxtitleref{x} is the current point n the mesh)
which should be a signed distance to the obstacle.
\sphinxtitleref{N} is the mesh dimension.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add master contact boundary to biased Nitsche large sliding contact brick\textquotesingle{}, int indbrick, mesh\_im mim, int region, string dispname{[}, string wname{]})}}
\begin{quote}

Adds a master contact boundary to an existing biased Nitsche’s large sliding contact
with friction brick.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add slave contact boundary to biased Nitsche large sliding contact brick\textquotesingle{}, int indbrick, mesh\_im mim, int region, string dispname, string lambdaname{[}, string wname{]})}}
\begin{quote}

Adds a slave contact boundary to an existing biased Nitsche’s large sliding contact
with friction brick.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_model\_set(model M, \textquotesingle{}add contact boundary to unbiased Nitsche large sliding contact brick\textquotesingle{}, int indbrick, mesh\_im mim, int region, string dispname, string lambdaname{[}, string wname{]})}}
\begin{quote}

Adds a contact boundary to an existing unbiased Nitschelarge sliding contact
with friction brick which is both master and slave.
\end{quote}
\end{quote}


\section{gf\_poly}
\label{\detokenize{matlab_octave/cmdref_gf_poly:gf-poly}}\label{\detokenize{matlab_octave/cmdref_gf_poly::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}poly}\PYG{p}{(}\PYG{n}{poly} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{print}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}poly}\PYG{p}{(}\PYG{n}{poly} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{product}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Performs various operations on the polynom POLY.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_poly(poly P, \textquotesingle{}print\textquotesingle{})}}
\begin{quote}

Prints the content of P.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_poly(poly P, \textquotesingle{}product\textquotesingle{})}}
\begin{quote}

To be done … !
\end{quote}
\end{quote}


\section{gf\_precond}
\label{\detokenize{matlab_octave/cmdref_gf_precond:gf-precond}}\label{\detokenize{matlab_octave/cmdref_gf_precond::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{identity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cidentity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diagonal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{D}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ildlt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{m}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ilu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{m}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ildltt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{m}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{fillin}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{threshold}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ilut}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{m}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{fillin}\PYG{p}{[}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{threshold}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{superlu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{m}\PYG{p}{)}
\PYG{n}{PC} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{spmat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{m}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for precond objects.
\begin{quote}

The preconditioners may store REAL or COMPLEX values. They accept getfem
sparse matrices and Matlab sparse matrices.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}identity\textquotesingle{})}}
\begin{quote}

Create a REAL identity precondioner.
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}cidentity\textquotesingle{})}}
\begin{quote}

Create a COMPLEX identity precondioner.
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}diagonal\textquotesingle{}, vec D)}}
\begin{quote}

Create a diagonal precondioner.
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}ildlt\textquotesingle{}, spmat m)}}
\begin{quote}

Create an ILDLT (Cholesky) preconditioner for the (symmetric) sparse
matrix \sphinxtitleref{m}. This preconditioner has the same sparsity pattern than \sphinxtitleref{m}
(no fill\sphinxhyphen{}in).
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}ilu\textquotesingle{}, spmat m)}}
\begin{quote}

Create an ILU (Incomplete LU) preconditioner for the sparse
matrix \sphinxtitleref{m}. This preconditioner has the same sparsity pattern
than \sphinxtitleref{m} (no fill\sphinxhyphen{}in).
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}ildltt\textquotesingle{}, spmat m{[}, int fillin{[}, scalar threshold{]}{]})}}
\begin{quote}

Create an ILDLTT (Cholesky with filling) preconditioner for the
(symmetric) sparse matrix \sphinxtitleref{m}. The preconditioner may add at most
\sphinxtitleref{fillin} additional non\sphinxhyphen{}zero entries on each line. The default value
for \sphinxtitleref{fillin} is 10, and the default threshold is1e\sphinxhyphen{}7.
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}ilut\textquotesingle{}, spmat m{[}, int fillin{[}, scalar threshold{]}{]})}}
\begin{quote}

Create an ILUT (Incomplete LU with filling) preconditioner for the
sparse matrix \sphinxtitleref{m}. The preconditioner may add at most \sphinxtitleref{fillin}
additional non\sphinxhyphen{}zero entries on each line. The default value for
\sphinxtitleref{fillin} is 10, and the default threshold is 1e\sphinxhyphen{}7.
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}superlu\textquotesingle{}, spmat m)}}
\begin{quote}

Uses SuperLU to build an exact factorization of the sparse matrix \sphinxtitleref{m}.
This preconditioner is only available if the getfem\sphinxhyphen{}interface was
built with SuperLU support. Note that LU factorization is likely to
eat all your memory for 3D problems.
\end{quote}

\sphinxcode{\sphinxupquote{PC = gf\_precond(\textquotesingle{}spmat\textquotesingle{}, spmat m)}}
\begin{quote}

Preconditioner given explicitely by a sparse matrix.
\end{quote}
\end{quote}


\section{gf\_precond\_get}
\label{\detokenize{matlab_octave/cmdref_gf_precond_get:gf-precond-get}}\label{\detokenize{matlab_octave/cmdref_gf_precond_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}precond\PYGZus{}get}\PYG{p}{(}\PYG{n}{precond} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mult}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}precond\PYGZus{}get}\PYG{p}{(}\PYG{n}{precond} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tmult}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}precond\PYGZus{}get}\PYG{p}{(}\PYG{n}{precond} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{type}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}precond\PYGZus{}get}\PYG{p}{(}\PYG{n}{precond} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}precond\PYGZus{}get}\PYG{p}{(}\PYG{n}{precond} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}complex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}precond\PYGZus{}get}\PYG{p}{(}\PYG{n}{precond} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}precond\PYGZus{}get}\PYG{p}{(}\PYG{n}{precond} \PYG{n}{P}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about precond objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_precond\_get(precond P, \textquotesingle{}mult\textquotesingle{}, vec V)}}
\begin{quote}

Apply the preconditioner to the supplied vector.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_precond\_get(precond P, \textquotesingle{}tmult\textquotesingle{}, vec V)}}
\begin{quote}

Apply the transposed preconditioner to the supplied vector.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_precond\_get(precond P, \textquotesingle{}type\textquotesingle{})}}
\begin{quote}

Return a string describing the type of the preconditioner (‘ilu’, ‘ildlt’,..).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_precond\_get(precond P, \textquotesingle{}size\textquotesingle{})}}
\begin{quote}

Return the dimensions of the preconditioner.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_precond\_get(precond P, \textquotesingle{}is\_complex\textquotesingle{})}}
\begin{quote}

Return 1 if the preconditioner stores complex values.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_precond\_get(precond P, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the precond.

This can be used to perform comparisons between two
different precond objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_precond\_get(precond P, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a precond object.
\end{quote}
\end{quote}


\section{gf\_slice}
\label{\detokenize{matlab_octave/cmdref_gf_slice:gf-slice}}\label{\detokenize{matlab_octave/cmdref_gf_slice::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{n}{sliceop}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n+nb}{slice} \PYG{n}{sl}\PYG{o}{|}\PYG{p}{\PYGZob{}}\PYG{n}{mesh} \PYG{n}{m}\PYG{o}{|} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{U}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{refine}\PYG{p}{\PYGZcb{}}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{CVfids}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{streamlines}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{U}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{S}\PYG{p}{)}
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{points}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{Pts}\PYG{p}{)}
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{load}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{[}\PYG{p}{,} \PYG{n}{mesh} \PYG{n}{m}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for slice objects.
\begin{quote}

Creation of a mesh slice. Mesh slices are very similar to a
P1\sphinxhyphen{}discontinuous mesh\_fem on which interpolation is very fast. The slice is
built from a mesh object, and a description of the slicing operation, for
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{planar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{n}{m}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

cuts the original mesh with the half space \{y\textgreater{}0\}. Each convex of the
original mesh \sphinxtitleref{m} is simplexified (for example a quadrangle is splitted
into 2 triangles), and each simplex is refined 5 times.

Slicing operations can be:
\begin{itemize}
\item {} 
cutting with a plane, a sphere or a cylinder

\item {} 
intersection or union of slices

\item {} 
isovalues surfaces/volumes

\item {} 
“points”, “streamlines” (see below)

\end{itemize}

If the first argument is a mesh\_fem \sphinxtitleref{mf} instead of a mesh, and if it is
followed by a \sphinxtitleref{mf}\sphinxhyphen{}field \sphinxtitleref{u} (with size(u,1) ==
gf\_mesh\_fem\_get(mesh\_fem MF, ‘nbdof’)), then the deformation \sphinxtitleref{u} will be applied to the
mesh before the slicing operation.

The first argument can also be a slice.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{sl = gf\_slice(sliceop, \{slice sl|\{mesh m| mesh\_fem mf, vec U\}, int refine\}{[}, mat CVfids{]})}}
\begin{quote}

Create a slice using \sphinxtitleref{sliceop} operation.

\sphinxtitleref{sliceop} operation is specified with Matlab CELL arrays (i.e.
with braces) . The first element is the
name of the operation, followed the slicing options:
\begin{itemize}
\item {} 
\{‘none’\} :
Does not cut the mesh.

\item {} 
\{‘planar’, int orient, vec p, vec n\} :
Planar cut. \sphinxtitleref{p} and \sphinxtitleref{n} define a half\sphinxhyphen{}space, \sphinxtitleref{p} being a point belong to
the boundary of the half\sphinxhyphen{}space, and \sphinxtitleref{n} being its normal. If \sphinxtitleref{orient} is
equal to \sphinxhyphen{}1 (resp. 0, +1), then the slicing operation will cut the mesh
with the “interior” (resp. “boundary”, “exterior”) of the half\sphinxhyphen{}space.
\sphinxtitleref{orient} may also be set to +2 which means that the mesh will be sliced,
but both the outer and inner parts will be kept.

\item {} 
\{‘ball’, int orient, vec c, scalar r\} :
Cut with a ball of center \sphinxtitleref{c} and radius \sphinxtitleref{r}.

\item {} 
\{‘cylinder’, int orient, vec p1, vec p2, scalar r\} :
Cut with a cylinder whose axis is the line \sphinxtitleref{(p1, p2)} and whose radius
is \sphinxtitleref{r}.

\item {} 
\{‘isovalues’, int orient, mesh\_fem mf, vec U, scalar s\} :
Cut using the isosurface of the field \sphinxtitleref{U} (defined on the mesh\_fem \sphinxtitleref{mf}).
The result is the set \sphinxtitleref{\{x such that :math:\textasciigrave{}U(x) leq s}\}\textasciigrave{} or \sphinxtitleref{\{x such that
\textasciigrave{}U\textasciigrave{}(x)=\textasciigrave{}s}\}\textasciigrave{} or \sphinxtitleref{\{x such that \textasciigrave{}U\textasciigrave{}(x) \textgreater{}= \textasciigrave{}s}\}\textasciigrave{} depending on the value of
\sphinxtitleref{orient}.

\item {} 
\{‘boundary’{[}, SLICEOP{]}\} :
Return the boundary of the result of SLICEOP, where SLICEOP is any
slicing operation. If SLICEOP is not specified, then the whole mesh is
considered (i.e. it is equivalent to \{‘boundary’,\{‘none’\}\}).

\item {} 
\{‘explode’, mat Coef\} :
Build an ‘exploded’ view of the mesh: each convex is shrinked (\(0 <
\text{Coef} \leq 1\)). In the case of 3D convexes, only their faces are kept.

\item {} 
\{‘union’, SLICEOP1, SLICEOP2\} :
Returns the union of slicing operations.

\item {} 
\{‘intersection’, SLICEOP1, SLICEOP2\} :
Returns the intersection of slicing operations, for example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{intersection}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{n}{planar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,+1,[0;0;0],[0;0;1]\PYGZcb{},}
                           \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isovalues}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{mf2}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{mf}\PYG{p}{,}\PYG{n}{u}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\item {} 
\{‘comp’, SLICEOP\} :
Returns the complementary of slicing operations.

\item {} 
\{‘diff’, SLICEOP1, SLICEOP2\} :
Returns the difference of slicing operations.

\item {} 
\{‘mesh’, mesh m\} :
Build a slice which is the intersection of the sliced mesh with another
mesh. The slice is such that all of its simplexes are stricly contained
into a convex of each mesh.

\end{itemize}
\end{quote}

\sphinxcode{\sphinxupquote{sl = gf\_slice(\textquotesingle{}streamlines\textquotesingle{}, mesh\_fem mf, mat U, mat S)}}
\begin{quote}

Compute streamlines of the (vector) field \sphinxtitleref{U}, with seed points given
by the columns of \sphinxtitleref{S}.
\end{quote}

\sphinxcode{\sphinxupquote{sl = gf\_slice(\textquotesingle{}points\textquotesingle{}, mesh m, mat Pts)}}
\begin{quote}

Return the “slice” composed of points given by the columns of \sphinxtitleref{Pts}
(useful for interpolation on a given set of sparse points, see
\sphinxcode{\sphinxupquote{gf\_compute(\textquotesingle{}interpolate on\textquotesingle{},sl)}}).
\end{quote}

\sphinxcode{\sphinxupquote{sl = gf\_slice(\textquotesingle{}load\textquotesingle{}, string filename{[}, mesh m{]})}}
\begin{quote}

Load the slice (and its linked mesh if it is not given as an argument)
from a text file.
\end{quote}
\end{quote}


\section{gf\_slice\_get}
\label{\detokenize{matlab_octave/cmdref_gf_slice_get:gf-slice-get}}\label{\detokenize{matlab_octave/cmdref_gf_slice_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{area}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{CVids} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cvs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbpts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ns} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nbsplxs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{dim}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{P} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{S}\PYG{p}{,} \PYG{n}{CV2S}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{splxs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{int} \PYG{n}{dim}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{P}\PYG{p}{,} \PYG{n}{E1}\PYG{p}{,} \PYG{n}{E2}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{edges}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Usl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{interpolate\PYGZus{}convex\PYGZus{}data}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{Ucv}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{linked mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mesh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{memsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to vtk}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to pov}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to dx}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{export to pos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{[}\PYG{p}{,} \PYG{n}{string} \PYG{n}{name}\PYG{p}{]}\PYG{p}{[}\PYG{p}{[}\PYG{p}{,}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{U1}\PYG{p}{,} \PYG{n}{string} \PYG{n}{nameU1}\PYG{p}{[}\PYG{p}{[}\PYG{p}{,}\PYG{n}{mesh\PYGZus{}fem} \PYG{n}{mf1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{U2}\PYG{p}{,} \PYG{n}{string} \PYG{n}{nameU2}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}slice\PYGZus{}get}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

General function for querying information about slice objects.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{d = gf\_slice\_get(slice S, \textquotesingle{}dim\textquotesingle{})}}
\begin{quote}

Return the dimension of the slice (2 for a 2D mesh, etc..).
\end{quote}

\sphinxcode{\sphinxupquote{a = gf\_slice\_get(slice S, \textquotesingle{}area\textquotesingle{})}}
\begin{quote}

Return the area of the slice.
\end{quote}

\sphinxcode{\sphinxupquote{CVids = gf\_slice\_get(slice S, \textquotesingle{}cvs\textquotesingle{})}}
\begin{quote}

Return the list of convexes of the original mesh contained in the slice.
\end{quote}

\sphinxcode{\sphinxupquote{n = gf\_slice\_get(slice S, \textquotesingle{}nbpts\textquotesingle{})}}
\begin{quote}

Return the number of points in the slice.
\end{quote}

\sphinxcode{\sphinxupquote{ns = gf\_slice\_get(slice S, \textquotesingle{}nbsplxs\textquotesingle{}{[}, int dim{]})}}
\begin{quote}

Return the number of simplexes in the slice.

Since the slice may contain points (simplexes of dim 0), segments
(simplexes of dimension 1), triangles etc., the result is a vector
of size gf\_slice\_get(slice S, ‘dim’)+1, except if the optional argument \sphinxtitleref{dim}
is used.
\end{quote}

\sphinxcode{\sphinxupquote{P = gf\_slice\_get(slice S, \textquotesingle{}pts\textquotesingle{})}}
\begin{quote}

Return the list of point coordinates.
\end{quote}

\sphinxcode{\sphinxupquote{\{S, CV2S\} = gf\_slice\_get(slice S, \textquotesingle{}splxs\textquotesingle{},int dim)}}
\begin{quote}

Return the list of simplexes of dimension \sphinxtitleref{dim}.

On output, S has ‘dim+1’ rows, each column contains the point
numbers of a simplex.  The vector \sphinxtitleref{CV2S} can be used to find the
list of simplexes for any convex stored in the slice. For example
‘S(:,CV2S(4):CV2S(5)\sphinxhyphen{}1)’
gives the list of simplexes for the fourth convex.
\end{quote}

\sphinxcode{\sphinxupquote{\{P, E1, E2\} = gf\_slice\_get(slice S, \textquotesingle{}edges\textquotesingle{})}}
\begin{quote}

Return the edges of the linked mesh contained in the slice.

\sphinxtitleref{P} contains the list of all edge vertices, \sphinxtitleref{E1} contains
the indices of each mesh edge in \sphinxtitleref{P}, and \sphinxtitleref{E2} contains the
indices of each “edges” which is on the border of the slice.
This function is useless except for post\sphinxhyphen{}processing purposes.
\end{quote}

\sphinxcode{\sphinxupquote{Usl = gf\_slice\_get(slice S, \textquotesingle{}interpolate\_convex\_data\textquotesingle{}, mat Ucv)}}
\begin{quote}

Interpolate data given on each convex of the mesh to the slice nodes.

The input array \sphinxtitleref{Ucv} may have any number of dimensions, but its
last dimension should be equal to gf\_mesh\_get(mesh M, ‘max cvid’).

Example of use: gf\_slice\_get(slice S, ‘interpolate\_convex\_data’, gf\_mesh\_get(mesh M, ‘quality’)).
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_slice\_get(slice S, \textquotesingle{}linked mesh\textquotesingle{})}}
\begin{quote}

Return the mesh on which the slice was taken.
\end{quote}

\sphinxcode{\sphinxupquote{m = gf\_slice\_get(slice S, \textquotesingle{}mesh\textquotesingle{})}}
\begin{quote}

Return the mesh on which the slice was taken
(identical to ‘linked mesh’)
\end{quote}

\sphinxcode{\sphinxupquote{z = gf\_slice\_get(slice S, \textquotesingle{}memsize\textquotesingle{})}}
\begin{quote}

Return the amount of memory (in bytes) used by the slice object.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_slice\_get(slice S, \textquotesingle{}export to vtk\textquotesingle{}, string filename, ...)}}
\begin{quote}

Export a slice to VTK.

Following the \sphinxtitleref{filename}, you may use any of the following options:
\begin{itemize}
\item {} 
if ‘ascii’ is not used, the file will contain binary data
(non portable, but fast).

\item {} 
if ‘edges’ is used, the edges of the original mesh will be
written instead of the slice content.

\end{itemize}

More than one dataset may be written, just list them. Each dataset
consists of either:
\begin{itemize}
\item {} 
a field interpolated on the slice (scalar, vector or tensor),
followed by an optional name.

\item {} 
a mesh\_fem and a field, followed by an optional name.

\end{itemize}

Examples:
\begin{itemize}
\item {} 
gf\_slice\_get(slice S, ‘export to vtk’, ‘test.vtk’, Usl, ‘first\_dataset’, mf,
U2, ‘second\_dataset’)

\item {} 
gf\_slice\_get(slice S, ‘export to vtk’, ‘test.vtk’, ‘ascii’, mf,U2)

\item {} 
gf\_slice\_get(slice S, ‘export to vtk’, ‘test.vtk’, ‘edges’, ‘ascii’, Uslice)

\end{itemize}
\end{quote}

\sphinxcode{\sphinxupquote{gf\_slice\_get(slice S, \textquotesingle{}export to pov\textquotesingle{}, string filename)}}
\begin{quote}

Export a the triangles of the slice to POV\sphinxhyphen{}RAY.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_slice\_get(slice S, \textquotesingle{}export to dx\textquotesingle{}, string filename, ...)}}
\begin{quote}

Export a slice to OpenDX.

Following the \sphinxtitleref{filename}, you may use any of the following
options:
\begin{itemize}
\item {} 
if ‘ascii’ is not used, the file will contain binary data
(non portable, but fast).

\item {} 
if ‘edges’ is used, the edges of the original mesh will be
written instead of the slice content.

\item {} 
if ‘append’ is used, the opendx file will not be overwritten,
and the new data will be added at the end of the file.

\end{itemize}

More than one dataset may be written, just list them. Each dataset
consists of either:
\begin{itemize}
\item {} 
a field interpolated on the slice (scalar, vector or tensor),
followed by an optional name.

\item {} 
a mesh\_fem and a field, followed by an optional name.

\end{itemize}
\end{quote}

\sphinxcode{\sphinxupquote{gf\_slice\_get(slice S, \textquotesingle{}export to pos\textquotesingle{}, string filename{[}, string name{]}{[}{[},mesh\_fem mf1{]}, mat U1, string nameU1{[}{[},mesh\_fem mf1{]}, mat U2, string nameU2,...{]})}}
\begin{quote}

Export a slice to Gmsh.

More than one dataset may be written, just list them.
Each dataset consists of either:
\begin{itemize}
\item {} 
a field interpolated on the slice (scalar, vector or tensor).

\item {} 
a mesh\_fem and a field.

\end{itemize}
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_slice\_get(slice S, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the slice.

This can be used to perform comparisons between two
different slice objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_slice\_get(slice S, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a slice object.
\end{quote}
\end{quote}


\section{gf\_slice\_set}
\label{\detokenize{matlab_octave/cmdref_gf_slice_set:gf-slice-set}}\label{\detokenize{matlab_octave/cmdref_gf_slice_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}slice\PYGZus{}set}\PYG{p}{(}\PYG{n+nb}{slice} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{P}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Edition of mesh slices.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_slice\_set(slice S, \textquotesingle{}pts\textquotesingle{}, mat P)}}
\begin{quote}

Replace the points of the slice.

The new points \sphinxtitleref{P} are stored in the columns the matrix. Note that
you can use the function to apply a deformation to a slice, or to
change the dimension of the slice (the number of rows of \sphinxtitleref{P} is not
required to be equal to gf\_slice\_get(slice S, ‘dim’)).
\end{quote}
\end{quote}


\section{gf\_spmat}
\label{\detokenize{matlab_octave/cmdref_gf_spmat:gf-spmat}}\label{\detokenize{matlab_octave/cmdref_gf_spmat::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{empty}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{m} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{n}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{SM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{copy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{K} \PYG{p}{[}\PYG{p}{,}  \PYG{n}{I} \PYG{p}{[}\PYG{p}{,}  \PYG{n}{J}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{SM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{identity}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{n}{SM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mult}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{A}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{SM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{A}\PYG{p}{,} \PYG{n}{spmat} \PYG{n}{B}\PYG{p}{)}
\PYG{n}{SM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diag}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{D} \PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{E} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{n} \PYG{p}{[}\PYG{p}{,}\PYG{n+nb}{int} \PYG{n}{m}\PYG{p}{]}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{SM} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{load}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{|}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{harwell\PYGZhy{}boeing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{|}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{|}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{matrix\PYGZhy{}market}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

General constructor for spmat objects.
\begin{quote}

Create a new sparse matrix in GetFEM format(, i.e. sparse
matrices which are stored in the getfem workspace, not the matlab sparse
matrices). These sparse matrix can be stored as CSC (compressed column
sparse), which is the format used by Matlab, or they can be stored as WSC
(internal format to getfem). The CSC matrices are not writable (it would
be very inefficient), but they are optimized for multiplication with
vectors, and memory usage. The WSC are writable, they are very fast with
respect to random read/write operation. However their memory overhead is
higher than CSC matrices, and they are a little bit slower for
matrix\sphinxhyphen{}vector multiplications.

By default, all newly created matrices are build as WSC matrices. This can
be changed later with \sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}to\_csc\textquotesingle{},...)}}, or may be changed
automatically by getfem (for example \sphinxcode{\sphinxupquote{gf\_linsolve()}} converts the
matrices to CSC).

The matrices may store REAL or COMPLEX values.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{SM = gf\_spmat(\textquotesingle{}empty\textquotesingle{}, int m {[}, int n{]})}}
\begin{quote}

Create a new empty (i.e. full of zeros) sparse matrix, of dimensions
\sphinxtitleref{m x n}. If \sphinxtitleref{n} is omitted, the matrix dimension is \sphinxtitleref{m x m}.
\end{quote}

\sphinxcode{\sphinxupquote{SM = gf\_spmat(\textquotesingle{}copy\textquotesingle{}, mat K {[},  I {[},  J{]}{]})}}
\begin{quote}

Duplicate a matrix \sphinxtitleref{K} (which might be a spmat or a native matlab
sparse matrix). If index \sphinxtitleref{I} and/or \sphinxtitleref{J} are given, the matrix will
be a submatrix of \sphinxtitleref{K}. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{copy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sprand}\PYG{p}{(}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{:}\PYG{l+m+mi}{40}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{l+m+mi}{8} \PYG{l+m+mi}{3} \PYG{l+m+mi}{10}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

will return a 40x5 matrix.
\end{quote}

\sphinxcode{\sphinxupquote{SM = gf\_spmat(\textquotesingle{}identity\textquotesingle{}, int n)}}
\begin{quote}

Create a \sphinxtitleref{n x n} identity matrix.
\end{quote}

\sphinxcode{\sphinxupquote{SM = gf\_spmat(\textquotesingle{}mult\textquotesingle{}, spmat A, spmat B)}}
\begin{quote}

Create a sparse matrix as the product of the sparse matrices \sphinxtitleref{A} and
\sphinxtitleref{B}. It requires that \sphinxtitleref{A} and \sphinxtitleref{B} be both real or both complex, you
may have to use \sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}to\_complex\textquotesingle{})}}
\end{quote}

\sphinxcode{\sphinxupquote{SM = gf\_spmat(\textquotesingle{}add\textquotesingle{}, spmat A, spmat B)}}
\begin{quote}

Create a sparse matrix as the sum of the sparse matrices \sphinxtitleref{A} and \sphinxtitleref{B}.
Adding a real matrix with a complex matrix is possible.
\end{quote}

\sphinxcode{\sphinxupquote{SM = gf\_spmat(\textquotesingle{}diag\textquotesingle{}, mat D {[}, ivec E {[}, int n {[},int m{]}{]}{]})}}
\begin{quote}

Create a diagonal matrix. If \sphinxtitleref{E} is given, \sphinxtitleref{D} might be a matrix and
each column of \sphinxtitleref{E} will contain the sub\sphinxhyphen{}diagonal number that will be
filled with the corresponding column of \sphinxtitleref{D}.
\end{quote}

\sphinxcode{\sphinxupquote{SM = gf\_spmat(\textquotesingle{}load\textquotesingle{},\textquotesingle{}hb\textquotesingle{}|\textquotesingle{}harwell\sphinxhyphen{}boeing\textquotesingle{}|\textquotesingle{}mm\textquotesingle{}|\textquotesingle{}matrix\sphinxhyphen{}market\textquotesingle{}, string filename)}}
\begin{quote}

Read a sparse matrix from an Harwell\sphinxhyphen{}Boeing or a Matrix\sphinxhyphen{}Market file
See also \sphinxcode{\sphinxupquote{gf\_util(\textquotesingle{}load matrix\textquotesingle{})}}.
\end{quote}
\end{quote}


\section{gf\_spmat\_get}
\label{\detokenize{matlab_octave/cmdref_gf_spmat_get:gf-spmat-get}}\label{\detokenize{matlab_octave/cmdref_gf_spmat_get::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{n} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{nnz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{Sm} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{full}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{list} \PYG{n}{I}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{list} \PYG{n}{J}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{MV} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mult}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{MtV} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tmult}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{D} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diag}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{list} \PYG{n}{E}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{storage}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{ni}\PYG{p}{,}\PYG{n}{nj}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{size}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{is\PYGZus{}complex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{JC}\PYG{p}{,} \PYG{n}{IR}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{csc\PYGZus{}ind}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{V} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{csc\PYGZus{}val}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{N}\PYG{p}{,} \PYG{n}{U0}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dirichlet nullspace}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vec} \PYG{n}{R}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{save}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n+nb}{format}\PYG{p}{,} \PYG{n}{string} \PYG{n}{filename}\PYG{p}{)}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{char}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{p}{\PYGZob{}}\PYG{n}{mantissa\PYGZus{}r}\PYG{p}{,} \PYG{n}{mantissa\PYGZus{}i}\PYG{p}{,} \PYG{n}{exponent}\PYG{p}{\PYGZcb{}} \PYG{o}{=} \PYG{n}{gf\PYGZus{}spmat\PYGZus{}get}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{determinant}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{n = gf\_spmat\_get(spmat S, \textquotesingle{}nnz\textquotesingle{})}}
\begin{quote}

Return the number of non\sphinxhyphen{}null values stored in the sparse matrix.
\end{quote}

\sphinxcode{\sphinxupquote{Sm = gf\_spmat\_get(spmat S, \textquotesingle{}full\textquotesingle{}{[}, list I{[}, list J{]}{]})}}
\begin{quote}

Return a full (sub\sphinxhyphen{})matrix.

The optional arguments \sphinxtitleref{I} and \sphinxtitleref{J}, are the sub\sphinxhyphen{}intervals for the
rows and columns that are to be extracted.
\end{quote}

\sphinxcode{\sphinxupquote{MV = gf\_spmat\_get(spmat S, \textquotesingle{}mult\textquotesingle{}, vec V)}}
\begin{quote}

Product of the sparse matrix \sphinxtitleref{M} with a vector \sphinxtitleref{V}.

For matrix\sphinxhyphen{}matrix multiplications, see gf\_spmat(‘mult’).
\end{quote}

\sphinxcode{\sphinxupquote{MtV = gf\_spmat\_get(spmat S, \textquotesingle{}tmult\textquotesingle{}, vec V)}}
\begin{quote}

Product of \sphinxtitleref{M} transposed (conjugated if \sphinxtitleref{M} is complex) with the
vector \sphinxtitleref{V}.
\end{quote}

\sphinxcode{\sphinxupquote{D = gf\_spmat\_get(spmat S, \textquotesingle{}diag\textquotesingle{}{[}, list E{]})}}
\begin{quote}

Return the diagonal of \sphinxtitleref{M} as a vector.

If \sphinxtitleref{E} is used, return the sub\sphinxhyphen{}diagonals whose ranks are given in E.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_spmat\_get(spmat S, \textquotesingle{}storage\textquotesingle{})}}
\begin{quote}

Return the storage type currently used for the matrix.

The storage is returned as a string, either ‘CSC’ or ‘WSC’.
\end{quote}

\sphinxcode{\sphinxupquote{\{ni,nj\} = gf\_spmat\_get(spmat S, \textquotesingle{}size\textquotesingle{})}}
\begin{quote}

Return a vector where \sphinxtitleref{ni} and \sphinxtitleref{nj} are the dimensions of the matrix.
\end{quote}

\sphinxcode{\sphinxupquote{b = gf\_spmat\_get(spmat S, \textquotesingle{}is\_complex\textquotesingle{})}}
\begin{quote}

Return 1 if the matrix contains complex values.
\end{quote}

\sphinxcode{\sphinxupquote{\{JC, IR\} = gf\_spmat\_get(spmat S, \textquotesingle{}csc\_ind\textquotesingle{})}}
\begin{quote}

Return the two usual index arrays of CSC storage.

If \sphinxtitleref{M} is not stored as a CSC matrix, it is converted into CSC.
\end{quote}

\sphinxcode{\sphinxupquote{V = gf\_spmat\_get(spmat S, \textquotesingle{}csc\_val\textquotesingle{})}}
\begin{quote}

Return the array of values of all non\sphinxhyphen{}zero entries of \sphinxtitleref{M}.

If \sphinxtitleref{M} is not stored as a CSC matrix, it is converted into CSC.
\end{quote}

\sphinxcode{\sphinxupquote{\{N, U0\} = gf\_spmat\_get(spmat S, \textquotesingle{}dirichlet nullspace\textquotesingle{}, vec R)}}
\begin{quote}

Solve the dirichlet conditions \sphinxtitleref{M.U=R}.

A solution \sphinxtitleref{U0} which has a minimum L2\sphinxhyphen{}norm is returned, with a
sparse matrix \sphinxtitleref{N} containing an orthogonal basis of the kernel of
the (assembled) constraints matrix \sphinxtitleref{M} (hence, the PDE linear system
should be solved on this subspace): the initial problem

\sphinxtitleref{K.U = B} with constraints \sphinxtitleref{M.U = R}

is replaced by

\sphinxtitleref{(N’.K.N).UU = N’.B} with \sphinxtitleref{U = N.UU + U0}
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_get(spmat S, \textquotesingle{}save\textquotesingle{}, string format, string filename)}}
\begin{quote}

Export the sparse matrix.

the format of the file may be ‘hb’ for Harwell\sphinxhyphen{}Boeing, or ‘mm’
for Matrix\sphinxhyphen{}Market.
\end{quote}

\sphinxcode{\sphinxupquote{s = gf\_spmat\_get(spmat S, \textquotesingle{}char\textquotesingle{})}}
\begin{quote}

Output a (unique) string representation of the spmat.

This can be used to perform comparisons between two
different spmat objects.
This function is to be completed.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_get(spmat S, \textquotesingle{}display\textquotesingle{})}}
\begin{quote}

displays a short summary for a spmat object.
\end{quote}

\sphinxcode{\sphinxupquote{\{mantissa\_r, mantissa\_i, exponent\} = gf\_spmat\_get(spmat S, \textquotesingle{}determinant\textquotesingle{})}}
\begin{quote}

returns the matrix determinant calculated using MUMPS.
\end{quote}
\end{quote}


\section{gf\_spmat\_set}
\label{\detokenize{matlab_octave/cmdref_gf_spmat_set:gf-spmat-set}}\label{\detokenize{matlab_octave/cmdref_gf_spmat_set::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{list} \PYG{n}{I}\PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{list} \PYG{n}{J}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scale}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{scalar} \PYG{n}{v}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transpose}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{conjugate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{transconj}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{to\PYGZus{}csc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{to\PYGZus{}wsc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{to\PYGZus{}complex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diag}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{D} \PYG{p}{[}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{E}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{assign}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{I}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{J}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{V}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}spmat\PYGZus{}set}\PYG{p}{(}\PYG{n}{spmat} \PYG{n}{S}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{add}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{I}\PYG{p}{,} \PYG{n}{ivec} \PYG{n}{J}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{V}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Modification of the content of a getfem sparse matrix.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}clear\textquotesingle{}{[}, list I{[}, list J{]}{]})}}
\begin{quote}

Erase the non\sphinxhyphen{}zero entries of the matrix.

The optional arguments \sphinxtitleref{I} and \sphinxtitleref{J} may be specified to clear a
sub\sphinxhyphen{}matrix instead of the entire matrix.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}scale\textquotesingle{}, scalar v)}}
\begin{quote}

Multiplies the matrix by a scalar value \sphinxtitleref{v}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}transpose\textquotesingle{})}}
\begin{quote}

Transpose the matrix.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}conjugate\textquotesingle{})}}
\begin{quote}

Conjugate each element of the matrix.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}transconj\textquotesingle{})}}
\begin{quote}

Transpose and conjugate the matrix.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}to\_csc\textquotesingle{})}}
\begin{quote}

Convert the matrix to CSC storage.

CSC storage is recommended for matrix\sphinxhyphen{}vector multiplications.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}to\_wsc\textquotesingle{})}}
\begin{quote}

Convert the matrix to WSC storage.

Read and write operation are quite fast with WSC storage.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}to\_complex\textquotesingle{})}}
\begin{quote}

Store complex numbers.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}diag\textquotesingle{}, mat D {[}, ivec E{]})}}
\begin{quote}

Change the diagonal (or sub\sphinxhyphen{}diagonals) of the matrix.

If \sphinxtitleref{E} is given, \sphinxtitleref{D} might be a matrix and each column of \sphinxtitleref{E} will
contain the sub\sphinxhyphen{}diagonal number that will be filled with the
corresponding column of \sphinxtitleref{D}.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}assign\textquotesingle{}, ivec I, ivec J, mat V)}}
\begin{quote}

Copy V into the sub\sphinxhyphen{}matrix ‘M(I,J)’.

\sphinxtitleref{V} might be a sparse matrix or a full matrix.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_spmat\_set(spmat S, \textquotesingle{}add\textquotesingle{}, ivec I, ivec J, mat V)}}
\begin{quote}

Add \sphinxtitleref{V} to the sub\sphinxhyphen{}matrix ‘M(I,J)’.

\sphinxtitleref{V} might be a sparse matrix or a full matrix.
\end{quote}
\end{quote}


\section{gf\_util}
\label{\detokenize{matlab_octave/cmdref_gf_util:gf-util}}\label{\detokenize{matlab_octave/cmdref_gf_util::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}util}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{save matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{FMT}\PYG{p}{,} \PYG{n}{string} \PYG{n}{FILENAME}\PYG{p}{,} \PYG{n}{mat} \PYG{n}{A}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{gf\PYGZus{}util}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{load matrix}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{string} \PYG{n}{FMT}\PYG{p}{,} \PYG{n}{string} \PYG{n}{FILENAME}\PYG{p}{)}
\PYG{n}{tl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}util}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{trace level}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{[}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{level}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{tl} \PYG{o}{=} \PYG{n}{gf\PYGZus{}util}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{warning level}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{level}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Performs various operations which do not fit elsewhere.
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_util(\textquotesingle{}save matrix\textquotesingle{}, string FMT, string FILENAME, mat A)}}
\begin{quote}

Exports a sparse matrix into the file named FILENAME, using
Harwell\sphinxhyphen{}Boeing (FMT=’hb’) or Matrix\sphinxhyphen{}Market (FMT=’mm’) formatting.
\end{quote}

\sphinxcode{\sphinxupquote{A = gf\_util(\textquotesingle{}load matrix\textquotesingle{}, string FMT, string FILENAME)}}
\begin{quote}

Imports a sparse matrix from a file.
\end{quote}

\sphinxcode{\sphinxupquote{tl = gf\_util(\textquotesingle{}trace level\textquotesingle{} {[}, int level{]})}}
\begin{quote}

Set the verbosity of some GetFEM routines.

Typically the messages printed by the model bricks, 0 means no
trace message (default is 3). if no level is given,
the current trace level is returned.
\end{quote}

\sphinxcode{\sphinxupquote{tl = gf\_util(\textquotesingle{}warning level\textquotesingle{}, int level)}}
\begin{quote}

Filter the less important warnings displayed by getfem.

0 means no warnings, default level is 3. if no level is given,
the current warning level is returned.
\end{quote}
\end{quote}


\section{gf\_workspace}
\label{\detokenize{matlab_octave/cmdref_gf_workspace:gf-workspace}}\label{\detokenize{matlab_octave/cmdref_gf_workspace::doc}}
\sphinxstylestrong{Synopsis}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{push}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pop}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}  \PYG{p}{[}\PYG{p}{,}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{stat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{stats}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keep}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{[}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keep all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clear}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{clear all}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gf\PYGZus{}workspace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{class name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstylestrong{Description :}
\begin{quote}

Getfem workspace management function.

Getfem uses its own workspaces in Matlab, independently of the
matlab workspaces (this is due to some limitations in the memory
management of matlab objects). By default, all getfem variables
belong to the root getfem workspace. A function can create its own
workspace by invoking gf\_workspace(‘push’) at its beginning. When
exiting, this function MUST invoke gf\_workspace(‘pop’) (you can
use matlab exceptions handling to do this cleanly when the
function exits on an error).
\end{quote}

\sphinxstylestrong{Command list :}
\begin{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}push\textquotesingle{})}}
\begin{quote}

Create a new temporary workspace on the workspace stack.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}pop\textquotesingle{},  {[},i,j, ...{]})}}
\begin{quote}

Leave the current workspace, destroying all getfem objects
belonging to it, except the one listed after ‘pop’, and the ones
moved to parent workspace by gf\_workspace(‘keep’).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}stat\textquotesingle{})}}
\begin{quote}

Print informations about variables in current workspace.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}stats\textquotesingle{})}}
\begin{quote}

Print informations about all getfem variables.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}keep\textquotesingle{}, i{[},j,k...{]})}}
\begin{quote}

prevent the listed variables from being deleted when
gf\_workspace(“pop”) will be called by moving these variables in the
parent workspace.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}keep all\textquotesingle{})}}
\begin{quote}

prevent all variables from being deleted when
gf\_workspace(“pop”) will be called by moving the variables in the
parent workspace.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}clear\textquotesingle{})}}
\begin{quote}

Clear the current workspace.
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}clear all\textquotesingle{})}}
\begin{quote}

Clear every workspace, and returns to the main workspace (you
should not need this command).
\end{quote}

\sphinxcode{\sphinxupquote{gf\_workspace(\textquotesingle{}class name\textquotesingle{}, i)}}
\begin{quote}

Return the class name of object i (if I is a mesh handle, it
return gfMesh etc..)
\end{quote}
\end{quote}


\chapter{\sphinxstyleemphasis{GetFEM} OO\sphinxhyphen{}commands}
\label{\detokenize{matlab_octave/oocmd:gfm-oo-commands}}\label{\detokenize{matlab_octave/oocmd:mlab-oocmd}}\label{\detokenize{matlab_octave/oocmd::doc}}
The toolbox comes with a set of \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} objects \sphinxhref{http://www.mathworks.com/products/matlab/object\_oriented\_programming.htm}{mathworks\sphinxhyphen{}oo}, (look at the
\sphinxcode{\sphinxupquote{@gf*}} sub\sphinxhyphen{}directories in the toolbox directory). These object are no more
than the getfem object handles, which are flagged by \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} as objects.

In order to use these objects, you have to call their constructors: \sphinxcode{\sphinxupquote{gfMesh}},
\sphinxcode{\sphinxupquote{gfMeshFem}}, \sphinxcode{\sphinxupquote{gfGeoTrans}}, \sphinxcode{\sphinxupquote{gfFem}}, \sphinxcode{\sphinxupquote{gfInteg}}.  These constructor just
call the corresponding \sphinxstyleemphasis{GetFEM} function (i.e.  \sphinxcode{\sphinxupquote{gf\_mesh}}, \sphinxcode{\sphinxupquote{gf\_mesh\_fem}}, …),
and convert the structure returned by these function into a \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} object. There
is also a \sphinxcode{\sphinxupquote{gfObject}} function which converts any getfem handle into the
corresponding \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} object.

With such object, the most interesting feature is that you do not have to call
the “long” functions names \sphinxcode{\sphinxupquote{gf\_mesh\_fem\_get(obj,...)}},
\sphinxcode{\sphinxupquote{gf\_slice\_set(obj,...)}} etc., instead you just call the shorter
\sphinxcode{\sphinxupquote{get(obj,...)}} or \sphinxcode{\sphinxupquote{set(obj,...)}} whatever the type of \sphinxcode{\sphinxupquote{obj}} is.

A small number of “pseudo\sphinxhyphen{}properties” are also defined on these objects, for
example if \sphinxcode{\sphinxupquote{m}} is a \sphinxcode{\sphinxupquote{gfMesh}} object, you can use directly \sphinxcode{\sphinxupquote{m.nbpts}} instead
of \sphinxcode{\sphinxupquote{get(m, \textquotesingle{}nbpts\textquotesingle{})}}.

As an example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZpc{} classical creation of a mesh object}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{=}\PYG{n}{gf\PYGZus{}mesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{load\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{many\PYGZus{}element.mesh\PYGZus{}fem\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m} \PYG{p}{=}
     \PYG{n}{id}\PYG{p}{:} \PYG{l+m+mi}{2}
    \PYG{n}{cid}\PYG{p}{:} \PYG{l+m+mi}{0}
\PYG{c}{\PYGZpc{} conversion to a matlab object. the display function is overloaded for gfMesh.}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mm}\PYG{p}{=}\PYG{n}{gfMesh}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\PYG{n}{gfMesh} \PYG{l+s}{object} \PYG{l+s}{ID=2} \PYG{l+s}{[11544} \PYG{l+s}{bytes],} \PYG{l+s}{dim=3,} \PYG{l+s}{nbpts=40,} \PYG{l+s}{nbcvs=7}
\PYG{c}{\PYGZpc{} direct creation of a gfMesh object. Arguments are the same than those of gf\PYGZus{}mesh}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{=}\PYG{n}{gfMesh}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{load\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{many\PYGZus{}element.mesh\PYGZus{}fem\PYGZsq{}}\PYG{p}{)}
\PYG{n}{gfMesh} \PYG{l+s}{object} \PYG{l+s}{ID=3} \PYG{l+s}{[11544} \PYG{l+s}{bytes],} \PYG{l+s}{dim=3,} \PYG{l+s}{nbpts=40,} \PYG{l+s}{nbcvs=7}
\PYG{c}{\PYGZpc{} get(m, \PYGZsq{}pid\PYGZus{}from\PYGZus{}cvid\PYGZsq{}) is redirected to gf\PYGZus{}mesh\PYGZus{}get(m,\PYGZsq{}pid from cvid\PYGZsq{})}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{get}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{pid\PYGZus{}from\PYGZus{}cvid\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n+nb}{ans} \PYG{p}{=}
     \PYG{n}{8}     \PYG{l+s}{9}    \PYG{l+s}{11}    \PYG{l+s}{15}    \PYG{l+s}{17}    \PYG{l+s}{16}    \PYG{l+s}{18}    \PYG{l+s}{10}    \PYG{l+s}{12}
\PYG{c}{\PYGZpc{} m.nbpts is directly translated into gf\PYGZus{}mesh\PYGZus{}get(m,\PYGZsq{}nbpts\PYGZsq{})}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{m}\PYG{p}{.}\PYG{n}{nbpts}
\PYG{n+nb}{ans} \PYG{p}{=}
    \PYG{n}{40}

\PYG{l+s}{\PYGZgt{}\PYGZgt{}} \PYG{l+s}{mf=gfMeshFem(}\PYG{l+s}{\PYGZsq{}load\PYGZsq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZsq{}many\PYGZus{}element.mesh\PYGZus{}fem\PYGZsq{}}\PYG{l+s}{)}
\PYG{n}{gfMeshFem} \PYG{l+s}{object:} \PYG{l+s}{ID=5} \PYG{l+s}{[1600} \PYG{l+s}{bytes],} \PYG{l+s}{qdim=1,} \PYG{l+s}{nbdof=99,}
  \PYG{n}{linked} \PYG{l+s}{gfMesh} \PYG{l+s}{object:} \PYG{l+s}{dim=3,} \PYG{l+s}{nbpts=40,} \PYG{l+s}{nbcvs=7}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{mesh}
\PYG{n}{gfMesh} \PYG{l+s}{object} \PYG{l+s}{ID=4} \PYG{l+s}{[11544} \PYG{l+s}{bytes],} \PYG{l+s}{dim=3,} \PYG{l+s}{nbpts=40,} \PYG{l+s}{nbcvs=7}
\PYG{c}{\PYGZpc{} accessing the linked mesh object}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{mesh}\PYG{p}{.}\PYG{n}{nbpts}
\PYG{n+nb}{ans} \PYG{p}{=}
    \PYG{n}{40}
\PYG{l+s}{\PYGZgt{}\PYGZgt{}} \PYG{l+s}{get(mf.mesh,} \PYG{l+s}{\PYGZsq{}pid\PYGZus{}from\PYGZus{}cvid\PYGZsq{}}\PYG{l+s}{,} \PYG{l+s}{3)}
\PYG{n+nb}{ans} \PYG{p}{=}
     \PYG{n}{8}     \PYG{l+s}{9}    \PYG{l+s}{11}    \PYG{l+s}{15}    \PYG{l+s}{17}    \PYG{l+s}{16}    \PYG{l+s}{18}    \PYG{l+s}{10}    \PYG{l+s}{12}

\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{nbdof}
\PYG{n+nb}{ans} \PYG{p}{=}
    \PYG{n}{99}

\PYG{l+s}{\PYGZpc{}} \PYG{l+s}{access} \PYG{l+s}{to} \PYG{l+s}{fem} \PYG{l+s}{of} \PYG{l+s}{convex} \PYG{l+s}{1}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{fem}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{gfFem} \PYG{l+s}{object} \PYG{l+s}{ID=0} \PYG{l+s}{dim=2,} \PYG{l+s}{target\PYGZus{}dim=1,} \PYG{l+s}{nbdof=9,[EQUIV,} \PYG{l+s}{POLY,} \PYG{l+s}{LAGR],} \PYG{l+s}{est.degree=4}
 \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{FEM\PYGZus{}QK}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{mf}\PYG{p}{.}\PYG{n}{mesh}\PYG{p}{.}\PYG{n}{geotrans}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{gfGeoTrans} \PYG{l+s}{object} \PYG{l+s}{ID=} \PYG{l+s}{0} \PYG{l+s}{dim=2,} \PYG{l+s}{nbpts=} \PYG{l+s}{6} \PYG{l+s}{:} \PYG{l+s}{GT\PYGZus{}PK(2,2)}
\end{sphinxVerbatim}

Although this interface seems more convenient, you must be aware that this always
induce a call to a mex\sphinxhyphen{}file, and additional \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} code:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tic}\PYG{p}{;} \PYG{n+nb}{j}\PYG{p}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{for} \PYG{l+s}{i=1:1000,} \PYG{l+s}{j=j+mf.nbdof}\PYG{p}{;} \PYG{k}{end}\PYG{p}{;} \PYG{n}{toc}
\PYG{l+s}{elapsed\PYGZus{}time} \PYG{l+s}{=}
    \PYG{l+m+mf}{0.6060}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tic}\PYG{p}{;} \PYG{n+nb}{j}\PYG{p}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{for} \PYG{l+s}{i=1:1000,} \PYG{l+s}{j=j+gf\PYGZus{}mesh\PYGZus{}fem\PYGZus{}get(mf,}\PYG{l+s}{\PYGZsq{}nbdof\PYGZsq{}}\PYG{l+s}{)}\PYG{p}{;} \PYG{k}{end}\PYG{p}{;} \PYG{n}{toc}
\PYG{l+s}{elapsed\PYGZus{}time} \PYG{l+s}{=}
    \PYG{l+m+mf}{0.1698}
\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{tic}\PYG{p}{;} \PYG{n+nb}{j}\PYG{p}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{n}\PYG{p}{=}\PYG{n}{mf}\PYG{p}{.}\PYG{n}{nbdof}\PYG{p}{;}  \PYG{n}{for} \PYG{l+s}{i=1:1000,} \PYG{l+s}{j=j+n}\PYG{p}{;} \PYG{k}{end}\PYG{p}{;} \PYG{n}{toc}
\PYG{l+s}{elapsed\PYGZus{}time} \PYG{l+s}{=}
    \PYG{l+m+mf}{0.0088}
\end{sphinxVerbatim}

Hence you should always try to store data in \sphinxstyleemphasis{Octave} / \sphinxstyleemphasis{MatLab} arrays instead of
repetitively calling the getfem functions.

Avalaible object types are \index{gfCvStruct@\spxentry{gfCvStruct}}\index{environment variable@\spxentry{environment variable}!gfCvStruct@\spxentry{gfCvStruct}}\sphinxcode{\sphinxupquote{gfCvStruct}}, \index{gfGeoTrans@\spxentry{gfGeoTrans}}\index{environment variable@\spxentry{environment variable}!gfGeoTrans@\spxentry{gfGeoTrans}}\sphinxcode{\sphinxupquote{gfGeoTrans}},
\index{gfEltm@\spxentry{gfEltm}}\index{environment variable@\spxentry{environment variable}!gfEltm@\spxentry{gfEltm}}\sphinxcode{\sphinxupquote{gfEltm}}, \index{gfInteg@\spxentry{gfInteg}}\index{environment variable@\spxentry{environment variable}!gfInteg@\spxentry{gfInteg}}\sphinxcode{\sphinxupquote{gfInteg}}, \index{gfFem@\spxentry{gfFem}}\index{environment variable@\spxentry{environment variable}!gfFem@\spxentry{gfFem}}\sphinxcode{\sphinxupquote{gfFem}}, \index{gfMesh@\spxentry{gfMesh}}\index{environment variable@\spxentry{environment variable}!gfMesh@\spxentry{gfMesh}}\sphinxcode{\sphinxupquote{gfMesh}},
\index{gfMeshFem@\spxentry{gfMeshFem}}\index{environment variable@\spxentry{environment variable}!gfMeshFem@\spxentry{gfMeshFem}}\sphinxcode{\sphinxupquote{gfMeshFem}}, \index{gfMeshIm@\spxentry{gfMeshIm}}\index{environment variable@\spxentry{environment variable}!gfMeshIm@\spxentry{gfMeshIm}}\sphinxcode{\sphinxupquote{gfMeshIm}}, \index{gfMdBrick@\spxentry{gfMdBrick}}\index{environment variable@\spxentry{environment variable}!gfMdBrick@\spxentry{gfMdBrick}}\sphinxcode{\sphinxupquote{gfMdBrick}},
\index{gfMdState@\spxentry{gfMdState}}\index{environment variable@\spxentry{environment variable}!gfMdState@\spxentry{gfMdState}}\sphinxcode{\sphinxupquote{gfMdState}}, \index{gfModel@\spxentry{gfModel}}\index{environment variable@\spxentry{environment variable}!gfModel@\spxentry{gfModel}}\sphinxcode{\sphinxupquote{gfModel}}, \index{gfSpmat@\spxentry{gfSpmat}}\index{environment variable@\spxentry{environment variable}!gfSpmat@\spxentry{gfSpmat}}\sphinxcode{\sphinxupquote{gfSpmat}}, \index{gfPrecond@\spxentry{gfPrecond}}\index{environment variable@\spxentry{environment variable}!gfPrecond@\spxentry{gfPrecond}}\sphinxcode{\sphinxupquote{gfPrecond}},
and \index{gfSlice@\spxentry{gfSlice}}\index{environment variable@\spxentry{environment variable}!gfSlice@\spxentry{gfSlice}}\sphinxcode{\sphinxupquote{gfSlice}}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}