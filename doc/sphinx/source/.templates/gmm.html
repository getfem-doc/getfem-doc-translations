{% extends "layout.html" %}
{% set title = 'Gmm++ HomePage' %}
{% set dlbase = 'dist' %}
{% block body %}

<div id="biglogo"><img src="{{ pathto("_static/gmmlogo.png", 1) }}" alt="Gmm++ logo"></div>

    <h1>{%trans%}Gmm++ Documentation{%endtrans%}</h1>
    <p>
      <p class="biglink">
       	<a class="biglink" href="{{ pathto("gmm/index") }}">{%trans%}Gmm++ Documentation is here (html version){%endtrans%}</a><br/></p>
    </p>

    <h1>{%trans%}Download Gmm++{%endtrans%}</h1>
    <p>
      {%trans%}The last stable release of the standalone Gmm++ library can be found in the{%endtrans%}
         <a class="biglink" href="{{ pathto("download") }}">download</a>
      {%trans%}page of {{ project }}.{%endtrans%}
    </p>


<h1>What is Gmm++</h1>


    <p>
      {%trans%}
      <abbr title="Generic Matrix Methods">Gmm++</abbr> is a
      generic C++ template library for sparse, dense and skyline
      matrices. It is a set of generic algorithms (mult, add,
      copy, sub-matrices, dense and sparse solvers ...) for any
      interfaced vector type or matrix type. It can be view as a glue
      library allowing cooperation between several vector and matrix
      types. However, basic sparse, dense and skyline matrix/vector types are built
      in Gmm++, hence it can be used as a standalone linear algebra
      library.
      {%endtrans%}

      {%trans%}
      Interfacing a vector or matrix type means writing "traits" objects called
      "<code>linalg_traits</code>", which describe their properties. The library
      offers predefined dense, sparse and skyline matrix types.
      {%endtrans%}
    </p>
    <p>
      {%trans%}
      The goal is to create a general, adaptable and easy to use
      framework of pre-defined methods for matrix computation. When a
      vector or a matrix type has been interfaced (i.e. its
      <code>linalg_traits</code> has been filled), all generic algorithms works on
      it. However, it is always possible (and easy) to specialize some
      generic algorithms for efficiency reason. Major generic
      algorithms are
      {%endtrans%}
    </p>
      <ul>
	<li>{%trans%} A set of miscellaneous generic commands (clear, clean,
	scalar product, scale, norms, ...){%endtrans%}</li> 
	
	<li>{%trans%} Vector-Vector addition with the possibility to mix
	formats (sparse, dense, skyline){%endtrans%}</li>
	
	<li>{%trans%} Matrix-Vector mult for any format.{%endtrans%}</li>

	<li>{%trans%} Matrix-Matrix mult with the possibility to mix formats
	(sparse, dense, skyline, row major, column major, ...){%endtrans%}</li>

	<li>{%trans%} Generic linear solvers (<abbr
	title="Conjugate Gradient">cg</abbr>, <abbr
	title="bi-Conjugated Gradient">bicgstag</abbr>, <abbr
	title="Quasi-Minimal Residual Method">qmr</abbr>, <abbr title="Generalized Minimum Residual Method">gmres</abbr> ...) with preconditioners for sparse matrices
	(<abbr title="Incomplete LU factorization with fill-in and threshold">ILUT</abbr>, <abbr title="Incomplete LU factorization with fill-in, threshold and column pivoting">ILUTP</abbr>, <abbr title="Incomplete LDLT factorization">ILDLT</abbr>, ...). Some of them are imported form <a href="http://www.osl.iu.edu/research/itl/" title="Iterative Template Library">ITL</a> (eventually corrected and optimized), some of them are new. {%endtrans%}</li>



	<li> {%trans%}Reference to sub-matrices (with sub-interval, sub-slice
	or sub-index) for any sparse dense or skyline matrix for read
	or write operations.{%endtrans%}</li>
	
	<li> {%trans%}LU and QR factorizations for dense matrices.{%endtrans%}</li>
	
	<li> {%trans%}Eigenvalues computation for dense matrices.{%endtrans%}</li>
      </ul>
    <p>
      {%trans%}
      The structure of Gmm++ is largely inspired from <a
      href="http://www.osl.iu.edu/research/mtl/" title="Matrix Template Library">MTL</a>. The major
      differences are : simpler use, built as an interface for existing
      matrix types, sub-matrices for any matrix types. The efficiency
      is comparable (see <a href="http://grh.mur.at/misc/sparselib_benchmark/">
      http://grh.mur.at/misc/sparselib_benchmark/</a> for instance).
      {%endtrans%}
    </p>

    <p>
      {%trans%}
      NOTE : For performance reason, an interface with <a
      href="http://www.netlib.org/lapack/">LAPACK</a> or <a
      href="http://math-atlas.sourceforge.net/" title="Automatically Tuned Linear Algebra Software">ATLAS</a> is provided
      for dense matrices. See the <a href="http://getfem.org/gmm.html">documentation</a> (if you make some
      benchmarks, do not forget to use optimization compiler options,
      at least -O3 and you should disable checks with
      -dNDEBUG).
      {%endtrans%}
    </p>
    
    <p>
      {%trans%}
      A small interface to <a
      href="http://crd.lbl.gov/~xiaoye/SuperLU/">SuperLU 3.0</a>
      (sparse matrix direct solver) is also proposed for sparse
      matrices.
      {%endtrans%}
    </p>

    <p>
      {%trans%}
      Gmm++ has been tested with
      <a href="http://www.cs.berkeley.edu/~yozo">QD</a>
      an
      efficient library for double double and quadruple double
      precision. See on the documentation how to link QD. This means
      that Gmm++ should work with any reasonable arbitrary precision
      floating point library.
      {%endtrans%}
    </p>

    <h1>{%trans%}Licence{%endtrans%}</h1> 
    {%trans%}
    Gmm++ is freely distributed under the terms of the
    <a href="http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html">
      Gnu Lesser General Public License, either version 2.1 of the license or any later version</a>.
    {%endtrans%}

    <h1>{%trans%}Contribute to Gmm++{%endtrans%}</h1>
    <p>
      {%trans%}
      Gmm++ offers a framework to develop efficient methods for linear algebra. This library is and will remain open-source. Here are some examples of possible extensions:
      {%endtrans%}
    </p>
      <ul>
	<li>{%trans%}Specialize some algorithms to optimize them for particular matrix implementation.{%endtrans%}</li>
	<li>{%trans%}New solvers and preconditioners.{%endtrans%}</li>
	<li>{%trans%}Eigenvalues computation for sparse matrices. {%endtrans%}</li>
	<li>{%trans%} ...{%endtrans%}</li>
      </ul>

    <h1>{%trans%}Gmm++ contributors{%endtrans%}</h1>
    <p>
       {%trans%}
       Yves Renard, Julien Pommier, Michel Fournie (Additive Schwarz), Benjamin Schleimer (least square CG).
       {%endtrans%}
    </p>
    <p>
       {%trans%}
       Many thanks to Jeremy G. Siek and Lie-Quan Lee for their nice work developing MTL-ITL on which Gmm++ is greatly inspired.
       {%endtrans%}
    </p>

    <h1>{%trans%}Random test procedures{%endtrans%}</h1>
    <p>
      {%trans%}
      A problem with generic programming is to be sure that every
      configuration has been fully tested. This is why there is now
      a random generator of
      tests. This means that a number of test procedures will
      be called with random parameters, i.e. random type of vector,
      sub-vector, matrix or sub-matrix types, with random base type
      (float, double, long double, std::complex&lt;float&gt;,
      std::complex&lt;double&gt;, dd_real ...) and random size and filling, testing all
      the possibilities of mixing formats in operations such as mult,
      add ...
      {%endtrans%}
    </p>
    
    <p> 
      {%trans%}
      You are encouraged to test them, runing a "make
      check" on the distribution of Gmm++ and sending us a bug report
      if it fails. We will also appreciate if you send us new test
      procedures.
      {%endtrans%}
    </p>



{% endblock %}
