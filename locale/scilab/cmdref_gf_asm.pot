# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2018 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-20 02:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/scilab/cmdref_gf_asm.rst:8
# 84df91a9d96e41d6a1ef2cd9d398e0e3
msgid "gf_asm"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:10
# 5043efa5ad6347d2b8f59f96feeb2149
msgid "**Synopsis**"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:41
# 19b8efe4f3434a82862bc308f719e5b1
msgid "**Description :**"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:45
# f15c4dea94bd4a61b9ce543774a9165b
msgid "General assembly function."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:47
# a38824dddd874f12b14973ae5eeac629
msgid "Many of the functions below use more than one mesh_fem: the main mesh_fem (mf_u) used for the main unknown, and data mesh_fem (mf_d) used for the data. It is always assumed that the Qdim of mf_d is equal to 1: if mf_d is used to describe vector or tensor data, you just have to \"stack\" (in fortran ordering) as many scalar fields as necessary."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:55
# a82fa91fb5b94f66a31f5869e34ebedd
msgid "**Command list :**"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:59
# 355fda80b2b444559fdf4e49060ca472
msgid "``{...} = gf_asm('generic', mesh_im mim, int order, string expression, int region, [model model, ['Secondary_domain', 'name',]] [string varname, int is_variable[, {mesh_fem mf, mesh_imd mimd}], value], ['select_output', 'varname1'[, 'varname2]], ...)``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:61
# 72e8224d255241de835b7f318b38079c
msgid "High-level generic assembly procedure for volumic or boundary assembly."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:63
# 6dd2acc4dde846d2bd947e7ffa90081e
msgid "Performs the generic assembly of <literal>expression</literal> with the integration method <literal>mim</literal> on the mesh region of index <literal>region</literal> (-1 means all elements of the mesh). The same mesh should be shared by the integration method and all the finite element methods or mesh_im_data corresponding to the variables."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:69
# 5a8d9d82e3674cdaa16fb3539d8e9719
msgid "<literal>order</literal> indicates either that the (scalar) potential (order = 0) or the (vector) residual (order = 1) or the tangent (matrix) (order = 2) is to be computed."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:73
# 2f997335880149d5b45f7355fbfc6807
msgid "<literal>model</literal> is an optional parameter allowing to take into account all variables and data of a model. Note that all enabled variables of the model will occupy space in the returned vector/matrix corresponding to their degrees of freedom in the global system, even if they are not present in <literal>expression</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:79
# 59fc8bc850264c5284b071753934be5f
msgid "The variables and constants (data) are listed after the region number (or optionally the model). For each variable/constant, a name must be given first (as it is referred in the assembly string), then an integer equal to 1 or 0 is expected respectively for declaring a variable or a constant, then the finite element method if it is a fem variable/constant or the mesh_im_data if it is data defined on integration points, and the vector representing the value of the variable/constant. It is possible to give an arbitrary number of variable/constant. The difference between a variable and a constant is that test functions are only available for variables, not for constants."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:91
# 4cb4ba7ea7114845a6f2a092645d8250
msgid "<literal>select_output</literal> is an optional parameter which allows to reduce the output vecotr (for <literal>order</literal> equal to 1) or the matrix (for <literal>order</literal> equal to 2) to the degrees of freedom of the specified variables. One variable has to be specified for a vector ouptut and two for a matrix output."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:97
# 8c694b1ad37948c8ac46a304036a3b5c
msgid "Note that if several variables are given, the assembly of the tangent matrix/residual vector will be done considering the order in the call of the function (the degrees of freedom of the first variable, then of the second one, and so on). If a model is provided, all degrees of freedom of the model will be counted first, even if some of the model variables do not appear in <literal>expression</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:104
# 2e85cc0e12d641718922ed6e7b456996
msgid "For example, the L2 norm of a vector field \"u\" can be computed with::"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:110
# 93aa9ccd2b464442834bd46da555f5dd
msgid "The nonhomogeneous Laplacian stiffness matrix of a scalar field can be evaluated with::"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:119
# e5be6da277f2412f8fbe9cadf5e2b211
msgid "``M = gf_asm('mass matrix', mesh_im mim, mesh_fem mf1[, mesh_fem mf2[, int region]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:121
# fae7c4cebabb47279024185e017e45b3
msgid "Assembly of a mass matrix."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:123
#: ../source/scilab/cmdref_gf_asm.rst:133
#: ../source/scilab/cmdref_gf_asm.rst:144
#: ../source/scilab/cmdref_gf_asm.rst:191
#: ../source/scilab/cmdref_gf_asm.rst:201
#: ../source/scilab/cmdref_gf_asm.rst:211
#: ../source/scilab/cmdref_gf_asm.rst:273
#: ../source/scilab/cmdref_gf_asm.rst:406
#: ../source/scilab/cmdref_gf_asm.rst:414
#: ../source/scilab/cmdref_gf_asm.rst:422
# 42b671bc704a431498a585a862dca470
# cb63164fcf52498e8e22a5929b41dc83
# fd0a2d01c8ca4195aa05f072cdc44af4
# 11414941457144f68933ab2e11058152
# f7bedaaab9884f86bbb93ef79d3b92a4
# ce08e4c5f8e24493bb39fb70427d96aa
# 3314f5a574ef4f4a902ccb6a27c782f5
# f6988bfa13dc4d72872f60d9b8c1e6b8
# a45b8f9301774ea5bad791d4702a55d9
# dfa698588c8843f0bc1a797beabc5830
msgid "Return a spmat object."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:127
# 8c27d09c7ad74dee84cfb69a018ace3f
msgid "``L = gf_asm('laplacian', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec a[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:129
# 6fb51db6ac4a4157bc5d11e13cb94b04
msgid "Assembly of the matrix for the Laplacian problem."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:131
# 1d594a3a97b0406cab61d1b83d90cd26
msgid "<latex style=\"text\"><![CDATA[\\nabla\\cdot(a(x)\\nabla u)]]></latex>  with <literal>a</literal> a scalar."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:137
# 3df842526f984dbca5d58e66df6f4e05
msgid "``Le = gf_asm('linear elasticity', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec lambda_d, vec mu_d[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:139
# 7c563ab5ec8a4f22ab274231788397f7
msgid "Assembles of the matrix for the linear (isotropic) elasticity problem."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:141
# 70e38cbc249f40bbbeb6c82c8456282e
msgid "<latex style=\"text\"><![CDATA[\\nabla\\cdot(C(x):\\nabla u)]]></latex> with <latex style=\"text\"><![CDATA[C]]></latex> defined via <literal>lambda_d</literal> and <literal>mu_d</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:148
# 12c2c82f6ee544e7b8d0574a267dca4e
msgid "``TRHS = gf_asm('nonlinear elasticity', mesh_im mim, mesh_fem mf_u, vec U, string law, mesh_fem mf_d, mat params, {'tangent matrix'|'rhs'|'incompressible tangent matrix', mesh_fem mf_p, vec P|'incompressible rhs', mesh_fem mf_p, vec P})``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:150
# 92bbc1ff28c94a419b4f8162eee97258
msgid "Assembles terms (tangent matrix and right hand side) for nonlinear elasticity."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:152
# fd66514f8f184d0a9cfa6844095dec4b
msgid "The solution <literal>U</literal> is required at the current time-step. The <literal>law</literal> may be choosen among:"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:155
# 5a3490bca5c247a8b158c742cb5a759d
msgid "'SaintVenant Kirchhoff': Linearized law, should be avoided). This law has the two usual Lame coefficients as parameters, called lambda and mu."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:158
# 8a07533a5ff640369f40d8a9ababb3fb
msgid "'Mooney Rivlin': This law has three parameters, called C1, C2 and D1. Can be preceded with the words 'compressible' or 'incompressible' to force a specific version. By default, the incompressible version is considered which requires only the first two material coefficients."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:163
# 3a61b66e6b8f4b469e7f355ebb385a22
msgid "'neo Hookean': A special case of the 'Mooney Rivlin' law that requires one material coefficient less (C2 = 0). By default, its compressible version is used."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:166
# f4b93fc74c1a4815afd77bd69cd5edfd
msgid "'Ciarlet Geymonat': This law has 3 parameters, called lambda, mu and gamma, with gamma chosen such that gamma is in ]-lambda/2-mu, -mu[."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:170
# ae495396802d4be5aec791cc88556ace
msgid "The parameters of the material law are described on the mesh_fem <literal>mf_d</literal>. The matrix <literal>params</literal> should have <literal>nbdof(mf_d)</literal> columns, each row correspounds to a parameter."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:174
# a1e6896d84f84de894dd1af758825efe
msgid "The last argument selects what is to be built: either the tangent matrix, or the right hand side. If the incompressibility is considered, it should be followed by a mesh_fem <literal>mf_p</literal>, for the pression."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:179
# 63176bc572ac4506b0bca7ca8bb4069a
msgid "Return a spmat object (tangent matrix), vec object (right hand side), tuple of spmat objects (incompressible tangent matrix), or tuple of vec objects (incompressible right hand side)."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:185
# 39906bb7243e47279036ef9595a797c7
msgid "``A = gf_asm('helmholtz', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec k[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:187
# 41091c0463a543dd992957c616deb927
msgid "Assembly of the matrix for the Helmholtz problem."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:189
# 5f4c044bc04a40c3bc7a9f5f2ab69244
msgid "<latex style=\"text\"><![CDATA[\\Delta u + k^2 u]]></latex> = 0,  with <literal>k</literal> complex scalar."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:195
# 91ca73eb5e5840f388d3b8457fb8b9e9
msgid "``A = gf_asm('bilaplacian', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec a[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:197
# bb8eae27248942c881a85dcd180cc606
msgid "Assembly of the matrix for the Bilaplacian problem."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:199
#: ../source/scilab/cmdref_gf_asm.rst:209
# 6bac98e0babf47babb412edaa187ba35
# 8d0379df34c24c5385171e3262b5ebdb
msgid "<latex style=\"text\"><![CDATA[\\Delta(a(x)\\Delta u) = 0]]></latex>   with <literal>a</literal> scalar."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:205
# 0633bef9c0e5427cabc45328a9b84af1
msgid "``A = gf_asm('bilaplacian KL', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec a, vec nu[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:207
# d6f2c683689c49028ed20063173a1b6f
msgid "Assembly of the matrix for the Bilaplacian problem with Kirchhoff-Love formulation."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:215
# 73a2175ce95842d5b79b8db12767ea0b
msgid "``V = gf_asm('volumic source', mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec fd[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:217
# 19e7d9736e164950801055de6a265e91
msgid "Assembly of a volumic source term."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:219
# f43765bce2224b9693714c315da6c71c
msgid "Output a vector <literal>V</literal>, assembled on the mesh_fem <literal>mf_u</literal>, using the data vector <literal>fd</literal> defined on the data mesh_fem <literal>mf_d</literal>. <literal>fd</literal> may be real or complex-valued."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:223
#: ../source/scilab/cmdref_gf_asm.rst:235
#: ../source/scilab/cmdref_gf_asm.rst:387
#: ../source/scilab/cmdref_gf_asm.rst:398
# ee48ae4c22ec4a8ca7a0d4e5e61796d4
# 641d0fc80e994e4fbab6b182ed14cdb7
# 4b2bf55b8ee84d5f99d05091e00c5010
# 9389bd9558754773afab8d4163e89346
msgid "Return a vec object."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:227
# 1949ce973a3e43b19c55d88ac39233a8
msgid "``B = gf_asm('boundary source', int bnum, mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, vec G)``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:229
# 5c5458993c8142d08a5bd0d4af181171
msgid "Assembly of a boundary source term."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:231
# 591f366a556a47168e859bcb5d58a933
msgid "<literal>G</literal> should be a [Qdim x N] matrix, where N is the number of dof of <literal>mf_d</literal>, and Qdim is the dimension of the unkown u (that is set when creating the mesh_fem)."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:239
# 29eaf3d93a9d468883a26709c112e582
msgid "``{HH, RR} = gf_asm('dirichlet', int bnum, mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, mat H, vec R [, scalar threshold])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:241
# 839fd3eace1c458b8f7d6578922ec841
msgid "Assembly of Dirichlet conditions of type <literal>h.u = r</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:243
# da88c5ff13fe4186bfab8d3e11808bd8
msgid "Handle <literal>h.u = r</literal> where h is a square matrix (of any rank) whose size is equal to the dimension of the unkown u. This matrix is stored in <literal>H</literal>, one column per dof in <literal>mf_d</literal>, each column containing the values of the matrix h stored in fortran order:"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:252
# 3e824e7250344ceca2976edb9cabd6eb
msgid "if u is a 2D vector field."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:254
# a546945c9195439e92f57d0495ee96ea
msgid "Of course, if the unknown is a scalar field, you just have to set <literal>H = ones(1, N)</literal>, where N is the number of dof of <literal>mf_d</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:257
# f7cf8168372c41eeb4b2c99c172a9b81
msgid "This is basically the same than calling gf_asm('boundary qu term') for <literal>H</literal> and calling gf_asm('neumann') for <literal>R</literal>, except that this function tries to produce a 'better' (more diagonal) constraints matrix (when possible)."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:262
# 0ef056cd9501473494285e32ada7a0d0
msgid "See also gf_spmat_get(spmat S, 'Dirichlet_nullspace')."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:265
# d5306bdc2a9b446792158b8c8dfca32f
msgid "``Q = gf_asm('boundary qu term',int boundary_num, mesh_im mim, mesh_fem mf_u, mesh_fem mf_d, mat q)``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:267
# dad9b446833948a4aaf4c89829e5288c
msgid "Assembly of a boundary qu term."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:269
# 1dc6b2f624c64111a327f3bb94f9fbf5
msgid "<literal>q</literal> should be be a [Qdim x Qdim x N] array, where N is the number of dof of <literal>mf_d</literal>, and Qdim is the dimension of the unkown u (that is set when creating the mesh_fem)."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:277
# c1d080d370e34f2bbaac18c7ebf5aef9
msgid "``gf_asm('define function', string name, int nb_args, string expression[, string expression_derivative_t[, string expression_derivative_u]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:279
# 6aa6c2017c524cd291d11ff025004dc1
msgid "Define a new function <literal>name</literal> which can be used in high level generic assembly. The function can have one or two parameters. In <literal>expression</literal> all available predefined function or operation of the generic assembly can be used. However, no reference to some variables or data can be specified. The argument of the function is <literal>t</literal> for a one parameter function and <literal>t</literal> and <literal>u</literal> for a two parameter function. For instance 'sin(pi*t)+2*t*t' is a valid expression for a one parameter function and 'sin(max(t,u)*pi)' is a valid expression for a two parameters function. <literal>expression_derivative_t</literal> and <literal>expression_derivative_u</literal> are optional expressions for the derivatives with respect to <literal>t</literal> and <literal>u</literal>. If they are not furnished, a symbolic derivation is used."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:294
# e7ad1e8f2b90465492b58fc6994d7d78
msgid "``gf_asm('undefine function', string name)``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:296
# 723321987a7d460bbd38e56532df2dce
msgid "Cancel the definition of a previously defined function <literal>name</literal> for the high level generic assembly."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:300
# 2d1008cd36334dbf940dff8b1dd53565
msgid "``gf_asm('define linear hardening function', string name, scalar sigma_y0, scalar H, ... [string 'Frobenius'])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:302
# e131d27d5f4445ac9ea56154a78ec8e0
msgid "Define a new linear hardening function under the name <literal>name</literal>, with initial yield stress <literal>sigma_y0</literal> and hardening modulus H. If an extra string argument with the value 'Frobenius' is provided, the hardening function is expressed in terms of Frobenius norms of its input strain and output stress, instead of their Von-Mises equivalents."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:309
# 05ab53826d8b4399a35c6d7c9d9c3bee
msgid "``gf_asm('define Ramberg Osgood hardening function', string name, scalar sigma_ref, {scalar eps_ref | scalar E, scalar alpha}, scalar n[, string 'Frobenius'])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:311
# 71e3a5d63a5b43baa46560248afc768c
msgid "Define a new Ramberg Osgood hardening function under the name <literal>name</literal>, with initial yield stress <literal>sigma_y0</literal> and hardening modulus H. If an extra string argument with the value 'Frobenius' is provided, the hardening function is expressed in terms of Frobenius norms of its input strain and output stress, instead of their Von-Mises equivalents."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:318
# 48a45f497cb841cfa18bd49d0cf8d0a4
msgid "``gf_asm('expression analysis', string expression [, {mesh mesh | mesh_im mim}] [, der_order] [, model model] [, string varname, int is_variable[, {mesh_fem mf | mesh_imd mimd}], ...])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:320
# 0206267235c646319906c235d03b27b8
msgid "Analyse a high-level generic assembly expression and print information about the provided expression."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:324
# 66b4b75dda4946e08a79871c01db2d90
msgid "``{...} = gf_asm('volumic' [,CVLST], expr [, mesh_ims, mesh_fems, data...])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:326
# 319877b197d94c949babef9a10ffa1b2
msgid "Low-level generic assembly procedure for volumic assembly."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:328
# d8ed44c9f63d4edbaa805c3104b26fab
msgid "The expression <literal>expr</literal> is evaluated over the mesh_fem's listed in the arguments (with optional data) and assigned to the output arguments. For details about the syntax of assembly expressions, please refer to the getfem user manual (or look at the file getfem_assembling.h in the getfem++ sources)."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:334
# 7c3fc5c17a6742adbf6e2da18b6cff4d
msgid "For example, the L2 norm of a field can be computed with::"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:340
# 490b0008ffeb4247b5f93d5c89e702d7
msgid "The Laplacian stiffness matrix can be evaluated with::"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:347
# 24324ce287da46e1a585ab4d31263b4e
msgid "``{...} = gf_asm('boundary', int bnum, string expr [, mesh_im mim, mesh_fem mf, data...])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:349
# 4225cf4f7ff64063b1cceae9ccae2cd5
msgid "Low-level generic boundary assembly."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:351
# d0f7209444ac4a749d0c9521d094daa2
msgid "See the help for gf_asm('volumic')."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:354
# c20f75baa6f04ac49de5a6f51aa0ae06
msgid "``Mi = gf_asm('interpolation matrix', mesh_fem mf, {mesh_fem mfi | vec pts})``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:356
# 65287bbbf06a4f278c2975ede3459b51
msgid "Build the interpolation matrix from a mesh_fem onto another mesh_fem or a set of points."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:358
# 2c9d191278354908ba6ebb51286ecd9b
msgid "Return a matrix <literal>Mi</literal>, such that <literal>V = Mi.U</literal> is equal to gf_compute('interpolate_on',mfi). Useful for repeated interpolations. Note that this is just interpolation, no elementary integrations are involved here, and <literal>mfi</literal> has to be lagrangian. In the more general case, you would have to do a L2 projection via the mass matrix."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:365
# 19e557f4775e4af3996df8c935986f18
msgid "<literal>Mi</literal> is a spmat object."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:369
# f1c8fd315b3843219298a0b5430a4c3f
msgid "``Me = gf_asm('extrapolation matrix',mesh_fem mf,  {mesh_fem mfe | vec pts})``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:371
# 02007cfe464540d1a2d09030779455b9
msgid "Build the extrapolation matrix from a mesh_fem onto another mesh_fem or a set of points."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:373
# 8c4e6828c11a4e5b9eeb707b8443f62a
msgid "Return a matrix <literal>Me</literal>, such that <literal>V = Me.U</literal> is equal to gf_compute('extrapolate_on',mfe). Useful for repeated extrapolations."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:377
# 90bc326f7e434d44a46d0a9aac92fe07
msgid "<literal>Me</literal> is a spmat object."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:381
# aea28f8932af4983a1297c090833d6e7
msgid "``B = gf_asm('integral contact Uzawa projection', int bnum, mesh_im mim, mesh_fem mf_u, vec U, mesh_fem mf_lambda, vec vec_lambda, mesh_fem mf_obstacle, vec obstacle, scalar r [, {scalar coeff | mesh_fem mf_coeff, vec coeff} [, int option[, scalar alpha, vec W]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:385
# cb4c5846e3084d789ba3159cac479f21
msgid "Specific assembly procedure for the use of an Uzawa algorithm to solve"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:384
# d8a21691dead4ab09fb4a0f12fa383b2
msgid "contact problems. Projects the term $-(\\lambda - r (u_N-g))_-$ on the finite element space of $\\lambda$."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:391
# bd62cc366c67479baaeb92e3a16c3969
msgid "``B = gf_asm('level set normal source term', int bnum, mesh_im mim, mesh_fem mf_u, mesh_fem mf_lambda, vec vec_lambda, mesh_fem mf_levelset, vec levelset)``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:393
# 47e272bb5fcb41e28e3424ec831b3aa4
msgid "Performs an assembly of the source term represented by <literal>vec_lambda</literal> on <literal>mf_lambda</literal> considered to be a component in the direction of the gradient of a levelset function (normal to the levelset) of a vector field defined on <literal>mf_u</literal> on the boundary <literal>bnum</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:402
# ad9c5b45c7b840918b6901df2edb7857
msgid "``M = gf_asm('lsneuman matrix', mesh_im mim, mesh_fem mf1, mesh_fem mf2, levelset ls[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:404
# b01c55f8f13944deb3fe6ed2e49cb8bb
msgid "Assembly of a level set Neuman  matrix."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:410
# 84a1607df7644241881271720ade3532
msgid "``M = gf_asm('nlsgrad matrix', mesh_im mim, mesh_fem mf1, mesh_fem mf2, levelset ls[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:412
# 47bda620bf254036ad817e91876ec05e
msgid "Assembly of a nlsgrad matrix."
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:418
# 425c496c918947f7b9b7609e0cbc1efa
msgid "``M = gf_asm('stabilization patch matrix', @tm mesh, mesh_fem mf,  mesh_im mim, real ratio, real h)``"
msgstr ""

#: ../source/scilab/cmdref_gf_asm.rst:420
# bbd9fd4b1f5f45a3ae8cd4a20e8f6bec
msgid "Assembly of stabilization patch matrix ."
msgstr ""

