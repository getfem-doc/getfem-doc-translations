# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2018 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-20 02:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/scilab/cmdref_gf_model_set.rst:8
# 2d7e29671b3d44338d050189d1794940
msgid "gf_model_set"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:10
# aa0d82c7671349aabda96022f5ad3069
msgid "**Synopsis**"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:140
# 887d47ef46184a6aba3310e45df4f00d
msgid "**Description :**"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:143
# 7a4bbc7842154f4980b2deed6465a6bb
msgid "Modifies a model object."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:146
# 0d8e7beb5aae42bfad5c3a44b8f5e9dd
msgid "**Command list :**"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:150
# 007693761ef94cc6be300cff424badba
msgid "``gf_model_set(model M, 'clear')``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:152
# 3e0747387c384163b8a8c411945aab69
msgid "Clear the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:155
# 80fb6f631a134c669f36698fdb9da840
msgid "``gf_model_set(model M, 'add fem variable', string name, mesh_fem mf)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:157
# 227a04e7ba264618a78b562f3d4c3df0
msgid "Add a variable to the model linked to a mesh_fem. <literal>name</literal> is the variable name."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:161
# 5c8c2deb6e0b43a3ba381aa4a48b76c7
msgid "``gf_model_set(model M, 'add filtered fem variable', string name, mesh_fem mf, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:163
# d9f786452d49463fb6c23e564e9d1e0f
msgid "Add a variable to the model linked to a mesh_fem. The variable is filtered in the sense that only the dof on the region are considered. <literal>name</literal> is the variable name."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:168
# dda4e965c6854749a8ab7cfdf01b56d6
msgid "``gf_model_set(model M, 'add variable', string name, sizes)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:170
# fabe558e95f74f2f8c54a512a56ff6da
msgid "Add a variable to the model of constant sizes. <literal>sizes</literal> is either a integer (for a scalar or vector variable) or a vector of dimensions for a tensor variable. <literal>name</literal> is the variable name."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:175
# abb233b72ed746ca9159c112f58c8fa3
msgid "``gf_model_set(model M, 'delete variable', string name)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:177
#: ../source/scilab/cmdref_gf_model_set.rst:267
# d254d51f68fa4728970d8735b91a35a0
# 5c18148cfe6b4b27851657e58829252f
msgid "Delete a variable or a data from the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:180
# 0995e57724fe49239f05c2b2064d7b71
msgid "``gf_model_set(model M, 'resize variable', string name, sizes)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:182
# 4f08266dbef247748da66a13571a150b
msgid "Resize a  constant size variable of the model.  <literal>sizes</literal> is either a integer (for a scalar or vector variable) or a vector of dimensions for a tensor variable. <literal>name</literal> is the variable name."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:187
# d05998133fbb4d48be4da313dc3d2f39
msgid "``gf_model_set(model M, 'add multiplier', string name, mesh_fem mf, string primalname[, mesh_im mim, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:189
# 18c53941c3184c3d97c8c83d2dd82ec1
msgid "Add a particular variable linked to a fem being a multiplier with respect to a primal variable. The dof will be filtered with the <literal></literal>gmm::range_basis<literal></literal> function applied on the terms of the model which link the multiplier and the primal variable. This in order to retain only linearly independent constraints on the primal variable. Optimized for boundary multipliers."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:197
# ba69b1c98a22489c8f89e564656dd5e7
msgid "``gf_model_set(model M, 'add im data', string name, mesh_imd mimd)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:199
# fb5a87c4f1704ea788ffe54a8a1fb117
msgid "Add a data set to the model linked to a mesh_imd. <literal>name</literal> is the data name."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:203
# eb819d25226e44fe81cb840378167fff
msgid "``gf_model_set(model M, 'add fem data', string name, mesh_fem mf[, sizes])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:205
# 1cd7db7ddd43471eb7f57a0fa16d9f83
msgid "Add a data to the model linked to a mesh_fem. <literal>name</literal> is the data name, <literal>sizes</literal> an optional parameter which is either an integer  or a vector of suplementary dimensions with respect to <literal>mf</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:210
# d748446c7bae44eea60d8241bed97816
msgid "``gf_model_set(model M, 'add initialized fem data', string name, mesh_fem mf, vec V[, sizes])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:212
# eae5016ff6bb410b8aa8f065b4c946bd
msgid "Add a data to the model linked to a mesh_fem. <literal>name</literal> is the data name. The data is initiakized with <literal>V</literal>. The data can be a scalar or vector field. <literal>sizes</literal> an optional parameter which is either an integer or a vector of suplementary dimensions with respect to <literal>mf</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:218
# 530116efff0c471f8bc7ae4d9b76fd7e
msgid "``gf_model_set(model M, 'add data', string name, int size)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:220
# fa63bf9eaafa4039a55547025e89093a
msgid "Add a fixed size data to the model.  <literal>sizes</literal> is either a integer (for a scalar or vector data) or a vector of dimensions for a tensor data. <literal>name</literal> is the data name."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:225
# f125f1dbebf54f7d859786ddc8a99bff
msgid "``gf_model_set(model M, 'add macro', string name, string expr)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:227
# 3afcce714f074bcbbbb5d71db8da1d72
msgid "Define a new macro for the high generic assembly language. The name include the parameters. For instance name='sp(a,b)', expr='a.b' is a valid definition. Macro without parameter can also be defined. For instance name='x1', expr='X[1]' is valid. Teh form name='grad(u)', expr='Grad_u' is also allowed but in that case, the parameter 'u' will only be allowed to be a variable name when using the macro. Note that macros can be directly defined inside the assembly strings with the keyword 'Def'."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:238
# a90ad8b1267545649c3840d49b8836d4
msgid "``gf_model_set(model M, 'del macro', string name)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:240
# 725a800005f44be3b0bb28959fc502e0
msgid "Delete a previously defined macro for the high generic assembly language."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:244
# 2a51b6d105464964848910e511e625e6
msgid "``gf_model_set(model M, 'add initialized data', string name, vec V[, sizes])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:246
# cb80dcca6fd44fb9a4e759b2b9b71abf
msgid "Add an initialized fixed size data to the model. <literal>sizes</literal> an optional parameter which is either an integer  or a vector dimensions that describes the format of the data. By default, the data is considered to b a vector field. <literal>name</literal> is the data name and <literal>V</literal> is the value of the data."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:253
# c663aff629de4344901c0e00e58e2906
msgid "``gf_model_set(model M, 'variable', string name, vec V)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:255
# c431dba818dd43be8dd252b4323a8ee4
msgid "Set the value of a variable or data. <literal>name</literal> is the data name."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:258
# 41528f7ecc924e66a1a6abfefc96863c
msgid "``gf_model_set(model M, 'to variables', vec V)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:260
# f2c6b7e458f149eba904536de7036932
msgid "Set the value of the variables of the model with the vector <literal>V</literal>. Typically, the vector <literal>V</literal> results of the solve of the tangent linear system (useful to solve your problem with you own solver)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:265
# e2d9d9739ecd40ee9e3c9100fc25e574
msgid "``gf_model_set(model M, 'delete brick', int ind_brick)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:270
# eb990887fd804112bf08d91a57bd0edc
msgid "``gf_model_set(model M, 'define variable group', string name[, string varname, ...])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:272
# 3c75735e33a44f0dbd86b91dde3e6aaa
msgid "Defines a group of variables for the interpolation (mainly for the raytracing interpolation transformation."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:276
# c7a82fadfb8a4083ba78b5ece7015236
msgid "``gf_model_set(model M, 'add elementary rotated RT0 projection', string transname)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:278
# 70fdf85822cf452cb9197d15cf18a192
msgid "Experimental method ..."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:281
# 1ea70e2271674b1f97fefbe943dc2195
msgid "``gf_model_set(model M, 'add interpolate transformation from expression', string transname, mesh source_mesh, mesh target_mesh, string expr)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:283
# 8d3dcbac788c47ebb525d7f27c59bc97
msgid "Add a transformation to the model from mesh <literal>source_mesh</literal> to mesh <literal>target_mesh</literal> given by the expression <literal>expr</literal> which corresponds to a high-level generic assembly expression which may contains some variable of the model. CAUTION: the derivative of the transformation with used variable is taken into account in the computation of the tangen system. However, order two derivative is not implemented, so such tranformation is not allowed in the definition of a potential."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:293
# d9f4f28ae9b643059a22259467fec6d9
msgid "``gf_model_set(model M, 'add element extrapolation transformation', string transname, mesh source_mesh, mat elt_corr)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:295
# 6c092c794b6048e197805f79023824fc
msgid "Add a special interpolation transformation which represents the identity transformation but allows to evaluate the expression on another element than the current element by polynomial extrapolation. It is used for stabilization term in fictitious domain applications. the array elt_cor should be a two entry array whose first line contains the elements concerned by the transformation and the second line the respective elements on which the extrapolation has to be made. If an element is not listed in elt_cor the evaluation is just made on the current element."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:306
# ae05dc8a5fc94414887edfa437918ec4
msgid "``gf_model_set(model M, 'add standard secondary domain', string name, mesh_im mim, int region = -1)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:308
# 4f17033f790b4ced92f260af37d77d56
msgid "Add a secondary domain to the model which can be used in a weak-form language expression for integration on the product of two domains. <literal>name</literal> is the name of the secondary domain, <literal>mim</literal> is an integration method on this domain and <literal>region</literal> the region on which the integration is to be performed."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:313
# 950b82b324334ebab880ecc9284361e2
msgid "``gf_model_set(model M, 'set element extrapolation correspondance', string transname, mat elt_corr)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:315
# 9dea3697667040d980a19b19057d5d08
msgid "Change the correspondance map of an element extrapolation interpolate transformation."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:319
# 9ff190f7f1274341a75cd01cd6db5de1
msgid "``gf_model_set(model M, 'add raytracing transformation', string transname, scalar release_distance)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:321
# 96670cc846bb470c93b060fa9a8970df
msgid "Add a raytracing interpolate transformation called <literal>transname</literal> to a model to be used by the generic assembly bricks. CAUTION: For the moment, the derivative of the transformation is not taken into account in the model solve."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:327
# 84a2a8ae6d4847b198752d53bb60a1df
msgid "``gf_model_set(model M, 'add master contact boundary to raytracing transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:329
# b76917ddf9784097b4594a68141d74bc
msgid "Add a master contact boundary with corresponding displacement variable <literal>dispname</literal> on a specific boundary <literal>region</literal> to an existing raytracing interpolate transformation called <literal>transname</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:334
# 01de30ff45d34e149fdc08ea448c9598
msgid "``gf_model_set(model M, 'add slave contact boundary to raytracing transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:336
# a7375acf6e834537a5a562d7334bb8da
msgid "Add a slave contact boundary with corresponding displacement variable <literal>dispname</literal> on a specific boundary <literal>region</literal> to an existing raytracing interpolate transformation called <literal>transname</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:341
# 0850b5cefc364add875850460490e239
msgid "``gf_model_set(model M, 'add rigid obstacle to raytracing transformation', string transname, string expr, int N)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:343
# fedb5302a3144ec984062d30e7fd877b
msgid "Add a rigid obstacle whose geometry corresponds to the zero level-set of the high-level generic assembly expression <literal>expr</literal> to an existing raytracing interpolate transformation called <literal>transname</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:349
# e61ba7a377934d72bad7febad180b024
msgid "``gf_model_set(model M, 'add projection transformation', string transname, scalar release_distance)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:351
# 48fde69aa4644356926fa31d4202d8c1
msgid "Add a projection interpolate transformation called <literal>transname</literal> to a model to be used by the generic assembly bricks. CAUTION: For the moment, the derivative of the transformation is not taken into account in the model solve."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:357
# 902eaee513ed492696c86dee0beb17c4
msgid "``gf_model_set(model M, 'add master contact boundary to projection transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:359
# 0f7fbccc258f45e18377fd477dba6617
msgid "Add a master contact boundary with corresponding displacement variable <literal>dispname</literal> on a specific boundary <literal>region</literal> to an existing projection interpolate transformation called <literal>transname</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:364
# 10df709e35594c83b8966566f7c8a43c
msgid "``gf_model_set(model M, 'add slave contact boundary to projection transformation', string transname, mesh m, string dispname, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:366
# effc833e57c3446ca34a13f681a60874
msgid "Add a slave contact boundary with corresponding displacement variable <literal>dispname</literal> on a specific boundary <literal>region</literal> to an existing projection interpolate transformation called <literal>transname</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:371
# a18c4117b4be4188abdd38c7ce3cb120
msgid "``gf_model_set(model M, 'add rigid obstacle to projection transformation', string transname, string expr, int N)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:373
# 7f21512c0f0c4514854939421ecac51e
msgid "Add a rigid obstacle whose geometry corresponds to the zero level-set of the high-level generic assembly expression <literal>expr</literal> to an existing projection interpolate transformation called <literal>transname</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:379
# e4bf19f8163e4ac0a84fc61578932ec8
msgid "``ind = gf_model_set(model M, 'add linear term', mesh_im mim, string expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:381
# a4ff064b49ea48a8a8c6c98d31871ea5
msgid "Adds a matrix term given by the assembly string <literal>expr</literal> which will be assembled in region <literal>region</literal> and with the integration method <literal>mim</literal>. Only the matrix term will be taken into account, assuming that it is linear. The advantage of declaring a term linear instead of nonlinear is that it will be assembled only once and no assembly is necessary for the residual. Take care that if the expression contains some variables and if the expression is a potential or of first order (i.e. describe the weak form, not the derivative of the weak form), the expression will be derivated with respect to all variables. You can specify if the term is symmetric, coercive or not. If you are not sure, the better is to declare the term not symmetric and not coercive. But some solvers (conjugate gradient for instance) are not allowed for non-coercive problems. <literal>brickname</literal> is an otpional name for the brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:399
# b8947378bbe4466b9d576babb1596f28
msgid "``ind = gf_model_set(model M, 'add linear twodomain term', mesh_im mim, string expression, int region, string secondary_domain[, int is_symmetric[, int is_coercive]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:401
# d11f22dccaff4368b944e2cce294232a
msgid "Adds a linear term given by a weak form language expression like gf_model_set(model M, 'add linear term') but for an integration on a direct product of two domains, a first specfied by <literal></literal>mim<literal></literal> and <literal></literal>region<literal></literal> and a second one by <literal></literal>secondary_domain<literal></literal> which has to be declared first into the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:408
# c0a9a107484143daa9ae94a51b228acc
msgid "``ind = gf_model_set(model M, 'add linear generic assembly brick', mesh_im mim, string expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:410
# 0cfdd28735f947d08cee1d94846d85d1
msgid "Deprecated. Use gf_model_set(model M, 'add linear term') instead."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:413
# aba6a21519dd41afac2b5acef5f80b05
msgid "``ind = gf_model_set(model M, 'add nonlinear term', mesh_im mim, string expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:415
# 1b909e4099484f01916a2d551f14ed5c
msgid "Adds a nonlinear term given by the assembly string <literal>expr</literal> which will be assembled in region <literal>region</literal> and with the integration method <literal>mim</literal>. The expression can describe a potential or a weak form. Second order terms (i.e. containing second order test functions, Test2) are not allowed. You can specify if the term is symmetric, coercive or not. If you are not sure, the better is to declare the term not symmetric and not coercive. But some solvers (conjugate gradient for instance) are not allowed for non-coercive problems. <literal>brickname</literal> is an otpional name for the brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:427
# e132c6c41d474cdab42b5981743392fc
msgid "``ind = gf_model_set(model M, 'add nonlinear twodomain term', mesh_im mim, string expression, int region, string secondary_domain[, int is_symmetric[, int is_coercive]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:429
# d2d47e0540bd4c35ae8f5009271413df
msgid "Adds a nonlinear term given by a weak form language expression like gf_model_set(model M, 'add nonlinear term') but for an integration on a direct product of two domains, a first specfied by <literal></literal>mim<literal></literal> and <literal></literal>region<literal></literal> and a second one by <literal></literal>secondary_domain<literal></literal> which has to be declared first into the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:436
# da9b803af6584e67bcd55af9715f11b6
msgid "``ind = gf_model_set(model M, 'add nonlinear generic assembly brick', mesh_im mim, string expression[, int region[, int is_symmetric[, int is_coercive]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:438
# 48a5469d80fb4642b6904b3f08396cd2
msgid "Deprecated. Use gf_model_set(model M, 'add nonlinear term') instead."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:441
# a8b29f36e674423ba6b41adc9a2b374c
msgid "``ind = gf_model_set(model M, 'add source term', mesh_im mim, string expression[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:443
# e3013777d3594043b38abf6222ce6253
msgid "Adds a source term given by the assembly string <literal>expr</literal> which will be assembled in region <literal>region</literal> and with the integration method <literal>mim</literal>. Only the residual term will be taken into account. Take care that if the expression contains some variables and if the expression is a potential, the expression will be derivated with respect to all variables. <literal>brickname</literal> is an optional name for the brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:452
# 44fc92745d4f4fd09ca59223feeae4f9
msgid "``ind = gf_model_set(model M, 'add twodomain source term', mesh_im mim, string expression, int region, string secondary_domain)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:454
# 850393ec51654203baf46301cd8bd023
msgid "Adds a source term given by a weak form language expression like gf_model_set(model M, 'add source term') but for an integration on a direct product of two domains, a first specfied by <literal></literal>mim<literal></literal> and <literal></literal>region<literal></literal> and a second one by <literal></literal>secondary_domain<literal></literal> which has to be declared first into the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:461
# 8060c55bc45d43f5a3594a79f63933fa
msgid "``ind = gf_model_set(model M, 'add source term generic assembly brick', mesh_im mim, string expression[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:463
# dd2c2b6aefbd4e73b602826b469ec755
msgid "Deprecated. Use gf_model_set(model M, 'add source term') instead."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:466
# 94e6b1521fa4495f8f87ee4a5b8df718
msgid "``gf_model_set(model M, 'add assembly assignment', string dataname, string expression[, int region[, int order[, int before]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:468
# 76dbc1e7cd854e41812f621e3e258208
msgid "Adds expression <literal>expr</literal> to be evaluated at assembly time and being assigned to the data <literal>dataname</literal> which has to be of im_data type. This allows for instance to store a sub-expression of an assembly computation to be used on an other assembly. It can be used for instance to store the plastic strain in plasticity models. <literal>order</literal> represents the order of assembly where this assignement has to be done (potential(0), weak form(1) or tangent system(2) or at each order(-1)). The default value is 1. If before = 1, the the assignement is perfromed before the computation of the other assembly terms, such that the data can be used in the remaining of the assembly as an intermediary result (be careful that it is still considered as a data, no derivation of the expression is performed for the tangent system). If before = 0 (default), the assignement is done after the assembly terms."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:485
# 720ed27d70734012a95aab3ac14ba2dc
msgid "``gf_model_set(model M, 'clear assembly assignment')``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:487
# 713f1011aaa44d789ed469781ce2b98a
msgid "Delete all added assembly assignments"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:491
# 36c4b4b1187a435fafce2b03cfa6330a
msgid "``ind = gf_model_set(model M, 'add Laplacian brick', mesh_im mim, string varname[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:493
# 5b63272364904bd0bdd229a8ffb6b0c4
msgid "Add a Laplacian term to the model relatively to the variable <literal>varname</literal> (in fact with a minus : <latex style=\"text\"><![CDATA[-\\text{div}(\\nabla u)]]></latex>). If this is a vector valued variable, the Laplacian term is added componentwise. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:501
# 5f9af9f963a841dd86c5373f3e0994d8
msgid "``ind = gf_model_set(model M, 'add generic elliptic brick', mesh_im mim, string varname, string dataname[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:503
# ab1f03a283d145ddaf49ed434bc83608
msgid "Add a generic elliptic term to the model relatively to the variable <literal>varname</literal>. The shape of the elliptic term depends both on the variable and the data. This corresponds to a term <latex style=\"text\"><![CDATA[-\\text{div}(a\\nabla u)]]></latex> where <latex style=\"text\"><![CDATA[a]]></latex> is the data and <latex style=\"text\"><![CDATA[u]]></latex> the variable. The data can be a scalar, a matrix or an order four tensor. The variable can be vector valued or not. If the data is a scalar or a matrix and the variable is vector valued then the term is added componentwise. An order four tensor data is allowed for vector valued variable only. The data can be constant or describbed on a fem. Of course, when the data is a tensor describe on a finite element method (a tensor field) the data can be a huge vector. The components of the matrix/tensor have to be stored with the fortran order (columnwise) in the data vector (compatibility with blas). The symmetry of the given matrix/tensor is not verified (but assumed). If this is a vector valued variable, the elliptic term is added componentwise. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Note that for the real version which uses the high-level generic assembly language, <literal>dataname</literal> can be any regular expression of the high-level generic assembly language (like \"1\", \"sin(X(1))\" or \"Norm(u)\" for instance) even depending on model variables. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:529
# 1cbb3c13cdc145d3aced5ac5b184cc87
msgid "``ind = gf_model_set(model M, 'add source term brick', mesh_im mim, string varname, string dataexpr[, int region[, string directdataname]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:531
# ac5579da18fe4c0f98ac8ab22c9273c0
msgid "Add a source term to the model relatively to the variable <literal>varname</literal>. The source term is represented by <literal>dataexpr</literal> which could be any regular expression of the high-level generic assembly language (except for the complex version where it has to be a declared data of the model). <literal>region</literal> is an optional mesh region on which the term is added. An additional optional data <literal>directdataname</literal> can be provided. The corresponding data vector will be directly added to the right hand side without assembly. Note that when region is a boundary, this brick allows to prescribe a nonzero Neumann boundary condition. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:544
# 7fe98ded85c64ab4a7572949db0463ed
msgid "``ind = gf_model_set(model M, 'add normal source term brick', mesh_im mim, string varname, string dataname, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:546
# afddc8e9dc3d4aa89c09dfe07f773469
msgid "Add a source term on the variable <literal>varname</literal> on a boundary <literal>region</literal>. This region should be a boundary. The source term is represented by the data <literal>dataepxpr</literal> which could be any regular expression of the high-level generic assembly language (except for the complex version where it has to be a declared data of the model). A scalar product with the outward normal unit vector to the boundary is performed. The main aim of this brick is to represent a Neumann condition with a vector data without performing the scalar product with the normal as a pre-processing. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:558
# a332dc1b6ead462db5af405138b85196
msgid "``ind = gf_model_set(model M, 'add Dirichlet condition with simplification', string varname, int region[, string dataname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:560
# 0282b3e675e24b64911717292134f8aa
msgid "Adds a (simple) Dirichlet condition on the variable <literal>varname</literal> and the mesh region <literal>region</literal>. The Dirichlet condition is prescribed by a simple post-treatment of the final linear system (tangent system for nonlinear problems) consisting of modifying the lines corresponding to the degree of freedom of the variable on <literal>region</literal> (0 outside the diagonal, 1 on the diagonal of the matrix and the expected value on the right hand side). The symmetry of the linear system is kept if all other bricks are symmetric. This brick is to be reserved for simple Dirichlet conditions (only dof declared on the correspodning boundary are prescribed). The application of this brick on reduced dof may be problematic. Intrinsic vectorial finite element method are not supported. <literal>dataname</literal> is the optional right hand side of  the Dirichlet condition. It could be constant (but in that case, it can only be applied to Lagrange f.e.m.) or (important) described on the same finite element method as <literal>varname</literal>. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:580
# 7ba1c36c37564df492c6d9bf82ac0a8d
msgid "``ind = gf_model_set(model M, 'add Dirichlet condition with multipliers', mesh_im mim, string varname, mult_description, int region[, string dataname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:582
# 6f8bffcb00084bd6aea4670c0c10acb8
msgid "Add a Dirichlet condition on the variable <literal>varname</literal> and the mesh region <literal>region</literal>. This region should be a boundary. The Dirichlet condition is prescribed with a multiplier variable described by <literal>mult_description</literal>. If <literal>mult_description</literal> is a string this is assumed to be the variable name corresponding to the multiplier (which should be first declared as a multiplier variable on the mesh region in the model). If it is a finite element method (mesh_fem object) then a multiplier variable will be added to the model and build on this finite element method (it will be restricted to the mesh region <literal>region</literal> and eventually some conflicting dofs with some other multiplier variables will be suppressed). If it is an integer, then a  multiplier variable will be added to the model and build on a classical finite element of degree that integer. <literal>dataname</literal> is the optional right hand side of  the Dirichlet condition. It could be constant or described on a fem; scalar or vector valued, depending on the variable on which the Dirichlet condition is prescribed. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:600
# 9c0f9b16fdd6468987d4179af86ebe34
msgid "``ind = gf_model_set(model M, 'add Dirichlet condition with Nitsche method', mesh_im mim, string varname, string Neumannterm, string datagamma0, int region[, scalar theta][, string dataname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:602
# 812a5095e9c646bdb17a0e87d081d81a
msgid "Add a Dirichlet condition on the variable <literal>varname</literal> and the mesh region <literal>region</literal>. This region should be a boundary. <literal>Neumannterm</literal> is the expression of the Neumann term (obtained by the Green formula) described as an expression of the high-level generic assembly language. This term can be obtained by gf_model_get(model M, 'Neumann term', varname, region) once all volumic bricks have been added to the model. The Dirichlet condition is prescribed with Nitsche's method. <literal>datag</literal> is the optional right hand side of the Dirichlet condition. <literal>datagamma0</literal> is the Nitsche's method parameter. <literal>theta</literal> is a scalar value which can be positive or negative. <literal>theta = 1</literal> corresponds to the standard symmetric method which is conditionnaly coercive for  <literal>gamma0</literal> small. <literal>theta = -1</literal> corresponds to the skew-symmetric method which is inconditionnaly coercive. <literal>theta = 0</literal> (default) is the simplest method for which the second derivative of the Neumann term is not necessary even for nonlinear problems. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:621
# 6a9ad6489a2e4197aca74cf57974b1eb
msgid "``ind = gf_model_set(model M, 'add Dirichlet condition with penalization', mesh_im mim, string varname, scalar coeff, int region[, string dataname, mesh_fem mf_mult])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:623
# ce6bae28b4a448e4bcc9b2230cf383bf
msgid "Add a Dirichlet condition on the variable <literal>varname</literal> and the mesh region <literal>region</literal>. This region should be a boundary. The Dirichlet condition is prescribed with penalization. The penalization coefficient is initially <literal>coeff</literal> and will be added to the data of the model. <literal>dataname</literal> is the optional right hand side of the Dirichlet condition. It could be constant or described on a fem; scalar or vector valued, depending on the variable on which the Dirichlet condition is prescribed. <literal>mf_mult</literal> is an optional parameter which allows to weaken the Dirichlet condition specifying a multiplier space. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:635
# e0e69dbc2f684238b892a38ec1b6a532
msgid "``ind = gf_model_set(model M, 'add normal Dirichlet condition with multipliers', mesh_im mim, string varname, mult_description, int region[, string dataname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:637
# 451db48388244dafaa38acb6700fec75
msgid "Add a Dirichlet condition to the normal component of the vector (or tensor) valued variable <literal>varname</literal> and the mesh region <literal>region</literal>. This region should be a boundary. The Dirichlet condition is prescribed with a multiplier variable described by <literal>mult_description</literal>. If <literal>mult_description</literal> is a string this is assumed to be the variable name corresponding to the multiplier (which should be first declared as a multiplier variable on the mesh region in the model). If it is a finite element method (mesh_fem object) then a multiplier variable will be added to the model and build on this finite element method (it will be restricted to the mesh region <literal>region</literal> and eventually some conflicting dofs with some other multiplier variables will be suppressed). If it is an integer, then a  multiplier variable will be added to the model and build on a classical finite element of degree that integer. <literal>dataname</literal> is the optional right hand side of  the Dirichlet condition. It could be constant or described on a fem; scalar or vector valued, depending on the variable on which the Dirichlet condition is prescribed (scalar if the variable is vector valued, vector if the variable is tensor valued). Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:658
# 9d72c3ab9ff146d8860c5131fc8a68f9
msgid "``ind = gf_model_set(model M, 'add normal Dirichlet condition with penalization', mesh_im mim, string varname, scalar coeff, int region[, string dataname, mesh_fem mf_mult])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:660
# 9e6ec8a3dacd460bbb077f3f2070afdb
msgid "Add a Dirichlet condition to the normal component of the vector (or tensor) valued variable <literal>varname</literal> and the mesh region <literal>region</literal>. This region should be a boundary. The Dirichlet condition is prescribed with penalization. The penalization coefficient is initially <literal>coeff</literal> and will be added to the data of the model. <literal>dataname</literal> is the optional right hand side of the Dirichlet condition. It could be constant or described on a fem; scalar or vector valued, depending on the variable on which the Dirichlet condition is prescribed (scalar if the variable is vector valued, vector if the variable is tensor valued). <literal>mf_mult</literal> is an optional parameter which allows to weaken the Dirichlet condition specifying a multiplier space. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:675
# 84e8b1f3dcfb4d329b4f9d465708adea
msgid "``ind = gf_model_set(model M, 'add normal Dirichlet condition with Nitsche method', mesh_im mim, string varname, string Neumannterm, string gamma0name, int region[, scalar theta][, string dataname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:677
# c28aa413bd6c44fb8b92eb6076f2ae1f
msgid "Add a Dirichlet condition to the normal component of the vector (or tensor) valued variable <literal>varname</literal> and the mesh region <literal>region</literal>. This region should be a boundary. <literal>Neumannterm</literal> is the expression of the Neumann term (obtained by the Green formula) described as an expression of the high-level generic assembly language. This term can be obtained by gf_model_get(model M, 'Neumann term', varname, region) once all volumic bricks have been added to the model. The Dirichlet condition is prescribed with Nitsche's method. <literal>dataname</literal> is the optional right hand side of the Dirichlet condition. It could be constant or described on a fem. <literal>gamma0name</literal> is the Nitsche's method parameter. <literal>theta</literal> is a scalar value which can be positive or negative. <literal>theta = 1</literal> corresponds to the standard symmetric method which is conditionnaly coercive for  <literal>gamma0</literal> small. <literal>theta = -1</literal> corresponds to the skew-symmetric method which is inconditionnaly coercive. <literal>theta = 0</literal> is the simplest method for which the second derivative of the Neumann term is not necessary even for nonlinear problems. Returns the brick index in the model. (This brick is not fully tested)"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:700
# 700c9dccdfc3462398ccbab16ae3cd21
msgid "``ind = gf_model_set(model M, 'add generalized Dirichlet condition with multipliers', mesh_im mim, string varname, mult_description, int region, string dataname, string Hname)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:702
# 4e99afdc62bd4ff497cfd8013abf6edb
msgid "Add a Dirichlet condition on the variable <literal>varname</literal> and the mesh region <literal>region</literal>.  This version is for vector field. It prescribes a condition <latex style=\"text\"><![CDATA[Hu = r]]></latex> where <literal>H</literal> is a matrix field. The region should be a boundary. The Dirichlet condition is prescribed with a multiplier variable described by <literal>mult_description</literal>. If <literal>mult_description</literal> is a string this is assumed to be the variable name corresponding to the multiplier (which should be first declared as a multiplier variable on the mesh region in the model). If it is a finite element method (mesh_fem object) then a multiplier variable will be added to the model and build on this finite element method (it will be restricted to the mesh region <literal>region</literal> and eventually some conflicting dofs with some other multiplier variables will be suppressed). If it is an integer, then a  multiplier variable will be added to the model and build on a classical finite element of degree that integer. <literal>dataname</literal> is the right hand side of  the Dirichlet condition. It could be constant or described on a fem; scalar or vector valued, depending on the variable on which the Dirichlet condition is prescribed. <literal>Hname</literal> is the data corresponding to the matrix field <literal>H</literal>. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:724
# ba773df496234ea583a50711ce8e6345
msgid "``ind = gf_model_set(model M, 'add generalized Dirichlet condition with penalization', mesh_im mim, string varname, scalar coeff, int region, string dataname, string Hname[, mesh_fem mf_mult])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:726
# 1f8c73e0fd3146babeb2c583e8c1738b
msgid "Add a Dirichlet condition on the variable <literal>varname</literal> and the mesh region <literal>region</literal>. This version is for vector field. It prescribes a condition <latex style=\"text\"><![CDATA[Hu = r]]></latex> where <literal>H</literal> is a matrix field. The region should be a boundary. The Dirichlet condition is prescribed with penalization. The penalization coefficient is intially <literal>coeff</literal> and will be added to the data of the model. <literal>dataname</literal> is the right hand side of the Dirichlet condition. It could be constant or described on a fem; scalar or vector valued, depending on the variable on which the Dirichlet condition is prescribed. <literal>Hname</literal> is the data corresponding to the matrix field <literal>H</literal>. It has to be a constant matrix or described on a scalar fem. <literal>mf_mult</literal> is an optional parameter which allows to weaken the Dirichlet condition specifying a multiplier space. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:744
# 6a1ef85be62a4756a9286a58612cd75e
msgid "``ind = gf_model_set(model M, 'add generalized Dirichlet condition with Nitsche method', mesh_im mim, string varname, string Neumannterm, string gamma0name, int region[, scalar theta], string dataname, string Hname)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:746
# 6b91a425eb2a433bae100429f12d52a5
msgid "Add a Dirichlet condition on the variable <literal>varname</literal> and the mesh region <literal>region</literal>. This version is for vector field. It prescribes a condition @f$ Hu = r @f$ where <literal>H</literal> is a matrix field. CAUTION : the matrix H should have all eigenvalues equal to 1 or 0. The region should be a boundary.   <literal>Neumannterm</literal> is the expression of the Neumann term (obtained by the Green formula) described as an expression of the high-level generic assembly language. This term can be obtained by gf_model_get(model M, 'Neumann term', varname, region) once all volumic bricks have been added to the model.  The Dirichlet condition is prescribed with Nitsche's method. <literal>dataname</literal> is the optional right hand side of the Dirichlet condition. It could be constant or described on a fem. <literal>gamma0name</literal> is the Nitsche's method parameter. <literal>theta</literal> is a scalar value which can be positive or negative. <literal>theta = 1</literal> corresponds to the standard symmetric method which is conditionnaly coercive for  <literal>gamma0</literal> small. <literal>theta = -1</literal> corresponds to the skew-symmetric method which is inconditionnaly coercive. <literal>theta = 0</literal> is the simplest method for which the second derivative of the Neumann term is not necessary even for nonlinear problems. <literal>Hname</literal> is the data corresponding to the matrix field <literal>H</literal>. It has to be a constant matrix or described on a scalar fem. Returns the brick index in the model. (This brick is not fully tested)"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:773
# ed7bfaeac1a84cf592d2f177d5cf7fd5
msgid "``ind = gf_model_set(model M, 'add pointwise constraints with multipliers', string varname, string dataname_pt[, string dataname_unitv] [, string dataname_val])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:775
# f78ffe2c4d01453388247fd4587ec0aa
msgid "Add some pointwise constraints on the variable <literal>varname</literal> using multiplier. The multiplier variable is automatically added to the model. The conditions are prescribed on a set of points given in the data <literal>dataname_pt</literal> whose dimension is the number of points times the dimension of the mesh. If the variable represents a vector field, one has to give the data <literal>dataname_unitv</literal> which represents a vector of dimension the number of points times the dimension of the vector field which should store some unit vectors. In that case the prescribed constraint is the scalar product of the variable at the corresponding point with the corresponding unit vector. The optional data <literal>dataname_val</literal> is the vector of values to be prescribed at the different points. This brick is specifically designed to kill rigid displacement in a Neumann problem. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:793
# e78eab6c99c748d0bd5d1603c0391c55
msgid "``ind = gf_model_set(model M, 'add pointwise constraints with given multipliers', string varname, string multname, string dataname_pt[, string dataname_unitv] [, string dataname_val])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:795
# 422c7ee865a7458cadcfa62d4d77b79a
msgid "Add some pointwise constraints on the variable <literal>varname</literal> using a given multiplier <literal>multname</literal>. The conditions are prescribed on a set of points given in the data <literal>dataname_pt</literal> whose dimension is the number of points times the dimension of the mesh. The multiplier variable should be a fixed size variable of size the number of points. If the variable represents a vector field, one has to give the data <literal>dataname_unitv</literal> which represents a vector of dimension the number of points times the dimension of the vector field which should store some unit vectors. In that case the prescribed constraint is the scalar product of the variable at the corresponding point with the corresponding unit vector. The optional data <literal>dataname_val</literal> is the vector of values to be prescribed at the different points. This brick is specifically designed to kill rigid displacement in a Neumann problem. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:815
# b5d858e9ec8e418fac3be69231ef1ddc
msgid "``ind = gf_model_set(model M, 'add pointwise constraints with penalization', string varname, scalar coeff, string dataname_pt[, string dataname_unitv] [, string dataname_val])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:817
# bcb9a8b15e474d43b101650b6f856484
msgid "Add some pointwise constraints on the variable <literal>varname</literal> thanks to a penalization. The penalization coefficient is initially <literal>penalization_coeff</literal> and will be added to the data of the model. The conditions are prescribed on a set of points given in the data <literal>dataname_pt</literal> whose dimension is the number of points times the dimension of the mesh. If the variable represents a vector field, one has to give the data <literal>dataname_unitv</literal> which represents a vector of dimension the number of points times the dimension of the vector field which should store some unit vectors. In that case the prescribed constraint is the scalar product of the variable at the corresponding point with the corresponding unit vector. The optional data <literal>dataname_val</literal> is the vector of values to be prescribed at the different points. This brick is specifically designed to kill rigid displacement in a Neumann problem. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:836
# 21bb8ac05c644e2b90540cb3c4eea90c
msgid "``gf_model_set(model M, 'change penalization coeff', int ind_brick, scalar coeff)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:838
# 05942fc08db546408c44ed61c3c51828
msgid "Change the penalization coefficient of a Dirichlet condition with penalization brick. If the brick is not of this kind, this function has an undefined behavior."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:843
# 8afbed955fb74eea85fd8fce252c8247
msgid "``ind = gf_model_set(model M, 'add Helmholtz brick', mesh_im mim, string varname, string dataexpr[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:845
# 5649ff3bf2ef401dbf386e14d436bfb8
msgid "Add a Helmholtz term to the model relatively to the variable <literal>varname</literal>. <literal>dataexpr</literal> is the wave number. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:851
# fe96ac09f32a49afbdad721b89b7c82c
msgid "``ind = gf_model_set(model M, 'add Fourier Robin brick', mesh_im mim, string varname, string dataexpr, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:853
# 4a30d12dd5264e628a2f86a312a496b6
msgid "Add a Fourier-Robin term to the model relatively to the variable <literal>varname</literal>. This corresponds to a weak term of the form <latex style=\"text\"><![CDATA[\\int (qu).v]]></latex>. <literal>dataexpr</literal> is the parameter <latex style=\"text\"><![CDATA[q]]></latex> of the Fourier-Robin condition.  It can be an arbitrary valid expression of the high-level generic assembly language (except for the complex version for which it should be a data of the model). <literal>region</literal> is the mesh region on which the term is added. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:862
# d45eee9a9d92412aa965e5da43c1ef11
msgid "``ind = gf_model_set(model M, 'add constraint with multipliers', string varname, string multname, spmat B, {vec L | string dataname})``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:864
# 96820970513d4deeb530a92d807ee068
msgid "Add an additional explicit constraint on the variable <literal>varname</literal> thank to a multiplier <literal>multname</literal> peviously added to the model (should be a fixed size variable). The constraint is <latex style=\"text\"><![CDATA[BU=L]]></latex> with <literal>B</literal> being a rectangular sparse matrix. It is possible to change the constraint at any time with the methods gf_model_set(model M, 'set private matrix') and gf_model_set(model M, 'set private rhs'). If <literal>dataname</literal> is specified instead of <literal>L</literal>, the vector <literal>L</literal> is defined in the model as data with the given name. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:874
# d1d6289d747043258f28d77308c9f837
msgid "``ind = gf_model_set(model M, 'add constraint with penalization', string varname, scalar coeff, spmat B, {vec L | string dataname})``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:876
# 5ac744dd360a45138c5c90225a9e7e7c
msgid "Add an additional explicit penalized constraint on the variable <literal>varname</literal>. The constraint is :math<literal>BU=L</literal> with <literal>B</literal> being a rectangular sparse matrix. Be aware that <literal>B</literal> should not contain a palin row, otherwise the whole tangent matrix will be plain. It is possible to change the constraint at any time with the methods gf_model_set(model M, 'set private matrix') and gf_model_set(model M, 'set private rhs'). The method gf_model_set(model M, 'change penalization coeff') can be used. If <literal>dataname</literal> is specified instead of <literal>L</literal>, the vector <literal>L</literal> is defined in the model as data with the given name. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:889
# fd12db765c3b4152be98b25e4789aa30
msgid "``ind = gf_model_set(model M, 'add explicit matrix', string varname1, string varname2, spmat B[, int issymmetric[, int iscoercive]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:891
# 2550f5d38a164369a9a2f5297eb17287
msgid "Add a brick representing an explicit matrix to be added to the tangent linear system relatively to the variables <literal>varname1</literal> and <literal>varname2</literal>. The given matrix should have has many rows as the dimension of <literal>varname1</literal> and as many columns as the dimension of <literal>varname2</literal>. If the two variables are different and if <literal>issymmetric</literal> is set to 1 then the transpose of the matrix is also added to the tangent system (default is 0). Set <literal>iscoercive</literal> to 1 if the term does not affect the coercivity of the tangent system (default is 0). The matrix can be changed by the command gf_model_set(model M, 'set private matrix'). Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:903
# 6eaf7c91035e4777a47cd67bfde3389d
msgid "``ind = gf_model_set(model M, 'add explicit rhs', string varname, vec L)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:905
# 36843b35125049be91b73ff66b06b490
msgid "Add a brick representing an explicit right hand side to be added to the right hand side of the tangent linear system relatively to the variable <literal>varname</literal>. The given rhs should have the same size than the dimension of <literal>varname</literal>. The rhs can be changed by the command gf_model_set(model M, 'set private rhs'). If <literal>dataname</literal> is specified instead of <literal>L</literal>, the vector <literal>L</literal> is defined in the model as data with the given name. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:914
# 93f2ec55cbe24a818c4818ea87bfb998
msgid "``gf_model_set(model M, 'set private matrix', int indbrick, spmat B)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:916
# 3836b3f5bb434b05bcc84b4ea969aeac
msgid "For some specific bricks having an internal sparse matrix (explicit bricks: 'constraint brick' and 'explicit matrix brick'), set this matrix."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:921
# 23b8d1025a2e4058891d6d26e565a7b9
msgid "``gf_model_set(model M, 'set private rhs', int indbrick, vec B)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:923
# bf79482cf7444d8d9fc6f70ef21dc9f0
msgid "For some specific bricks having an internal right hand side vector (explicit bricks: 'constraint brick' and 'explicit rhs brick'), set this rhs."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:928
# f45bb1f100ef42288f4974a0df849517
msgid "``ind = gf_model_set(model M, 'add isotropic linearized elasticity brick', mesh_im mim, string varname, string dataname_lambda, string dataname_mu[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:930
# 080b0d1a146147fd9b68fd0569c42abe
msgid "Add an isotropic linearized elasticity term to the model relatively to the variable <literal>varname</literal>. <literal>dataname_lambda</literal> and <literal>dataname_mu</literal> should contain the Lame coefficients. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:937
# a9fa175c16744eddabdd97954fbf69d4
msgid "``ind = gf_model_set(model M, 'add isotropic linearized elasticity brick pstrain', mesh_im mim, string varname, string data_E, string data_nu[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:939
# 66f8dee251214910b41978520f67f4bc
msgid "Add an isotropic linearized elasticity term to the model relatively to the variable <literal>varname</literal>. <literal>data_E</literal> and <literal>data_nu</literal> should contain the Young modulus and Poisson ratio, respectively. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. On two-dimensional meshes, the term will correpsond to a plain strain approximation. On three-dimensional meshes, it will correspond to the standard model. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:951
# 524a6d26d99244608de7da6a22f59570
msgid "``ind = gf_model_set(model M, 'add isotropic linearized elasticity brick pstress', mesh_im mim, string varname, string data_E, string data_nu[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:953
# 5732879ea6b44e25b47049ba3ab2cec2
msgid "Add an isotropic linearized elasticity term to the model relatively to the variable <literal>varname</literal>. <literal>data_E</literal> and <literal>data_nu</literal> should contain the Young modulus and Poisson ratio, respectively. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. On two-dimensional meshes, the term will correpsond to a plain stress approximation. On three-dimensional meshes, it will correspond to the standard model. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:965
# d4177e7bc5614a4595d1bf01e62d9cf0
msgid "``ind = gf_model_set(model M, 'add linear incompressibility brick', mesh_im mim, string varname, string multname_pressure[, int region[, string dataexpr_coeff]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:967
# ba01c65294a7418cb814d981f89a05d9
msgid "Add a linear incompressibility condition on <literal>variable</literal>. <literal>multname_pressure</literal> is a variable which represent the pressure. Be aware that an inf-sup condition between the finite element method describing the pressure and the primal variable has to be satisfied. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. <literal>dataexpr_coeff</literal> is an optional penalization coefficient for nearly incompressible elasticity for instance. In this case, it is the inverse of the Lame coefficient <latex style=\"text\"><![CDATA[\\lambda]]></latex>. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:978
# f88a2359afbc4c1b84f7ac3a370d74a5
msgid "``ind = gf_model_set(model M, 'add nonlinear elasticity brick', mesh_im mim, string varname, string constitutive_law, string dataname[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:980
# 0d97504bf8c34d8ab7bb618c58f71642
msgid "Add a nonlinear elasticity term to the model relatively to the variable <literal>varname</literal> (deprecated brick, use add_finite_strain_elaticity instead). <literal>lawname</literal> is the constitutive law which could be 'SaintVenant Kirchhoff', 'Mooney Rivlin', 'neo Hookean', 'Ciarlet Geymonat' or 'generalized Blatz Ko'. 'Mooney Rivlin' and 'neo Hookean' law names can be preceded with the word 'compressible' or 'incompressible' to force using the corresponding version. The compressible version of these laws requires one additional material coefficient. By default, the incompressible version of 'Mooney Rivlin' law and the compressible one of the 'neo Hookean' law are considered. In general, 'neo Hookean' is a special case of the 'Mooney Rivlin' law that requires one coefficient less. IMPORTANT : if the variable is defined on a 2D mesh, the plane strain approximation is automatically used. <literal>dataname</literal> is a vector of parameters for the constitutive law. Its length depends on the law. It could be a short vector of constant values or a vector field described on a finite element method for variable coefficients. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. This brick use the low-level generic assembly. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1003
# 2b694ef5853c4e5898cd9e08d32d8361
msgid "``ind = gf_model_set(model M, 'add finite strain elasticity brick', mesh_im mim, string constitutive_law, string varname, string params[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1005
# 10e35d491f4140caaa1d302040d5eb61
msgid "Add a nonlinear elasticity term to the model relatively to the variable <literal>varname</literal>. <literal>lawname</literal> is the constitutive law which could be 'SaintVenant Kirchhoff', 'Mooney Rivlin', 'Neo Hookean', 'Ciarlet Geymonat' or 'Generalized Blatz Ko'. 'Mooney Rivlin' and 'Neo Hookean' law names have to be preceeded with the word 'Compressible' or 'Incompressible' to force using the corresponding version. The compressible version of these laws requires one additional material coefficient."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1015
# e15db1832fb84779b457e74b8bfe2c35
msgid "IMPORTANT : if the variable is defined on a 2D mesh, the plane strain approximation is automatically used. <literal>params</literal> is a vector of parameters for the constitutive law. Its length depends on the law. It could be a short vector of constant values or a vector field described on a finite element method for variable coefficients. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. This brick use the high-level generic assembly. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1026
# 63adb5b409ee42a587fbc37077a888dd
msgid "``ind = gf_model_set(model M, 'add small strain elastoplasticity brick', mesh_im mim,  string lawname, string unknowns_type [, string varnames, ...] [, string params, ...] [, string theta = '1' [, string dt = 'timestep']] [, int region = -1])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1028
# 6157c399fad6430cb8aad0c48d4406e5
msgid "Adds a small strain plasticity term to the model <literal>M</literal>. This is the main GetFEM++ brick for small strain plasticity. <literal>lawname</literal> is the name of an implemented plastic law, <literal>unknowns_type</literal> indicates the choice between a discretization where the plastic multiplier is an unknown of the problem or (return mapping approach) just a data of the model stored for the next iteration. Remember that in both cases, a multiplier is stored anyway. <literal>varnames</literal> is a set of variable and data names with length which may depend on the plastic law (at least the displacement, the plastic multiplier and the plastic strain). <literal>params</literal> is a list of expressions for the parameters (at least elastic coefficients and the yield stress). These expressions can be some data names (or even variable names) of the model but can also be any scalar valid expression of the high level assembly language (such as '1/2', '2+sin(X[0])', '1+Norm(v)' ...). The last two parameters optionally provided in <literal>params</literal> are the <literal>theta</literal> parameter of the <literal>theta</literal>-scheme (generalized trapezoidal rule) used for the plastic strain integration and the time-step<literal>dt</literal>. The default value for <literal>theta</literal> if omitted is 1, which corresponds to the classical Backward Euler scheme which is first order consistent. <literal>theta=1/2</literal> corresponds to the Crank-Nicolson scheme (trapezoidal rule) which is second order consistent. Any value between 1/2 and 1 should be a valid value. The default value of <literal>dt</literal> is 'timestep' which simply indicates the time step defined in the model (by md.set_time_step(dt)). Alternatively it can be any expression (data name, constant value ...). The time step can be altered from one iteration to the next one. <literal>region</literal> is a mesh region."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1054
# a7647ed84e8443869e2466f916b3780a
msgid "The available plasticity laws are:"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1056
# 250bb9cae7bd4799ae484e2bb4484afe
msgid "'Prandtl Reuss' (or 'isotropic perfect plasticity'). Isotropic elasto-plasticity with no hardening. The variables are the displacement, the plastic multiplier and the plastic strain. The displacement should be a variable and have a corresponding data having the same name preceded by 'Previous\\_' corresponding to the displacement at the previous time step (typically 'u' and 'Previous_u'). The plastic multiplier should also have two versions (typically 'xi' and 'Previous_xi') the first one being defined as data if <literal>unknowns_type </literal> is 'DISPLACEMENT_ONLY' or the integer value 0, or as a variable if <literal>unknowns_type</literal> is DISPLACEMENT_AND_PLASTIC_MULTIPLIER or the integer value 1. The plastic strain should represent a n x n data tensor field stored on mesh_fem or (preferably) on an im_data (corresponding to <literal>mim</literal>). The data are the first Lame coefficient, the second one (shear modulus) and the uniaxial yield stress. A typical call is gf_model_get(model M, 'add small strain elastoplasticity brick', mim, 'Prandtl Reuss', 0, 'u', 'xi', 'Previous_Ep', 'lambda', 'mu', 'sigma_y', '1', 'timestep'); IMPORTANT: Note that this law implements the 3D expressions. If it is used in 2D, the expressions are just transposed to the 2D. For the plane strain approximation, see below."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1075
# c6b43081d6014634959864707a9539aa
msgid "\"plane strain Prandtl Reuss\" (or \"plane strain isotropic perfect plasticity\") The same law as the previous one but adapted to the plane strain approximation. Can only be used in 2D."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1079
# 653d1f228c9c4c10931ecc7514f742d4
msgid "\"Prandtl Reuss linear hardening\" (or \"isotropic plasticity linear hardening\"). Isotropic elasto-plasticity with linear isotropic and kinematic hardening. An additional variable compared to \"Prandtl Reuss\" law: the accumulated plastic strain. Similarly to the plastic strain, it is only stored at the end of the time step, so a simple data is required (preferably on an im_data). Two additional parameters: the kinematic hardening modulus and the isotropic one. 3D expressions only. A typical call is gf_model_get(model M, 'add small strain elastoplasticity brick', mim, 'Prandtl Reuss linear hardening', 0, 'u', 'xi', 'Previous_Ep', 'Previous_alpha', 'lambda', 'mu', 'sigma_y', 'H_k', H_i', '1', 'timestep');"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1089
# f170bff6fd9f45d1bfb20784c83a93d9
msgid "\"plane strain Prandtl Reuss linear hardening\" (or \"plane strain isotropic plasticity linear hardening\"). The same law as the previous one but adapted to the plane strain approximation. Can only be used in 2D."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1094
# 2e179894e36d4a239b4e6fae29518353
msgid "See GetFEM++ user documentation for further explanations on the discretization of the plastic flow and on the implemented plastic laws. See also GetFEM++ user documentation on time integration strategy (integration of transient problems)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1099
# 39dbc11e85e148bead0678552a395810
msgid "IMPORTANT : remember that <literal>small_strain_elastoplasticity_next_iter</literal> has to be called at the end of each time step, before the next one (and before any post-treatment : this sets the value of the plastic strain and plastic multiplier)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1106
# 8a9ba46dd6d5489688669b0c6c4ec07c
msgid "``ind = gf_model_set(model M, 'add elastoplasticity brick', mesh_im mim ,string projname, string varname, string previous_dep_name, string datalambda, string datamu, string datathreshold, string datasigma[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1108
# f675b817ec544b49abdcba1707cad414
msgid "Old (obsolete) brick which do not use the high level generic assembly. Add a nonlinear elastoplastic term to the model relatively to the variable <literal>varname</literal>, in small deformations, for an isotropic material and for a quasistatic model. <literal>projname</literal> is the type of projection that used: only the Von Mises projection is available with 'VM' or 'Von Mises'. <literal>datasigma</literal> is the variable representing the constraints on the material. <literal>previous_dep_name</literal> represents the displacement at the previous time step. Moreover, the finite element method on which <literal>varname</literal> is described is an K ordered mesh_fem, the <literal>datasigma</literal> one have to be at least an K-1 ordered mesh_fem. <literal>datalambda</literal> and <literal>datamu</literal> are the Lame coefficients of the studied material. <literal>datathreshold</literal> is the plasticity threshold of the material. The three last variables could be constants or described on the same finite element method. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1129
# 46dba819f109417b83ac6c6ffc174358
msgid "``ind = gf_model_set(model M, 'add finite strain elastoplasticity brick', mesh_im mim , string lawname, string unknowns_type [, string varnames, ...] [, string params, ...] [, int region = -1])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1131
# 0bc8f08fee4145fa8b0859f4b34fea94
msgid "Add a finite strain elastoplasticity brick to the model. For the moment there is only one supported law defined through <literal>lawname</literal> as \"Simo_Miehe\". This law supports to possibilities of unknown variables to solve for defined by means of <literal>unknowns_type</literal> set to either 'DISPLACEMENT_AND_PLASTIC_MULTIPLIER' (integer value 1) or 'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' (integer value 3). The  \"Simo_Miehe\" law expects as <literal>varnames</literal> a set of the following names that have to be defined as variables in the model:"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1141
# 0b6e60621d4d46a4b2ee666c0ba71c3a
msgid "the displacement variable which has to be defined as an unknown,"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1142
# 36a5be936fae41469ee6b7bcd0d91bc4
msgid "the plastic multiplier which has also defined as an unknown,"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1143
# ef318b51b382446d81d11255316b9882
msgid "optionally the pressure variable for a mixed displacement-pressure formulation for 'DISPLACEMENT_AND_PLASTIC_MULTIPLIER_AND_PRESSURE' as <literal>unknowns_type</literal>,"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1146
# 2b40d00ec28f4dd692d526f4da5a1ab8
msgid "the name of a (scalar) fem_data or im_data field that holds the plastic strain at the previous time step, and"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1148
# 0c9b2ef735314a908b96135d4c4cca33
msgid "the name of a fem_data or im_data field that holds all non-repeated components of the inverse of the plastic right Cauchy-Green tensor at the previous time step (it has to be a 4 element vector for plane strain 2D problems and a 6 element vector for 3D problems)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1154
# bd34c5c623a24ef987fa37c101dc9ea9
msgid "The  \"Simo_Miehe\" law also expects as <literal>params</literal> a set of the following three parameters:"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1157
# 4b51abd30e1f475eb33b25dc96b48493
msgid "an expression for the initial bulk modulus K,"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1158
# 53b0cd515d44479789340819ecb5e073
msgid "an expression for the initial shear modulus G,"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1159
# 25394500537e4af1816fe2bdb12879b4
msgid "the name of a user predefined function that decribes the yield limit as a function of the hardening variable (both the yield limit and the hardening variable values are assumed to be Frobenius norms of appropriate stress and strain tensors, respectively)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1165
# e14fb485ef644b4eb0f3fbf238cad61b
msgid "As usual, <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1170
# 8edb0cc51e724ea5bb0d60c413146521
msgid "``ind = gf_model_set(model M, 'add nonlinear incompressibility brick', mesh_im mim, string varname, string multname_pressure[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1172
# daa351163ba64c36a655eb653d6817ea
msgid "Add a nonlinear incompressibility condition on <literal>variable</literal> (for large strain elasticity). <literal>multname_pressure</literal> is a variable which represent the pressure. Be aware that an inf-sup condition between the finite element method describing the pressure and the primal variable has to be satisfied. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1181
# 1e2cd28499aa469c80392d8da231c05f
msgid "``ind = gf_model_set(model M, 'add finite strain incompressibility brick', mesh_im mim, string varname, string multname_pressure[, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1183
# 2f55635f3e544b2fb9f44e97dc6608d2
msgid "Add a finite strain incompressibility condition on <literal>variable</literal> (for large strain elasticity). <literal>multname_pressure</literal> is a variable which represent the pressure. Be aware that an inf-sup condition between the finite element method describing the pressure and the primal variable has to be satisfied. <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model. This brick is equivalent to the <literal></literal>nonlinear incompressibility brick<literal></literal> but uses the high-level generic assembly adding the term <literal></literal>p*(1-Det(Id(meshdim)+Grad_u))<literal></literal> if <literal></literal>p<literal></literal> is the multiplier and <literal></literal>u<literal></literal> the variable which represent the displacement."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1196
# abc18d6b07244661ad608f518271a8eb
msgid "``ind = gf_model_set(model M, 'add bilaplacian brick', mesh_im mim, string varname, string dataname [, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1198
# 9568910384294238b9d35b208610701b
msgid "Add a bilaplacian brick on the variable <literal>varname</literal> and on the mesh region <literal>region</literal>. This represent a term <latex style=\"text\"><![CDATA[\\Delta(D \\Delta u)]]></latex>. where <latex style=\"text\"><![CDATA[D(x)]]></latex> is a coefficient determined by <literal>dataname</literal> which could be constant or described on a f.e.m. The corresponding weak form is <latex style=\"text\"><![CDATA[\\int D(x)\\Delta u(x) \\Delta v(x) dx]]></latex>. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1207
# c12d15e7ad034fcf9d56bd6bf0539e09
msgid "``ind = gf_model_set(model M, 'add Kirchhoff-Love plate brick', mesh_im mim, string varname, string dataname_D, string dataname_nu [, int region])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1209
# a8ccd806f829485ca5edb70b5415dd4b
msgid "Add a bilaplacian brick on the variable <literal>varname</literal> and on the mesh region <literal>region</literal>. This represent a term <latex style=\"text\"><![CDATA[\\Delta(D \\Delta u)]]></latex> where <latex style=\"text\"><![CDATA[D(x)]]></latex> is a the flexion modulus determined by <literal>dataname_D</literal>. The term is integrated by part following a Kirchhoff-Love plate model with <literal>dataname_nu</literal> the poisson ratio. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1218
# f44c6fa3c4f24986a3f3d09270664105
msgid "``ind = gf_model_set(model M, 'add normal derivative source term brick', mesh_im mim, string varname, string dataname, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1220
# 3840810daea74b7fa1d80cfb726e8710
msgid "Add a normal derivative source term brick <latex style=\"text\"><![CDATA[F = \\int b.\\partial_n v]]></latex> on the variable <literal>varname</literal> and the mesh region <literal>region</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1224
# 4016711ba76547abbfa1ea6d8b60eafa
msgid "Update the right hand side of the linear system. <literal>dataname</literal> represents <literal>b</literal> and <literal>varname</literal> represents <literal>v</literal>. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1229
# 8fcdd2df3b1d4c6f94ca00f26fcf82e7
msgid "``ind = gf_model_set(model M, 'add Kirchhoff-Love Neumann term brick', mesh_im mim, string varname, string dataname_M, string dataname_divM, int region)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1231
# ce9fd0c5e33b4c6980d42da656509be7
msgid "Add a Neumann term brick for Kirchhoff-Love model on the variable <literal>varname</literal> and the mesh region <literal>region</literal>. <literal>dataname_M</literal> represents the bending moment tensor and  <literal>dataname_divM</literal> its divergence. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1238
# 575e714483204ecab173ab358c1bd3e8
msgid "``ind = gf_model_set(model M, 'add normal derivative Dirichlet condition with multipliers', mesh_im mim, string varname, mult_description, int region [, string dataname, int R_must_be_derivated])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1240
# 0b6df50e8c3e45c1aadc3877e1f82741
msgid "Add a Dirichlet condition on the normal derivative of the variable <literal>varname</literal> and on the mesh region <literal>region</literal> (which should be a boundary. The general form is <latex style=\"text\"><![CDATA[\\int \\partial_n u(x)v(x) = \\int r(x)v(x) \\forall v]]></latex> where <latex style=\"text\"><![CDATA[r(x)]]></latex> is the right hand side for the Dirichlet condition (0 for homogeneous conditions) and <latex style=\"text\"><![CDATA[v]]></latex> is in a space of multipliers defined by <literal>mult_description</literal>. If <literal>mult_description</literal> is a string this is assumed to be the variable name corresponding to the multiplier (which should be first declared as a multiplier variable on the mesh region in the model). If it is a finite element method (mesh_fem object) then a multiplier variable will be added to the model and build on this finite element method (it will be restricted to the mesh region <literal>region</literal> and eventually some conflicting dofs with some other multiplier variables will be suppressed). If it is an integer, then a  multiplier variable will be added to the model and build on a classical finite element of degree that integer. <literal>dataname</literal> is an optional parameter which represents the right hand side of the Dirichlet condition. If <literal>R_must_be_derivated</literal> is set to <literal>true</literal> then the normal derivative of <literal>dataname</literal> is considered. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1264
# b9ab46a969f049d4b1ec7e3566574433
msgid "``ind = gf_model_set(model M, 'add normal derivative Dirichlet condition with penalization', mesh_im mim, string varname, scalar coeff, int region [, string dataname, int R_must_be_derivated])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1266
# 671d1b6413ca480b9bec66c7fb2e855e
msgid "Add a Dirichlet condition on the normal derivative of the variable <literal>varname</literal> and on the mesh region <literal>region</literal> (which should be a boundary. The general form is <latex style=\"text\"><![CDATA[\\int \\partial_n u(x)v(x) = \\int r(x)v(x) \\forall v]]></latex> where <latex style=\"text\"><![CDATA[r(x)]]></latex> is the right hand side for the Dirichlet condition (0 for homogeneous conditions). The penalization coefficient is initially <literal>coeff</literal> and will be added to the data of the model. It can be changed with the command gf_model_set(model M, 'change penalization coeff'). <literal>dataname</literal> is an optional parameter which represents the right hand side of the Dirichlet condition. If <literal>R_must_be_derivated</literal> is set to <literal>true</literal> then the normal derivative of <literal>dataname</literal> is considered. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1283
# 6dbd7ee33293441aa5230d6279ea5303
msgid "``ind = gf_model_set(model M, 'add Mindlin Reissner plate brick', mesh_im mim, mesh_im mim_reduced, string varname_u3, string varname_theta , string param_E, string param_nu, string param_epsilon, string param_kappa [,int variant [, int region]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1285
# 4a6cfbf5491643a0bdd5ff7d8e655455
msgid "Add a term corresponding to the classical Reissner-Mindlin plate model for which <literal>varname_u3</literal> is the transverse displacement, <literal>varname_theta</literal> the rotation of fibers normal to the midplane, 'param_E' the Young Modulus, <literal>param_nu</literal> the poisson ratio, <literal>param_epsilon</literal> the plate thickness, <literal>param_kappa</literal> the shear correction factor. Note that since this brick uses the high level generic assembly language, the parameter can be regular expression of this language. There are three variants. <literal>variant = 0</literal> corresponds to the an unreduced formulation and in that case only the integration method <literal>mim</literal> is used. Practically this variant is not usable since it is subject to a strong locking phenomenon. <literal>variant = 1</literal> corresponds to a reduced integration where <literal>mim</literal> is used for the rotation term and <literal>mim_reduced</literal> for the transverse shear term. <literal>variant = 2</literal> (default) corresponds to the projection onto a rotated RT0 element of the transverse shear term. For the moment, this is adapted to quadrilateral only (because it is not sufficient to remove the locking phenomenon on triangle elements). Note also that if you use high order elements, the projection on RT0 will reduce the order of the approximation. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1311
# 11a9bacedccc48c6b5c745b5b4022be0
msgid "``ind = gf_model_set(model M, 'add mass brick', mesh_im mim, string varname[, string dataexpr_rho[, int region]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1313
# 7dd834707ed34c71874d1e0f9f7c1c18
msgid "Add mass term to the model relatively to the variable <literal>varname</literal>. If specified, the data <literal>dataexpr_rho</literal> is the density (1 if omitted). <literal>region</literal> is an optional mesh region on which the term is added. If it is not specified, it is added on the whole mesh. Return the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1320
# f2c51c97dd0342b59ff408cd0d501160
msgid "``gf_model_set(model M, 'shift variables for time integration')``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1322
# 8584f27b290d48bca7dc35c9991af2fe
msgid "Function used to shift the variables of a model to the data corresponding of ther value on the previous time step for time integration schemes. For each variable for which a time integration scheme has been declared, the scheme is called to perform the shift. This function has to be called between two time steps."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1329
# 5feac16b86764916980ed182116a8375
msgid "``gf_model_set(model M, 'perform init time derivative', scalar ddt)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1331
# 1cc3594fdbf247e09d4b426e27f8cf27
msgid "By calling this function, indicates that the next solve will compute the solution for a (very) small time step <literal>ddt</literal> in order to initalize the data corresponding to the derivatives needed by time integration schemes (mainly the initial time derivative for order one in time problems  and the second order time derivative for second order in time problems). The next solve will not change the value of the variables."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1339
# cd4e0d1f672b4e6eb7def30df9e5c8be
msgid "``gf_model_set(model M, 'set time step', scalar dt)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1341
# f8a9f69f3c214e4da5719127c90be87f
msgid "Set the value of the time step to <literal>dt</literal>. This value can be change from a step to another for all one-step schemes (i.e for the moment to all proposed time integration schemes)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1346
# d169515be89948e587b59e94d62af26f
msgid "``gf_model_set(model M, 'set time', scalar t)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1348
# 80910eb092664266a015c78ea87b3d3e
msgid "Set the value of the data <literal>t</literal> corresponding to the current time to <literal>t</literal>."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1352
# 5a9b19c71e7443e5ad61e0edac8169c1
msgid "``gf_model_set(model M, 'add theta method for first order', string varname, scalar theta)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1354
# 2a209873909c4423b3abdc78ff54cf50
msgid "Attach a theta method for the time discretization of the variable <literal>varname</literal>. Valid only if there is at most first order time derivative of the variable."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1359
# f026933602e14207af48a5ea73bae51a
msgid "``gf_model_set(model M, 'add theta method for second order', string varname, scalar theta)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1361
#: ../source/scilab/cmdref_gf_model_set.rst:1368
# b3cafd9d908949a1875180b550f43b29
# 65553d737e9146aaa47de3a730a50b74
msgid "Attach a theta method for the time discretization of the variable <literal>varname</literal>. Valid only if there is at most second order time derivative of the variable."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1366
# f9868fa549194501b778a5705ac97591
msgid "``gf_model_set(model M, 'add Newmark scheme', string varname, scalar beta, scalar gamma)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1373
# 9987871d012b486fb0d6b4540aadbf92
msgid "``gf_model_set(model M, 'disable bricks', ivec bricks_indices)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1375
# fe4e4fd9136448fd9d372e22c4de84a4
msgid "Disable a brick (the brick will no longer participate to the building of the tangent linear system)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1379
# 65588876675f4f22806b87b9f436e5d8
msgid "``gf_model_set(model M, 'enable bricks', ivec bricks_indices)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1381
# 6c8cacdbabe74ad48584268e6bac906e
msgid "Enable a disabled brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1384
# 0fc38fe5970b47fca32cf3303d5401db
msgid "``gf_model_set(model M, 'disable variable', string varname)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1386
# aa36ae9109064d8290fa9ef1afa3e870
msgid "Disable a variable for a solve (and its attached multipliers). The next solve will operate only on the remaining variables. This allows to solve separately different parts of a model. If there is a strong coupling of the variables, a fixed point strategy can the be used."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1393
# 63af3128631e4b5cb28300a359d492d3
msgid "``gf_model_set(model M, 'enable variable', string varname)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1395
# 3061a183e2b04c0a8b944a7e129d6981
msgid "Enable a disabled variable (and its attached multipliers)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1398
# 272b1b66cd6b49a4970f39516bee0873
msgid "``gf_model_set(model M, 'first iter')``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1400
# f90740f9af174fdca0d2131482d91a26
msgid "To be executed before the first iteration of a time integration scheme."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1404
# 91b0541576ec42db82763e4cb35f0db3
msgid "``gf_model_set(model M, 'next iter')``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1406
# 70b0aab977b045889207533c4419e179
msgid "To be executed at the end of each iteration of a time integration scheme."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1410
# 5551c2264de64eed85df2e3d836f0c9b
msgid "``ind = gf_model_set(model M, 'add basic contact brick', string varname_u, string multname_n[, string multname_t], string dataname_r, spmat BN[, spmat BT, string dataname_friction_coeff][, string dataname_gap[, string dataname_alpha[, int augmented_version[, string dataname_gamma, string dataname_wt]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1412
# 3b22beb24e764604b4f7ebc40bdcf773
msgid "Add a contact with or without friction brick to the model. If U is the vector of degrees of freedom on which the unilateral constraint is applied, the matrix <literal>BN</literal> have to be such that this constraint is defined by <latex style=\"text\"><![CDATA[B_N U \\le 0]]></latex>. A friction condition can be considered by adding the three parameters <literal>multname_t</literal>, <literal>BT</literal> and <literal>dataname_friction_coeff</literal>. In this case, the tangential displacement is <latex style=\"text\"><![CDATA[B_T U]]></latex> and the matrix <literal>BT</literal> should have as many rows as <literal>BN</literal> multiplied by <latex style=\"text\"><![CDATA[d-1]]></latex> where <latex style=\"text\"><![CDATA[d]]></latex> is the domain dimension. In this case also, <literal>dataname_friction_coeff</literal> is a data which represents the coefficient of friction. It can be a scalar or a vector representing a value on each contact condition.  The unilateral constraint is prescribed thank to a multiplier <literal>multname_n</literal> whose dimension should be equal to the number of rows of <literal>BN</literal>. If a friction condition is added, it is prescribed with a multiplier <literal>multname_t</literal> whose dimension should be equal to the number of rows of <literal>BT</literal>. The augmentation parameter <literal>r</literal> should be chosen in a range of acceptabe values (see Getfem user documentation). <literal>dataname_gap</literal> is an optional parameter representing the initial gap. It can be a single value or a vector of value. <literal>dataname_alpha</literal> is an optional homogenization parameter for the augmentation parameter (see Getfem user documentation).  The parameter <literal>augmented_version</literal> indicates the augmentation strategy : 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 for the symmetric one (except for the coupling between contact and Coulomb friction), 3 for the unsymmetric method with augmented multipliers, 4 for the unsymmetric method with augmented multipliers and De Saxce projection."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1442
# 8f0d50f0a2f442bbbed642ed3d3f75b3
msgid "``ind = gf_model_set(model M, 'add basic contact brick two deformable bodies', string varname_u1, string varname_u2, string multname_n, string dataname_r, spmat BN1, spmat BN2[, string dataname_gap[, string dataname_alpha[, int augmented_version]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1461
# 7babf059dd004c8faaec22a7d0fb5a62
msgid "Add a frictionless contact condition to the model between two deformable"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1445
# be2893c0a198413c86ebc5a8102def5b
msgid "bodies. If U1, U2 are the vector of degrees of freedom on which the unilateral constraint is applied, the matrices <literal>BN1</literal> and <literal>BN2</literal> have to be such that this condition is defined by $B_{N1} U_1 B_{N2} U_2 + \\le gap$. The constraint is prescribed thank to a multiplier <literal>multname_n</literal> whose dimension should be equal to the number of lines of <literal>BN</literal>. The augmentation parameter <literal>r</literal> should be chosen in a range of acceptabe values (see Getfem user documentation). <literal>dataname_gap</literal> is an optional parameter representing the initial gap. It can be a single value or a vector of value. <literal>dataname_alpha</literal> is an optional homogenization parameter for the augmentation parameter (see Getfem user documentation). The parameter <literal>aug_version</literal> indicates the augmentation strategy : 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 for the symmetric one, 3 for the unsymmetric method with augmented multiplier."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1463
# 931cb6b5ef9e469d8244d526040cb803
msgid "``gf_model_set(model M, 'contact brick set BN', int indbrick, spmat BN)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1465
# 21b9cf5573d14a818097614d17f2a646
msgid "Can be used to set the BN matrix of a basic contact/friction brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1468
# 9a49c3c8d990412bb46c560cece1f255
msgid "``gf_model_set(model M, 'contact brick set BT', int indbrick, spmat BT)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1470
# 046fb3085189408193ddda6929518249
msgid "Can be used to set the BT matrix of a basic contact with friction brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1474
# 1d5984880d8845669360edb4fcafbf58
msgid "``ind = gf_model_set(model M, 'add nodal contact with rigid obstacle brick',  mesh_im mim, string varname_u, string multname_n[, string multname_t], string dataname_r[, string dataname_friction_coeff], int region, string obstacle[,  int augmented_version])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1476
# 8e18c985308d4fcf9dd3f924047a15e0
msgid "Add a contact with or without friction condition with a rigid obstacle to the model. The condition is applied on the variable <literal>varname_u</literal> on the boundary corresponding to <literal>region</literal>. The rigid obstacle should be described with the string <literal>obstacle</literal> being a signed distance to the obstacle. This string should be an expression where the coordinates are 'x', 'y' in 2D and 'x', 'y', 'z' in 3D. For instance, if the rigid obstacle correspond to <latex style=\"text\"><![CDATA[z \\le 0]]></latex>, the corresponding signed distance will be simply \"z\". <literal>multname_n</literal> should be a fixed size variable whose size is the number of degrees of freedom on boundary <literal>region</literal>. It represents the contact equivalent nodal forces. In order to add a friction condition one has to add the <literal>multname_t</literal> and <literal>dataname_friction_coeff</literal> parameters. <literal>multname_t</literal> should be a fixed size variable whose size is the number of degrees of freedom on boundary <literal>region</literal> multiplied by <latex style=\"text\"><![CDATA[d-1]]></latex> where <latex style=\"text\"><![CDATA[d]]></latex> is the domain dimension. It represents the friction equivalent nodal forces. The augmentation parameter <literal>r</literal> should be chosen in a range of acceptabe values (close to the Young modulus of the elastic body, see Getfem user documentation).  <literal>dataname_friction_coeff</literal> is the friction coefficient. It could be a scalar or a vector of values representing the friction coefficient on each contact node. The parameter <literal>augmented_version</literal> indicates the augmentation strategy : 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 for the symmetric one (except for the coupling between contact and Coulomb friction), 3 for the new unsymmetric method. Basically, this brick compute the matrix BN and the vectors gap and alpha and calls the basic contact brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1505
# a55d27b52a2646c8b99ad38f049341b9
msgid "``ind = gf_model_set(model M, 'add contact with rigid obstacle brick',  mesh_im mim, string varname_u, string multname_n[, string multname_t], string dataname_r[, string dataname_friction_coeff], int region, string obstacle[,  int augmented_version])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1507
# bb9b2e7571574eae8aa32a6fd7e10516
msgid "DEPRECATED FUNCTION. Use 'add nodal contact with rigid obstacle brick' instead."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1510
# 9fb3deb971994cdc8692f8bc147eeeca
msgid "``ind = gf_model_set(model M, 'add integral contact with rigid obstacle brick',  mesh_im mim, string varname_u, string multname, string dataname_obstacle, string dataname_r [, string dataname_friction_coeff], int region [, int option [, string dataname_alpha [, string dataname_wt [, string dataname_gamma [, string dataname_vt]]]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1512
# b2bb0b30ec2a4559a21f090f249b682c
msgid "Add a contact with or without friction condition with a rigid obstacle to the model. This brick adds a contact which is defined in an integral way. It is the direct approximation of an augmented Lagrangian formulation (see Getfem user documentation) defined at the continuous level. The advantage is a better scalability: the number of Newton iterations should be more or less independent of the mesh size. The contact condition is applied on the variable <literal>varname_u</literal> on the boundary corresponding to <literal>region</literal>. The rigid obstacle should be described with the data <literal>dataname_obstacle</literal> being a signed distance to the obstacle (interpolated on a finite element method). <literal>multname</literal> should be a fem variable representing the contact stress. An inf-sup condition beetween <literal>multname</literal> and <literal>varname_u</literal> is required. The augmentation parameter <literal>dataname_r</literal> should be chosen in a range of acceptabe values. The optional parameter <literal>dataname_friction_coeff</literal> is the friction coefficient which could be constant or defined on a finite element method. Possible values for <literal>option</literal> is 1 for the non-symmetric Alart-Curnier augmented Lagrangian method, 2 for the symmetric one, 3 for the non-symmetric Alart-Curnier method with an additional augmentation and 4 for a new unsymmetric method. The default value is 1. In case of contact with friction, <literal>dataname_alpha</literal> and <literal>dataname_wt</literal> are optional parameters to solve evolutionary friction problems. <literal>dataname_gamma</literal> and <literal>dataname_vt</literal> represent optional data for adding a parameter-dependent sliding velocity to the friction condition."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1539
# 57b467b60d7f40b3adf7fefc2c7c81f1
msgid "``ind = gf_model_set(model M, 'add penalized contact with rigid obstacle brick',  mesh_im mim, string varname_u, string dataname_obstacle, string dataname_r [, string dataname_coeff], int region [, int option, string dataname_lambda, [, string dataname_alpha [, string dataname_wt]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1541
# 4436e270d4e44c1ea04010ef84cfe88b
msgid "Add a penalized contact with or without friction condition with a rigid obstacle to the model. The condition is applied on the variable <literal>varname_u</literal> on the boundary corresponding to <literal>region</literal>. The rigid obstacle should be described with the data <literal>dataname_obstacle</literal> being a signed distance to the obstacle (interpolated on a finite element method). The penalization parameter <literal>dataname_r</literal> should be chosen large enough to prescribe approximate non-penetration and friction conditions but not too large not to deteriorate too much the conditionning of the tangent system. <literal>dataname_lambda</literal> is an optional parameter used if option is 2. In that case, the penalization term is shifted by lambda (this allows the use of an Uzawa algorithm on the corresponding augmented Lagrangian formulation)"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1558
# 4aa019e48f5c4011bd5b86040c8e8315
msgid "``ind = gf_model_set(model M, 'add Nitsche contact with rigid obstacle brick', mesh_im mim, string varname, string Neumannterm, string dataname_obstacle, string gamma0name,  int region[, scalar theta[, string dataname_friction_coeff[, string dataname_alpha, string dataname_wt]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1560
# 87b5481d21124c31a89d9cfea6b9caf4
msgid "Adds a contact condition with or without Coulomb friction on the variable <literal>varname</literal> and the mesh boundary <literal>region</literal>. The contact condition is prescribed with Nitsche's method. The rigid obstacle should be described with the data <literal>dataname_obstacle</literal> being a signed distance to the obstacle (interpolated on a finite element method). <literal>gamma0name</literal> is the Nitsche's method parameter. <literal>theta</literal> is a scalar value which can be positive or negative. <literal>theta = 1</literal> corresponds to the standard symmetric method which is conditionnaly coercive for  <literal>gamma0</literal> small. <literal>theta = -1</literal> corresponds to the skew-symmetric method which is inconditionnaly coercive. <literal>theta = 0</literal> is the simplest method for which the second derivative of the Neumann term is not necessary. The optional parameter <literal>dataname_friction_coeff</literal> is the friction coefficient which could be constant or defined on a finite element method. CAUTION: This brick has to be added in the model after all the bricks corresponding to partial differential terms having a Neumann term. Moreover, This brick can only be applied to bricks declaring their Neumann terms. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1582
# a875039fecdd41dfaa71a69a6a52fb3b
msgid "``ind = gf_model_set(model M, 'add Nitsche midpoint contact with rigid obstacle brick', mesh_im mim, string varname, string Neumannterm, string Neumannterm_wt, string dataname_obstacle, string gamma0name,  int region, scalar theta, string dataname_friction_coeff, string dataname_alpha, string dataname_wt)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1584
# 959cad59bc084a8fbd868ac71c4e9ad8
msgid "EXPERIMENTAL BRICK: for midpoint scheme only !! Adds a contact condition with or without Coulomb friction on the variable <literal>varname</literal> and the mesh boundary <literal>region</literal>. The contact condition is prescribed with Nitsche's method. The rigid obstacle should be described with the data <literal>dataname_obstacle</literal> being a signed distance to the obstacle (interpolated on a finite element method). <literal>gamma0name</literal> is the Nitsche's method parameter. <literal>theta</literal> is a scalar value which can be positive or negative. <literal>theta = 1</literal> corresponds to the standard symmetric method which is conditionnaly coercive for  <literal>gamma0</literal> small. <literal>theta = -1</literal> corresponds to the skew-symmetric method which is inconditionnaly coercive. <literal>theta = 0</literal> is the simplest method for which the second derivative of the Neumann term is not necessary. The optional parameter <literal>dataname_friction_coeff</literal> is the friction coefficient which could be constant or defined on a finite element method. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1605
# 12b2093e9fb24d6bbd30ab43a717eb8a
msgid "``ind = gf_model_set(model M, 'add Nitsche fictitious domain contact brick', mesh_im mim, string varname1, string varname2, string dataname_d1, string dataname_d2, string gamma0name [, scalar theta[, string dataname_friction_coeff[, string dataname_alpha, string dataname_wt1,string dataname_wt2]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1607
# 23d0251f1b5742448278178b6a11aefb
msgid "Adds a contact condition with or without Coulomb friction between two bodies in a fictitious domain. The contact condition is applied on the variable <literal>varname_u1</literal> corresponds with the first and slave body with Nitsche's method and on the variable <literal>varname_u2</literal> corresponds with the second and master body with Nitsche's method. The contact condition is evaluated on the fictitious slave boundary. The first body should be described by the level-set <literal>dataname_d1</literal> and the second body should be described by the level-set <literal>dataname_d2</literal>. <literal>gamma0name</literal> is the Nitsche's method parameter. <literal>theta</literal> is a scalar value which can be positive or negative. <literal>theta = 1</literal> corresponds to the standard symmetric method which is conditionnaly coercive for  <literal>gamma0</literal> small. <literal>theta = -1</literal> corresponds to the skew-symmetric method which is inconditionnaly coercive. <literal>theta = 0</literal> is the simplest method for which the second derivative of the Neumann term is not necessary. The optional parameter <literal>dataname_friction_coeff</literal> is the friction coefficient which could be constant or defined on a finite element method. CAUTION: This brick has to be added in the model after all the bricks corresponding to partial differential terms having a Neumann term. Moreover, This brick can only be applied to bricks declaring their Neumann terms. Returns the brick index in the model."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1630
# 8ca3c318d75349ed9682672564766be1
msgid "``ind = gf_model_set(model M, 'add nodal contact between nonmatching meshes brick',  mesh_im mim1[, mesh_im mim2], string varname_u1[, string varname_u2], string multname_n[, string multname_t], string dataname_r[, string dataname_fr], int rg1, int rg2[, int slave1, int slave2,  int augmented_version])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1632
# d805fb8f26954e16a10d7c1f3a4f0686
msgid "Add a contact with or without friction condition between two faces of one or two elastic bodies. The condition is applied on the variable <literal>varname_u1</literal> or the variables <literal>varname_u1</literal> and <literal>varname_u2</literal> depending if a single or two distinct displacement fields are given. Integers <literal>rg1</literal> and <literal>rg2</literal> represent the regions expected to come in contact with each other. In the single displacement variable case the regions defined in both <literal>rg1</literal> and <literal>rg2</literal> refer to the variable <literal>varname_u1</literal>. In the case of two displacement variables, <literal>rg1</literal> refers to <literal>varname_u1</literal> and <literal>rg2</literal> refers to <literal>varname_u2</literal>. <literal>multname_n</literal> should be a fixed size variable whose size is the number of degrees of freedom on those regions among the ones defined in <literal>rg1</literal> and <literal>rg2</literal> which are characterized as \"slaves\". It represents the contact equivalent nodal normal forces. <literal>multname_t</literal> should be a fixed size variable whose size corresponds to the size of <literal>multname_n</literal> multiplied by qdim - 1 . It represents the contact equivalent nodal tangent (frictional) forces. The augmentation parameter <literal>r</literal> should be chosen in a range of acceptabe values (close to the Young modulus of the elastic body, see Getfem user documentation). The friction coefficient stored in the parameter <literal>fr</literal> is either a single value or a vector of the same size as <literal>multname_n</literal>. The optional parameters <literal>slave1</literal> and <literal>slave2</literal> declare if the regions defined in <literal>rg1</literal> and <literal>rg2</literal> are correspondingly considered as \"slaves\". By default <literal>slave1</literal> is true and <literal>slave2</literal> is false, i.e. <literal>rg1</literal> contains the slave surfaces, while 'rg2' the master surfaces. Preferrably only one of <literal>slave1</literal> and <literal>slave2</literal> is set to true.  The parameter <literal>augmented_version</literal> indicates the augmentation strategy : 1 for the non-symmetric Alart-Curnier augmented Lagrangian, 2 for the symmetric one (except for the coupling between contact and Coulomb friction), 3 for the new unsymmetric method. Basically, this brick computes the matrices BN and BT and the vectors gap and alpha and calls the basic contact brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1664
# 063aea2901984b4586a482549f75cae2
msgid "``ind = gf_model_set(model M, 'add nonmatching meshes contact brick',  mesh_im mim1[, mesh_im mim2], string varname_u1[, string varname_u2], string multname_n[, string multname_t], string dataname_r[, string dataname_fr], int rg1, int rg2[, int slave1, int slave2,  int augmented_version])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1666
# 0f9a615a241440659f2cc454bda00eb7
msgid "DEPRECATED FUNCTION. Use 'add nodal contact between nonmatching meshes brick' instead."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1669
# 8406c93c563e4942820c07b52a330cbe
msgid "``ind = gf_model_set(model M, 'add integral contact between nonmatching meshes brick',  mesh_im mim, string varname_u1, string varname_u2, string multname, string dataname_r [, string dataname_friction_coeff], int region1, int region2 [, int option [, string dataname_alpha [, string dataname_wt1 , string dataname_wt2]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1671
# ebf75809c592472a8125f551ab9f3cea
msgid "Add a contact with or without friction condition between nonmatching meshes to the model. This brick adds a contact which is defined in an integral way. It is the direct approximation of an augmented agrangian formulation (see Getfem user documentation) defined at the continuous level. The advantage should be a better scalability: the number of Newton iterations should be more or less independent of the mesh size. The condition is applied on the variables <literal>varname_u1</literal> and <literal>varname_u2</literal> on the boundaries corresponding to <literal>region1</literal> and <literal>region2</literal>. <literal>multname</literal> should be a fem variable representing the contact stress for the frictionless case and the contact and friction stress for the case with friction. An inf-sup condition between <literal>multname</literal> and <literal>varname_u1</literal> and <literal>varname_u2</literal> is required. The augmentation parameter <literal>dataname_r</literal> should be chosen in a range of acceptable values. The optional parameter <literal>dataname_friction_coeff</literal> is the friction coefficient which could be constant or defined on a finite element method on the same mesh as <literal>varname_u1</literal>. Possible values for <literal>option</literal> is 1 for the non-symmetric Alart-Curnier augmented Lagrangian method, 2 for the symmetric one, 3 for the non-symmetric Alart-Curnier method with an additional augmentation and 4 for a new unsymmetric method. The default value is 1. In case of contact with friction, <literal>dataname_alpha</literal>, <literal>dataname_wt1</literal> and <literal>dataname_wt2</literal> are optional parameters to solve evolutionary friction problems."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1699
# f55f1e3d56f14c6dba52c111be8b08e5
msgid "``ind = gf_model_set(model M, 'add penalized contact between nonmatching meshes brick',  mesh_im mim, string varname_u1, string varname_u2, string dataname_r [, string dataname_coeff], int region1, int region2 [, int option [, string dataname_lambda, [, string dataname_alpha [, string dataname_wt1, string dataname_wt2]]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1701
# e268301a868c4056bc642ddeeb80df60
msgid "Add a penalized contact condition with or without friction between nonmatching meshes to the model. The condition is applied on the variables <literal>varname_u1</literal> and  <literal>varname_u2</literal> on the boundaries corresponding to <literal>region1</literal> and <literal>region2</literal>. The penalization parameter <literal>dataname_r</literal> should be chosen large enough to prescribe approximate non-penetration and friction conditions but not too large not to deteriorate too much the conditionning of the tangent system. The optional parameter <literal>dataname_friction_coeff</literal> is the friction coefficient which could be constant or defined on a finite element method on the same mesh as <literal>varname_u1</literal>. <literal>dataname_lambda</literal> is an optional parameter used if option is 2. In that case, the penalization term is shifted by lambda (this allows the use of an Uzawa algorithm on the corresponding augmented Lagrangian formulation) In case of contact with friction, <literal>dataname_alpha</literal>, <literal>dataname_wt1</literal> and <literal>dataname_wt2</literal> are optional parameters to solve evolutionary friction problems."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1722
# 2e9b4d7ffb50430da47a58f3b97d12e9
msgid "``ind = gf_model_set(model M, 'add integral large sliding contact brick raytracing', string dataname_r, scalar release_distance, [, string dataname_fr[, string dataname_alpha[, int version]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1724
# 02742f9f43ea4a86acdc9a8d7006ec65
msgid "Adds a large sliding contact with friction brick to the model. This brick is able to deal with self-contact, contact between several deformable bodies and contact with rigid obstacles. It uses the high-level generic assembly. It adds to the model a raytracing_interpolate_transformation object. For each slave boundary a multiplier variable should be defined. The release distance should be determined with care (generally a few times a mean element size, and less than the thickness of the body). Initially, the brick is added with no contact boundaries. The contact boundaries and rigid bodies are added with special functions. <literal>version</literal> is 0 (the default value) for the non-symmetric version and 1 for the more symmetric one (not fully symmetric even without friction)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1739
# b54547bbf1944c55952a39e4fe3f12aa
msgid "``gf_model_set(model M, 'add rigid obstacle to large sliding contact brick', int indbrick, string expr, int N)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1741
#: ../source/scilab/cmdref_gf_model_set.rst:1787
# c0fe586c19984b0484e18646b765fbf8
# e619c87cdf51406a8426f5f7b39ede22
msgid "Adds a rigid obstacle to an existing large sliding contact with friction brick. <literal>expr</literal> is an expression using the high-level generic assembly language (where <literal>x</literal> is the current point n the mesh) which should be a signed distance to the obstacle. <literal>N</literal> is the mesh dimension."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1748
# f0f69c8d516d4a27ad414601efbb1b5b
msgid "``gf_model_set(model M, 'add master contact boundary to large sliding contact brick', int indbrick, mesh_im mim, int region, string dispname[, string wname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1750
# 8900caabafb34e3fbfd719137215be16
msgid "Adds a master contact boundary to an existing large sliding contact with friction brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1754
# 4ed4158721b3417caf4b194dbe1f8dde
msgid "``gf_model_set(model M, 'add slave contact boundary to large sliding contact brick', int indbrick, mesh_im mim, int region, string dispname, string lambdaname[, string wname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1756
# 56bd509d04d84522aa1691bd34aa8bc7
msgid "Adds a slave contact boundary to an existing large sliding contact with friction brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1760
# ba3e5f56f3cc48778d28dd3159d76168
msgid "``gf_model_set(model M, 'add master slave contact boundary to large sliding contact brick', int indbrick, mesh_im mim, int region, string dispname, string lambdaname[, string wname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1762
# af86f21fa670417aa501d057fb8b0a93
msgid "Adds a contact boundary to an existing large sliding contact with friction brick which is both master and slave (allowing the self-contact)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1767
# 26124d31274c4530a80d5f7235b1b7c0
msgid "``ind = gf_model_set(model M, 'add Nitsche large sliding contact brick raytracing', bool unbiased_version, string dataname_r, scalar release_distance[, string dataname_fr[, string dataname_alpha[, int version]]])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1769
# 2fa03a987ec449b59a930e1c59e5df23
msgid "Adds a large sliding contact with friction brick to the model based on the Nitsche's method. This brick is able to deal with self-contact, contact between several deformable bodies and contact with rigid obstacles. It uses the high-level generic assembly. It adds to the model a raytracing_interpolate_transformation object. \"unbiased_version\" refers to the version of Nische's method to be used. (unbiased or biased one). For each slave boundary a  material law should be defined as a function of the dispacement variable on this boundary. The release distance should be determined with care (generally a few times a mean element size, and less than the thickness of the body). Initially, the brick is added with no contact boundaries. The contact boundaries and rigid bodies are added with special functions. <literal>version</literal> is 0 (the default value) for the non-symmetric version and 1 for the more symmetric one (not fully symmetric even without friction)."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1785
# 293d52b6d09a4462989eca096805d356
msgid "``gf_model_set(model M, 'add rigid obstacle to Nitsche large sliding contact brick', int indbrick, string expr, int N)``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1794
# ff0443a3321447739dc4f6f255d38920
msgid "``gf_model_set(model M, 'add master contact boundary to biased Nitsche large sliding contact brick', int indbrick, mesh_im mim, int region, string dispname[, string wname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1796
# 1eadd8ee192f44a08ea44fc14a2db799
msgid "Adds a master contact boundary to an existing biased Nitsche's large sliding contact with friction brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1800
# a57207e950794891b8b71d24c4ebfedd
msgid "``gf_model_set(model M, 'add slave contact boundary to biased Nitsche large sliding contact brick', int indbrick, mesh_im mim, int region, string dispname, string lambdaname[, string wname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1802
# 1501e3b2cc2e438e947231aa55b6d66d
msgid "Adds a slave contact boundary to an existing biased Nitsche's large sliding contact with friction brick."
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1806
# 35d77459635246c09ab64eefd9aeff01
msgid "``gf_model_set(model M, 'add contact boundary to unbiased Nitsche large sliding contact brick', int indbrick, mesh_im mim, int region, string dispname, string lambdaname[, string wname])``"
msgstr ""

#: ../source/scilab/cmdref_gf_model_set.rst:1808
# b58b28b14a96427e84387da600698510
msgid "Adds a contact boundary to an existing unbiased Nitschelarge sliding contact with friction brick which is both master and slave."
msgstr ""

