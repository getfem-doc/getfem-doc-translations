# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2018 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-15 02:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/userdoc/model_continuation.rst:14
# e6ad8a8ec8e243f4b020807fb583dfa2
msgid "Numerical continuation and bifurcation"
msgstr ""

#: ../source/userdoc/model_continuation.rst:16
# 5d4e61eb025744f68ec497806f1ec6ef
msgid "Let an algebraic problem coming from discretisation of a FEM-model can be written in the form"
msgstr ""

#: ../source/userdoc/model_continuation.rst:23
# ce5d3e9e49ca4e4b9244191e8170dc48
msgid "In what follows, we shall suppose that the model depends on an additional scalar parameter :math:`\\lambda` so that :math:`F(U) = F(U, \\lambda)`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:27
# 4e79c40dca5b4fc492425c9ad8b762d5
msgid "Numerical continuation"
msgstr ""

#: ../source/userdoc/model_continuation.rst:29
# b58e3171c9a645ad8a52c67a40823003
msgid "Methods of numerical continuation serve for tracing solutions of the system"
msgstr ""

#: ../source/userdoc/model_continuation.rst:35
# eca1ade8e7d748f29d079b382f9c4b1a
msgid "In |gf|, a continuation technique for piecewise :math:`C^{1}` (:math:`PC^{1}`) solution curves is implemented (see [Li-Re2014]_ for more details). Since it does not make an explicit difference between the state variable :math:`U` and the parameter :math:`\\lambda`, we shall denote :math:`Y := (U, \\lambda)` for brevity. Nevertheless, to avoid bad scaling when calculating tangents, for example, we shall use the following weighted scalar product and norm:"
msgstr ""

#: ../source/userdoc/model_continuation.rst:46
# 7b3c21a8734e46f4a7ef3aae09f21790
msgid "Here, :math:`\\kappa` should be chosen so that :math:`\\kappa \\langle U, \\tilde{U} \\rangle` is proportional to the scalar product of the corresponding space variables, usually in :math:`L^{2}`. One can take, for example, :math:`\\kappa = h^{d}`, where :math:`h` is the mesh size and :math:`d` stands for the dimension of the underlying problem. Alternatively, :math:`\\kappa` can be chosen as :math:`1/N` for simplicity."
msgstr ""

#: ../source/userdoc/model_continuation.rst:53
# 6d72a883cf3e43ebbbaf96a0fa6003c8
msgid "The idea of the continuation strategy is to continue smooth pieces of solution curves by a classical predictor-corrector method and to join the smooth pieces continuously."
msgstr ""

#: ../source/userdoc/model_continuation.rst:57
# a99077c2382549728b6ae0394d78d90e
msgid "The particular predictor-corrector method employed is a slight modification of the *inexact Moore-Penrose* continuation implemented in MATCONT [Dh-Go-Ku2003]_. It computes a sequence of consecutive points :math:`Y_{j}` lying approximately on a solution curve and a sequence of the corresponding unit tangent vectors :math:`T_{j}`:"
msgstr ""

#: ../source/userdoc/model_continuation.rst:67
# ccafb52ab0f24a60b4e7d744810807de
msgid "To describe it, let us suppose that we have a couple :math:`(Y_{j}, T_{j})` satisfying the relations above at our disposal. In the *prediction*, an initial approximation of :math:`(Y_{j+1}, T_{j+1})` is taken as"
msgstr ""

#: ../source/userdoc/model_continuation.rst:75
# 4ef6a6592ee5439d84d3292fa84ae725
msgid "where :math:`h_{j}` is a step size. Its choice will be discussed later on."
msgstr ""

#: ../source/userdoc/model_continuation.rst:77
# 439d24ad31604a279ceb07e11adabd2b
msgid "In the *correction*, one computes a sequence :math:`\\{(Y_{j+1}^{l}, T_{j+1}^{l})\\}`, where :math:`T_{j+1}^{l} := \\tilde{T}_{j+1}^{l} / \\lVert \\tilde{T}_{j+1}^{l} \\rVert_{w}` and the couple :math:`(Y_{j+1}^{l}, \\tilde{T}_{j+1}^{l})` is given by one iteration of the Newton method applied to the equation :math:`F^{l}(Y, T) = 0` with"
msgstr ""

#: ../source/userdoc/model_continuation.rst:88
# f1f3066a2a4c4f85bad3cca0bd446032
msgid "and the initial approximation :math:`(Y_{j+1}^{l-1}, T_{j+1}^{l-1})`. Due to the potential non-differentiability of :math:`F`, a piecewise-smooth variant of the Newton method is used (Algorithm 7.2.14 in [Fa-Pa2003]_)."
msgstr ""

#: ../source/userdoc/model_continuation.rst:96
# 2d2b7ec50a3e4b4db9309aff7a6ac09e
msgid "Correction."
msgstr ""

#: ../source/userdoc/model_continuation.rst:98
# 5e6c712696b54d65bb68816e80e137f0
msgid "A couple :math:`(Y_{j+1}^{l}, T_{j+1}^{l})` is accepted for :math:`(Y_{j+1}, T_{j+1})` if :math:`\\lVert F(Y_{j+1}^{l})\\rVert \\leq \\varepsilon`, :math:`\\lVert Y_{j+1}^{l} - Y_{j+1}^{l-1}\\rVert_{w} \\leq \\varepsilon'`, and the cosine of the angle between :math:`T_{j+1}^{l}` and :math:`T_{j}` is greater or equal to :math:`c_{\\mathrm{min}}`. Let us note that the partial gradient of :math:`F` (or of one of its selection functions in the case of the non-differentiability) with respect to :math:`U` is assembled analytically whereas the partial gradient with respect to :math:`\\lambda` is evaluated by forward finite differences with an increment equal to 1e-8."
msgstr ""

#: ../source/userdoc/model_continuation.rst:109
# 1872c1a6e28f4fcd833ce26c0e51418e
msgid "The step size :math:`h_{j+1}` in the next prediction depends on how the Newton correction has been successful. Denoting the number of iterations needed by :math:`l_{\\mathrm{it}}`, it is selected as"
msgstr ""

#: ../source/userdoc/model_continuation.rst:117
# b3df148ebe0c4e498f100da2060476a5
msgid "where :math:`0 < h_{\\mathrm{dec}} < 1 < h_{\\mathrm{inc}}`, :math:`0 < l_{\\mathrm{thr}}` and :math:`0 < h_{\\mathrm{min}} < h_{\\mathrm{max}}` are given constants. At the beginning, one sets :math:`h_{1} := h_{\\mathrm{init}}` for some :math:`h_{\\mathrm{min}} \\leq h_{\\mathrm{init}} \\leq h_{\\mathrm{max}}`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:123
# 9984215d8e414347a565422510e9173e
msgid "Now, let us suppose that we have approximated a piece of a solution curve corresponding to one sub-domain of smooth behaviour of :math:`F` and we want to recover a piece corresponding to another sub-domain of smooth behaviour. Let :math:`(Y_{j},T_{j})` be the last computed couple."
msgstr ""

#: ../source/userdoc/model_continuation.rst:132
# a565ebd8642b4ee08b86091049f96687
msgid "Transition between smooth pieces of a solution curve."
msgstr ""

#: ../source/userdoc/model_continuation.rst:134
# aadb4f016d324afb902d16676c959ac8
msgid "To approximate the tangent to the other smooth piece, we first take a point :math:`Y_{j} + h T_{j}` with :math:`h` a bit greater than :math:`h_{\\mathrm{min}}` so that this point belongs to the interior of the other sub-domain of smooth behaviour. Then we find :math:`\\tilde{T}` such that"
msgstr ""

#: ../source/userdoc/model_continuation.rst:143
# 41baaf66984d4d5cbdaa56544340cde5
msgid "and it remains to determine an appropriate direction of this vector. This can be done on the basis of the following observations:  First, there exists :math:`r \\in \\{\\pm 1\\}` such that :math:`Y_{j} - r \\tilde{h} \\tilde{T}` remains in the same sub-domain as :math:`Y_{j}` for any :math:`\\tilde{h}` positive. This is characterised by the fact that :math:`\\frac{\\lvert T_{-}^{\\top} \\tilde{T}\\rvert}{\\lVert T_{-} \\rVert \\lVert \\tilde{T} \\rVert}` is significantly smaller than 1 for :math:`T_{-}` with :math:`\\nabla F(Y_{j} - r \\tilde{h} \\tilde{T}) T_{-} = 0`. Second, :math:`Y_{j} + r \\tilde{h} \\tilde{T}` appears in the other sub-domain for :math:`\\tilde{h}` larger than some positive threshold, and, for such values, :math:`\\frac{\\lvert T_{+}^{\\top} \\tilde{T}\\rvert}{\\lVert T_{+} \\rVert \\lVert \\tilde{T} \\rVert}` is close to 1 for :math:`T_{+}` with :math:`\\nabla F(Y_{j} + r \\tilde{h} \\tilde{T}) T_{+} = 0`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:157
# 15c42cf674dc4a46ab133964de5c3f78
msgid "This suggests the following procedure for selecting the desired direction of :math:`\\tilde{T}`: Increase the values of :math:`\\tilde{h}` successively from :math:`h_{\\mathrm{min}}`, and when you arrive at :math:`\\tilde{h}` and :math:`r \\in \\{\\pm 1\\}` such that"
msgstr ""

#: ../source/userdoc/model_continuation.rst:166
# ae3954591e334e0a99ad89f7ab08090a
msgid "take :math:`r \\tilde{T}` as the approximation of the tangent to the other smooth piece."
msgstr ""

#: ../source/userdoc/model_continuation.rst:169
# 6d93c23007394d66b162bcf19101605e
msgid "Having this approximation at our disposal, we restart the predictor-corrector with :math:`(Y_{j}, r \\tilde{T})`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:172
# 4d67a660544b4f8c86c3779da478c066
msgid "In |gf|, the continuation is implemented for two ways of parametrisation of the model:"
msgstr ""

#: ../source/userdoc/model_continuation.rst:175
# 492d2bd8b34644cc89ebb0a2249c4c92
msgid "The parameter :math:`\\lambda` is directly a scalar datum, which the model depends on."
msgstr ""

#: ../source/userdoc/model_continuation.rst:178
# 1981725a1e834fb6aa56b2b401d4f2e7
msgid "The model is parametrised by the scalar parameter :math:`\\lambda` *via* a vector datum :math:`P`, which the model depends on. In this case, one takes the linear path"
msgstr ""

#: ../source/userdoc/model_continuation.rst:186
# 415d03c6399a40c1baba2cd2efd11371
msgid "where :math:`P^{0}` and :math:`P^{1}` are given values of :math:`P`, and one traces the solution set of the problem"
msgstr ""

#: ../source/userdoc/model_continuation.rst:194
# 28b2da77de834665ade4c35f04f4cde2
msgid "Detection of limit points"
msgstr ""

#: ../source/userdoc/model_continuation.rst:196
# 8aa7cd46b98341599644f78b2439e1ee
msgid "When tracing solutions of the system :math:`F(U,\\lambda) = 0`, one may be interested in *limit points* (also called fold or turning points), where the number of solutions with the same value of :math:`\\lambda` changes. These points can be detected by a sign change of a test function :math:`\\tau_{\\mathrm{LP}}`:"
msgstr ""

#: ../source/userdoc/model_continuation.rst:205
# 40c98d0d4c7d4a94ac9ec3e981f0eab2
msgid "where :math:`\\tau_{\\mathrm{LP}}` is defined by"
msgstr ""

#: ../source/userdoc/model_continuation.rst:215
# f303f2eb3967489d8a788533c9a52079
msgid "Limit point."
msgstr ""

#: ../source/userdoc/model_continuation.rst:218
# 5d0310a848c048aba16fc3b87659108d
msgid "Numerical bifurcation"
msgstr ""

#: ../source/userdoc/model_continuation.rst:220
# a143228ad26641d99aa023b0114f9a85
msgid "A point :math:`\\bar{Y}` is called a *bifurcation point* of the system :math:`F(Y) = 0` if :math:`F(\\bar{Y}) = 0` and two or more distinct solution curves pass through it. The following result gives a test for *smooth* bifurcation points (see, e.g., [Georg2001]_):"
msgstr ""

#: ../source/userdoc/model_continuation.rst:225
# b3af8d1612634fd2ae48c6a20cd0c8fd
msgid "Let :math:`s \\mapsto Y(s)` be a parametrisation of a solution curve and :math:`\\bar{Y} := Y(\\bar{s})` be a bifurcation point. Moreover, let :math:`T^{\\top} \\dot{Y}(\\bar{s}) > 0`, :math:`B \\notin \\mathrm{Im}(J(\\bar{Y}))`, :math:`C \\notin \\mathrm{Im}(J(\\bar{Y})^{\\top})`, :math:`d \\in \\mathbb{R}` and"
msgstr ""

#: ../source/userdoc/model_continuation.rst:235
# 04bc07291be94f128b4e700ad1afa28a
msgid "Define :math:`\\tau_{\\mathrm{BP}}(Y)` via"
msgstr ""

#: ../source/userdoc/model_continuation.rst:241
# 705493fda80b459f86fd0d067e45087e
msgid "Then :math:`\\tau_{\\mathrm{BP}}(Y(s))` changes its sign at :math:`s = \\bar{s}`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:243
# 76d99e43e3854abf99da2d2177fd224c
msgid "Obviously, if one takes :math:`B`, :math:`C` and :math:`d` randomly, it is highly possible that they satisfy the requirements above. Consequently, the numerical continuation method is able to detect bifurcation points by taking the vectors :math:`Y` and :math:`T` supplied by the correction at each continuation step and monitoring the signs of :math:`\\tau_{\\mathrm{BP}}`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:249
# 2df499dc8eb94b399120c19baad90476
msgid "Once a bifurcation point :math:`\\bar{Y}` is detected by a sign change :math:`\\tau_{\\mathrm{BP}}(Y_{j}) \\tau_{\\mathrm{BP}}(Y_{j+1}) < 0`, it can be approximated more precisely by the predictor-corrector steps described above with a special step-length adaptation (see Section 8.1 in [Al-Ge1997]_). Namely, one can take the subsequent step lengths as"
msgstr ""

#: ../source/userdoc/model_continuation.rst:259
# 515a24f4cd444bc2b3ebefab24a658e6
msgid "until :math:`\\lvert h_{j+1} \\rvert < h_{\\mathrm{min}}`, which corresponds to the secant method for finding a zero of the function :math:`s \\mapsto \\tau_{\\mathrm{BP}}(Y(s))`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:263
# a4af3f3f1e534710981359e4d59422ef
msgid "Finally, it would be desirable to switch solution branches. To this end, we shall consider the case of the so-called *simple bifurcation point*, where only two distinct solution curves intersect."
msgstr ""

#: ../source/userdoc/model_continuation.rst:267
# bd64e738ea714e719152c61e023b8bad
msgid "Let :math:`\\tilde{Y}` be an approximation of :math:`\\bar{Y}` that we are given and :math:`V(\\tilde{Y})` be the first part of the solution of the augmented system for computing the test function :math:`\\tau_{\\mathrm{BP}}(\\tilde{Y})`. As proposed in [Georg2001]_, one can take :math:`V(\\tilde{Y})` as a predictor direction and do one continuation step starting with :math:`(\\tilde{Y}, V(\\tilde{Y}))` to obtain a point on a new branch. After this continuation step has been performed successfully and a point on the new branch has been recovered, one can proceed with usual predictor-corrector steps to trace this branch."
msgstr ""

#: ../source/userdoc/model_continuation.rst:277
# 23751e9d2ab347208eca5525f4ec39fe
msgid "Recently, tools for numerical :math:`PC^{1}`-bifurcation have been developed in |gf|. Let :math:`J` be a matrix function of a real parameter now defined by"
msgstr ""

#: ../source/userdoc/model_continuation.rst:284
# 4c9cdbd6370a491bb6ae237ba011116a
msgid "As proposed in [Li-Re2014hal]_, the following test can be used for detection of a :math:`PC^{1}` bifurcation point between :math:`Y_{j}` and :math:`Y_{j+1}`:"
msgstr ""

#: ../source/userdoc/model_continuation.rst:291
# e1d7e2f7711a4b15a232ed86f9d57d2e
msgid "To perform this test numerically, introduce"
msgstr ""

#: ../source/userdoc/model_continuation.rst:297
# 4c88d0a2fca841f589e72d5dc92f95dd
msgid "and :math:`\\tau_{\\mathrm{BP}}(\\alpha)` analogously as above via"
msgstr ""

#: ../source/userdoc/model_continuation.rst:303
# 756452be06ab4527bf4402614b0467a4
msgid "It follows from Cramer's rule that"
msgstr ""

#: ../source/userdoc/model_continuation.rst:309
# ddf6545d6198468b81253f4c233a4da4
msgid "provided that :math:`\\det M(\\alpha)` is non-zero. Hence if :math:`B`, :math:`C` and :math:`d` are chosen so that :math:`\\det M(\\alpha)` is non-zero whenever :math:`\\det J(\\alpha)` is zero, then the sign changes of :math:`\\det J(\\alpha)` are characterised by passings of :math:`\\tau_{\\mathrm{BP}}(\\alpha)` through 0 whereas the sign changes of :math:`\\det M(\\alpha)` by sign changes of :math:`\\tau_{\\mathrm{BP}}(\\alpha)` caused by singularities. To conclude, the sign of :math:`\\det J(0)\\det J(1)` is determined by following the behaviour of :math:`\\tau_{\\mathrm{BP}}(\\alpha)` and monitoring the sign changes of :math:`\\det J(\\alpha)` when :math:`\\alpha` passes through :math:`[0,1]`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:319
# 7c4e747fa2a34f1da16bee260f656478
msgid "As justified in [Li-Re2014hal]_, :math:`B`, :math:`C` and :math:`d` can be chosen randomly again. The increments :math:`\\delta` of the current values of :math:`\\alpha` are changed adaptively so that singularities of :math:`\\tau_{\\mathrm{BP}}` are treated effectively. After each calculation of :math:`\\tau_{\\mathrm{BP}}(\\alpha)`, :math:`\\delta` is set as follows:"
msgstr ""

#: ../source/userdoc/model_continuation.rst:329
# 018c0b91d8854c94836998c8dab65c34
msgid "where :math:`\\delta_{\\mathrm{max}} > \\delta_{\\mathrm{min}} > 0` and :math:`\\tau_{\\mathrm{fac}} > 0` are given constants and :math:`\\tau_{\\mathrm{ref}} := \\max\\{\\lvert \\tau_{\\mathrm{BP}}(1) - \\tau_{\\mathrm{BP}}(0) \\rvert, 10^{-8}\\}`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:333
# c7855a0ee2b5450e997707dfceceb38b
msgid "When a :math:`PC^{1}` bifurcation point is detected between :math:`Y_{j}` and :math:`Y_{j+1}`, it is approximated more precisely by a bisection-like procedure. The obtained approximation lies on the same smooth branch as :math:`Y_{j},` and the corresponding unit tangent that points out from the corresponding region of smoothness is calculated too."
msgstr ""

#: ../source/userdoc/model_continuation.rst:339
# ca6c31ad26ec45539afe06cc9df77bd6
msgid "Contrary to the smooth case, it is not clear how many branches can emanate from the :math:`PC^{1}` bifurcation point and in which directions they could be sought. For this reason, continuation steps for a whole sequence of predictor directions are tried out for finding points on new branches."
msgstr ""

#: ../source/userdoc/model_continuation.rst:344
# 005e2c0ddc4c4e4faf2bc08e6f858e9a
msgid "Denoting :math:`\\tilde{Y}`, :math:`\\tilde{T}` the approximation of the bifurcation point and the corresponding tangent, respectively, the predictor directions are taken as follows: For a couple of reference vectors :math:`\\tilde{V}_{1}` and :math:`\\tilde{V}_{2}`, one takes :math:`\\pm V` with :math:`V` satisfying"
msgstr ""

#: ../source/userdoc/model_continuation.rst:354
# 78fd1aea990a412dbebd0a36a9954c6a
msgid "where :math:`\\tilde{V}` passes through a set of linear combinations of :math:`\\tilde{V}_{1}` and :math:`\\tilde{V}_{2}`. The total number of the linear combinations is given by :math:`n_{\\mathrm{dir}},` and the reference vectors are chosen successively according to the following strategy:"
msgstr ""

#: ../source/userdoc/model_continuation.rst:359
# e11eb655a93b4b169b95d26a46e28635
msgid "One takes :math:`\\tilde{V}_{1} := -\\tilde{T}` and :math:`\\tilde{V}_{2}` such that"
msgstr ""

#: ../source/userdoc/model_continuation.rst:366
# a4e40861e52f4eda86a810fed1170771
msgid "Let :math:`\\{\\tilde{T}_{1},\\dotsc\\tilde{T}_{n_{\\mathrm{br}}}\\}` denote the set of unit tangents that correspond to the points from the branches found so far and that are oriented in the directions of branching from the bifurcation point. Then :math:`\\tilde{V}_{1}` and :math:`\\tilde{V}_{2}` are taken successively as different combinations from :math:`\\{\\tilde{T}_{1},\\dotsc\\tilde{T}_{n_{\\mathrm{br}}}\\}`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:373
# d678e3b4cbe84c3082211e6f20cfe95b
msgid "If all combinations that are available so far have already been used, let :math:`\\tilde{V}_{1}` be unchanged and take :math:`\\tilde{V}_{2} := \\tilde{V}_{2}^{+}` with :math:`\\tilde{V}_{2}^{+}` satisfying"
msgstr ""

#: ../source/userdoc/model_continuation.rst:382
# e4ab6e5c37434aaab38c3c00a9499b74
msgid "Here, :math:`\\tilde{V}_{2}^{-}` equals the vector :math:`\\tilde{V}_{2}` employed previously and :math:`\\tilde{V}_{3}` is chosen randomly."
msgstr ""

#: ../source/userdoc/model_continuation.rst:385
# 36f09b4db5fe4f3cb228b411bfd8a618
msgid "The total number of selections of :math:`\\tilde{V}_{1}` and :math:`\\tilde{V}_{2}` is given by :math:`n_{\\mathrm{span}}`."
msgstr ""

#: ../source/userdoc/model_continuation.rst:389
# 00e686adce6741f6916f2ab68fe71022
msgid "More details on :math:`PC^1` numerical branching can be found in [Li-Re2015hal]_."
msgstr ""

#: ../source/userdoc/model_continuation.rst:393
# 56fe492266fd41138a91e3e777f8aa61
msgid "Approximation of solution curves of a model"
msgstr ""

#: ../source/userdoc/model_continuation.rst:395
# 509d1234f7ae469aad2eeef6f95dc29a
msgid "The numerical continuation is defined in ``getfem/getfem_continuation.h``. In order to use it, one has to set it up via the corresponding object first::"
msgstr ""

#: ../source/userdoc/model_continuation.rst:402
# 8b97af3c896d4ce4885a99a9ee665251
msgid "where ``parameter_name`` is the name of the model datum representing :math:`\\lambda`, ``sfac`` represents the scale factor :math:`\\kappa`, and ``ls`` is the name of the solver to be used for the linear systems incorporated in the process (e.g., ``getfem::default_linear_solver<getfem::model_real_sparse_matrix, getfem::model_real_plain_vector>(model)``). The real numbers ``h_init``, ``h_max``, ``h_min``, ``h_inc``, ``h_dec`` denote :math:`h_{\\mathrm{init}}`, :math:`h_{\\mathrm{max}}`, :math:`h_{\\mathrm{min}}`, :math:`h_{\\mathrm{inc}}`, and :math:`h_{\\mathrm{dec}}`, the integer ``maxit`` is the maximum number of iterations allowed in the correction and ``thrit``, ``maxres``, ``maxdiff``, ``mincos``, and ``maxres_solve`` denote :math:`l_{\\mathrm{thr}}`, :math:`\\varepsilon`, :math:`\\varepsilon'`, :math:`c_{\\mathrm{min}}`, and the target residual value for the linear systems to be solved, respectively. The non-negative integer ``noisy`` determines how detailed information has to be displayed in the course of the continuation process (the larger value the more details), the integer ``singularities`` determines whether the tools for detection and treatment of singular points have to be used (0 for ignoring them completely, 1 for detecting limit points, and 2 for detecting and treating bifurcation points, as well), and the boolean value of ``non-smooth`` determines whether only tools for smooth continuation and bifurcation have to be used or even tools for non-smooth ones do. The real numbers ``delta_max``, ``delta_min`` and ``thrvar`` represent :math:`\\delta_{\\mathrm{max}}`, :math:`\\delta_{\\mathrm{min}}` and :math:`\\tau_{\\mathrm{fac}}`, and the integers ``ndir`` and ``nspan`` stand for :math:`n_{\\mathrm{dir}}` and :math:`n_{\\mathrm{span}}`, respectively."
msgstr ""

#: ../source/userdoc/model_continuation.rst:426
# f959af3dc9e74704b3eab4318640d0c2
msgid "Optionally, parametrisation by a vector datum is then declared by::"
msgstr ""

#: ../source/userdoc/model_continuation.rst:430
# 9096be15b54240c6ba336f44850d7a9c
msgid "Here, the data names ``initdata_name`` and ``finaldata_name`` should represent :math:`P^{0}` and :math:`P^{1}`, respectively. Under ``currentdata_name``, the values of :math:`P(\\lambda)` have to be stored, that is, actual values of the datum the model depends on."
msgstr ""

#: ../source/userdoc/model_continuation.rst:435
# 296cf3222da5486eaa8d7a94eb1324ef
msgid "Next, the continuation is initialised by::"
msgstr ""

#: ../source/userdoc/model_continuation.rst:439
# 12e18b2a8aff454dbb3f7277446fcbd7
msgid "where ``U`` should be a solution for the value of the parameter :math:`\\lambda` equal to ``lambda`` so that :math:`Y_{0}=` (\\ ``U``\\ ,\\ ``lambda``\\ ). During this initialisation, an initial unit tangent :math:`T_{0}` corresponding to :math:`Y_{0}` is computed in accordance with the sign of the initial value ``T_lambda``, and it is returned in ``T_U``, ``T_lambda``. Moreover, ``h`` is set to the initial step size ``h_init``."
msgstr ""

#: ../source/userdoc/model_continuation.rst:446
# 84a74b41016a45f19e7a7e3e112e3c3e
msgid "Subsequently, one step of the continuation is called by ::"
msgstr ""

#: ../source/userdoc/model_continuation.rst:450
# f21d0b6aa2f64f1899b3d308b57baf24
msgid "After each call, a new point on a solution curve and the corresponding tangent are returned in the variables ``U``, ``lambda`` and ``T_U``, ``T_lambda``. The step size for the next prediction is returned in ``h``. The size of the current step is returned in the optional argument ``h0``. According to the chosen value of ``singularities``, the test functions for limit and bifurcation points are evaluated at the end of each continuation step. Furthermore, if a smooth bifurcation point is detected, the procedure for numerical bifurcation is performed and an approximation of the branching point as well as tangents to both bifurcating curves are saved in the continuation object ``S``. From there, they can easily be recovered with member functions of ``S`` so that one can initialise the continuation to trace either of the curves next time."
msgstr ""

#: ../source/userdoc/model_continuation.rst:462
# ceba73490c2a47fb9988c4054be38614
msgid "Complete examples of use on a smooth problem are shown in the test programs ``tests/test_continuation.cc``, ``interface/tests/matlab/demo_continuation.m`` and ``interface/src/scilab/demos/demo_continuation.sce``, whereas ``interface/src/scilab/demos/demo_continuation_vee.sce`` and ``interface/src/scilab/demos/demo_continuation_block.sce`` employ also non-smooth tools."
msgstr ""

#: ../source/userdoc/model_continuation.rst:7
# c97b5fde9c7e4b1cad6623977c98c67f
msgid "models"
msgstr ""

#: ../source/userdoc/model_continuation.rst:7
# c97b5fde9c7e4b1cad6623977c98c67f
msgid "model bricks"
msgstr ""

