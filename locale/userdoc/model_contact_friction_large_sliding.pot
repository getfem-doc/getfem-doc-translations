# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2018 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-15 02:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/userdoc/model_contact_friction_large_sliding.rst:12
# 640f7e739d2f482f94fc2d7a6073bce4
msgid "Large sliding/large deformation contact with friction bricks"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:14
# 0456f29ec5ac4834bddda6add13b73b6
msgid "The basic tools to deal with large sliding/large deformation contact of deformable structures are accessible in the weak form language. Some interpolate transformations (see :ref:`ud-gasm-high-transf`) are defined to perform the contact detection and allow to integrate from a contacct bondary to the opposite contact boundary. Some other useful tools such as the unit normal vector in the real configuration and projections to take into account contact with Coulomb friction are also defined as operators in the weak form language."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:16
# 0fc26f22c87f4a918b9341deb2e28d32
msgid "Of course, the computational cost of large sliding/large deformation contact algorithms is greatly higher than small sliding-small deformation ones."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:21
# d56b2acd2fc542ea94d4531248189731
msgid "Raytracing interpolate transformation"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:23
# 7f6a232ae279412d840a427eaf5cd09a
msgid "In order to incorporate the contact detection in the high-level generic assembly, a specific interpolate transformation has been defined (see :ref:`ud-gasm-high-transf` for more explanations on interpolate tranformations). It is based on a raytracing contact detection has described in [KO-RE2014]_ and uses the criteria described below. The interpolate transformation stores the different potential contact surfaces. On most of methods, potential contact surface are classified into two categories: master and slave surface (see  :ref:`figure<ud-fig-masterslave>`)."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:31
# 8c9b6b7844aa4565b6c93ce2a8482965
msgid "The slave surface is the \"contactor\" and the master one the \"target\". Rigid obstacle are also considered. They are always master surfaces.  The basic rule is that the contact is considered between a slave surface and a master one. However, the multi-contact frame object and the |gf| bricks allow multi-contact situations, including contact between two master surfaces, self-contact of a master surface and an arbitrary number of slave and master surfaces."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:33
# 9000f3105dbf4fdc9a8a170682969625
msgid "Basically, in order to detect the contact pairs, Gauss points or f.e.m. nodes of slave surfaces are projected on master surfaces (see  :ref:`figure<ud-fig-masterslave>`). If self-contact is considered, Gauss points or f.e.m. nodes of master surface are also projected on master surfaces."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:36
# 325bf5252ab14345a52d0f01109e3615
msgid "The addition of a raytracing transformation to a model::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:41
# cd1b25e4fc744adaaac193cdc9c5ca0e
msgid "where ``transname`` is a name given to the transformation which allows to refer to it in the weak form language and ``d`` is the release distance (see above)."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:43
# f37801dd0d124764b55f67d2eb20cc89
msgid "The raytracing transformation is added without any slave or master contact boundary. The following functions allows to add some boundaries to the transformation::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:53
# e34f1311b31742c0a9e31edbb41e3899
msgid "where ``dispname`` is the variable name which represent the displacement on that contact boundary. The difference between master and slave contact boundary is that the contact detection is to be performed starting from a slave or master boundary toward a master boundary. The contact detection is not performed toward a slave boundary. Consequently, only the influence boxes of the elements of the master surfaces are computed and stored."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:56
# 632a978018e9411c85e883ea1f471ca5
msgid "It is also possible to add a rigid obstacle (considered as a master surface) thanks to the function::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:62
# fa02fe0ded4c489e811770e231618be2
msgid "where ``expr`` is the expression of a signed distance to the obstacle using the syntax of the weak form language (``X`` being the current position, ``X(0)``, ``X(1)`` ... the corresponding components). For instance an expression ``X(0) + 5`` will correspond to a flat obstacle lying on the right of the position ``-5`` of the first coordinate. Be aware that the expression have to be close to a signed distance, which in particular means that the gradient norm have to be close to 1."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:64
# 7a5709e692844ac69e3b33867e0857f0
msgid "In order to distinguish between non-contact situations and the occurence of a contact with another deformable body or with a rigid obstacle, the transformation returns an integer identifier which can be used by the `Interpolate_filter` command of the weak form language (see :ref:`ud-gasm-high-transf`). The different values:"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:66
# cbdf4883adec43c5b228ea8b4d01fa06
msgid "0 : no contact found on this Gauss point"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:68
# b8e228429e28485798e98bc2590d4d0d
msgid "1 : contact occurs on this Gauss point with a deformable body"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:70
# 3d8dc55e9d3d429c93174623510fc199
msgid "2 : contact occurs on this Gauss point with a rigid obstacle."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:72
# 886352278f5e431f9f51ecd0e1ff1a34
msgid "such that it is possible to differentiate the treatment of these three cases using::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:78
# e0f1c06836a649379b874ccd79e398ce
msgid "in the weak form language, where ``expr1``, ``expr2`` and ``expr3`` correspond to the different terms to be computed. The matlab interface demo program :file:`/interface/tests/matlab/demo_large_sliding_contact.m` presents an example of use."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:80
# 1bf1da5c498c4cf7a61d2412c3b4e542
msgid "Note that the transformation could also be directly used with a `ga_workspace` object if model object are not used. See :file:`getfem/getfem_contact_and_friction_common.h` for more details. Note also that in the framework of the model object, a interfaced use of this transformation is allowed by the model bricks described below."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:84
# 83e7729083774230a3f3a9314574b655
msgid "The contact pair detection algorithm"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:86
# 303f2a81825c4ea5928f37d1de477203
msgid "A contact pair is formed by a point of a slave (or master in case of self-contact) surface and a projected point on the nearest master surface (or rigid obstacle). The Algorithm used is summerized in :ref:`figure<ud-fig-algodetect>`"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:95
# 6604b9071d974757b19109c3abeee832
msgid "It is impossible to distinguish without fail between valid and invalid contact situations without a global topological criterion (such as in [Pantz2008]_), a fortiori for self-contact detection. However, this kind of criterion can be very costly to implement. Thus, one generally implements some simple heuristic criteria which cannot cover all the possible cases. We present such a set of criteria here. They are of course perfectible and subject to change. First, in :ref:`figure<ud-fig-invalidcontact>` one can see a certain number of situations of valid or invalid contact that criteria have to distinguish."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:109
# 207f7a9aa9d44f85aac3439b3010d24c
msgid "Some details on the algorithm:"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:111
# 68a6c9b8b96d473d997f34a0f2189320
msgid "**Computation of influence boxes.** The influence box of an element is just an offset to its bounding box at a distance equal to the release distance. If this strategy is used, the release distance should not be too large compared to the element size. Otherwise, a point would correspond to a a large number of influence box which can considerably slow down the search of contact pairs. The influence boxes are stored in a region tree object in order to find the boxes containing a point with an algorithm having a mean complexity in :math:`O(log(N))`."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:120
# 573ebd2071914ab18d7b013de48eb692
msgid "**What is a potential contact pair.** A potential contact pair is a pair slave point - master element face which will be investigated. The projection of the slave point on the master surface will be done and criteria will be applied."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:125
# cdf4282cc5c14ca19305ba8d918791f3
msgid "**Projection algorithm.** The projection of the slave point onto a master element face is done by a parametrization of the surface on the reference element via the geometric transformation and the displacement field. During the projection, no constraint is applied to remain inside the element face, which means that the element face is prolongated analytically. The projection is performed by minimizing the distance between the slave point and the projected one using the parametrization and Newton's and/or BFGS algorithms. If ``raytrace`` is set to true, then no projection is computed. Instead a ray tracing from the point x in the direction of the unit normal vector at x to find y. This means the reverse of the usual situation (x will be the projection of y)."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:137
# f31817eb636543ef9b728521d5bea84b
msgid "The list of criteria:"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:139
# c4e97d6f4bbf40a0bd9a3252c4d8fae8
msgid "**Criterion 1: the unit normal cone/vector should be compatible, and the two points do not share the same element.** Two unit normal vector are compatible if their scalar product are non-positive. In case of f.e.m. node contact, since a fem node is shared generally by several elements, a normal cone constituted of the unit normal vectors of each element is considered. Two normal cones are compatible if at least one pair of unit normal vector have their scalar product non-positive. In order to simplify the computation, a normal cone is reduced to a mean normal vector if the solid angle of the normal cone is less than ``cut_angle`` a parameter of the multi-contact frame object. This criterion allows to treat cases (B) and (K1)."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:151
# a25e170d08f342e68a44bd35d775b402
msgid "**Criterion 2: the contact pair is eliminated when the search of the projection/raytrace point do not converge.** When Newton's algorithms (and BFGS one for projection) used to compute the projection/raytrace of the slave point on the master element surface fails to converge, the pair is not considered. A warning is generated."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:157
# f5e19ef36ccd4a4d8ee1acfa02f8e1be
msgid "**Criterion 3 : the projected point should be inside the element.** The slave point is projected on the surface of the master element without the constraint to remain inside the face (which means that the face is prolongated). If the orthogonal projection is outside the face, the pair is not considered. This is the present state, however, to treat case (J3) an aditional treatment will have to be considered (projection on the face with the constraint to remain inside it and test of the normal cone at this point) This criterion allows to treat cases (F2), (K2), (M1) and (M2)."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:168
# 83011a2774674c7fac6a1eae198fbf03
msgid "**Criterion 4 : the release distance is applied.** If the distance between the slave point and its projection on the master surface is greater than the release distance, the contact pair is not considered. This can treat cases (C), (E), (F1), (G), (H) if the release distance is adapted and the deformation not too important."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:174
# c419115d1e17438db352b91d2fdbbbcd
msgid "**Criterion 5 : comparison with rigid obstacles.** If the signed distance between the slave point and its projection on the master surface is greater than the one with a rigid obstacle (considering that the release distance is also first applied to rigid obstacle) then the contact pair is not considered."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:180
# 69a1589617184505935e0969cff2a632
msgid "**Criterion 6 : for self-contact only : apply a test on unit normals in reference configuration.** In case of self contact, a contact pair is eliminated when the slave point and the master element belong to the same mesh and if the slave point is behind the master surface (with respect to its unit outward normal vector) and not four times farther than the release distance. This can treat cases (A), (C), (D), (H)."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:188
# d79c2ee7d7e548168751baaa797a4152
msgid "**Criterion 7 : smallest signed distance on contact pairs.** Between the retained contact pairs (or rigid obstacle) the one corresponding to the smallest signed distance is retained."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:196
# 715fd431fa9f4a6db3e6ee4615fb101b
msgid "Nodal contact brick with projection"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:198
# 9555dc27b5a84e8eb54452defc739659
msgid "Notations: :math:`\\Omega \\subset \\Reel^d` denotes the reference configuration of a deformable body, possibly constituted by several unconnected parts (see  :ref:`figure<ud-fig-masterslave>`). :math:`\\Omega_t` is the deformed configuration and :math:`\\varphi^h: \\Omega \\rightarrow \\Omega_t` is the approximated deformation on a finite element space :math:`V^h`. The displacement  :math:`u^h: \\Omega \\rightarrow \\Reel^d` is defined by :math:`\\varphi^h(X) = X + u^h(X)`. A generic point of the reference configuration :math:`\\Omega` is denoted by :math:`X` while the corresponding point of the deformed configuration is denoted by :math:`x = \\varphi^h(X)`. :math:`\\Gamma^S` denotes a slave boundary of :math:`\\Omega` and :math:`\\Gamma^M` a master one. The corresponding boundaries on the deformed configuration are :math:`\\Gamma_t^S` and :math:`\\Gamma_t^M`, respectively. The outward unit normal vector to the boundary (in the deformed configuration) at a point :math:`x = \\varphi^h(X)` of that boundary is denoted by :math:`n_x`. Finally, the notation :math:`\\delta A[B]` denotes the directional derivative of the quantity :math:`A` with respect to the deformation and in the direction :math:`B`. Similarly, The notation :math:`\\delta^2 A[B,C]` is the second derivative in the directions  :math:`B` and :math:`C`."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:202
# dde5d37d9ae542098327c6d1603f9278
msgid "Let :math:`J(\\varphi^h)` be the potential energy of the system, without taking into account contact and friction contributions. Typically, it includes elastic and external load potential energy. Let :math:`X_i` for  :math:`i \\in I_{\\text{nodes}}` the set of finite element nodes on the slave boundary in the reference configuration. Let :math:`X_i` for  :math:`i \\in I_{\\text{def}}` be the contact nodes in potential contact with the master surface of a deformable body. Let  :math:`X_i` for  :math:`i \\in I_{\\text{rig}}` be the contact nodes in potential contact with a rigid obstacle."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:204
# 60dd872fd69d4007be51890678ad34f1
msgid "We denote by :math:`x_i = \\varphi^h(X_i)` the corresponding node on the deformed configuration and :math:`y_i` the projection on the master surface (or rigid obstacle) on the deformed configuration. Let :math:`Y_i` the point on the master surface verifying :math:`y_i = \\varphi^h(Y_i)`. This allows to define the normal gap as"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:210
# 837967d22bbe451a9f3a7a9321d6e39c
msgid "where :math:`n_y` is the outward unit normal vector of the master surface at :math:`y`."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:212
# a5c344e1cd5c4ef9b4fe4c5ffc3b1a09
msgid "Considering only stationnary rigid obstacles and applying the principle of Alart-Curnier augmented Lagrangian [AL-CU1991]_, the problem with nodal contact with friction condition can be expressed as follows in an unsymmetric version (see [renard2013]_ for the linear elasticity case)"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:223
# edf50550f28e432e8abc695dcbde3068
msgid "where :math:`W_T, \\alpha, P_{n_y, {\\mathscr F}}` ... + tangent system"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:227
# d1559aa0edf6424297d9612e751ffd71
msgid "Sorry, for the moment the brick is not working."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:232
# 10ff6d302d7645a194492aa49e2412d5
msgid "Tools of the high-level generic assembly for contact with friction"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:234
# 79f2a319475744a6a09f88ddefda4f18
msgid "The following nonlinear operators are defined in the weak form language (see :ref:`ud-gasm-high`):"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:236
# 5399517f7fae47b0ad4bc7dd9dcef68a
msgid "``Transformed_unit_vector(Grad_u, n)`` where ``Grad_u`` is the gradient of a displacement field and ``n`` a unit vector in the reference configuration. This nonlinear operator corresponds to"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:244
# 6188917b339a450ab7072810a86b8ef6
msgid "with the following partial derivatives"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:252
# 36fadf922a924efcbf1f819deee335f1
msgid "``Coulomb_friction_coupled_projection(lambda, n, Vs, g, f, r)`` where ``lambda`` is the contact force, ``n`` is a unit normal vector, ``Vs`` is the sliding velocity, ``g`` is the gap, ``f`` the friction coefficient and ``r`` a positive augmentation parameter. The expression of the operator is"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:263
# fac90ed8ea8143158add5628611cbaaf
msgid "where :math:`(\\cdot)_-` is the negative part (:math:`(x)_- = (-x)_+`) and :math:`f_1, f_2, f_3` are the three components of the friction coefficient. Note that the components :math:`f_2, f_3` are optional. If a scalar fiction coefficient is given (only :math:`f_1`) then this corresponds to the classical Coulomb friction law. If a vector of two components is given  (only :math:`f_1, f_2`) then this corresponds to a Coulomb friction with a given threshold. Finally, if a vector of three components is given, the friction law correspongs to the expression of :math:`\\tau` given above."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:265
# 173a63a47025463dbca7c97d7c98028f
msgid "The expression :math:`P_{B(n,\\tau)}(q)` refers to the orthogonal projection (this is link to the return mapping algorithm) on the tangential ball (with respect to :math:`n` of radius :math:`\\tau`."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:267
# 425ec6b894674351ac07b413d395adca
msgid "The derivatives can be expressed as follows with :math:`T_n = (I - n \\otimes n)` and :math:`q_{_T} = T_n q`:"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:330
# 4826d495800146d0af94002d3ebcb904
msgid "Integral contact brick with raytrace"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:333
# 43d55c4db50c432aaeafce48e054a481
msgid "Add of the brick::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:341
# 721204628a8246b3b253d0fab6f26715
msgid "This brick allows to deal with a multi-contact situation. It adds to the model a raytracing interpolate transformation as described in a previous section whose name can be obtained by the command::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:346
# 6142e9745fe74873ad8ae1c1550eddb1
msgid "Once the brick is added to the model, the master and slave contact boundaries have to be added with the following function::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:354
# 973a0b2520a1403eb5e659bf7713d668
msgid "where ``region`` should be a valid mesh region number representing a boundary, ``is_master`` should be set to ``true`` if the contact detection is to be done on that contact boundary, ``is_slave`` should be set to ``true`` if the integration of contact terms is to be done on that boundary. Note that a contact boundary is allowed to be both master and slave, in particular to allow self-contact detection. ``u`` is the displacement variable. If ``is_slave`` is set to true, ``lambda`` should describe a multiplier variable with degrees of freedom on the contact boundary (typically added to the model with the ``md.add_filtered_fem_variable(...) method). Pure master contact boundary do not need the definition of a multiplier. Additionally, ``w`` is for the evolutionnary case and represents the displacement at the previous time step."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:356
# c65d40b6df5c4703a7d3a69cabac4a75
msgid "A rigid obstacle can be added to the brick with::"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:361
# 6e0c01b0073545d5b69b6ea80084749b
msgid "where `expr` is an expression using the weak form language (with `X` is the current position) which should be a signed distance to the obstacle. `N` is the mesh dimension."
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:7
# 2f3291cecd9047c281121478962cea7c
msgid "models"
msgstr ""

#: ../source/userdoc/model_contact_friction_large_sliding.rst:7
# 2f3291cecd9047c281121478962cea7c
msgid "model bricks"
msgstr ""

