# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2018 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-16 15:44+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../source/userdoc/model_time_integration.rst:14
msgid "The model tools for the integration of transient problems"
msgstr "The model tools for the integration of transient problems"

#: ../source/userdoc/model_time_integration.rst:16
msgid ""
"Although time integration scheme can be written directly using the model "
"object by describing the problem to be solved at each iteration, the model "
"object furnishes some basic tools to facilitate the writing of such schemes."
" These tools are based on the following basic principles:"
msgstr ""
"Although time integration scheme can be written directly using the model "
"object by describing the problem to be solved at each iteration, the model "
"object furnishes some basic tools to facilitate the writing of such schemes."
" These tools are based on the following basic principles:"

#: ../source/userdoc/model_time_integration.rst:18
msgid ""
"The original variables of the model represent the state of the system to be "
"solved at the current time step (say step n). This is the case even for a "
"middle point scheme, mainly because if one needs to apply different schemes "
"to different variables of the system, all variable should describe the "
"system at a unique time step."
msgstr ""
"The original variables of the model represent the state of the system to be "
"solved at the current time step (say step n). This is the case even for a "
"middle point scheme, mainly because if one needs to apply different schemes "
"to different variables of the system, all variable should describe the "
"system at a unique time step."

#: ../source/userdoc/model_time_integration.rst:20
msgid ""
"Some data are added to the model to represent the state of the system at "
"previous time steps. For classical one-step schemes (for the moment, only "
"one-step schemes are provided), only the previous time step is stored. For "
"instance if `u` is a variable (thus represented at step n), `Previous_u` "
"will be the data representing the state of the variable at the previous time"
" step (step n-1). Eventually, for future extension to multi-step methods, "
"`Previous2_u` may represent the variable at time step n-2."
msgstr ""
"Some data are added to the model to represent the state of the system at "
"previous time steps. For classical one-step schemes (for the moment, only "
"one-step schemes are provided), only the previous time step is stored. For "
"instance if `u` is a variable (thus represented at step n), `Previous_u` "
"will be the data representing the state of the variable at the previous time"
" step (step n-1). Eventually, for future extension to multi-step methods, "
"`Previous2_u` may represent the variable at time step n-2."

#: ../source/userdoc/model_time_integration.rst:22
msgid ""
"Some intermediate variables are added to the model to represent the time "
"derivative (and the second order time derivative for second order problem). "
"For instance, if `u` is a variable, `Dot_u` will represent the first order "
"time derivative of `u` and `Dot2_u` the second order one. One can refer to "
"these variables in the model to add a brick on it or to use it in the weak "
"form language. However, these are not considered to be independent "
"variables, they will be linked to their corresponding original variable (in "
"an affine way) by the time integration scheme. Most of the schemes need also"
" the time derivative at the previous time step and add the data "
"`Previous_Dot_u` and possibly `Previous_Dot2_u` to the model."
msgstr ""
"Some intermediate variables are added to the model to represent the time "
"derivative (and the second order time derivative for second order problem). "
"For instance, if `u` is a variable, `Dot_u` will represent the first order "
"time derivative of `u` and `Dot2_u` the second order one. One can refer to "
"these variables in the model to add a brick on it or to use it in the weak "
"form language. However, these are not considered to be independent "
"variables, they will be linked to their corresponding original variable (in "
"an affine way) by the time integration scheme. Most of the schemes need also"
" the time derivative at the previous time step and add the data "
"`Previous_Dot_u` and possibly `Previous_Dot2_u` to the model."

#: ../source/userdoc/model_time_integration.rst:24
msgid ""
"A different time integration scheme can be applied on each variable of the "
"model. Note that most of the time, multiplier variable and more generally "
"variables for which no time derivative is used do not need a time "
"integration scheme."
msgstr ""
"A different time integration scheme can be applied on each variable of the "
"model. Note that most of the time, multiplier variable and more generally "
"variables for which no time derivative is used do not need a time "
"integration scheme."

#: ../source/userdoc/model_time_integration.rst:26
msgid ""
"The data `t` represent the time parameter and can be used (either in the "
"weak form language or as parameter of some bricks). Before the assembly of "
"the system, the data `t` is automatically updated to the time step `n`."
msgstr ""
"The data `t` represent the time parameter and can be used (either in the "
"weak form language or as parameter of some bricks). Before the assembly of "
"the system, the data `t` is automatically updated to the time step `n`."

#: ../source/userdoc/model_time_integration.rst:28
msgid ""
"The problem to be solved at each iteration correspond to the formulation of "
"the transient problem in its natural (weak) formulation in which the "
"velocity and the acceleration are expressed by the intermediate variables "
"introduced. For instance, the translation into the weak form language of the"
" problem"
msgstr ""
"The problem to be solved at each iteration correspond to the formulation of "
"the transient problem in its natural (weak) formulation in which the "
"velocity and the acceleration are expressed by the intermediate variables "
"introduced. For instance, the translation into the weak form language of the"
" problem"

#: ../source/userdoc/model_time_integration.rst:34
msgid "can simply be::"
msgstr "can simply be::"

#: ../source/userdoc/model_time_integration.rst:38
msgid ""
"(even though, of course, in this situation, the use of linear bricks is "
"preferable for efficiency reasons)"
msgstr ""
"(even though, of course, in this situation, the use of linear bricks is "
"preferable for efficiency reasons)"

#: ../source/userdoc/model_time_integration.rst:40
msgid ""
"For all implemented one-step schemes, the time step can be changed from an "
"iteration to another for both order one and order two in time problems (or "
"even quasi-static problems)."
msgstr ""
"For all implemented one-step schemes, the time step can be changed from an "
"iteration to another for both order one and order two in time problems (or "
"even quasi-static problems)."

#: ../source/userdoc/model_time_integration.rst:42
msgid ""
"A scheme for second order in time problem (resp. first order in time) can be"
" applied to a second or first order in time or even to a quasi-static "
"problem (resp. to a first order or quasi-static problem) without any problem"
" except that the initial data corresponding to the velocity/displacement "
"have to be initialized with respect ot the order of the scheme. Conversely, "
"of course, a scheme for first order problem cannot be applied to a second "
"order in time problem."
msgstr ""
"A scheme for second order in time problem (resp. first order in time) can be"
" applied to a second or first order in time or even to a quasi-static "
"problem (resp. to a first order or quasi-static problem) without any problem"
" except that the initial data corresponding to the velocity/displacement "
"have to be initialized with respect ot the order of the scheme. Conversely, "
"of course, a scheme for first order problem cannot be applied to a second "
"order in time problem."

#: ../source/userdoc/model_time_integration.rst:46
msgid "The implicit theta-method for first-order problems"
msgstr "The implicit theta-method for first-order problems"

#: ../source/userdoc/model_time_integration.rst:48
#: ../source/userdoc/model_time_integration.rst:124
#: ../source/userdoc/model_time_integration.rst:178
msgid "For a problem which reads"
msgstr "For a problem which reads"

#: ../source/userdoc/model_time_integration.rst:54
msgid ""
"where :math:`F(U)` might be nonlinear (and may depend on some other "
"variables for coupled problems), for :math:`dt` a time step, :math:`V = "
"\\dot{U}` and :math:`U^n, V^n` the approximation of :math:`U, V` at time "
":math:`ndt`, theta-method reads"
msgstr ""
"where :math:`F(U)` might be nonlinear (and may depend on some other "
"variables for coupled problems), for :math:`dt` a time step, :math:`V = "
"\\dot{U}` and :math:`U^n, V^n` the approximation of :math:`U, V` at time "
":math:`ndt`, theta-method reads"

#: ../source/userdoc/model_time_integration.rst:63
msgid ""
"for :math:`\\theta \\in (0, 1]` the parameter of the theta-method (for "
":math:`\\theta = 0`, the method corresponds to the forward Euler method and "
"is not an implicit scheme) and for :math:`U^{n-1}, V^{n-1}` given."
msgstr ""
"for :math:`\\theta \\in (0, 1]` the parameter of the theta-method (for "
":math:`\\theta = 0`, the method corresponds to the forward Euler method and "
"is not an implicit scheme) and for :math:`U^{n-1}, V^{n-1}` given."

#: ../source/userdoc/model_time_integration.rst:65
msgid ""
"Before the first time step, :math:`U^0` should be initialized, however, "
":math:`V^0` is also needed (except for :math:`\\theta = 1`). In this "
"example, it should correspond to :math:`M^{-1}F(U^0)`. For a general coupled"
" problem where :math:`M` might be singular, a generic precomputation of "
":math:`V^0` is difficult to obtain. Thus :math:`V^0` have to be furnisded "
"also. Alternatively (see below) the model object (and the standard solve) "
"furnishes a mean to evaluate them thanks to the application of a Backward "
"Euler scheme on a (very) small time step."
msgstr ""
"Before the first time step, :math:`U^0` should be initialized, however, "
":math:`V^0` is also needed (except for :math:`\\theta = 1`). In this "
"example, it should correspond to :math:`M^{-1}F(U^0)`. For a general coupled"
" problem where :math:`M` might be singular, a generic precomputation of "
":math:`V^0` is difficult to obtain. Thus :math:`V^0` have to be furnisded "
"also. Alternatively (see below) the model object (and the standard solve) "
"furnishes a mean to evaluate them thanks to the application of a Backward "
"Euler scheme on a (very) small time step."

#: ../source/userdoc/model_time_integration.rst:68
#: ../source/userdoc/model_time_integration.rst:144
#: ../source/userdoc/model_time_integration.rst:198
msgid "The following formula can be deduced for the time derivative:"
msgstr "The following formula can be deduced for the time derivative:"

#: ../source/userdoc/model_time_integration.rst:74
msgid ""
"When applying this scheme to a variable \"u\" of the model, the following "
"affine dependent variable is added to the model::"
msgstr ""
"When applying this scheme to a variable \"u\" of the model, the following "
"affine dependent variable is added to the model::"

#: ../source/userdoc/model_time_integration.rst:78
msgid ""
"which represent the time derivative of the variable and can be used in some "
"brick definition."
msgstr ""
"which represent the time derivative of the variable and can be used in some "
"brick definition."

#: ../source/userdoc/model_time_integration.rst:80
#: ../source/userdoc/model_time_integration.rst:158
#: ../source/userdoc/model_time_integration.rst:212
msgid "The following data are also added::"
msgstr "The following data are also added::"

#: ../source/userdoc/model_time_integration.rst:84
msgid ""
"which correspond to the values of \"u\" and \"Dot_u\" at the previous time "
"step."
msgstr ""
"which correspond to the values of \"u\" and \"Dot_u\" at the previous time "
"step."

#: ../source/userdoc/model_time_integration.rst:86
msgid ""
"Before the solve, the data  \"Previous_u\" (corresponding to :math:`U^0` in "
"the example) has to be initialized (except for :math:`\\theta = 1`). Again, "
"\"Previous_Dot_u\" has to be either initialized or pre-computed as described"
" in the next section. The affine dependence of \"Dot_u\" is thus given by::"
msgstr ""
"Before the solve, the data  \"Previous_u\" (corresponding to :math:`U^0` in "
"the example) has to be initialized (except for :math:`\\theta = 1`). Again, "
"\"Previous_Dot_u\" has to be either initialized or pre-computed as described"
" in the next section. The affine dependence of \"Dot_u\" is thus given by::"

#: ../source/userdoc/model_time_integration.rst:90
msgid ""
"Which means that \"Dot_u\" will be replaced at assembly time by its "
"expression in term of \"u\" (multipied by :math:`1/(\\theta*dt)`) and in "
"term of a constant remaining part depending on the previous time step. The "
"addition of this scheme to a variable is to be done thanks to::"
msgstr ""
"Which means that \"Dot_u\" will be replaced at assembly time by its "
"expression in term of \"u\" (multipied by :math:`1/(\\theta*dt)`) and in "
"term of a constant remaining part depending on the previous time step. The "
"addition of this scheme to a variable is to be done thanks to::"

#: ../source/userdoc/model_time_integration.rst:98
msgid "Precomputation of velocity/acceleration"
msgstr "Precomputation of velocity/acceleration"

#: ../source/userdoc/model_time_integration.rst:100
msgid ""
"Most of the time integration schemes (except, for instance, the backward "
"Euler scheme) needs the pre-computation of the first or second order time "
"derivative before the initial time step (for instance :math:`V^0` for the "
"theta-method for first order problems, :math:`A^0` for second order problems"
" ...)."
msgstr ""
"Most of the time integration schemes (except, for instance, the backward "
"Euler scheme) needs the pre-computation of the first or second order time "
"derivative before the initial time step (for instance :math:`V^0` for the "
"theta-method for first order problems, :math:`A^0` for second order problems"
" ...)."

#: ../source/userdoc/model_time_integration.rst:102
msgid ""
"The choice is let to the user to either initialize these derivative or to "
"ask to the model to automatically approximate them."
msgstr ""
"The choice is let to the user to either initialize these derivative or to "
"ask to the model to automatically approximate them."

#: ../source/userdoc/model_time_integration.rst:105
msgid ""
"The method used (for the moment) to approximate the supplementary "
"derivatives may be explained in the example of the solve of"
msgstr ""
"The method used (for the moment) to approximate the supplementary "
"derivatives may be explained in the example of the solve of"

#: ../source/userdoc/model_time_integration.rst:111
msgid ""
"with a theta-method (see the previous section). In order to approximate "
":math:`V_0`, the theta-method is applied for :math:`\\theta = 1` (i.e. a "
"backward Euler scheme) on a very small time step. This is possible since the"
"  backward Euler do not need an initial time derivative. Then the time "
"derivative computed thanks to the  backward Euler at the end of the very "
"small time step is simply used as an approximation of the initial time "
"derivative."
msgstr ""
"with a theta-method (see the previous section). In order to approximate "
":math:`V_0`, the theta-method is applied for :math:`\\theta = 1` (i.e. a "
"backward Euler scheme) on a very small time step. This is possible since the"
"  backward Euler do not need an initial time derivative. Then the time "
"derivative computed thanks to the  backward Euler at the end of the very "
"small time step is simply used as an approximation of the initial time "
"derivative."

#: ../source/userdoc/model_time_integration.rst:114
msgid "For a model `md`, the following instructions::"
msgstr "For a model `md`, the following instructions::"

#: ../source/userdoc/model_time_integration.rst:119
msgid ""
"allows to perform automatically the approximation of the initial time "
"derivative. The parameter `ddt` corresponds to the small time step used to "
"perform the aproximation. Typically, `dtt = dt/20` could be used where  `dt`"
" is the time step used to approximate the transient problem (see the example"
" below)."
msgstr ""
"allows to perform automatically the approximation of the initial time "
"derivative. The parameter `ddt` corresponds to the small time step used to "
"perform the aproximation. Typically, `dtt = dt/20` could be used where  `dt`"
" is the time step used to approximate the transient problem (see the example"
" below)."

#: ../source/userdoc/model_time_integration.rst:122
msgid "The implicit theta-method for second-order problems"
msgstr "The implicit theta-method for second-order problems"

#: ../source/userdoc/model_time_integration.rst:130
#: ../source/userdoc/model_time_integration.rst:184
msgid ""
"where :math:`F(U)` might be nonlinear (and may depend on some othere "
"variables for coupled problems), for :math:`dt` a time step, :math:`V = "
"\\dot{U}`, :math:`A = \\ddot{U}` and :math:`U^n, V^n, A^n` the approximation"
" of :math:`U, V, A` at time :math:`ndt`, the first oder theta-method reads"
msgstr ""
"where :math:`F(U)` might be nonlinear (and may depend on some othere "
"variables for coupled problems), for :math:`dt` a time step, :math:`V = "
"\\dot{U}`, :math:`A = \\ddot{U}` and :math:`U^n, V^n, A^n` the approximation"
" of :math:`U, V, A` at time :math:`ndt`, the first oder theta-method reads"

#: ../source/userdoc/model_time_integration.rst:140
msgid ""
"for :math:`\\theta \\in (0, 1]` the parameter of the theta-method (for "
":math:`\\theta = 0`, the method correspond to the forward Euler method and "
"is not an implicit scheme) and for :math:`U^{n-1}, V^{n-1}, A^{n-1}` given."
msgstr ""
"for :math:`\\theta \\in (0, 1]` the parameter of the theta-method (for "
":math:`\\theta = 0`, the method correspond to the forward Euler method and "
"is not an implicit scheme) and for :math:`U^{n-1}, V^{n-1}, A^{n-1}` given."

#: ../source/userdoc/model_time_integration.rst:142
msgid ""
"At the first time step, :math:`U^0, V^0` should be given and :math:`A^0` is "
"to be given or pre-computed (except for :math:`\\theta = 1`)."
msgstr ""
"At the first time step, :math:`U^0, V^0` should be given and :math:`A^0` is "
"to be given or pre-computed (except for :math:`\\theta = 1`)."

#: ../source/userdoc/model_time_integration.rst:152
#: ../source/userdoc/model_time_integration.rst:206
msgid ""
"When aplying this scheme to a variable \"u\" of the model, the following "
"affine dependent variables are added to the model::"
msgstr ""
"When aplying this scheme to a variable \"u\" of the model, the following "
"affine dependent variables are added to the model::"

#: ../source/userdoc/model_time_integration.rst:156
#: ../source/userdoc/model_time_integration.rst:210
msgid ""
"which represent the first and second order time derivative of the variable "
"and can be used in some brick definition."
msgstr ""
"which represent the first and second order time derivative of the variable "
"and can be used in some brick definition."

#: ../source/userdoc/model_time_integration.rst:162
#: ../source/userdoc/model_time_integration.rst:216
msgid ""
"which correspond to the values of \"u\", \"Dot_u\"  and \"Dot2_u\" at the "
"previous time step."
msgstr ""
"which correspond to the values of \"u\", \"Dot_u\"  and \"Dot2_u\" at the "
"previous time step."

#: ../source/userdoc/model_time_integration.rst:164
msgid ""
"Before the solve, the data  \"Previous_u\" and \"Previous_Dot_u\" "
"(corresponding to :math:`U^0` in the example) have to be initialized and "
"\"Previous_Dot2_u\" should be either initialized or precomputed (see the "
"previous section, and except for :math:`\\theta = 1`). The affine "
"dependences are thus given by::"
msgstr ""
"Before the solve, the data  \"Previous_u\" and \"Previous_Dot_u\" "
"(corresponding to :math:`U^0` in the example) have to be initialized and "
"\"Previous_Dot2_u\" should be either initialized or precomputed (see the "
"previous section, and except for :math:`\\theta = 1`). The affine "
"dependences are thus given by::"

#: ../source/userdoc/model_time_integration.rst:169
#: ../source/userdoc/model_time_integration.rst:221
msgid "The addition of this scheme to a variable is to be done thanks to::"
msgstr "The addition of this scheme to a variable is to be done thanks to::"

#: ../source/userdoc/model_time_integration.rst:176
msgid "The implicit Newmark scheme for second order problems"
msgstr "The implicit Newmark scheme for second order problems"

#: ../source/userdoc/model_time_integration.rst:194
msgid ""
"for :math:`\\beta \\in (0, 1]` and :math:`\\gamma \\in [1/2, 1]` are the "
"parameters of the Newmark scheme and for :math:`U^{n-1}, V^{n-1}, A^{n-1}` "
"given."
msgstr ""
"for :math:`\\beta \\in (0, 1]` and :math:`\\gamma \\in [1/2, 1]` are the "
"parameters of the Newmark scheme and for :math:`U^{n-1}, V^{n-1}, A^{n-1}` "
"given."

#: ../source/userdoc/model_time_integration.rst:196
msgid ""
"At the first time step, :math:`U^0, V^0` should be given and :math:`A^0` is "
"to be given or pre-computed (except for :math:`\\beta = 1/2, \\gamma = 1`)."
msgstr ""
"At the first time step, :math:`U^0, V^0` should be given and :math:`A^0` is "
"to be given or pre-computed (except for :math:`\\beta = 1/2, \\gamma = 1`)."

#: ../source/userdoc/model_time_integration.rst:218
msgid ""
"Before the first solve, the data  \"Previous_u\" and \"Previous_Dot_u\" "
"(corresponding to :math:`U^0` in the example) have to be initialized. The "
"data \"Previous_Dot2_u\" is to be given or precomputed (see "
":ref:`precomp_time_der_section` and except for :math:`\\beta = 1/2, \\gamma "
"= 1`)."
msgstr ""
"Before the first solve, the data  \"Previous_u\" and \"Previous_Dot_u\" "
"(corresponding to :math:`U^0` in the example) have to be initialized. The "
"data \"Previous_Dot2_u\" is to be given or precomputed (see "
":ref:`precomp_time_der_section` and except for :math:`\\beta = 1/2, \\gamma "
"= 1`)."

#: ../source/userdoc/model_time_integration.rst:228
msgid "Transient terms"
msgstr "Transient terms"

#: ../source/userdoc/model_time_integration.rst:230
msgid ""
"As it has been explained in previous sections, some intermediate variables "
"are added to the model in order to represent the time derivative of the "
"variables on which the scheme is applied. Once again, if \"u\" is such a "
"variable, \"Dot_u\" will represent the time derivative of \"u\" approximated"
" by the used scheme."
msgstr ""
"As it has been explained in previous sections, some intermediate variables "
"are added to the model in order to represent the time derivative of the "
"variables on which the scheme is applied. Once again, if \"u\" is such a "
"variable, \"Dot_u\" will represent the time derivative of \"u\" approximated"
" by the used scheme."

#: ../source/userdoc/model_time_integration.rst:232
msgid ""
"This also mean that \"Dot_u\" (and \"Dot2_u\" in order two in time problems)"
" can be used to express the transient terms. In the weak form language, the "
"term:"
msgstr ""
"This also mean that \"Dot_u\" (and \"Dot2_u\" in order two in time problems)"
" can be used to express the transient terms. In the weak form language, the "
"term:"

#: ../source/userdoc/model_time_integration.rst:238
msgid "can be simply expressed by::"
msgstr "can be simply expressed by::"

#: ../source/userdoc/model_time_integration.rst:242
msgid ""
"Similarly, every existing model brick of |gf| can be applied to \"Dot_u\". "
"This is the case for instance with::"
msgstr ""
"Similarly, every existing model brick of |gf| can be applied to \"Dot_u\". "
"This is the case for instance with::"

#: ../source/userdoc/model_time_integration.rst:246
msgid "which adds the same transient term."
msgstr "which adds the same transient term."

#: ../source/userdoc/model_time_integration.rst:248
msgid ""
"VERY IMPORTANT: When adding an existing model brick applied to an affine "
"dependent variable such as \"Dot_u\", it is always assumed that the "
"corresponding test function is the one of the corresponding original "
"variable (i.e. \"Test_u\" here). In other words, \"Test_Dot_u\", the test "
"variable corresponding to the velocity, is not used. This corresponds to the"
" choice made to solve the problem in term of the original variable, so that "
"the test function corresponds to the original variable."
msgstr ""
"VERY IMPORTANT: When adding an existing model brick applied to an affine "
"dependent variable such as \"Dot_u\", it is always assumed that the "
"corresponding test function is the one of the corresponding original "
"variable (i.e. \"Test_u\" here). In other words, \"Test_Dot_u\", the test "
"variable corresponding to the velocity, is not used. This corresponds to the"
" choice made to solve the problem in term of the original variable, so that "
"the test function corresponds to the original variable."

#: ../source/userdoc/model_time_integration.rst:250
msgid ""
"Another example of model brick which can be used to account for a Kelvin-"
"Voigt linearized viscosity term is the linearized elasticity brick::"
msgstr ""
"Another example of model brick which can be used to account for a Kelvin-"
"Voigt linearized viscosity term is the linearized elasticity brick::"

#: ../source/userdoc/model_time_integration.rst:254
msgid "when applied to an order two transient elasticity problem."
msgstr "when applied to an order two transient elasticity problem."

#: ../source/userdoc/model_time_integration.rst:257
msgid "Computation on the sequence of time steps"
msgstr "Computation on the sequence of time steps"

#: ../source/userdoc/model_time_integration.rst:259
msgid ""
"Typically, the solve on the different time steps will take the following "
"form::"
msgstr ""
"Typically, the solve on the different time steps will take the following "
"form::"

#: ../source/userdoc/model_time_integration.rst:274
msgid "Note that the call of the method::"
msgstr "Note that the call of the method::"

#: ../source/userdoc/model_time_integration.rst:278
msgid ""
"is needed between two time step since it will copy the current value of the "
"variables (`u` and `Dot_u` for instance) to the previous ones (`Pevious_u` "
"and `Previous_Dot_u`)."
msgstr ""
"is needed between two time step since it will copy the current value of the "
"variables (`u` and `Dot_u` for instance) to the previous ones (`Pevious_u` "
"and `Previous_Dot_u`)."

#: ../source/userdoc/model_time_integration.rst:281
msgid "Boundary conditions"
msgstr "Boundary conditions"

#: ../source/userdoc/model_time_integration.rst:283
msgid ""
"Standard boundary conditions can of course be applied normally to the "
"different variables of the unknown. By default, applying Dirichlet, Neumann "
"or contact boundary conditions to the unknown simply means that the "
"conditions are prescribed on the variable at the current time step n."
msgstr ""
"Standard boundary conditions can of course be applied normally to the "
"different variables of the unknown. By default, applying Dirichlet, Neumann "
"or contact boundary conditions to the unknown simply means that the "
"conditions are prescribed on the variable at the current time step n."

#: ../source/userdoc/model_time_integration.rst:287
msgid "Small example: heat equation"
msgstr "Small example: heat equation"

#: ../source/userdoc/model_time_integration.rst:289
msgid ""
"The complete compilable program corresponds to the test program "
":file:`tests/heat_equation.cc` of |gf| distribution. See also "
":file:`/interface/tests/matlab/demo_wave_equation.m` for an example of order"
" two in time problem with the Matlab interface."
msgstr ""
"The complete compilable program corresponds to the test program "
":file:`tests/heat_equation.cc` of |gf| distribution. See also "
":file:`/interface/tests/matlab/demo_wave_equation.m` for an example of order"
" two in time problem with the Matlab interface."

#: ../source/userdoc/model_time_integration.rst:291
msgid ""
"Assuming that `mf_u` and `mim` are valid finite element and integration "
"methods defined on a valid mesh, the following code will perform the "
"approximation of the evolution of the temperature on the mesh assuming a "
"unitary diffusion coefficient::"
msgstr ""
"Assuming that `mf_u` and `mim` are valid finite element and integration "
"methods defined on a valid mesh, the following code will perform the "
"approximation of the evolution of the temperature on the mesh assuming a "
"unitary diffusion coefficient::"

#: ../source/userdoc/model_time_integration.rst:340
msgid "Implicit/explicit some terms"
msgstr "Implicit/explicit some terms"

#: ../source/userdoc/model_time_integration.rst:342
#: ../source/userdoc/model_time_integration.rst:348
#: ../source/userdoc/model_time_integration.rst:354
#: ../source/userdoc/model_time_integration.rst:359
msgid "..."
msgstr "..."

#: ../source/userdoc/model_time_integration.rst:346
msgid "Explicit schemes"
msgstr "Explicit schemes"

#: ../source/userdoc/model_time_integration.rst:352
msgid "Time step adaptation"
msgstr "Time step adaptation"

#: ../source/userdoc/model_time_integration.rst:357
msgid "Quasi-static problems"
msgstr "Quasi-static problems"

#: ../source/userdoc/model_time_integration.rst:7
msgid "models"
msgstr "models"

#: ../source/userdoc/model_time_integration.rst:7
msgid "model bricks"
msgstr "model bricks"
