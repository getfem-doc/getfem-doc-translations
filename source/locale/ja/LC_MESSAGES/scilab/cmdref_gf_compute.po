# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2018 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-20 02:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

# 9ebd1546e0e6449c87a0c317322f300b
#: ../source/scilab/cmdref_gf_compute.rst:8
msgid "gf_compute"
msgstr ""

# 26bc7fa802014a33ade2a1badf1c365f
#: ../source/scilab/cmdref_gf_compute.rst:10
msgid "**Synopsis**"
msgstr ""

# d42d2cb21aa74d30b800265db7884012
#: ../source/scilab/cmdref_gf_compute.rst:30
msgid "**Description :**"
msgstr ""

# b374f173a98141c3b91d7e8a75c608b7
#: ../source/scilab/cmdref_gf_compute.rst:34
msgid "Various computations involving the solution U to a finite element problem."
msgstr ""

# 18a4d1b93e094a5093900e3b9eabe453
#: ../source/scilab/cmdref_gf_compute.rst:37
msgid "**Command list :**"
msgstr ""

# eea46ef0b21f460880f43e7bbd00b3f7
#: ../source/scilab/cmdref_gf_compute.rst:41
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'L2 norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# 94ea1c6734fa4cdaa68d9ac38007267a
#: ../source/scilab/cmdref_gf_compute.rst:43
msgid "Compute the L2 norm of the (real or complex) field <literal>U</literal>."
msgstr ""

# 5ed75ee6a4ac4dd28c5f09fa71642a51
# 502360a8af6b49499af51b9ed9a42757
# 14eec95bb1ac48ed99656efee4bb2088
# 97602b1ccdf04054b4146f8df777e94a
# 03a004cc7d024833984556b5b20feb80
# 000f8db8dae547388de6bddcc8c0e606
# d58ff1e2448543fe8db2b2421ca17213
#: ../source/scilab/cmdref_gf_compute.rst:45
#: ../source/scilab/cmdref_gf_compute.rst:53
#: ../source/scilab/cmdref_gf_compute.rst:61
#: ../source/scilab/cmdref_gf_compute.rst:69
#: ../source/scilab/cmdref_gf_compute.rst:77
#: ../source/scilab/cmdref_gf_compute.rst:85
#: ../source/scilab/cmdref_gf_compute.rst:93
msgid ""
"If <literal>CVids</literal> is given, the norm will be computed only on "
"the listed elements."
msgstr ""

# 3e8225f6033f457886bd30669b959095
#: ../source/scilab/cmdref_gf_compute.rst:49
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'L2 dist', mesh_im mim, mesh_fem "
"mf2, vec U2[, mat CVids])``"
msgstr ""

# 76df4e85b80441edb772f824f6d9bb13
#: ../source/scilab/cmdref_gf_compute.rst:51
msgid ""
"Compute the L2 distance between <literal>U</literal> and "
"<literal>U2</literal>."
msgstr ""

# c09a0a5840dd4a7c970fc33c6876763a
#: ../source/scilab/cmdref_gf_compute.rst:57
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H1 semi norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# c9fef898c7294f74a03a5dfd91e4a3d6
#: ../source/scilab/cmdref_gf_compute.rst:59
msgid "Compute the L2 norm of grad(<literal>U</literal>)."
msgstr ""

# 952b66ebfee24b4f9d7d40414188d827
#: ../source/scilab/cmdref_gf_compute.rst:65
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H1 semi dist', mesh_im mim, "
"mesh_fem mf2, vec U2[, mat CVids])``"
msgstr ""

# 9a329c74d4494bd38ac5425d466ec8bc
#: ../source/scilab/cmdref_gf_compute.rst:67
msgid ""
"Compute the semi H1 distance between <literal>U</literal> and "
"<literal>U2</literal>."
msgstr ""

# 68012edce5cc44ac92e442e2db5315a2
#: ../source/scilab/cmdref_gf_compute.rst:73
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H1 norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# abfc3392fcce4f33b23960b405b3dee3
#: ../source/scilab/cmdref_gf_compute.rst:75
msgid "Compute the H1 norm of <literal>U</literal>."
msgstr ""

# 973de17c2572437ca39246882b3a382b
#: ../source/scilab/cmdref_gf_compute.rst:81
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H2 semi norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# 75b86470ce364c0bb3b8a810fca6968b
#: ../source/scilab/cmdref_gf_compute.rst:83
msgid "Compute the L2 norm of D^2(<literal>U</literal>)."
msgstr ""

# d8a62a2bbdcc4f6695a26dfb3f5aa2d4
#: ../source/scilab/cmdref_gf_compute.rst:89
msgid ""
"``n = gf_compute(mesh_fem MF, vec U, 'H2 norm', mesh_im mim[, mat "
"CVids])``"
msgstr ""

# 0d954b8bc0f340cebec628f902408128
#: ../source/scilab/cmdref_gf_compute.rst:91
msgid "Compute the H2 norm of <literal>U</literal>."
msgstr ""

# 3005c3f8c8f449e695d0e9f307aca19a
#: ../source/scilab/cmdref_gf_compute.rst:97
msgid "``DU = gf_compute(mesh_fem MF, vec U, 'gradient', mesh_fem mf_du)``"
msgstr ""

# 2b15eb37f7784beb8738b58139152deb
#: ../source/scilab/cmdref_gf_compute.rst:99
msgid ""
"Compute the gradient of the field <literal>U</literal> defined on "
"mesh_fem <literal>mf_du</literal>."
msgstr ""

# 9aa63a0c4f594452bc896fd41cb46b3e
#: ../source/scilab/cmdref_gf_compute.rst:101
msgid ""
"The gradient is interpolated on the mesh_fem <literal>mf_du</literal>, "
"and returned in <literal>DU</literal>. For example, if "
"<literal>U</literal> is defined on a P2 mesh_fem, <literal>DU</literal> "
"should be evaluated on a P1-discontinuous mesh_fem. <literal>mf</literal>"
" and <literal>mf_du</literal> should share the same mesh."
msgstr ""

# 4b5970ff0812422b8a60cb59353844e4
#: ../source/scilab/cmdref_gf_compute.rst:106
msgid ""
"<literal>U</literal> may have any number of dimensions (i.e. this "
"function is not restricted to the gradient of scalar fields, but may also"
" be used for tensor fields). However the last dimension of "
"<literal>U</literal> has to be equal to the number of dof of "
"<literal>mf</literal>. For example, if <literal>U</literal> is a "
"[3x3xNmf] array (where Nmf is the number of dof of "
"<literal>mf</literal>), <literal>DU</literal> will be a "
"[Nx3x3[xQ]xNmf_du] array, where N is the dimension of the mesh, Nmf_du is"
" the number of dof of <literal>mf_du</literal>, and the optional Q "
"dimension is inserted if <literal>Qdim_mf != Qdim_mf_du</literal>, where "
"Qdim_mf is the Qdim of <literal>mf</literal> and Qdim_mf_du is the Qdim "
"of <literal>mf_du</literal>."
msgstr ""

# 5f75ae8c3b0c48a0a442069a799053c5
#: ../source/scilab/cmdref_gf_compute.rst:117
msgid "``HU = gf_compute(mesh_fem MF, vec U, 'hessian', mesh_fem mf_h)``"
msgstr ""

# 01b577f328ac42ce83b4a6fe3f68cdd1
#: ../source/scilab/cmdref_gf_compute.rst:119
msgid ""
"Compute the hessian of the field <literal>U</literal> defined on mesh_fem"
" <literal>mf_h</literal>."
msgstr ""

# 21192ce8b2694011810d8092faf49510
#: ../source/scilab/cmdref_gf_compute.rst:121
msgid "See also gf_compute('gradient', mesh_fem mf_du)."
msgstr ""

# 13a456feb89145229b5f41599deba273
#: ../source/scilab/cmdref_gf_compute.rst:124
msgid ""
"``UP = gf_compute(mesh_fem MF, vec U, 'eval on triangulated surface', int"
" Nrefine, [vec CVLIST])``"
msgstr ""

# 9bca130009d14dbdbc958ee35f7bc4d0
#: ../source/scilab/cmdref_gf_compute.rst:126
msgid ""
"[OBSOLETE FUNCTION! will be removed in a future release] Utility function"
" designed for 2D triangular meshes : returns a list of triangles "
"coordinates with interpolated U values. This can be used for the accurate"
" visualization of data defined on a discontinous high order element. On "
"output, the six first rows of UP contains the triangle coordinates, and "
"the others rows contain the interpolated values of U (one for each "
"triangle vertex) CVLIST may indicate the list of convex number that "
"should be consider, if not used then all the mesh convexes will be used. "
"U should be a row vector."
msgstr ""

# 3e49cc4cd6ab41e3a85247dc2f6318fb
#: ../source/scilab/cmdref_gf_compute.rst:139
msgid ""
"``Ui = gf_compute(mesh_fem MF, vec U, 'interpolate on', {mesh_fem mfi | "
"slice sli | vec pts})``"
msgstr ""

# d11b629d26e94f1c8ab5c5ee85d5bde5
#: ../source/scilab/cmdref_gf_compute.rst:141
msgid "Interpolate a field on another mesh_fem or a slice or a list of points."
msgstr ""

# 28336d2109a44a0db23c1f101439cf68
#: ../source/scilab/cmdref_gf_compute.rst:144
msgid "Interpolation on another mesh_fem <literal>mfi</literal>:"
msgstr ""

# 025f238b29f24238b6b0949a412903e0
#: ../source/scilab/cmdref_gf_compute.rst:144
msgid ""
"<literal>mfi</literal> has to be Lagrangian. If <literal>mf</literal> and"
" <literal>mfi</literal> share the same mesh object, the interpolation "
"will be much faster."
msgstr ""

# 37c5d32126be4b498ff6db451e0dff63
#: ../source/scilab/cmdref_gf_compute.rst:149
msgid "Interpolation on a slice <literal>sli</literal>:"
msgstr ""

# 442427422350480baa8006f659080999
#: ../source/scilab/cmdref_gf_compute.rst:147
msgid ""
"this is similar to interpolation on a refined P1-discontinuous mesh, but "
"it is much faster. This can also be used with gf_slice('points') to "
"obtain field values at a given set of points."
msgstr ""

# cece07bb79f14ae9b2837406fb0a4d82
#: ../source/scilab/cmdref_gf_compute.rst:151
msgid "Interpolation on a set of points <literal>pts</literal>"
msgstr ""

# f0462e40977d481c8ef345c24a9b203c
#: ../source/scilab/cmdref_gf_compute.rst:153
msgid "See also gf_asm('interpolation matrix')"
msgstr ""

# 062db991b37b4fe2932b0a23bcbbcab1
#: ../source/scilab/cmdref_gf_compute.rst:157
msgid "``Ue = gf_compute(mesh_fem MF, vec U, 'extrapolate on', mesh_fem mfe)``"
msgstr ""

# 3b402341f2fe47988cab1c0e64e46547
#: ../source/scilab/cmdref_gf_compute.rst:159
msgid "Extrapolate a field on another mesh_fem."
msgstr ""

# 46c9e3206ea74e09a130f9f0e60aa368
#: ../source/scilab/cmdref_gf_compute.rst:161
msgid ""
"If the mesh of <literal>mfe</literal> is stricly included in the mesh of "
"<literal>mf</literal>, this function does stricly the same job as "
"gf_compute('interpolate_on'). However, if the mesh of "
"<literal>mfe</literal> is not exactly included in <literal>mf</literal> "
"(imagine interpolation between a curved refined mesh and a coarse mesh), "
"then values which are outside <literal>mf</literal> will be extrapolated."
msgstr ""

# 23efeccf7d184590a9971f2c67235ea3
#: ../source/scilab/cmdref_gf_compute.rst:168
msgid "See also gf_asm('extrapolation matrix')"
msgstr ""

# db2a26571b724f588382edfd67fb2930
#: ../source/scilab/cmdref_gf_compute.rst:171
msgid "``E = gf_compute(mesh_fem MF, vec U, 'error estimate', mesh_im mim)``"
msgstr ""

# 7a3398ca8c864c9db3986859e7964c52
#: ../source/scilab/cmdref_gf_compute.rst:173
msgid "Compute an a posteriori error estimate."
msgstr ""

# fc6d78f01fd648f19313cbc9481278e4
# 0d0a3b011cad4fc2a0dfde08aca68703
#: ../source/scilab/cmdref_gf_compute.rst:175
#: ../source/scilab/cmdref_gf_compute.rst:183
msgid ""
"Currently there is only one which is available: for each convex, the jump"
" of the normal derivative is integrated on its faces."
msgstr ""

# 9dfcfc7816f74f72b87f27a16aed1867
#: ../source/scilab/cmdref_gf_compute.rst:179
msgid ""
"``E = gf_compute(mesh_fem MF, vec U, 'error estimate nitsche', mesh_im "
"mim, int GAMMAC, int GAMMAN, scalar lambda_, scalar mu_, scalar gamma0, "
"scalar f_coeff, scalar vertical_force)``"
msgstr ""

# 25fa13c3416d4d66a41ad6d5834e90f4
#: ../source/scilab/cmdref_gf_compute.rst:181
msgid "Compute an a posteriori error estimate in the case of Nitsche method."
msgstr ""

# 9367a57a8c7d4182b8bc5931e07c46df
#: ../source/scilab/cmdref_gf_compute.rst:187
msgid ""
"``gf_compute(mesh_fem MF, vec U, 'convect', mesh_fem mf_v, vec V, scalar "
"dt, int nt[, string option[, vec per_min, vec per_max]])``"
msgstr ""

# 99a263a51a7e46a58a6a4649c6969632
#: ../source/scilab/cmdref_gf_compute.rst:189
msgid ""
"Compute a convection of <literal>U</literal> with regards to a steady "
"state velocity field <literal>V</literal> with a Characteristic-Galerkin "
"method. The result is returned in-place in <literal>U</literal>. This "
"method is restricted to pure Lagrange fems for U. <literal>mf_v</literal>"
" should represent a continuous finite element method. "
"<literal>dt</literal> is the integration time and <literal>nt</literal> "
"is the number of integration step on the caracteristics. "
"<literal>option</literal> is an option for the part of the boundary where"
" there is a re-entrant convection. <literal>option = "
"'extrapolation'</literal> for an extrapolation on the nearest element, "
"<literal>option = 'unchanged'</literal> for a constant value on that "
"boundary or <literal>option = 'periodicity'</literal> for a peridiodic "
"boundary. For this latter option the two vectors per_min, per_max has to "
"be given and represent the limits of the periodic domain (on components "
"where per_max[k] < per_min[k] no operation is done). This method is "
"rather dissipative, but stable."
msgstr ""

