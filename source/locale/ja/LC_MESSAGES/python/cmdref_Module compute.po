# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2004-2018 GetFEM++ project
# This file is distributed under the same license as the GetFEM++ package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: GetFEM++ 5.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-11-20 02:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

# e1ce1b1a2ef04b5eae1813334cf5b436
#: ../source/python/cmdref_Module compute.rst:8
msgid "Module compute"
msgstr ""

# 65f8ee32c9a241f3b8a93e53adb52c24
#: getfem.compute_L2_norm:1 of
msgid "Compute the L2 norm of the (real or complex) field `U`."
msgstr ""

# f3a0cd9203da4b4f89b81005e26acad1
# 93aaf37b57dc4ba0b846829a9c6e59a7
# 922c7b3fcc70407f9cfe7e50d95925d4
# 8a2be9632c604275abc73ae3107a1bfd
# 3043d78a7b2344b2a9161621edb0b895
# bb4e0dcbe47b4e5d8511d5a5d3cb936f
# 41617a1bab114ce79a3638c31b34dcbd
#: getfem.compute_H1_norm:3 getfem.compute_H1_semi_dist:3
#: getfem.compute_H1_semi_norm:3 getfem.compute_H2_norm:3
#: getfem.compute_H2_semi_norm:3 getfem.compute_L2_dist:3
#: getfem.compute_L2_norm:3 of
msgid ""
"If `CVids` is given, the norm will be computed only on the listed "
"elements."
msgstr ""

# 5eef5a4503d14435b9d0c9bf5e0c3b99
#: getfem.compute_L2_dist:1 of
msgid "Compute the L2 distance between `U` and `U2`."
msgstr ""

# a75a980959e14bf984029a8417fd4d53
#: getfem.compute_H1_semi_norm:1 of
msgid "Compute the L2 norm of grad(`U`)."
msgstr ""

# 90095f02452143e2a6bc50371335c3dd
#: getfem.compute_H1_semi_dist:1 of
msgid "Compute the semi H1 distance between `U` and `U2`."
msgstr ""

# 0da4089a9f0242d7b8382519f819b03a
#: getfem.compute_H1_norm:1 of
msgid "Compute the H1 norm of `U`."
msgstr ""

# 67fd267bd7c8414a92c8c9f50eca9fe5
#: getfem.compute_H2_semi_norm:1 of
msgid "Compute the L2 norm of D^2(`U`)."
msgstr ""

# b221f04740b54f6189474d7816316198
#: getfem.compute_H2_norm:1 of
msgid "Compute the H2 norm of `U`."
msgstr ""

# 958d3ff9492d471a9a3314a085960d5c
#: getfem.compute_gradient:1 of
msgid "Compute the gradient of the field `U` defined on MeshFem `mf_du`."
msgstr ""

# f8261bc450c84de09a582250fb6bb620
#: getfem.compute_gradient:3 of
msgid ""
"The gradient is interpolated on the MeshFem `mf_du`, and returned in "
"`DU`. For example, if `U` is defined on a P2 MeshFem, `DU` should be "
"evaluated on a P1-discontinuous MeshFem. `mf` and `mf_du` should share "
"the same mesh."
msgstr ""

# bc1fcf14a0df4ddaaa298c3a87a1e68e
#: getfem.compute_gradient:8 of
msgid ""
"`U` may have any number of dimensions (i.e. this function is not "
"restricted to the gradient of scalar fields, but may also be used for "
"tensor fields). However the last dimension of `U` has to be equal to the "
"number of dof of `mf`. For example, if `U` is a [3x3xNmf] array (where "
"Nmf is the number of dof of `mf`), `DU` will be a [Nx3x3[xQ]xNmf_du] "
"array, where N is the dimension of the mesh, Nmf_du is the number of dof "
"of `mf_du`, and the optional Q dimension is inserted if `Qdim_mf != "
"Qdim_mf_du`, where Qdim_mf is the Qdim of `mf` and Qdim_mf_du is the Qdim"
" of `mf_du`."
msgstr ""

# 5723557519c64eef95bb755b9e981f8b
#: getfem.compute_hessian:1 of
msgid "Compute the hessian of the field `U` defined on MeshFem `mf_h`."
msgstr ""

# 272936fcfd9040aa9a57b4db85de8ba2
#: getfem.compute_hessian:3 of
msgid "See also gf_compute('gradient', MeshFem mf_du)."
msgstr ""

# f9e2258f8ac6474284ff4d25b21bc023
#: getfem.compute_eval_on_triangulated_surface:1 of
msgid ""
"[OBSOLETE FUNCTION! will be removed in a future release] Utility function"
" designed for 2D triangular meshes : returns a list of triangles "
"coordinates with interpolated U values. This can be used for the accurate"
" visualization of data defined on a discontinous high order element. On "
"output, the six first rows of UP contains the triangle coordinates, and "
"the others rows contain the interpolated values of U (one for each "
"triangle vertex) CVLIST may indicate the list of convex number that "
"should be consider, if not used then all the mesh convexes will be used. "
"U should be a row vector."
msgstr ""

# f2bda8371c4f4c2ab8b144af10791b0f
#: getfem.compute_interpolate_on:1 of
msgid ""
"Synopsis: Ui = compute_interpolate_on(MeshFem MF, vec U, {MeshFem mfi | "
"Slice sli | vec pts})"
msgstr ""

# c7ef4a1eada1442eae6f67e9947048bf
#: getfem.compute_interpolate_on:3 of
msgid "Interpolate a field on another MeshFem or a Slice or a list of points."
msgstr ""

# 6f404fb1815745be9561c916f894c196
#: getfem.compute_interpolate_on:6 of
msgid "Interpolation on another MeshFem `mfi`:"
msgstr ""

# 308f4753f1644aada0d5cfecc04b0441
#: getfem.compute_interpolate_on:6 of
msgid ""
"`mfi` has to be Lagrangian. If `mf` and `mfi` share the same mesh object,"
" the interpolation will be much faster."
msgstr ""

# 00b0bad768114c069ea2e24a2973a418
#: getfem.compute_interpolate_on:11 of
msgid "Interpolation on a Slice `sli`:"
msgstr ""

# 2d1cfa9f39e046d9a623161472770351
#: getfem.compute_interpolate_on:9 of
msgid ""
"this is similar to interpolation on a refined P1-discontinuous mesh, but "
"it is much faster. This can also be used with Slice('points') to obtain "
"field values at a given set of points."
msgstr ""

# 10b1bb3535d04fd8a11e9043129bce0b
#: getfem.compute_interpolate_on:13 of
msgid "Interpolation on a set of points `pts`"
msgstr ""

# 72399e0cceb2439ab3376d6b797455a8
#: getfem.compute_interpolate_on:15 of
msgid "See also gf_asm('interpolation matrix')"
msgstr ""

# cfd3adf66e7341928788d7fdfc4a70e9
#: getfem.compute_extrapolate_on:1 of
msgid "Extrapolate a field on another MeshFem."
msgstr ""

# d4f647dd823540d6ac76a7e8757a06e3
#: getfem.compute_extrapolate_on:3 of
msgid ""
"If the mesh of `mfe` is stricly included in the mesh of `mf`, this "
"function does stricly the same job as gf_compute('interpolate_on'). "
"However, if the mesh of `mfe` is not exactly included in `mf` (imagine "
"interpolation between a curved refined mesh and a coarse mesh), then "
"values which are outside `mf` will be extrapolated."
msgstr ""

# 6e4c010bd3f3460eab4f36a44cd8e21f
#: getfem.compute_extrapolate_on:10 of
msgid "See also gf_asm('extrapolation matrix')"
msgstr ""

# 4da0e26aedea42f6837b464af87343d5
#: getfem.compute_error_estimate:1 of
msgid "Compute an a posteriori error estimate."
msgstr ""

# 2347e7ae5adf4cdf8d2c143b1a7af139
# 45e47271ab794979a7386f85f1320ecf
#: getfem.compute_error_estimate:3 getfem.compute_error_estimate_nitsche:3 of
msgid ""
"Currently there is only one which is available: for each convex, the jump"
" of the normal derivative is integrated on its faces."
msgstr ""

# e725583489ea43a4bfe3c04f18ad7de0
#: getfem.compute_error_estimate_nitsche:1 of
msgid "Compute an a posteriori error estimate in the case of Nitsche method."
msgstr ""

# 6d1ebe30cfa84195bcc4204ffa0eeffd
#: getfem.compute_convect:1 of
msgid ""
"Synopsis: compute_convect(MeshFem MF, vec U, MeshFem mf_v, vec V, scalar "
"dt, int nt[, string option[, vec per_min, vec per_max]])"
msgstr ""

# 2fefaff396e640628f67938d9a941af7
#: getfem.compute_convect:3 of
msgid ""
"Compute a convection of `U` with regards to a steady state velocity field"
" `V` with a Characteristic-Galerkin method. The result is returned in-"
"place in `U`. This method is restricted to pure Lagrange fems for U. "
"`mf_v` should represent a continuous finite element method. `dt` is the "
"integration time and `nt` is the number of integration step on the "
"caracteristics. `option` is an option for the part of the boundary where "
"there is a re-entrant convection. `option = 'extrapolation'` for an "
"extrapolation on the nearest element, `option = 'unchanged'` for a "
"constant value on that boundary or `option = 'periodicity'` for a "
"peridiodic boundary. For this latter option the two vectors per_min, "
"per_max has to be given and represent the limits of the periodic domain "
"(on components where per_max[k] < per_min[k] no operation is done). This "
"method is rather dissipative, but stable."
msgstr ""

